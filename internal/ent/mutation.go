// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/emoss08/trenova/internal/ent/accessorialcharge"
	"github.com/emoss08/trenova/internal/ent/accountingcontrol"
	"github.com/emoss08/trenova/internal/ent/billingcontrol"
	"github.com/emoss08/trenova/internal/ent/businessunit"
	"github.com/emoss08/trenova/internal/ent/chargetype"
	"github.com/emoss08/trenova/internal/ent/commenttype"
	"github.com/emoss08/trenova/internal/ent/commodity"
	"github.com/emoss08/trenova/internal/ent/customer"
	"github.com/emoss08/trenova/internal/ent/customercontact"
	"github.com/emoss08/trenova/internal/ent/customerdetentionpolicy"
	"github.com/emoss08/trenova/internal/ent/customeremailprofile"
	"github.com/emoss08/trenova/internal/ent/customerruleprofile"
	"github.com/emoss08/trenova/internal/ent/customreport"
	"github.com/emoss08/trenova/internal/ent/delaycode"
	"github.com/emoss08/trenova/internal/ent/deliveryslot"
	"github.com/emoss08/trenova/internal/ent/dispatchcontrol"
	"github.com/emoss08/trenova/internal/ent/divisioncode"
	"github.com/emoss08/trenova/internal/ent/documentclassification"
	"github.com/emoss08/trenova/internal/ent/emailcontrol"
	"github.com/emoss08/trenova/internal/ent/emailprofile"
	"github.com/emoss08/trenova/internal/ent/equipmentmanufactuer"
	"github.com/emoss08/trenova/internal/ent/equipmenttype"
	"github.com/emoss08/trenova/internal/ent/feasibilitytoolcontrol"
	"github.com/emoss08/trenova/internal/ent/featureflag"
	"github.com/emoss08/trenova/internal/ent/fleetcode"
	"github.com/emoss08/trenova/internal/ent/formulatemplate"
	"github.com/emoss08/trenova/internal/ent/generalledgeraccount"
	"github.com/emoss08/trenova/internal/ent/googleapi"
	"github.com/emoss08/trenova/internal/ent/hazardousmaterial"
	"github.com/emoss08/trenova/internal/ent/hazardousmaterialsegregation"
	"github.com/emoss08/trenova/internal/ent/invoicecontrol"
	"github.com/emoss08/trenova/internal/ent/location"
	"github.com/emoss08/trenova/internal/ent/locationcategory"
	"github.com/emoss08/trenova/internal/ent/locationcomment"
	"github.com/emoss08/trenova/internal/ent/locationcontact"
	"github.com/emoss08/trenova/internal/ent/organization"
	"github.com/emoss08/trenova/internal/ent/organizationfeatureflag"
	"github.com/emoss08/trenova/internal/ent/permission"
	"github.com/emoss08/trenova/internal/ent/predicate"
	"github.com/emoss08/trenova/internal/ent/qualifiercode"
	"github.com/emoss08/trenova/internal/ent/reasoncode"
	"github.com/emoss08/trenova/internal/ent/resource"
	"github.com/emoss08/trenova/internal/ent/revenuecode"
	"github.com/emoss08/trenova/internal/ent/role"
	"github.com/emoss08/trenova/internal/ent/routecontrol"
	"github.com/emoss08/trenova/internal/ent/servicetype"
	"github.com/emoss08/trenova/internal/ent/session"
	"github.com/emoss08/trenova/internal/ent/shipment"
	"github.com/emoss08/trenova/internal/ent/shipmentcharges"
	"github.com/emoss08/trenova/internal/ent/shipmentcomment"
	"github.com/emoss08/trenova/internal/ent/shipmentcommodity"
	"github.com/emoss08/trenova/internal/ent/shipmentcontrol"
	"github.com/emoss08/trenova/internal/ent/shipmentdocumentation"
	"github.com/emoss08/trenova/internal/ent/shipmentmove"
	"github.com/emoss08/trenova/internal/ent/shipmentroute"
	"github.com/emoss08/trenova/internal/ent/shipmenttype"
	"github.com/emoss08/trenova/internal/ent/stop"
	"github.com/emoss08/trenova/internal/ent/tablechangealert"
	"github.com/emoss08/trenova/internal/ent/tag"
	"github.com/emoss08/trenova/internal/ent/tractor"
	"github.com/emoss08/trenova/internal/ent/trailer"
	"github.com/emoss08/trenova/internal/ent/user"
	"github.com/emoss08/trenova/internal/ent/userfavorite"
	"github.com/emoss08/trenova/internal/ent/usernotification"
	"github.com/emoss08/trenova/internal/ent/userreport"
	"github.com/emoss08/trenova/internal/ent/usstate"
	"github.com/emoss08/trenova/internal/ent/worker"
	"github.com/emoss08/trenova/internal/ent/workercomment"
	"github.com/emoss08/trenova/internal/ent/workercontact"
	"github.com/emoss08/trenova/internal/ent/workerprofile"
	"github.com/emoss08/trenova/internal/util/types"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccessorialCharge            = "AccessorialCharge"
	TypeAccountingControl            = "AccountingControl"
	TypeBillingControl               = "BillingControl"
	TypeBusinessUnit                 = "BusinessUnit"
	TypeChargeType                   = "ChargeType"
	TypeCommentType                  = "CommentType"
	TypeCommodity                    = "Commodity"
	TypeCustomReport                 = "CustomReport"
	TypeCustomer                     = "Customer"
	TypeCustomerContact              = "CustomerContact"
	TypeCustomerDetentionPolicy      = "CustomerDetentionPolicy"
	TypeCustomerEmailProfile         = "CustomerEmailProfile"
	TypeCustomerRuleProfile          = "CustomerRuleProfile"
	TypeDelayCode                    = "DelayCode"
	TypeDeliverySlot                 = "DeliverySlot"
	TypeDispatchControl              = "DispatchControl"
	TypeDivisionCode                 = "DivisionCode"
	TypeDocumentClassification       = "DocumentClassification"
	TypeEmailControl                 = "EmailControl"
	TypeEmailProfile                 = "EmailProfile"
	TypeEquipmentManufactuer         = "EquipmentManufactuer"
	TypeEquipmentType                = "EquipmentType"
	TypeFeasibilityToolControl       = "FeasibilityToolControl"
	TypeFeatureFlag                  = "FeatureFlag"
	TypeFleetCode                    = "FleetCode"
	TypeFormulaTemplate              = "FormulaTemplate"
	TypeGeneralLedgerAccount         = "GeneralLedgerAccount"
	TypeGoogleApi                    = "GoogleApi"
	TypeHazardousMaterial            = "HazardousMaterial"
	TypeHazardousMaterialSegregation = "HazardousMaterialSegregation"
	TypeInvoiceControl               = "InvoiceControl"
	TypeLocation                     = "Location"
	TypeLocationCategory             = "LocationCategory"
	TypeLocationComment              = "LocationComment"
	TypeLocationContact              = "LocationContact"
	TypeOrganization                 = "Organization"
	TypeOrganizationFeatureFlag      = "OrganizationFeatureFlag"
	TypePermission                   = "Permission"
	TypeQualifierCode                = "QualifierCode"
	TypeReasonCode                   = "ReasonCode"
	TypeResource                     = "Resource"
	TypeRevenueCode                  = "RevenueCode"
	TypeRole                         = "Role"
	TypeRouteControl                 = "RouteControl"
	TypeServiceType                  = "ServiceType"
	TypeSession                      = "Session"
	TypeShipment                     = "Shipment"
	TypeShipmentCharges              = "ShipmentCharges"
	TypeShipmentComment              = "ShipmentComment"
	TypeShipmentCommodity            = "ShipmentCommodity"
	TypeShipmentControl              = "ShipmentControl"
	TypeShipmentDocumentation        = "ShipmentDocumentation"
	TypeShipmentMove                 = "ShipmentMove"
	TypeShipmentRoute                = "ShipmentRoute"
	TypeShipmentType                 = "ShipmentType"
	TypeStop                         = "Stop"
	TypeTableChangeAlert             = "TableChangeAlert"
	TypeTag                          = "Tag"
	TypeTractor                      = "Tractor"
	TypeTrailer                      = "Trailer"
	TypeUsState                      = "UsState"
	TypeUser                         = "User"
	TypeUserFavorite                 = "UserFavorite"
	TypeUserNotification             = "UserNotification"
	TypeUserReport                   = "UserReport"
	TypeWorker                       = "Worker"
	TypeWorkerComment                = "WorkerComment"
	TypeWorkerContact                = "WorkerContact"
	TypeWorkerProfile                = "WorkerProfile"
)

// AccessorialChargeMutation represents an operation that mutates the AccessorialCharge nodes in the graph.
type AccessorialChargeMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	created_at              *time.Time
	updated_at              *time.Time
	version                 *int
	addversion              *int
	status                  *accessorialcharge.Status
	code                    *string
	description             *string
	is_detention            *bool
	method                  *accessorialcharge.Method
	amount                  *float64
	addamount               *float64
	clearedFields           map[string]struct{}
	business_unit           *uuid.UUID
	clearedbusiness_unit    bool
	organization            *uuid.UUID
	clearedorganization     bool
	shipment_charges        map[uuid.UUID]struct{}
	removedshipment_charges map[uuid.UUID]struct{}
	clearedshipment_charges bool
	done                    bool
	oldValue                func(context.Context) (*AccessorialCharge, error)
	predicates              []predicate.AccessorialCharge
}

var _ ent.Mutation = (*AccessorialChargeMutation)(nil)

// accessorialchargeOption allows management of the mutation configuration using functional options.
type accessorialchargeOption func(*AccessorialChargeMutation)

// newAccessorialChargeMutation creates new mutation for the AccessorialCharge entity.
func newAccessorialChargeMutation(c config, op Op, opts ...accessorialchargeOption) *AccessorialChargeMutation {
	m := &AccessorialChargeMutation{
		config:        c,
		op:            op,
		typ:           TypeAccessorialCharge,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccessorialChargeID sets the ID field of the mutation.
func withAccessorialChargeID(id uuid.UUID) accessorialchargeOption {
	return func(m *AccessorialChargeMutation) {
		var (
			err   error
			once  sync.Once
			value *AccessorialCharge
		)
		m.oldValue = func(ctx context.Context) (*AccessorialCharge, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AccessorialCharge.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccessorialCharge sets the old AccessorialCharge of the mutation.
func withAccessorialCharge(node *AccessorialCharge) accessorialchargeOption {
	return func(m *AccessorialChargeMutation) {
		m.oldValue = func(context.Context) (*AccessorialCharge, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccessorialChargeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccessorialChargeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AccessorialCharge entities.
func (m *AccessorialChargeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccessorialChargeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccessorialChargeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AccessorialCharge.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *AccessorialChargeMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *AccessorialChargeMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the AccessorialCharge entity.
// If the AccessorialCharge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessorialChargeMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *AccessorialChargeMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *AccessorialChargeMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *AccessorialChargeMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the AccessorialCharge entity.
// If the AccessorialCharge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessorialChargeMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *AccessorialChargeMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AccessorialChargeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccessorialChargeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AccessorialCharge entity.
// If the AccessorialCharge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessorialChargeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccessorialChargeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AccessorialChargeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AccessorialChargeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AccessorialCharge entity.
// If the AccessorialCharge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessorialChargeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AccessorialChargeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *AccessorialChargeMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *AccessorialChargeMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the AccessorialCharge entity.
// If the AccessorialCharge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessorialChargeMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *AccessorialChargeMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *AccessorialChargeMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *AccessorialChargeMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetStatus sets the "status" field.
func (m *AccessorialChargeMutation) SetStatus(a accessorialcharge.Status) {
	m.status = &a
}

// Status returns the value of the "status" field in the mutation.
func (m *AccessorialChargeMutation) Status() (r accessorialcharge.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AccessorialCharge entity.
// If the AccessorialCharge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessorialChargeMutation) OldStatus(ctx context.Context) (v accessorialcharge.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *AccessorialChargeMutation) ResetStatus() {
	m.status = nil
}

// SetCode sets the "code" field.
func (m *AccessorialChargeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *AccessorialChargeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the AccessorialCharge entity.
// If the AccessorialCharge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessorialChargeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *AccessorialChargeMutation) ResetCode() {
	m.code = nil
}

// SetDescription sets the "description" field.
func (m *AccessorialChargeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AccessorialChargeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AccessorialCharge entity.
// If the AccessorialCharge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessorialChargeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AccessorialChargeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[accessorialcharge.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AccessorialChargeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[accessorialcharge.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AccessorialChargeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, accessorialcharge.FieldDescription)
}

// SetIsDetention sets the "is_detention" field.
func (m *AccessorialChargeMutation) SetIsDetention(b bool) {
	m.is_detention = &b
}

// IsDetention returns the value of the "is_detention" field in the mutation.
func (m *AccessorialChargeMutation) IsDetention() (r bool, exists bool) {
	v := m.is_detention
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDetention returns the old "is_detention" field's value of the AccessorialCharge entity.
// If the AccessorialCharge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessorialChargeMutation) OldIsDetention(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDetention is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDetention requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDetention: %w", err)
	}
	return oldValue.IsDetention, nil
}

// ResetIsDetention resets all changes to the "is_detention" field.
func (m *AccessorialChargeMutation) ResetIsDetention() {
	m.is_detention = nil
}

// SetMethod sets the "method" field.
func (m *AccessorialChargeMutation) SetMethod(a accessorialcharge.Method) {
	m.method = &a
}

// Method returns the value of the "method" field in the mutation.
func (m *AccessorialChargeMutation) Method() (r accessorialcharge.Method, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the AccessorialCharge entity.
// If the AccessorialCharge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessorialChargeMutation) OldMethod(ctx context.Context) (v accessorialcharge.Method, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ResetMethod resets all changes to the "method" field.
func (m *AccessorialChargeMutation) ResetMethod() {
	m.method = nil
}

// SetAmount sets the "amount" field.
func (m *AccessorialChargeMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *AccessorialChargeMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the AccessorialCharge entity.
// If the AccessorialCharge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessorialChargeMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *AccessorialChargeMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *AccessorialChargeMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *AccessorialChargeMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *AccessorialChargeMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[accessorialcharge.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *AccessorialChargeMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *AccessorialChargeMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *AccessorialChargeMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *AccessorialChargeMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[accessorialcharge.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *AccessorialChargeMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *AccessorialChargeMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *AccessorialChargeMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// AddShipmentChargeIDs adds the "shipment_charges" edge to the ShipmentCharges entity by ids.
func (m *AccessorialChargeMutation) AddShipmentChargeIDs(ids ...uuid.UUID) {
	if m.shipment_charges == nil {
		m.shipment_charges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.shipment_charges[ids[i]] = struct{}{}
	}
}

// ClearShipmentCharges clears the "shipment_charges" edge to the ShipmentCharges entity.
func (m *AccessorialChargeMutation) ClearShipmentCharges() {
	m.clearedshipment_charges = true
}

// ShipmentChargesCleared reports if the "shipment_charges" edge to the ShipmentCharges entity was cleared.
func (m *AccessorialChargeMutation) ShipmentChargesCleared() bool {
	return m.clearedshipment_charges
}

// RemoveShipmentChargeIDs removes the "shipment_charges" edge to the ShipmentCharges entity by IDs.
func (m *AccessorialChargeMutation) RemoveShipmentChargeIDs(ids ...uuid.UUID) {
	if m.removedshipment_charges == nil {
		m.removedshipment_charges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.shipment_charges, ids[i])
		m.removedshipment_charges[ids[i]] = struct{}{}
	}
}

// RemovedShipmentCharges returns the removed IDs of the "shipment_charges" edge to the ShipmentCharges entity.
func (m *AccessorialChargeMutation) RemovedShipmentChargesIDs() (ids []uuid.UUID) {
	for id := range m.removedshipment_charges {
		ids = append(ids, id)
	}
	return
}

// ShipmentChargesIDs returns the "shipment_charges" edge IDs in the mutation.
func (m *AccessorialChargeMutation) ShipmentChargesIDs() (ids []uuid.UUID) {
	for id := range m.shipment_charges {
		ids = append(ids, id)
	}
	return
}

// ResetShipmentCharges resets all changes to the "shipment_charges" edge.
func (m *AccessorialChargeMutation) ResetShipmentCharges() {
	m.shipment_charges = nil
	m.clearedshipment_charges = false
	m.removedshipment_charges = nil
}

// Where appends a list predicates to the AccessorialChargeMutation builder.
func (m *AccessorialChargeMutation) Where(ps ...predicate.AccessorialCharge) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccessorialChargeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccessorialChargeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AccessorialCharge, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccessorialChargeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccessorialChargeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AccessorialCharge).
func (m *AccessorialChargeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccessorialChargeMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.business_unit != nil {
		fields = append(fields, accessorialcharge.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, accessorialcharge.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, accessorialcharge.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, accessorialcharge.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, accessorialcharge.FieldVersion)
	}
	if m.status != nil {
		fields = append(fields, accessorialcharge.FieldStatus)
	}
	if m.code != nil {
		fields = append(fields, accessorialcharge.FieldCode)
	}
	if m.description != nil {
		fields = append(fields, accessorialcharge.FieldDescription)
	}
	if m.is_detention != nil {
		fields = append(fields, accessorialcharge.FieldIsDetention)
	}
	if m.method != nil {
		fields = append(fields, accessorialcharge.FieldMethod)
	}
	if m.amount != nil {
		fields = append(fields, accessorialcharge.FieldAmount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccessorialChargeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case accessorialcharge.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case accessorialcharge.FieldOrganizationID:
		return m.OrganizationID()
	case accessorialcharge.FieldCreatedAt:
		return m.CreatedAt()
	case accessorialcharge.FieldUpdatedAt:
		return m.UpdatedAt()
	case accessorialcharge.FieldVersion:
		return m.Version()
	case accessorialcharge.FieldStatus:
		return m.Status()
	case accessorialcharge.FieldCode:
		return m.Code()
	case accessorialcharge.FieldDescription:
		return m.Description()
	case accessorialcharge.FieldIsDetention:
		return m.IsDetention()
	case accessorialcharge.FieldMethod:
		return m.Method()
	case accessorialcharge.FieldAmount:
		return m.Amount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccessorialChargeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case accessorialcharge.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case accessorialcharge.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case accessorialcharge.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case accessorialcharge.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case accessorialcharge.FieldVersion:
		return m.OldVersion(ctx)
	case accessorialcharge.FieldStatus:
		return m.OldStatus(ctx)
	case accessorialcharge.FieldCode:
		return m.OldCode(ctx)
	case accessorialcharge.FieldDescription:
		return m.OldDescription(ctx)
	case accessorialcharge.FieldIsDetention:
		return m.OldIsDetention(ctx)
	case accessorialcharge.FieldMethod:
		return m.OldMethod(ctx)
	case accessorialcharge.FieldAmount:
		return m.OldAmount(ctx)
	}
	return nil, fmt.Errorf("unknown AccessorialCharge field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccessorialChargeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case accessorialcharge.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case accessorialcharge.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case accessorialcharge.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case accessorialcharge.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case accessorialcharge.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case accessorialcharge.FieldStatus:
		v, ok := value.(accessorialcharge.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case accessorialcharge.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case accessorialcharge.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case accessorialcharge.FieldIsDetention:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDetention(v)
		return nil
	case accessorialcharge.FieldMethod:
		v, ok := value.(accessorialcharge.Method)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case accessorialcharge.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	}
	return fmt.Errorf("unknown AccessorialCharge field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccessorialChargeMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, accessorialcharge.FieldVersion)
	}
	if m.addamount != nil {
		fields = append(fields, accessorialcharge.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccessorialChargeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case accessorialcharge.FieldVersion:
		return m.AddedVersion()
	case accessorialcharge.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccessorialChargeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case accessorialcharge.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case accessorialcharge.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown AccessorialCharge numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccessorialChargeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(accessorialcharge.FieldDescription) {
		fields = append(fields, accessorialcharge.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccessorialChargeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccessorialChargeMutation) ClearField(name string) error {
	switch name {
	case accessorialcharge.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown AccessorialCharge nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccessorialChargeMutation) ResetField(name string) error {
	switch name {
	case accessorialcharge.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case accessorialcharge.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case accessorialcharge.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case accessorialcharge.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case accessorialcharge.FieldVersion:
		m.ResetVersion()
		return nil
	case accessorialcharge.FieldStatus:
		m.ResetStatus()
		return nil
	case accessorialcharge.FieldCode:
		m.ResetCode()
		return nil
	case accessorialcharge.FieldDescription:
		m.ResetDescription()
		return nil
	case accessorialcharge.FieldIsDetention:
		m.ResetIsDetention()
		return nil
	case accessorialcharge.FieldMethod:
		m.ResetMethod()
		return nil
	case accessorialcharge.FieldAmount:
		m.ResetAmount()
		return nil
	}
	return fmt.Errorf("unknown AccessorialCharge field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccessorialChargeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.business_unit != nil {
		edges = append(edges, accessorialcharge.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, accessorialcharge.EdgeOrganization)
	}
	if m.shipment_charges != nil {
		edges = append(edges, accessorialcharge.EdgeShipmentCharges)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccessorialChargeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case accessorialcharge.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case accessorialcharge.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case accessorialcharge.EdgeShipmentCharges:
		ids := make([]ent.Value, 0, len(m.shipment_charges))
		for id := range m.shipment_charges {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccessorialChargeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedshipment_charges != nil {
		edges = append(edges, accessorialcharge.EdgeShipmentCharges)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccessorialChargeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case accessorialcharge.EdgeShipmentCharges:
		ids := make([]ent.Value, 0, len(m.removedshipment_charges))
		for id := range m.removedshipment_charges {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccessorialChargeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbusiness_unit {
		edges = append(edges, accessorialcharge.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, accessorialcharge.EdgeOrganization)
	}
	if m.clearedshipment_charges {
		edges = append(edges, accessorialcharge.EdgeShipmentCharges)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccessorialChargeMutation) EdgeCleared(name string) bool {
	switch name {
	case accessorialcharge.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case accessorialcharge.EdgeOrganization:
		return m.clearedorganization
	case accessorialcharge.EdgeShipmentCharges:
		return m.clearedshipment_charges
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccessorialChargeMutation) ClearEdge(name string) error {
	switch name {
	case accessorialcharge.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case accessorialcharge.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown AccessorialCharge unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccessorialChargeMutation) ResetEdge(name string) error {
	switch name {
	case accessorialcharge.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case accessorialcharge.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case accessorialcharge.EdgeShipmentCharges:
		m.ResetShipmentCharges()
		return nil
	}
	return fmt.Errorf("unknown AccessorialCharge edge %s", name)
}

// AccountingControlMutation represents an operation that mutates the AccountingControl nodes in the graph.
type AccountingControlMutation struct {
	config
	op                              Op
	typ                             string
	id                              *uuid.UUID
	created_at                      *time.Time
	updated_at                      *time.Time
	rec_threshold                   *int8
	addrec_threshold                *int8
	rec_threshold_action            *accountingcontrol.RecThresholdAction
	auto_create_journal_entries     *bool
	journal_entry_criteria          *accountingcontrol.JournalEntryCriteria
	restrict_manual_journal_entries *bool
	require_journal_entry_approval  *bool
	enable_rec_notifications        *bool
	halt_on_pending_rec             *bool
	critical_processes              *string
	clearedFields                   map[string]struct{}
	organization                    *uuid.UUID
	clearedorganization             bool
	business_unit                   *uuid.UUID
	clearedbusiness_unit            bool
	default_rev_account             *uuid.UUID
	cleareddefault_rev_account      bool
	default_exp_account             *uuid.UUID
	cleareddefault_exp_account      bool
	done                            bool
	oldValue                        func(context.Context) (*AccountingControl, error)
	predicates                      []predicate.AccountingControl
}

var _ ent.Mutation = (*AccountingControlMutation)(nil)

// accountingcontrolOption allows management of the mutation configuration using functional options.
type accountingcontrolOption func(*AccountingControlMutation)

// newAccountingControlMutation creates new mutation for the AccountingControl entity.
func newAccountingControlMutation(c config, op Op, opts ...accountingcontrolOption) *AccountingControlMutation {
	m := &AccountingControlMutation{
		config:        c,
		op:            op,
		typ:           TypeAccountingControl,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountingControlID sets the ID field of the mutation.
func withAccountingControlID(id uuid.UUID) accountingcontrolOption {
	return func(m *AccountingControlMutation) {
		var (
			err   error
			once  sync.Once
			value *AccountingControl
		)
		m.oldValue = func(ctx context.Context) (*AccountingControl, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AccountingControl.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccountingControl sets the old AccountingControl of the mutation.
func withAccountingControl(node *AccountingControl) accountingcontrolOption {
	return func(m *AccountingControlMutation) {
		m.oldValue = func(context.Context) (*AccountingControl, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountingControlMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountingControlMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AccountingControl entities.
func (m *AccountingControlMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountingControlMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountingControlMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AccountingControl.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountingControlMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountingControlMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AccountingControl entity.
// If the AccountingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingControlMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountingControlMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AccountingControlMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AccountingControlMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AccountingControl entity.
// If the AccountingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingControlMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AccountingControlMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetRecThreshold sets the "rec_threshold" field.
func (m *AccountingControlMutation) SetRecThreshold(i int8) {
	m.rec_threshold = &i
	m.addrec_threshold = nil
}

// RecThreshold returns the value of the "rec_threshold" field in the mutation.
func (m *AccountingControlMutation) RecThreshold() (r int8, exists bool) {
	v := m.rec_threshold
	if v == nil {
		return
	}
	return *v, true
}

// OldRecThreshold returns the old "rec_threshold" field's value of the AccountingControl entity.
// If the AccountingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingControlMutation) OldRecThreshold(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecThreshold is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecThreshold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecThreshold: %w", err)
	}
	return oldValue.RecThreshold, nil
}

// AddRecThreshold adds i to the "rec_threshold" field.
func (m *AccountingControlMutation) AddRecThreshold(i int8) {
	if m.addrec_threshold != nil {
		*m.addrec_threshold += i
	} else {
		m.addrec_threshold = &i
	}
}

// AddedRecThreshold returns the value that was added to the "rec_threshold" field in this mutation.
func (m *AccountingControlMutation) AddedRecThreshold() (r int8, exists bool) {
	v := m.addrec_threshold
	if v == nil {
		return
	}
	return *v, true
}

// ResetRecThreshold resets all changes to the "rec_threshold" field.
func (m *AccountingControlMutation) ResetRecThreshold() {
	m.rec_threshold = nil
	m.addrec_threshold = nil
}

// SetRecThresholdAction sets the "rec_threshold_action" field.
func (m *AccountingControlMutation) SetRecThresholdAction(ata accountingcontrol.RecThresholdAction) {
	m.rec_threshold_action = &ata
}

// RecThresholdAction returns the value of the "rec_threshold_action" field in the mutation.
func (m *AccountingControlMutation) RecThresholdAction() (r accountingcontrol.RecThresholdAction, exists bool) {
	v := m.rec_threshold_action
	if v == nil {
		return
	}
	return *v, true
}

// OldRecThresholdAction returns the old "rec_threshold_action" field's value of the AccountingControl entity.
// If the AccountingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingControlMutation) OldRecThresholdAction(ctx context.Context) (v accountingcontrol.RecThresholdAction, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecThresholdAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecThresholdAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecThresholdAction: %w", err)
	}
	return oldValue.RecThresholdAction, nil
}

// ResetRecThresholdAction resets all changes to the "rec_threshold_action" field.
func (m *AccountingControlMutation) ResetRecThresholdAction() {
	m.rec_threshold_action = nil
}

// SetAutoCreateJournalEntries sets the "auto_create_journal_entries" field.
func (m *AccountingControlMutation) SetAutoCreateJournalEntries(b bool) {
	m.auto_create_journal_entries = &b
}

// AutoCreateJournalEntries returns the value of the "auto_create_journal_entries" field in the mutation.
func (m *AccountingControlMutation) AutoCreateJournalEntries() (r bool, exists bool) {
	v := m.auto_create_journal_entries
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoCreateJournalEntries returns the old "auto_create_journal_entries" field's value of the AccountingControl entity.
// If the AccountingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingControlMutation) OldAutoCreateJournalEntries(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoCreateJournalEntries is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoCreateJournalEntries requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoCreateJournalEntries: %w", err)
	}
	return oldValue.AutoCreateJournalEntries, nil
}

// ResetAutoCreateJournalEntries resets all changes to the "auto_create_journal_entries" field.
func (m *AccountingControlMutation) ResetAutoCreateJournalEntries() {
	m.auto_create_journal_entries = nil
}

// SetJournalEntryCriteria sets the "journal_entry_criteria" field.
func (m *AccountingControlMutation) SetJournalEntryCriteria(aec accountingcontrol.JournalEntryCriteria) {
	m.journal_entry_criteria = &aec
}

// JournalEntryCriteria returns the value of the "journal_entry_criteria" field in the mutation.
func (m *AccountingControlMutation) JournalEntryCriteria() (r accountingcontrol.JournalEntryCriteria, exists bool) {
	v := m.journal_entry_criteria
	if v == nil {
		return
	}
	return *v, true
}

// OldJournalEntryCriteria returns the old "journal_entry_criteria" field's value of the AccountingControl entity.
// If the AccountingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingControlMutation) OldJournalEntryCriteria(ctx context.Context) (v accountingcontrol.JournalEntryCriteria, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJournalEntryCriteria is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJournalEntryCriteria requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJournalEntryCriteria: %w", err)
	}
	return oldValue.JournalEntryCriteria, nil
}

// ResetJournalEntryCriteria resets all changes to the "journal_entry_criteria" field.
func (m *AccountingControlMutation) ResetJournalEntryCriteria() {
	m.journal_entry_criteria = nil
}

// SetRestrictManualJournalEntries sets the "restrict_manual_journal_entries" field.
func (m *AccountingControlMutation) SetRestrictManualJournalEntries(b bool) {
	m.restrict_manual_journal_entries = &b
}

// RestrictManualJournalEntries returns the value of the "restrict_manual_journal_entries" field in the mutation.
func (m *AccountingControlMutation) RestrictManualJournalEntries() (r bool, exists bool) {
	v := m.restrict_manual_journal_entries
	if v == nil {
		return
	}
	return *v, true
}

// OldRestrictManualJournalEntries returns the old "restrict_manual_journal_entries" field's value of the AccountingControl entity.
// If the AccountingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingControlMutation) OldRestrictManualJournalEntries(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRestrictManualJournalEntries is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRestrictManualJournalEntries requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRestrictManualJournalEntries: %w", err)
	}
	return oldValue.RestrictManualJournalEntries, nil
}

// ResetRestrictManualJournalEntries resets all changes to the "restrict_manual_journal_entries" field.
func (m *AccountingControlMutation) ResetRestrictManualJournalEntries() {
	m.restrict_manual_journal_entries = nil
}

// SetRequireJournalEntryApproval sets the "require_journal_entry_approval" field.
func (m *AccountingControlMutation) SetRequireJournalEntryApproval(b bool) {
	m.require_journal_entry_approval = &b
}

// RequireJournalEntryApproval returns the value of the "require_journal_entry_approval" field in the mutation.
func (m *AccountingControlMutation) RequireJournalEntryApproval() (r bool, exists bool) {
	v := m.require_journal_entry_approval
	if v == nil {
		return
	}
	return *v, true
}

// OldRequireJournalEntryApproval returns the old "require_journal_entry_approval" field's value of the AccountingControl entity.
// If the AccountingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingControlMutation) OldRequireJournalEntryApproval(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequireJournalEntryApproval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequireJournalEntryApproval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequireJournalEntryApproval: %w", err)
	}
	return oldValue.RequireJournalEntryApproval, nil
}

// ResetRequireJournalEntryApproval resets all changes to the "require_journal_entry_approval" field.
func (m *AccountingControlMutation) ResetRequireJournalEntryApproval() {
	m.require_journal_entry_approval = nil
}

// SetEnableRecNotifications sets the "enable_rec_notifications" field.
func (m *AccountingControlMutation) SetEnableRecNotifications(b bool) {
	m.enable_rec_notifications = &b
}

// EnableRecNotifications returns the value of the "enable_rec_notifications" field in the mutation.
func (m *AccountingControlMutation) EnableRecNotifications() (r bool, exists bool) {
	v := m.enable_rec_notifications
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableRecNotifications returns the old "enable_rec_notifications" field's value of the AccountingControl entity.
// If the AccountingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingControlMutation) OldEnableRecNotifications(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnableRecNotifications is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnableRecNotifications requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableRecNotifications: %w", err)
	}
	return oldValue.EnableRecNotifications, nil
}

// ResetEnableRecNotifications resets all changes to the "enable_rec_notifications" field.
func (m *AccountingControlMutation) ResetEnableRecNotifications() {
	m.enable_rec_notifications = nil
}

// SetHaltOnPendingRec sets the "halt_on_pending_rec" field.
func (m *AccountingControlMutation) SetHaltOnPendingRec(b bool) {
	m.halt_on_pending_rec = &b
}

// HaltOnPendingRec returns the value of the "halt_on_pending_rec" field in the mutation.
func (m *AccountingControlMutation) HaltOnPendingRec() (r bool, exists bool) {
	v := m.halt_on_pending_rec
	if v == nil {
		return
	}
	return *v, true
}

// OldHaltOnPendingRec returns the old "halt_on_pending_rec" field's value of the AccountingControl entity.
// If the AccountingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingControlMutation) OldHaltOnPendingRec(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHaltOnPendingRec is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHaltOnPendingRec requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHaltOnPendingRec: %w", err)
	}
	return oldValue.HaltOnPendingRec, nil
}

// ResetHaltOnPendingRec resets all changes to the "halt_on_pending_rec" field.
func (m *AccountingControlMutation) ResetHaltOnPendingRec() {
	m.halt_on_pending_rec = nil
}

// SetCriticalProcesses sets the "critical_processes" field.
func (m *AccountingControlMutation) SetCriticalProcesses(s string) {
	m.critical_processes = &s
}

// CriticalProcesses returns the value of the "critical_processes" field in the mutation.
func (m *AccountingControlMutation) CriticalProcesses() (r string, exists bool) {
	v := m.critical_processes
	if v == nil {
		return
	}
	return *v, true
}

// OldCriticalProcesses returns the old "critical_processes" field's value of the AccountingControl entity.
// If the AccountingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingControlMutation) OldCriticalProcesses(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCriticalProcesses is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCriticalProcesses requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCriticalProcesses: %w", err)
	}
	return oldValue.CriticalProcesses, nil
}

// ClearCriticalProcesses clears the value of the "critical_processes" field.
func (m *AccountingControlMutation) ClearCriticalProcesses() {
	m.critical_processes = nil
	m.clearedFields[accountingcontrol.FieldCriticalProcesses] = struct{}{}
}

// CriticalProcessesCleared returns if the "critical_processes" field was cleared in this mutation.
func (m *AccountingControlMutation) CriticalProcessesCleared() bool {
	_, ok := m.clearedFields[accountingcontrol.FieldCriticalProcesses]
	return ok
}

// ResetCriticalProcesses resets all changes to the "critical_processes" field.
func (m *AccountingControlMutation) ResetCriticalProcesses() {
	m.critical_processes = nil
	delete(m.clearedFields, accountingcontrol.FieldCriticalProcesses)
}

// SetDefaultRevAccountID sets the "default_rev_account_id" field.
func (m *AccountingControlMutation) SetDefaultRevAccountID(u uuid.UUID) {
	m.default_rev_account = &u
}

// DefaultRevAccountID returns the value of the "default_rev_account_id" field in the mutation.
func (m *AccountingControlMutation) DefaultRevAccountID() (r uuid.UUID, exists bool) {
	v := m.default_rev_account
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultRevAccountID returns the old "default_rev_account_id" field's value of the AccountingControl entity.
// If the AccountingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingControlMutation) OldDefaultRevAccountID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultRevAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultRevAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultRevAccountID: %w", err)
	}
	return oldValue.DefaultRevAccountID, nil
}

// ClearDefaultRevAccountID clears the value of the "default_rev_account_id" field.
func (m *AccountingControlMutation) ClearDefaultRevAccountID() {
	m.default_rev_account = nil
	m.clearedFields[accountingcontrol.FieldDefaultRevAccountID] = struct{}{}
}

// DefaultRevAccountIDCleared returns if the "default_rev_account_id" field was cleared in this mutation.
func (m *AccountingControlMutation) DefaultRevAccountIDCleared() bool {
	_, ok := m.clearedFields[accountingcontrol.FieldDefaultRevAccountID]
	return ok
}

// ResetDefaultRevAccountID resets all changes to the "default_rev_account_id" field.
func (m *AccountingControlMutation) ResetDefaultRevAccountID() {
	m.default_rev_account = nil
	delete(m.clearedFields, accountingcontrol.FieldDefaultRevAccountID)
}

// SetDefaultExpAccountID sets the "default_exp_account_id" field.
func (m *AccountingControlMutation) SetDefaultExpAccountID(u uuid.UUID) {
	m.default_exp_account = &u
}

// DefaultExpAccountID returns the value of the "default_exp_account_id" field in the mutation.
func (m *AccountingControlMutation) DefaultExpAccountID() (r uuid.UUID, exists bool) {
	v := m.default_exp_account
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultExpAccountID returns the old "default_exp_account_id" field's value of the AccountingControl entity.
// If the AccountingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingControlMutation) OldDefaultExpAccountID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultExpAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultExpAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultExpAccountID: %w", err)
	}
	return oldValue.DefaultExpAccountID, nil
}

// ClearDefaultExpAccountID clears the value of the "default_exp_account_id" field.
func (m *AccountingControlMutation) ClearDefaultExpAccountID() {
	m.default_exp_account = nil
	m.clearedFields[accountingcontrol.FieldDefaultExpAccountID] = struct{}{}
}

// DefaultExpAccountIDCleared returns if the "default_exp_account_id" field was cleared in this mutation.
func (m *AccountingControlMutation) DefaultExpAccountIDCleared() bool {
	_, ok := m.clearedFields[accountingcontrol.FieldDefaultExpAccountID]
	return ok
}

// ResetDefaultExpAccountID resets all changes to the "default_exp_account_id" field.
func (m *AccountingControlMutation) ResetDefaultExpAccountID() {
	m.default_exp_account = nil
	delete(m.clearedFields, accountingcontrol.FieldDefaultExpAccountID)
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *AccountingControlMutation) SetOrganizationID(id uuid.UUID) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *AccountingControlMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *AccountingControlMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *AccountingControlMutation) OrganizationID() (id uuid.UUID, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *AccountingControlMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *AccountingControlMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// SetBusinessUnitID sets the "business_unit" edge to the BusinessUnit entity by id.
func (m *AccountingControlMutation) SetBusinessUnitID(id uuid.UUID) {
	m.business_unit = &id
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *AccountingControlMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *AccountingControlMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitID returns the "business_unit" edge ID in the mutation.
func (m *AccountingControlMutation) BusinessUnitID() (id uuid.UUID, exists bool) {
	if m.business_unit != nil {
		return *m.business_unit, true
	}
	return
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *AccountingControlMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *AccountingControlMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearDefaultRevAccount clears the "default_rev_account" edge to the GeneralLedgerAccount entity.
func (m *AccountingControlMutation) ClearDefaultRevAccount() {
	m.cleareddefault_rev_account = true
	m.clearedFields[accountingcontrol.FieldDefaultRevAccountID] = struct{}{}
}

// DefaultRevAccountCleared reports if the "default_rev_account" edge to the GeneralLedgerAccount entity was cleared.
func (m *AccountingControlMutation) DefaultRevAccountCleared() bool {
	return m.DefaultRevAccountIDCleared() || m.cleareddefault_rev_account
}

// DefaultRevAccountIDs returns the "default_rev_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DefaultRevAccountID instead. It exists only for internal usage by the builders.
func (m *AccountingControlMutation) DefaultRevAccountIDs() (ids []uuid.UUID) {
	if id := m.default_rev_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDefaultRevAccount resets all changes to the "default_rev_account" edge.
func (m *AccountingControlMutation) ResetDefaultRevAccount() {
	m.default_rev_account = nil
	m.cleareddefault_rev_account = false
}

// ClearDefaultExpAccount clears the "default_exp_account" edge to the GeneralLedgerAccount entity.
func (m *AccountingControlMutation) ClearDefaultExpAccount() {
	m.cleareddefault_exp_account = true
	m.clearedFields[accountingcontrol.FieldDefaultExpAccountID] = struct{}{}
}

// DefaultExpAccountCleared reports if the "default_exp_account" edge to the GeneralLedgerAccount entity was cleared.
func (m *AccountingControlMutation) DefaultExpAccountCleared() bool {
	return m.DefaultExpAccountIDCleared() || m.cleareddefault_exp_account
}

// DefaultExpAccountIDs returns the "default_exp_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DefaultExpAccountID instead. It exists only for internal usage by the builders.
func (m *AccountingControlMutation) DefaultExpAccountIDs() (ids []uuid.UUID) {
	if id := m.default_exp_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDefaultExpAccount resets all changes to the "default_exp_account" edge.
func (m *AccountingControlMutation) ResetDefaultExpAccount() {
	m.default_exp_account = nil
	m.cleareddefault_exp_account = false
}

// Where appends a list predicates to the AccountingControlMutation builder.
func (m *AccountingControlMutation) Where(ps ...predicate.AccountingControl) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountingControlMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountingControlMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AccountingControl, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountingControlMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountingControlMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AccountingControl).
func (m *AccountingControlMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountingControlMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, accountingcontrol.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, accountingcontrol.FieldUpdatedAt)
	}
	if m.rec_threshold != nil {
		fields = append(fields, accountingcontrol.FieldRecThreshold)
	}
	if m.rec_threshold_action != nil {
		fields = append(fields, accountingcontrol.FieldRecThresholdAction)
	}
	if m.auto_create_journal_entries != nil {
		fields = append(fields, accountingcontrol.FieldAutoCreateJournalEntries)
	}
	if m.journal_entry_criteria != nil {
		fields = append(fields, accountingcontrol.FieldJournalEntryCriteria)
	}
	if m.restrict_manual_journal_entries != nil {
		fields = append(fields, accountingcontrol.FieldRestrictManualJournalEntries)
	}
	if m.require_journal_entry_approval != nil {
		fields = append(fields, accountingcontrol.FieldRequireJournalEntryApproval)
	}
	if m.enable_rec_notifications != nil {
		fields = append(fields, accountingcontrol.FieldEnableRecNotifications)
	}
	if m.halt_on_pending_rec != nil {
		fields = append(fields, accountingcontrol.FieldHaltOnPendingRec)
	}
	if m.critical_processes != nil {
		fields = append(fields, accountingcontrol.FieldCriticalProcesses)
	}
	if m.default_rev_account != nil {
		fields = append(fields, accountingcontrol.FieldDefaultRevAccountID)
	}
	if m.default_exp_account != nil {
		fields = append(fields, accountingcontrol.FieldDefaultExpAccountID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountingControlMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case accountingcontrol.FieldCreatedAt:
		return m.CreatedAt()
	case accountingcontrol.FieldUpdatedAt:
		return m.UpdatedAt()
	case accountingcontrol.FieldRecThreshold:
		return m.RecThreshold()
	case accountingcontrol.FieldRecThresholdAction:
		return m.RecThresholdAction()
	case accountingcontrol.FieldAutoCreateJournalEntries:
		return m.AutoCreateJournalEntries()
	case accountingcontrol.FieldJournalEntryCriteria:
		return m.JournalEntryCriteria()
	case accountingcontrol.FieldRestrictManualJournalEntries:
		return m.RestrictManualJournalEntries()
	case accountingcontrol.FieldRequireJournalEntryApproval:
		return m.RequireJournalEntryApproval()
	case accountingcontrol.FieldEnableRecNotifications:
		return m.EnableRecNotifications()
	case accountingcontrol.FieldHaltOnPendingRec:
		return m.HaltOnPendingRec()
	case accountingcontrol.FieldCriticalProcesses:
		return m.CriticalProcesses()
	case accountingcontrol.FieldDefaultRevAccountID:
		return m.DefaultRevAccountID()
	case accountingcontrol.FieldDefaultExpAccountID:
		return m.DefaultExpAccountID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountingControlMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case accountingcontrol.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case accountingcontrol.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case accountingcontrol.FieldRecThreshold:
		return m.OldRecThreshold(ctx)
	case accountingcontrol.FieldRecThresholdAction:
		return m.OldRecThresholdAction(ctx)
	case accountingcontrol.FieldAutoCreateJournalEntries:
		return m.OldAutoCreateJournalEntries(ctx)
	case accountingcontrol.FieldJournalEntryCriteria:
		return m.OldJournalEntryCriteria(ctx)
	case accountingcontrol.FieldRestrictManualJournalEntries:
		return m.OldRestrictManualJournalEntries(ctx)
	case accountingcontrol.FieldRequireJournalEntryApproval:
		return m.OldRequireJournalEntryApproval(ctx)
	case accountingcontrol.FieldEnableRecNotifications:
		return m.OldEnableRecNotifications(ctx)
	case accountingcontrol.FieldHaltOnPendingRec:
		return m.OldHaltOnPendingRec(ctx)
	case accountingcontrol.FieldCriticalProcesses:
		return m.OldCriticalProcesses(ctx)
	case accountingcontrol.FieldDefaultRevAccountID:
		return m.OldDefaultRevAccountID(ctx)
	case accountingcontrol.FieldDefaultExpAccountID:
		return m.OldDefaultExpAccountID(ctx)
	}
	return nil, fmt.Errorf("unknown AccountingControl field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountingControlMutation) SetField(name string, value ent.Value) error {
	switch name {
	case accountingcontrol.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case accountingcontrol.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case accountingcontrol.FieldRecThreshold:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecThreshold(v)
		return nil
	case accountingcontrol.FieldRecThresholdAction:
		v, ok := value.(accountingcontrol.RecThresholdAction)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecThresholdAction(v)
		return nil
	case accountingcontrol.FieldAutoCreateJournalEntries:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoCreateJournalEntries(v)
		return nil
	case accountingcontrol.FieldJournalEntryCriteria:
		v, ok := value.(accountingcontrol.JournalEntryCriteria)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJournalEntryCriteria(v)
		return nil
	case accountingcontrol.FieldRestrictManualJournalEntries:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRestrictManualJournalEntries(v)
		return nil
	case accountingcontrol.FieldRequireJournalEntryApproval:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequireJournalEntryApproval(v)
		return nil
	case accountingcontrol.FieldEnableRecNotifications:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableRecNotifications(v)
		return nil
	case accountingcontrol.FieldHaltOnPendingRec:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHaltOnPendingRec(v)
		return nil
	case accountingcontrol.FieldCriticalProcesses:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCriticalProcesses(v)
		return nil
	case accountingcontrol.FieldDefaultRevAccountID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultRevAccountID(v)
		return nil
	case accountingcontrol.FieldDefaultExpAccountID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultExpAccountID(v)
		return nil
	}
	return fmt.Errorf("unknown AccountingControl field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountingControlMutation) AddedFields() []string {
	var fields []string
	if m.addrec_threshold != nil {
		fields = append(fields, accountingcontrol.FieldRecThreshold)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountingControlMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case accountingcontrol.FieldRecThreshold:
		return m.AddedRecThreshold()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountingControlMutation) AddField(name string, value ent.Value) error {
	switch name {
	case accountingcontrol.FieldRecThreshold:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRecThreshold(v)
		return nil
	}
	return fmt.Errorf("unknown AccountingControl numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountingControlMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(accountingcontrol.FieldCriticalProcesses) {
		fields = append(fields, accountingcontrol.FieldCriticalProcesses)
	}
	if m.FieldCleared(accountingcontrol.FieldDefaultRevAccountID) {
		fields = append(fields, accountingcontrol.FieldDefaultRevAccountID)
	}
	if m.FieldCleared(accountingcontrol.FieldDefaultExpAccountID) {
		fields = append(fields, accountingcontrol.FieldDefaultExpAccountID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountingControlMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountingControlMutation) ClearField(name string) error {
	switch name {
	case accountingcontrol.FieldCriticalProcesses:
		m.ClearCriticalProcesses()
		return nil
	case accountingcontrol.FieldDefaultRevAccountID:
		m.ClearDefaultRevAccountID()
		return nil
	case accountingcontrol.FieldDefaultExpAccountID:
		m.ClearDefaultExpAccountID()
		return nil
	}
	return fmt.Errorf("unknown AccountingControl nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountingControlMutation) ResetField(name string) error {
	switch name {
	case accountingcontrol.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case accountingcontrol.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case accountingcontrol.FieldRecThreshold:
		m.ResetRecThreshold()
		return nil
	case accountingcontrol.FieldRecThresholdAction:
		m.ResetRecThresholdAction()
		return nil
	case accountingcontrol.FieldAutoCreateJournalEntries:
		m.ResetAutoCreateJournalEntries()
		return nil
	case accountingcontrol.FieldJournalEntryCriteria:
		m.ResetJournalEntryCriteria()
		return nil
	case accountingcontrol.FieldRestrictManualJournalEntries:
		m.ResetRestrictManualJournalEntries()
		return nil
	case accountingcontrol.FieldRequireJournalEntryApproval:
		m.ResetRequireJournalEntryApproval()
		return nil
	case accountingcontrol.FieldEnableRecNotifications:
		m.ResetEnableRecNotifications()
		return nil
	case accountingcontrol.FieldHaltOnPendingRec:
		m.ResetHaltOnPendingRec()
		return nil
	case accountingcontrol.FieldCriticalProcesses:
		m.ResetCriticalProcesses()
		return nil
	case accountingcontrol.FieldDefaultRevAccountID:
		m.ResetDefaultRevAccountID()
		return nil
	case accountingcontrol.FieldDefaultExpAccountID:
		m.ResetDefaultExpAccountID()
		return nil
	}
	return fmt.Errorf("unknown AccountingControl field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountingControlMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.organization != nil {
		edges = append(edges, accountingcontrol.EdgeOrganization)
	}
	if m.business_unit != nil {
		edges = append(edges, accountingcontrol.EdgeBusinessUnit)
	}
	if m.default_rev_account != nil {
		edges = append(edges, accountingcontrol.EdgeDefaultRevAccount)
	}
	if m.default_exp_account != nil {
		edges = append(edges, accountingcontrol.EdgeDefaultExpAccount)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountingControlMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case accountingcontrol.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case accountingcontrol.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case accountingcontrol.EdgeDefaultRevAccount:
		if id := m.default_rev_account; id != nil {
			return []ent.Value{*id}
		}
	case accountingcontrol.EdgeDefaultExpAccount:
		if id := m.default_exp_account; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountingControlMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountingControlMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountingControlMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedorganization {
		edges = append(edges, accountingcontrol.EdgeOrganization)
	}
	if m.clearedbusiness_unit {
		edges = append(edges, accountingcontrol.EdgeBusinessUnit)
	}
	if m.cleareddefault_rev_account {
		edges = append(edges, accountingcontrol.EdgeDefaultRevAccount)
	}
	if m.cleareddefault_exp_account {
		edges = append(edges, accountingcontrol.EdgeDefaultExpAccount)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountingControlMutation) EdgeCleared(name string) bool {
	switch name {
	case accountingcontrol.EdgeOrganization:
		return m.clearedorganization
	case accountingcontrol.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case accountingcontrol.EdgeDefaultRevAccount:
		return m.cleareddefault_rev_account
	case accountingcontrol.EdgeDefaultExpAccount:
		return m.cleareddefault_exp_account
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountingControlMutation) ClearEdge(name string) error {
	switch name {
	case accountingcontrol.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case accountingcontrol.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case accountingcontrol.EdgeDefaultRevAccount:
		m.ClearDefaultRevAccount()
		return nil
	case accountingcontrol.EdgeDefaultExpAccount:
		m.ClearDefaultExpAccount()
		return nil
	}
	return fmt.Errorf("unknown AccountingControl unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountingControlMutation) ResetEdge(name string) error {
	switch name {
	case accountingcontrol.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case accountingcontrol.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case accountingcontrol.EdgeDefaultRevAccount:
		m.ResetDefaultRevAccount()
		return nil
	case accountingcontrol.EdgeDefaultExpAccount:
		m.ResetDefaultExpAccount()
		return nil
	}
	return fmt.Errorf("unknown AccountingControl edge %s", name)
}

// BillingControlMutation represents an operation that mutates the BillingControl nodes in the graph.
type BillingControlMutation struct {
	config
	op                         Op
	typ                        string
	id                         *uuid.UUID
	created_at                 *time.Time
	updated_at                 *time.Time
	remove_billing_history     *bool
	auto_bill_shipment         *bool
	auto_mark_ready_to_bill    *bool
	validate_customer_rates    *bool
	auto_bill_criteria         *billingcontrol.AutoBillCriteria
	shipment_transfer_criteria *billingcontrol.ShipmentTransferCriteria
	enforce_customer_billing   *bool
	clearedFields              map[string]struct{}
	organization               *uuid.UUID
	clearedorganization        bool
	business_unit              *uuid.UUID
	clearedbusiness_unit       bool
	done                       bool
	oldValue                   func(context.Context) (*BillingControl, error)
	predicates                 []predicate.BillingControl
}

var _ ent.Mutation = (*BillingControlMutation)(nil)

// billingcontrolOption allows management of the mutation configuration using functional options.
type billingcontrolOption func(*BillingControlMutation)

// newBillingControlMutation creates new mutation for the BillingControl entity.
func newBillingControlMutation(c config, op Op, opts ...billingcontrolOption) *BillingControlMutation {
	m := &BillingControlMutation{
		config:        c,
		op:            op,
		typ:           TypeBillingControl,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillingControlID sets the ID field of the mutation.
func withBillingControlID(id uuid.UUID) billingcontrolOption {
	return func(m *BillingControlMutation) {
		var (
			err   error
			once  sync.Once
			value *BillingControl
		)
		m.oldValue = func(ctx context.Context) (*BillingControl, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BillingControl.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBillingControl sets the old BillingControl of the mutation.
func withBillingControl(node *BillingControl) billingcontrolOption {
	return func(m *BillingControlMutation) {
		m.oldValue = func(context.Context) (*BillingControl, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillingControlMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillingControlMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BillingControl entities.
func (m *BillingControlMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BillingControlMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BillingControlMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BillingControl.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BillingControlMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BillingControlMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BillingControl entity.
// If the BillingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingControlMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BillingControlMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BillingControlMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BillingControlMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BillingControl entity.
// If the BillingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingControlMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BillingControlMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetRemoveBillingHistory sets the "remove_billing_history" field.
func (m *BillingControlMutation) SetRemoveBillingHistory(b bool) {
	m.remove_billing_history = &b
}

// RemoveBillingHistory returns the value of the "remove_billing_history" field in the mutation.
func (m *BillingControlMutation) RemoveBillingHistory() (r bool, exists bool) {
	v := m.remove_billing_history
	if v == nil {
		return
	}
	return *v, true
}

// OldRemoveBillingHistory returns the old "remove_billing_history" field's value of the BillingControl entity.
// If the BillingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingControlMutation) OldRemoveBillingHistory(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemoveBillingHistory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemoveBillingHistory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemoveBillingHistory: %w", err)
	}
	return oldValue.RemoveBillingHistory, nil
}

// ResetRemoveBillingHistory resets all changes to the "remove_billing_history" field.
func (m *BillingControlMutation) ResetRemoveBillingHistory() {
	m.remove_billing_history = nil
}

// SetAutoBillShipment sets the "auto_bill_shipment" field.
func (m *BillingControlMutation) SetAutoBillShipment(b bool) {
	m.auto_bill_shipment = &b
}

// AutoBillShipment returns the value of the "auto_bill_shipment" field in the mutation.
func (m *BillingControlMutation) AutoBillShipment() (r bool, exists bool) {
	v := m.auto_bill_shipment
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoBillShipment returns the old "auto_bill_shipment" field's value of the BillingControl entity.
// If the BillingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingControlMutation) OldAutoBillShipment(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoBillShipment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoBillShipment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoBillShipment: %w", err)
	}
	return oldValue.AutoBillShipment, nil
}

// ResetAutoBillShipment resets all changes to the "auto_bill_shipment" field.
func (m *BillingControlMutation) ResetAutoBillShipment() {
	m.auto_bill_shipment = nil
}

// SetAutoMarkReadyToBill sets the "auto_mark_ready_to_bill" field.
func (m *BillingControlMutation) SetAutoMarkReadyToBill(b bool) {
	m.auto_mark_ready_to_bill = &b
}

// AutoMarkReadyToBill returns the value of the "auto_mark_ready_to_bill" field in the mutation.
func (m *BillingControlMutation) AutoMarkReadyToBill() (r bool, exists bool) {
	v := m.auto_mark_ready_to_bill
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoMarkReadyToBill returns the old "auto_mark_ready_to_bill" field's value of the BillingControl entity.
// If the BillingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingControlMutation) OldAutoMarkReadyToBill(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoMarkReadyToBill is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoMarkReadyToBill requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoMarkReadyToBill: %w", err)
	}
	return oldValue.AutoMarkReadyToBill, nil
}

// ResetAutoMarkReadyToBill resets all changes to the "auto_mark_ready_to_bill" field.
func (m *BillingControlMutation) ResetAutoMarkReadyToBill() {
	m.auto_mark_ready_to_bill = nil
}

// SetValidateCustomerRates sets the "validate_customer_rates" field.
func (m *BillingControlMutation) SetValidateCustomerRates(b bool) {
	m.validate_customer_rates = &b
}

// ValidateCustomerRates returns the value of the "validate_customer_rates" field in the mutation.
func (m *BillingControlMutation) ValidateCustomerRates() (r bool, exists bool) {
	v := m.validate_customer_rates
	if v == nil {
		return
	}
	return *v, true
}

// OldValidateCustomerRates returns the old "validate_customer_rates" field's value of the BillingControl entity.
// If the BillingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingControlMutation) OldValidateCustomerRates(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidateCustomerRates is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidateCustomerRates requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidateCustomerRates: %w", err)
	}
	return oldValue.ValidateCustomerRates, nil
}

// ResetValidateCustomerRates resets all changes to the "validate_customer_rates" field.
func (m *BillingControlMutation) ResetValidateCustomerRates() {
	m.validate_customer_rates = nil
}

// SetAutoBillCriteria sets the "auto_bill_criteria" field.
func (m *BillingControlMutation) SetAutoBillCriteria(bbc billingcontrol.AutoBillCriteria) {
	m.auto_bill_criteria = &bbc
}

// AutoBillCriteria returns the value of the "auto_bill_criteria" field in the mutation.
func (m *BillingControlMutation) AutoBillCriteria() (r billingcontrol.AutoBillCriteria, exists bool) {
	v := m.auto_bill_criteria
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoBillCriteria returns the old "auto_bill_criteria" field's value of the BillingControl entity.
// If the BillingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingControlMutation) OldAutoBillCriteria(ctx context.Context) (v billingcontrol.AutoBillCriteria, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoBillCriteria is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoBillCriteria requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoBillCriteria: %w", err)
	}
	return oldValue.AutoBillCriteria, nil
}

// ResetAutoBillCriteria resets all changes to the "auto_bill_criteria" field.
func (m *BillingControlMutation) ResetAutoBillCriteria() {
	m.auto_bill_criteria = nil
}

// SetShipmentTransferCriteria sets the "shipment_transfer_criteria" field.
func (m *BillingControlMutation) SetShipmentTransferCriteria(btc billingcontrol.ShipmentTransferCriteria) {
	m.shipment_transfer_criteria = &btc
}

// ShipmentTransferCriteria returns the value of the "shipment_transfer_criteria" field in the mutation.
func (m *BillingControlMutation) ShipmentTransferCriteria() (r billingcontrol.ShipmentTransferCriteria, exists bool) {
	v := m.shipment_transfer_criteria
	if v == nil {
		return
	}
	return *v, true
}

// OldShipmentTransferCriteria returns the old "shipment_transfer_criteria" field's value of the BillingControl entity.
// If the BillingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingControlMutation) OldShipmentTransferCriteria(ctx context.Context) (v billingcontrol.ShipmentTransferCriteria, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShipmentTransferCriteria is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShipmentTransferCriteria requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipmentTransferCriteria: %w", err)
	}
	return oldValue.ShipmentTransferCriteria, nil
}

// ResetShipmentTransferCriteria resets all changes to the "shipment_transfer_criteria" field.
func (m *BillingControlMutation) ResetShipmentTransferCriteria() {
	m.shipment_transfer_criteria = nil
}

// SetEnforceCustomerBilling sets the "enforce_customer_billing" field.
func (m *BillingControlMutation) SetEnforceCustomerBilling(b bool) {
	m.enforce_customer_billing = &b
}

// EnforceCustomerBilling returns the value of the "enforce_customer_billing" field in the mutation.
func (m *BillingControlMutation) EnforceCustomerBilling() (r bool, exists bool) {
	v := m.enforce_customer_billing
	if v == nil {
		return
	}
	return *v, true
}

// OldEnforceCustomerBilling returns the old "enforce_customer_billing" field's value of the BillingControl entity.
// If the BillingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingControlMutation) OldEnforceCustomerBilling(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnforceCustomerBilling is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnforceCustomerBilling requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnforceCustomerBilling: %w", err)
	}
	return oldValue.EnforceCustomerBilling, nil
}

// ResetEnforceCustomerBilling resets all changes to the "enforce_customer_billing" field.
func (m *BillingControlMutation) ResetEnforceCustomerBilling() {
	m.enforce_customer_billing = nil
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *BillingControlMutation) SetOrganizationID(id uuid.UUID) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *BillingControlMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *BillingControlMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *BillingControlMutation) OrganizationID() (id uuid.UUID, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *BillingControlMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *BillingControlMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// SetBusinessUnitID sets the "business_unit" edge to the BusinessUnit entity by id.
func (m *BillingControlMutation) SetBusinessUnitID(id uuid.UUID) {
	m.business_unit = &id
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *BillingControlMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *BillingControlMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitID returns the "business_unit" edge ID in the mutation.
func (m *BillingControlMutation) BusinessUnitID() (id uuid.UUID, exists bool) {
	if m.business_unit != nil {
		return *m.business_unit, true
	}
	return
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *BillingControlMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *BillingControlMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// Where appends a list predicates to the BillingControlMutation builder.
func (m *BillingControlMutation) Where(ps ...predicate.BillingControl) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BillingControlMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BillingControlMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BillingControl, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BillingControlMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BillingControlMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BillingControl).
func (m *BillingControlMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BillingControlMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, billingcontrol.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, billingcontrol.FieldUpdatedAt)
	}
	if m.remove_billing_history != nil {
		fields = append(fields, billingcontrol.FieldRemoveBillingHistory)
	}
	if m.auto_bill_shipment != nil {
		fields = append(fields, billingcontrol.FieldAutoBillShipment)
	}
	if m.auto_mark_ready_to_bill != nil {
		fields = append(fields, billingcontrol.FieldAutoMarkReadyToBill)
	}
	if m.validate_customer_rates != nil {
		fields = append(fields, billingcontrol.FieldValidateCustomerRates)
	}
	if m.auto_bill_criteria != nil {
		fields = append(fields, billingcontrol.FieldAutoBillCriteria)
	}
	if m.shipment_transfer_criteria != nil {
		fields = append(fields, billingcontrol.FieldShipmentTransferCriteria)
	}
	if m.enforce_customer_billing != nil {
		fields = append(fields, billingcontrol.FieldEnforceCustomerBilling)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BillingControlMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case billingcontrol.FieldCreatedAt:
		return m.CreatedAt()
	case billingcontrol.FieldUpdatedAt:
		return m.UpdatedAt()
	case billingcontrol.FieldRemoveBillingHistory:
		return m.RemoveBillingHistory()
	case billingcontrol.FieldAutoBillShipment:
		return m.AutoBillShipment()
	case billingcontrol.FieldAutoMarkReadyToBill:
		return m.AutoMarkReadyToBill()
	case billingcontrol.FieldValidateCustomerRates:
		return m.ValidateCustomerRates()
	case billingcontrol.FieldAutoBillCriteria:
		return m.AutoBillCriteria()
	case billingcontrol.FieldShipmentTransferCriteria:
		return m.ShipmentTransferCriteria()
	case billingcontrol.FieldEnforceCustomerBilling:
		return m.EnforceCustomerBilling()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BillingControlMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case billingcontrol.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case billingcontrol.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case billingcontrol.FieldRemoveBillingHistory:
		return m.OldRemoveBillingHistory(ctx)
	case billingcontrol.FieldAutoBillShipment:
		return m.OldAutoBillShipment(ctx)
	case billingcontrol.FieldAutoMarkReadyToBill:
		return m.OldAutoMarkReadyToBill(ctx)
	case billingcontrol.FieldValidateCustomerRates:
		return m.OldValidateCustomerRates(ctx)
	case billingcontrol.FieldAutoBillCriteria:
		return m.OldAutoBillCriteria(ctx)
	case billingcontrol.FieldShipmentTransferCriteria:
		return m.OldShipmentTransferCriteria(ctx)
	case billingcontrol.FieldEnforceCustomerBilling:
		return m.OldEnforceCustomerBilling(ctx)
	}
	return nil, fmt.Errorf("unknown BillingControl field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingControlMutation) SetField(name string, value ent.Value) error {
	switch name {
	case billingcontrol.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case billingcontrol.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case billingcontrol.FieldRemoveBillingHistory:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemoveBillingHistory(v)
		return nil
	case billingcontrol.FieldAutoBillShipment:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoBillShipment(v)
		return nil
	case billingcontrol.FieldAutoMarkReadyToBill:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoMarkReadyToBill(v)
		return nil
	case billingcontrol.FieldValidateCustomerRates:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidateCustomerRates(v)
		return nil
	case billingcontrol.FieldAutoBillCriteria:
		v, ok := value.(billingcontrol.AutoBillCriteria)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoBillCriteria(v)
		return nil
	case billingcontrol.FieldShipmentTransferCriteria:
		v, ok := value.(billingcontrol.ShipmentTransferCriteria)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipmentTransferCriteria(v)
		return nil
	case billingcontrol.FieldEnforceCustomerBilling:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnforceCustomerBilling(v)
		return nil
	}
	return fmt.Errorf("unknown BillingControl field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BillingControlMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BillingControlMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingControlMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BillingControl numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BillingControlMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BillingControlMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillingControlMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BillingControl nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BillingControlMutation) ResetField(name string) error {
	switch name {
	case billingcontrol.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case billingcontrol.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case billingcontrol.FieldRemoveBillingHistory:
		m.ResetRemoveBillingHistory()
		return nil
	case billingcontrol.FieldAutoBillShipment:
		m.ResetAutoBillShipment()
		return nil
	case billingcontrol.FieldAutoMarkReadyToBill:
		m.ResetAutoMarkReadyToBill()
		return nil
	case billingcontrol.FieldValidateCustomerRates:
		m.ResetValidateCustomerRates()
		return nil
	case billingcontrol.FieldAutoBillCriteria:
		m.ResetAutoBillCriteria()
		return nil
	case billingcontrol.FieldShipmentTransferCriteria:
		m.ResetShipmentTransferCriteria()
		return nil
	case billingcontrol.FieldEnforceCustomerBilling:
		m.ResetEnforceCustomerBilling()
		return nil
	}
	return fmt.Errorf("unknown BillingControl field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BillingControlMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.organization != nil {
		edges = append(edges, billingcontrol.EdgeOrganization)
	}
	if m.business_unit != nil {
		edges = append(edges, billingcontrol.EdgeBusinessUnit)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BillingControlMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case billingcontrol.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case billingcontrol.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BillingControlMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BillingControlMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BillingControlMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorganization {
		edges = append(edges, billingcontrol.EdgeOrganization)
	}
	if m.clearedbusiness_unit {
		edges = append(edges, billingcontrol.EdgeBusinessUnit)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BillingControlMutation) EdgeCleared(name string) bool {
	switch name {
	case billingcontrol.EdgeOrganization:
		return m.clearedorganization
	case billingcontrol.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BillingControlMutation) ClearEdge(name string) error {
	switch name {
	case billingcontrol.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case billingcontrol.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	}
	return fmt.Errorf("unknown BillingControl unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BillingControlMutation) ResetEdge(name string) error {
	switch name {
	case billingcontrol.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case billingcontrol.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	}
	return fmt.Errorf("unknown BillingControl edge %s", name)
}

// BusinessUnitMutation represents an operation that mutates the BusinessUnit nodes in the graph.
type BusinessUnitMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	status               *businessunit.Status
	name                 *string
	entity_key           *string
	phone_number         *string
	address              *string
	city                 *string
	state                *string
	country              *string
	postal_code          *string
	tax_id               *string
	subscription_plan    *string
	description          *string
	legal_name           *string
	contact_name         *string
	contact_email        *string
	paid_until           *time.Time
	settings             *map[string]interface{}
	free_trial           *bool
	clearedFields        map[string]struct{}
	prev                 *uuid.UUID
	clearedprev          bool
	next                 *uuid.UUID
	clearednext          bool
	organizations        map[uuid.UUID]struct{}
	removedorganizations map[uuid.UUID]struct{}
	clearedorganizations bool
	done                 bool
	oldValue             func(context.Context) (*BusinessUnit, error)
	predicates           []predicate.BusinessUnit
}

var _ ent.Mutation = (*BusinessUnitMutation)(nil)

// businessunitOption allows management of the mutation configuration using functional options.
type businessunitOption func(*BusinessUnitMutation)

// newBusinessUnitMutation creates new mutation for the BusinessUnit entity.
func newBusinessUnitMutation(c config, op Op, opts ...businessunitOption) *BusinessUnitMutation {
	m := &BusinessUnitMutation{
		config:        c,
		op:            op,
		typ:           TypeBusinessUnit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBusinessUnitID sets the ID field of the mutation.
func withBusinessUnitID(id uuid.UUID) businessunitOption {
	return func(m *BusinessUnitMutation) {
		var (
			err   error
			once  sync.Once
			value *BusinessUnit
		)
		m.oldValue = func(ctx context.Context) (*BusinessUnit, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BusinessUnit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBusinessUnit sets the old BusinessUnit of the mutation.
func withBusinessUnit(node *BusinessUnit) businessunitOption {
	return func(m *BusinessUnitMutation) {
		m.oldValue = func(context.Context) (*BusinessUnit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BusinessUnitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BusinessUnitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BusinessUnit entities.
func (m *BusinessUnitMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BusinessUnitMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BusinessUnitMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BusinessUnit.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BusinessUnitMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BusinessUnitMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BusinessUnitMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BusinessUnitMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BusinessUnitMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BusinessUnitMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *BusinessUnitMutation) SetStatus(b businessunit.Status) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *BusinessUnitMutation) Status() (r businessunit.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldStatus(ctx context.Context) (v businessunit.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BusinessUnitMutation) ResetStatus() {
	m.status = nil
}

// SetName sets the "name" field.
func (m *BusinessUnitMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BusinessUnitMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BusinessUnitMutation) ResetName() {
	m.name = nil
}

// SetEntityKey sets the "entity_key" field.
func (m *BusinessUnitMutation) SetEntityKey(s string) {
	m.entity_key = &s
}

// EntityKey returns the value of the "entity_key" field in the mutation.
func (m *BusinessUnitMutation) EntityKey() (r string, exists bool) {
	v := m.entity_key
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityKey returns the old "entity_key" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldEntityKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityKey: %w", err)
	}
	return oldValue.EntityKey, nil
}

// ResetEntityKey resets all changes to the "entity_key" field.
func (m *BusinessUnitMutation) ResetEntityKey() {
	m.entity_key = nil
}

// SetPhoneNumber sets the "phone_number" field.
func (m *BusinessUnitMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *BusinessUnitMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *BusinessUnitMutation) ResetPhoneNumber() {
	m.phone_number = nil
}

// SetAddress sets the "address" field.
func (m *BusinessUnitMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *BusinessUnitMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *BusinessUnitMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[businessunit.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *BusinessUnitMutation) AddressCleared() bool {
	_, ok := m.clearedFields[businessunit.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *BusinessUnitMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, businessunit.FieldAddress)
}

// SetCity sets the "city" field.
func (m *BusinessUnitMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *BusinessUnitMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ClearCity clears the value of the "city" field.
func (m *BusinessUnitMutation) ClearCity() {
	m.city = nil
	m.clearedFields[businessunit.FieldCity] = struct{}{}
}

// CityCleared returns if the "city" field was cleared in this mutation.
func (m *BusinessUnitMutation) CityCleared() bool {
	_, ok := m.clearedFields[businessunit.FieldCity]
	return ok
}

// ResetCity resets all changes to the "city" field.
func (m *BusinessUnitMutation) ResetCity() {
	m.city = nil
	delete(m.clearedFields, businessunit.FieldCity)
}

// SetState sets the "state" field.
func (m *BusinessUnitMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *BusinessUnitMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *BusinessUnitMutation) ClearState() {
	m.state = nil
	m.clearedFields[businessunit.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *BusinessUnitMutation) StateCleared() bool {
	_, ok := m.clearedFields[businessunit.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *BusinessUnitMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, businessunit.FieldState)
}

// SetCountry sets the "country" field.
func (m *BusinessUnitMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *BusinessUnitMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ClearCountry clears the value of the "country" field.
func (m *BusinessUnitMutation) ClearCountry() {
	m.country = nil
	m.clearedFields[businessunit.FieldCountry] = struct{}{}
}

// CountryCleared returns if the "country" field was cleared in this mutation.
func (m *BusinessUnitMutation) CountryCleared() bool {
	_, ok := m.clearedFields[businessunit.FieldCountry]
	return ok
}

// ResetCountry resets all changes to the "country" field.
func (m *BusinessUnitMutation) ResetCountry() {
	m.country = nil
	delete(m.clearedFields, businessunit.FieldCountry)
}

// SetPostalCode sets the "postal_code" field.
func (m *BusinessUnitMutation) SetPostalCode(s string) {
	m.postal_code = &s
}

// PostalCode returns the value of the "postal_code" field in the mutation.
func (m *BusinessUnitMutation) PostalCode() (r string, exists bool) {
	v := m.postal_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPostalCode returns the old "postal_code" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldPostalCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostalCode: %w", err)
	}
	return oldValue.PostalCode, nil
}

// ClearPostalCode clears the value of the "postal_code" field.
func (m *BusinessUnitMutation) ClearPostalCode() {
	m.postal_code = nil
	m.clearedFields[businessunit.FieldPostalCode] = struct{}{}
}

// PostalCodeCleared returns if the "postal_code" field was cleared in this mutation.
func (m *BusinessUnitMutation) PostalCodeCleared() bool {
	_, ok := m.clearedFields[businessunit.FieldPostalCode]
	return ok
}

// ResetPostalCode resets all changes to the "postal_code" field.
func (m *BusinessUnitMutation) ResetPostalCode() {
	m.postal_code = nil
	delete(m.clearedFields, businessunit.FieldPostalCode)
}

// SetTaxID sets the "tax_id" field.
func (m *BusinessUnitMutation) SetTaxID(s string) {
	m.tax_id = &s
}

// TaxID returns the value of the "tax_id" field in the mutation.
func (m *BusinessUnitMutation) TaxID() (r string, exists bool) {
	v := m.tax_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxID returns the old "tax_id" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldTaxID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxID: %w", err)
	}
	return oldValue.TaxID, nil
}

// ClearTaxID clears the value of the "tax_id" field.
func (m *BusinessUnitMutation) ClearTaxID() {
	m.tax_id = nil
	m.clearedFields[businessunit.FieldTaxID] = struct{}{}
}

// TaxIDCleared returns if the "tax_id" field was cleared in this mutation.
func (m *BusinessUnitMutation) TaxIDCleared() bool {
	_, ok := m.clearedFields[businessunit.FieldTaxID]
	return ok
}

// ResetTaxID resets all changes to the "tax_id" field.
func (m *BusinessUnitMutation) ResetTaxID() {
	m.tax_id = nil
	delete(m.clearedFields, businessunit.FieldTaxID)
}

// SetSubscriptionPlan sets the "subscription_plan" field.
func (m *BusinessUnitMutation) SetSubscriptionPlan(s string) {
	m.subscription_plan = &s
}

// SubscriptionPlan returns the value of the "subscription_plan" field in the mutation.
func (m *BusinessUnitMutation) SubscriptionPlan() (r string, exists bool) {
	v := m.subscription_plan
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionPlan returns the old "subscription_plan" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldSubscriptionPlan(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscriptionPlan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscriptionPlan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionPlan: %w", err)
	}
	return oldValue.SubscriptionPlan, nil
}

// ClearSubscriptionPlan clears the value of the "subscription_plan" field.
func (m *BusinessUnitMutation) ClearSubscriptionPlan() {
	m.subscription_plan = nil
	m.clearedFields[businessunit.FieldSubscriptionPlan] = struct{}{}
}

// SubscriptionPlanCleared returns if the "subscription_plan" field was cleared in this mutation.
func (m *BusinessUnitMutation) SubscriptionPlanCleared() bool {
	_, ok := m.clearedFields[businessunit.FieldSubscriptionPlan]
	return ok
}

// ResetSubscriptionPlan resets all changes to the "subscription_plan" field.
func (m *BusinessUnitMutation) ResetSubscriptionPlan() {
	m.subscription_plan = nil
	delete(m.clearedFields, businessunit.FieldSubscriptionPlan)
}

// SetDescription sets the "description" field.
func (m *BusinessUnitMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BusinessUnitMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BusinessUnitMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[businessunit.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BusinessUnitMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[businessunit.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BusinessUnitMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, businessunit.FieldDescription)
}

// SetLegalName sets the "legal_name" field.
func (m *BusinessUnitMutation) SetLegalName(s string) {
	m.legal_name = &s
}

// LegalName returns the value of the "legal_name" field in the mutation.
func (m *BusinessUnitMutation) LegalName() (r string, exists bool) {
	v := m.legal_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLegalName returns the old "legal_name" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldLegalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLegalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLegalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLegalName: %w", err)
	}
	return oldValue.LegalName, nil
}

// ClearLegalName clears the value of the "legal_name" field.
func (m *BusinessUnitMutation) ClearLegalName() {
	m.legal_name = nil
	m.clearedFields[businessunit.FieldLegalName] = struct{}{}
}

// LegalNameCleared returns if the "legal_name" field was cleared in this mutation.
func (m *BusinessUnitMutation) LegalNameCleared() bool {
	_, ok := m.clearedFields[businessunit.FieldLegalName]
	return ok
}

// ResetLegalName resets all changes to the "legal_name" field.
func (m *BusinessUnitMutation) ResetLegalName() {
	m.legal_name = nil
	delete(m.clearedFields, businessunit.FieldLegalName)
}

// SetContactName sets the "contact_name" field.
func (m *BusinessUnitMutation) SetContactName(s string) {
	m.contact_name = &s
}

// ContactName returns the value of the "contact_name" field in the mutation.
func (m *BusinessUnitMutation) ContactName() (r string, exists bool) {
	v := m.contact_name
	if v == nil {
		return
	}
	return *v, true
}

// OldContactName returns the old "contact_name" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldContactName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactName: %w", err)
	}
	return oldValue.ContactName, nil
}

// ClearContactName clears the value of the "contact_name" field.
func (m *BusinessUnitMutation) ClearContactName() {
	m.contact_name = nil
	m.clearedFields[businessunit.FieldContactName] = struct{}{}
}

// ContactNameCleared returns if the "contact_name" field was cleared in this mutation.
func (m *BusinessUnitMutation) ContactNameCleared() bool {
	_, ok := m.clearedFields[businessunit.FieldContactName]
	return ok
}

// ResetContactName resets all changes to the "contact_name" field.
func (m *BusinessUnitMutation) ResetContactName() {
	m.contact_name = nil
	delete(m.clearedFields, businessunit.FieldContactName)
}

// SetContactEmail sets the "contact_email" field.
func (m *BusinessUnitMutation) SetContactEmail(s string) {
	m.contact_email = &s
}

// ContactEmail returns the value of the "contact_email" field in the mutation.
func (m *BusinessUnitMutation) ContactEmail() (r string, exists bool) {
	v := m.contact_email
	if v == nil {
		return
	}
	return *v, true
}

// OldContactEmail returns the old "contact_email" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldContactEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactEmail: %w", err)
	}
	return oldValue.ContactEmail, nil
}

// ClearContactEmail clears the value of the "contact_email" field.
func (m *BusinessUnitMutation) ClearContactEmail() {
	m.contact_email = nil
	m.clearedFields[businessunit.FieldContactEmail] = struct{}{}
}

// ContactEmailCleared returns if the "contact_email" field was cleared in this mutation.
func (m *BusinessUnitMutation) ContactEmailCleared() bool {
	_, ok := m.clearedFields[businessunit.FieldContactEmail]
	return ok
}

// ResetContactEmail resets all changes to the "contact_email" field.
func (m *BusinessUnitMutation) ResetContactEmail() {
	m.contact_email = nil
	delete(m.clearedFields, businessunit.FieldContactEmail)
}

// SetPaidUntil sets the "paid_until" field.
func (m *BusinessUnitMutation) SetPaidUntil(t time.Time) {
	m.paid_until = &t
}

// PaidUntil returns the value of the "paid_until" field in the mutation.
func (m *BusinessUnitMutation) PaidUntil() (r time.Time, exists bool) {
	v := m.paid_until
	if v == nil {
		return
	}
	return *v, true
}

// OldPaidUntil returns the old "paid_until" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldPaidUntil(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaidUntil is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaidUntil requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaidUntil: %w", err)
	}
	return oldValue.PaidUntil, nil
}

// ClearPaidUntil clears the value of the "paid_until" field.
func (m *BusinessUnitMutation) ClearPaidUntil() {
	m.paid_until = nil
	m.clearedFields[businessunit.FieldPaidUntil] = struct{}{}
}

// PaidUntilCleared returns if the "paid_until" field was cleared in this mutation.
func (m *BusinessUnitMutation) PaidUntilCleared() bool {
	_, ok := m.clearedFields[businessunit.FieldPaidUntil]
	return ok
}

// ResetPaidUntil resets all changes to the "paid_until" field.
func (m *BusinessUnitMutation) ResetPaidUntil() {
	m.paid_until = nil
	delete(m.clearedFields, businessunit.FieldPaidUntil)
}

// SetSettings sets the "settings" field.
func (m *BusinessUnitMutation) SetSettings(value map[string]interface{}) {
	m.settings = &value
}

// Settings returns the value of the "settings" field in the mutation.
func (m *BusinessUnitMutation) Settings() (r map[string]interface{}, exists bool) {
	v := m.settings
	if v == nil {
		return
	}
	return *v, true
}

// OldSettings returns the old "settings" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldSettings(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettings: %w", err)
	}
	return oldValue.Settings, nil
}

// ClearSettings clears the value of the "settings" field.
func (m *BusinessUnitMutation) ClearSettings() {
	m.settings = nil
	m.clearedFields[businessunit.FieldSettings] = struct{}{}
}

// SettingsCleared returns if the "settings" field was cleared in this mutation.
func (m *BusinessUnitMutation) SettingsCleared() bool {
	_, ok := m.clearedFields[businessunit.FieldSettings]
	return ok
}

// ResetSettings resets all changes to the "settings" field.
func (m *BusinessUnitMutation) ResetSettings() {
	m.settings = nil
	delete(m.clearedFields, businessunit.FieldSettings)
}

// SetFreeTrial sets the "free_trial" field.
func (m *BusinessUnitMutation) SetFreeTrial(b bool) {
	m.free_trial = &b
}

// FreeTrial returns the value of the "free_trial" field in the mutation.
func (m *BusinessUnitMutation) FreeTrial() (r bool, exists bool) {
	v := m.free_trial
	if v == nil {
		return
	}
	return *v, true
}

// OldFreeTrial returns the old "free_trial" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldFreeTrial(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFreeTrial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFreeTrial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFreeTrial: %w", err)
	}
	return oldValue.FreeTrial, nil
}

// ResetFreeTrial resets all changes to the "free_trial" field.
func (m *BusinessUnitMutation) ResetFreeTrial() {
	m.free_trial = nil
}

// SetParentID sets the "parent_id" field.
func (m *BusinessUnitMutation) SetParentID(u uuid.UUID) {
	m.prev = &u
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *BusinessUnitMutation) ParentID() (r uuid.UUID, exists bool) {
	v := m.prev
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldParentID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *BusinessUnitMutation) ClearParentID() {
	m.prev = nil
	m.clearedFields[businessunit.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *BusinessUnitMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[businessunit.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *BusinessUnitMutation) ResetParentID() {
	m.prev = nil
	delete(m.clearedFields, businessunit.FieldParentID)
}

// SetPrevID sets the "prev" edge to the BusinessUnit entity by id.
func (m *BusinessUnitMutation) SetPrevID(id uuid.UUID) {
	m.prev = &id
}

// ClearPrev clears the "prev" edge to the BusinessUnit entity.
func (m *BusinessUnitMutation) ClearPrev() {
	m.clearedprev = true
	m.clearedFields[businessunit.FieldParentID] = struct{}{}
}

// PrevCleared reports if the "prev" edge to the BusinessUnit entity was cleared.
func (m *BusinessUnitMutation) PrevCleared() bool {
	return m.ParentIDCleared() || m.clearedprev
}

// PrevID returns the "prev" edge ID in the mutation.
func (m *BusinessUnitMutation) PrevID() (id uuid.UUID, exists bool) {
	if m.prev != nil {
		return *m.prev, true
	}
	return
}

// PrevIDs returns the "prev" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PrevID instead. It exists only for internal usage by the builders.
func (m *BusinessUnitMutation) PrevIDs() (ids []uuid.UUID) {
	if id := m.prev; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrev resets all changes to the "prev" edge.
func (m *BusinessUnitMutation) ResetPrev() {
	m.prev = nil
	m.clearedprev = false
}

// SetNextID sets the "next" edge to the BusinessUnit entity by id.
func (m *BusinessUnitMutation) SetNextID(id uuid.UUID) {
	m.next = &id
}

// ClearNext clears the "next" edge to the BusinessUnit entity.
func (m *BusinessUnitMutation) ClearNext() {
	m.clearednext = true
}

// NextCleared reports if the "next" edge to the BusinessUnit entity was cleared.
func (m *BusinessUnitMutation) NextCleared() bool {
	return m.clearednext
}

// NextID returns the "next" edge ID in the mutation.
func (m *BusinessUnitMutation) NextID() (id uuid.UUID, exists bool) {
	if m.next != nil {
		return *m.next, true
	}
	return
}

// NextIDs returns the "next" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NextID instead. It exists only for internal usage by the builders.
func (m *BusinessUnitMutation) NextIDs() (ids []uuid.UUID) {
	if id := m.next; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNext resets all changes to the "next" edge.
func (m *BusinessUnitMutation) ResetNext() {
	m.next = nil
	m.clearednext = false
}

// AddOrganizationIDs adds the "organizations" edge to the Organization entity by ids.
func (m *BusinessUnitMutation) AddOrganizationIDs(ids ...uuid.UUID) {
	if m.organizations == nil {
		m.organizations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.organizations[ids[i]] = struct{}{}
	}
}

// ClearOrganizations clears the "organizations" edge to the Organization entity.
func (m *BusinessUnitMutation) ClearOrganizations() {
	m.clearedorganizations = true
}

// OrganizationsCleared reports if the "organizations" edge to the Organization entity was cleared.
func (m *BusinessUnitMutation) OrganizationsCleared() bool {
	return m.clearedorganizations
}

// RemoveOrganizationIDs removes the "organizations" edge to the Organization entity by IDs.
func (m *BusinessUnitMutation) RemoveOrganizationIDs(ids ...uuid.UUID) {
	if m.removedorganizations == nil {
		m.removedorganizations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.organizations, ids[i])
		m.removedorganizations[ids[i]] = struct{}{}
	}
}

// RemovedOrganizations returns the removed IDs of the "organizations" edge to the Organization entity.
func (m *BusinessUnitMutation) RemovedOrganizationsIDs() (ids []uuid.UUID) {
	for id := range m.removedorganizations {
		ids = append(ids, id)
	}
	return
}

// OrganizationsIDs returns the "organizations" edge IDs in the mutation.
func (m *BusinessUnitMutation) OrganizationsIDs() (ids []uuid.UUID) {
	for id := range m.organizations {
		ids = append(ids, id)
	}
	return
}

// ResetOrganizations resets all changes to the "organizations" edge.
func (m *BusinessUnitMutation) ResetOrganizations() {
	m.organizations = nil
	m.clearedorganizations = false
	m.removedorganizations = nil
}

// Where appends a list predicates to the BusinessUnitMutation builder.
func (m *BusinessUnitMutation) Where(ps ...predicate.BusinessUnit) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BusinessUnitMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BusinessUnitMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BusinessUnit, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BusinessUnitMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BusinessUnitMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BusinessUnit).
func (m *BusinessUnitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BusinessUnitMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.created_at != nil {
		fields = append(fields, businessunit.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, businessunit.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, businessunit.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, businessunit.FieldName)
	}
	if m.entity_key != nil {
		fields = append(fields, businessunit.FieldEntityKey)
	}
	if m.phone_number != nil {
		fields = append(fields, businessunit.FieldPhoneNumber)
	}
	if m.address != nil {
		fields = append(fields, businessunit.FieldAddress)
	}
	if m.city != nil {
		fields = append(fields, businessunit.FieldCity)
	}
	if m.state != nil {
		fields = append(fields, businessunit.FieldState)
	}
	if m.country != nil {
		fields = append(fields, businessunit.FieldCountry)
	}
	if m.postal_code != nil {
		fields = append(fields, businessunit.FieldPostalCode)
	}
	if m.tax_id != nil {
		fields = append(fields, businessunit.FieldTaxID)
	}
	if m.subscription_plan != nil {
		fields = append(fields, businessunit.FieldSubscriptionPlan)
	}
	if m.description != nil {
		fields = append(fields, businessunit.FieldDescription)
	}
	if m.legal_name != nil {
		fields = append(fields, businessunit.FieldLegalName)
	}
	if m.contact_name != nil {
		fields = append(fields, businessunit.FieldContactName)
	}
	if m.contact_email != nil {
		fields = append(fields, businessunit.FieldContactEmail)
	}
	if m.paid_until != nil {
		fields = append(fields, businessunit.FieldPaidUntil)
	}
	if m.settings != nil {
		fields = append(fields, businessunit.FieldSettings)
	}
	if m.free_trial != nil {
		fields = append(fields, businessunit.FieldFreeTrial)
	}
	if m.prev != nil {
		fields = append(fields, businessunit.FieldParentID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BusinessUnitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case businessunit.FieldCreatedAt:
		return m.CreatedAt()
	case businessunit.FieldUpdatedAt:
		return m.UpdatedAt()
	case businessunit.FieldStatus:
		return m.Status()
	case businessunit.FieldName:
		return m.Name()
	case businessunit.FieldEntityKey:
		return m.EntityKey()
	case businessunit.FieldPhoneNumber:
		return m.PhoneNumber()
	case businessunit.FieldAddress:
		return m.Address()
	case businessunit.FieldCity:
		return m.City()
	case businessunit.FieldState:
		return m.State()
	case businessunit.FieldCountry:
		return m.Country()
	case businessunit.FieldPostalCode:
		return m.PostalCode()
	case businessunit.FieldTaxID:
		return m.TaxID()
	case businessunit.FieldSubscriptionPlan:
		return m.SubscriptionPlan()
	case businessunit.FieldDescription:
		return m.Description()
	case businessunit.FieldLegalName:
		return m.LegalName()
	case businessunit.FieldContactName:
		return m.ContactName()
	case businessunit.FieldContactEmail:
		return m.ContactEmail()
	case businessunit.FieldPaidUntil:
		return m.PaidUntil()
	case businessunit.FieldSettings:
		return m.Settings()
	case businessunit.FieldFreeTrial:
		return m.FreeTrial()
	case businessunit.FieldParentID:
		return m.ParentID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BusinessUnitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case businessunit.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case businessunit.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case businessunit.FieldStatus:
		return m.OldStatus(ctx)
	case businessunit.FieldName:
		return m.OldName(ctx)
	case businessunit.FieldEntityKey:
		return m.OldEntityKey(ctx)
	case businessunit.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case businessunit.FieldAddress:
		return m.OldAddress(ctx)
	case businessunit.FieldCity:
		return m.OldCity(ctx)
	case businessunit.FieldState:
		return m.OldState(ctx)
	case businessunit.FieldCountry:
		return m.OldCountry(ctx)
	case businessunit.FieldPostalCode:
		return m.OldPostalCode(ctx)
	case businessunit.FieldTaxID:
		return m.OldTaxID(ctx)
	case businessunit.FieldSubscriptionPlan:
		return m.OldSubscriptionPlan(ctx)
	case businessunit.FieldDescription:
		return m.OldDescription(ctx)
	case businessunit.FieldLegalName:
		return m.OldLegalName(ctx)
	case businessunit.FieldContactName:
		return m.OldContactName(ctx)
	case businessunit.FieldContactEmail:
		return m.OldContactEmail(ctx)
	case businessunit.FieldPaidUntil:
		return m.OldPaidUntil(ctx)
	case businessunit.FieldSettings:
		return m.OldSettings(ctx)
	case businessunit.FieldFreeTrial:
		return m.OldFreeTrial(ctx)
	case businessunit.FieldParentID:
		return m.OldParentID(ctx)
	}
	return nil, fmt.Errorf("unknown BusinessUnit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BusinessUnitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case businessunit.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case businessunit.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case businessunit.FieldStatus:
		v, ok := value.(businessunit.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case businessunit.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case businessunit.FieldEntityKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityKey(v)
		return nil
	case businessunit.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case businessunit.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case businessunit.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case businessunit.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case businessunit.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case businessunit.FieldPostalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostalCode(v)
		return nil
	case businessunit.FieldTaxID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxID(v)
		return nil
	case businessunit.FieldSubscriptionPlan:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionPlan(v)
		return nil
	case businessunit.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case businessunit.FieldLegalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLegalName(v)
		return nil
	case businessunit.FieldContactName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactName(v)
		return nil
	case businessunit.FieldContactEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactEmail(v)
		return nil
	case businessunit.FieldPaidUntil:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaidUntil(v)
		return nil
	case businessunit.FieldSettings:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettings(v)
		return nil
	case businessunit.FieldFreeTrial:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFreeTrial(v)
		return nil
	case businessunit.FieldParentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	}
	return fmt.Errorf("unknown BusinessUnit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BusinessUnitMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BusinessUnitMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BusinessUnitMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BusinessUnit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BusinessUnitMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(businessunit.FieldAddress) {
		fields = append(fields, businessunit.FieldAddress)
	}
	if m.FieldCleared(businessunit.FieldCity) {
		fields = append(fields, businessunit.FieldCity)
	}
	if m.FieldCleared(businessunit.FieldState) {
		fields = append(fields, businessunit.FieldState)
	}
	if m.FieldCleared(businessunit.FieldCountry) {
		fields = append(fields, businessunit.FieldCountry)
	}
	if m.FieldCleared(businessunit.FieldPostalCode) {
		fields = append(fields, businessunit.FieldPostalCode)
	}
	if m.FieldCleared(businessunit.FieldTaxID) {
		fields = append(fields, businessunit.FieldTaxID)
	}
	if m.FieldCleared(businessunit.FieldSubscriptionPlan) {
		fields = append(fields, businessunit.FieldSubscriptionPlan)
	}
	if m.FieldCleared(businessunit.FieldDescription) {
		fields = append(fields, businessunit.FieldDescription)
	}
	if m.FieldCleared(businessunit.FieldLegalName) {
		fields = append(fields, businessunit.FieldLegalName)
	}
	if m.FieldCleared(businessunit.FieldContactName) {
		fields = append(fields, businessunit.FieldContactName)
	}
	if m.FieldCleared(businessunit.FieldContactEmail) {
		fields = append(fields, businessunit.FieldContactEmail)
	}
	if m.FieldCleared(businessunit.FieldPaidUntil) {
		fields = append(fields, businessunit.FieldPaidUntil)
	}
	if m.FieldCleared(businessunit.FieldSettings) {
		fields = append(fields, businessunit.FieldSettings)
	}
	if m.FieldCleared(businessunit.FieldParentID) {
		fields = append(fields, businessunit.FieldParentID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BusinessUnitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BusinessUnitMutation) ClearField(name string) error {
	switch name {
	case businessunit.FieldAddress:
		m.ClearAddress()
		return nil
	case businessunit.FieldCity:
		m.ClearCity()
		return nil
	case businessunit.FieldState:
		m.ClearState()
		return nil
	case businessunit.FieldCountry:
		m.ClearCountry()
		return nil
	case businessunit.FieldPostalCode:
		m.ClearPostalCode()
		return nil
	case businessunit.FieldTaxID:
		m.ClearTaxID()
		return nil
	case businessunit.FieldSubscriptionPlan:
		m.ClearSubscriptionPlan()
		return nil
	case businessunit.FieldDescription:
		m.ClearDescription()
		return nil
	case businessunit.FieldLegalName:
		m.ClearLegalName()
		return nil
	case businessunit.FieldContactName:
		m.ClearContactName()
		return nil
	case businessunit.FieldContactEmail:
		m.ClearContactEmail()
		return nil
	case businessunit.FieldPaidUntil:
		m.ClearPaidUntil()
		return nil
	case businessunit.FieldSettings:
		m.ClearSettings()
		return nil
	case businessunit.FieldParentID:
		m.ClearParentID()
		return nil
	}
	return fmt.Errorf("unknown BusinessUnit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BusinessUnitMutation) ResetField(name string) error {
	switch name {
	case businessunit.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case businessunit.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case businessunit.FieldStatus:
		m.ResetStatus()
		return nil
	case businessunit.FieldName:
		m.ResetName()
		return nil
	case businessunit.FieldEntityKey:
		m.ResetEntityKey()
		return nil
	case businessunit.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case businessunit.FieldAddress:
		m.ResetAddress()
		return nil
	case businessunit.FieldCity:
		m.ResetCity()
		return nil
	case businessunit.FieldState:
		m.ResetState()
		return nil
	case businessunit.FieldCountry:
		m.ResetCountry()
		return nil
	case businessunit.FieldPostalCode:
		m.ResetPostalCode()
		return nil
	case businessunit.FieldTaxID:
		m.ResetTaxID()
		return nil
	case businessunit.FieldSubscriptionPlan:
		m.ResetSubscriptionPlan()
		return nil
	case businessunit.FieldDescription:
		m.ResetDescription()
		return nil
	case businessunit.FieldLegalName:
		m.ResetLegalName()
		return nil
	case businessunit.FieldContactName:
		m.ResetContactName()
		return nil
	case businessunit.FieldContactEmail:
		m.ResetContactEmail()
		return nil
	case businessunit.FieldPaidUntil:
		m.ResetPaidUntil()
		return nil
	case businessunit.FieldSettings:
		m.ResetSettings()
		return nil
	case businessunit.FieldFreeTrial:
		m.ResetFreeTrial()
		return nil
	case businessunit.FieldParentID:
		m.ResetParentID()
		return nil
	}
	return fmt.Errorf("unknown BusinessUnit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BusinessUnitMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.prev != nil {
		edges = append(edges, businessunit.EdgePrev)
	}
	if m.next != nil {
		edges = append(edges, businessunit.EdgeNext)
	}
	if m.organizations != nil {
		edges = append(edges, businessunit.EdgeOrganizations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BusinessUnitMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case businessunit.EdgePrev:
		if id := m.prev; id != nil {
			return []ent.Value{*id}
		}
	case businessunit.EdgeNext:
		if id := m.next; id != nil {
			return []ent.Value{*id}
		}
	case businessunit.EdgeOrganizations:
		ids := make([]ent.Value, 0, len(m.organizations))
		for id := range m.organizations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BusinessUnitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedorganizations != nil {
		edges = append(edges, businessunit.EdgeOrganizations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BusinessUnitMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case businessunit.EdgeOrganizations:
		ids := make([]ent.Value, 0, len(m.removedorganizations))
		for id := range m.removedorganizations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BusinessUnitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedprev {
		edges = append(edges, businessunit.EdgePrev)
	}
	if m.clearednext {
		edges = append(edges, businessunit.EdgeNext)
	}
	if m.clearedorganizations {
		edges = append(edges, businessunit.EdgeOrganizations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BusinessUnitMutation) EdgeCleared(name string) bool {
	switch name {
	case businessunit.EdgePrev:
		return m.clearedprev
	case businessunit.EdgeNext:
		return m.clearednext
	case businessunit.EdgeOrganizations:
		return m.clearedorganizations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BusinessUnitMutation) ClearEdge(name string) error {
	switch name {
	case businessunit.EdgePrev:
		m.ClearPrev()
		return nil
	case businessunit.EdgeNext:
		m.ClearNext()
		return nil
	}
	return fmt.Errorf("unknown BusinessUnit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BusinessUnitMutation) ResetEdge(name string) error {
	switch name {
	case businessunit.EdgePrev:
		m.ResetPrev()
		return nil
	case businessunit.EdgeNext:
		m.ResetNext()
		return nil
	case businessunit.EdgeOrganizations:
		m.ResetOrganizations()
		return nil
	}
	return fmt.Errorf("unknown BusinessUnit edge %s", name)
}

// ChargeTypeMutation represents an operation that mutates the ChargeType nodes in the graph.
type ChargeTypeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	version              *int
	addversion           *int
	status               *chargetype.Status
	name                 *string
	description          *string
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	done                 bool
	oldValue             func(context.Context) (*ChargeType, error)
	predicates           []predicate.ChargeType
}

var _ ent.Mutation = (*ChargeTypeMutation)(nil)

// chargetypeOption allows management of the mutation configuration using functional options.
type chargetypeOption func(*ChargeTypeMutation)

// newChargeTypeMutation creates new mutation for the ChargeType entity.
func newChargeTypeMutation(c config, op Op, opts ...chargetypeOption) *ChargeTypeMutation {
	m := &ChargeTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeChargeType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChargeTypeID sets the ID field of the mutation.
func withChargeTypeID(id uuid.UUID) chargetypeOption {
	return func(m *ChargeTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ChargeType
		)
		m.oldValue = func(ctx context.Context) (*ChargeType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ChargeType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChargeType sets the old ChargeType of the mutation.
func withChargeType(node *ChargeType) chargetypeOption {
	return func(m *ChargeTypeMutation) {
		m.oldValue = func(context.Context) (*ChargeType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChargeTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChargeTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ChargeType entities.
func (m *ChargeTypeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChargeTypeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChargeTypeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ChargeType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *ChargeTypeMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *ChargeTypeMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the ChargeType entity.
// If the ChargeType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChargeTypeMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *ChargeTypeMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *ChargeTypeMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *ChargeTypeMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the ChargeType entity.
// If the ChargeType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChargeTypeMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *ChargeTypeMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ChargeTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChargeTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ChargeType entity.
// If the ChargeType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChargeTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChargeTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ChargeTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ChargeTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ChargeType entity.
// If the ChargeType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChargeTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ChargeTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *ChargeTypeMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *ChargeTypeMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the ChargeType entity.
// If the ChargeType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChargeTypeMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *ChargeTypeMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *ChargeTypeMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *ChargeTypeMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetStatus sets the "status" field.
func (m *ChargeTypeMutation) SetStatus(c chargetype.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *ChargeTypeMutation) Status() (r chargetype.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ChargeType entity.
// If the ChargeType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChargeTypeMutation) OldStatus(ctx context.Context) (v chargetype.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ChargeTypeMutation) ResetStatus() {
	m.status = nil
}

// SetName sets the "name" field.
func (m *ChargeTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ChargeTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ChargeType entity.
// If the ChargeType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChargeTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ChargeTypeMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ChargeTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ChargeTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ChargeType entity.
// If the ChargeType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChargeTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ChargeTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[chargetype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ChargeTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[chargetype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ChargeTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, chargetype.FieldDescription)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *ChargeTypeMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[chargetype.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *ChargeTypeMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *ChargeTypeMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *ChargeTypeMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *ChargeTypeMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[chargetype.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *ChargeTypeMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *ChargeTypeMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *ChargeTypeMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the ChargeTypeMutation builder.
func (m *ChargeTypeMutation) Where(ps ...predicate.ChargeType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChargeTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChargeTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ChargeType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChargeTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChargeTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ChargeType).
func (m *ChargeTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChargeTypeMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.business_unit != nil {
		fields = append(fields, chargetype.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, chargetype.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, chargetype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, chargetype.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, chargetype.FieldVersion)
	}
	if m.status != nil {
		fields = append(fields, chargetype.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, chargetype.FieldName)
	}
	if m.description != nil {
		fields = append(fields, chargetype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChargeTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case chargetype.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case chargetype.FieldOrganizationID:
		return m.OrganizationID()
	case chargetype.FieldCreatedAt:
		return m.CreatedAt()
	case chargetype.FieldUpdatedAt:
		return m.UpdatedAt()
	case chargetype.FieldVersion:
		return m.Version()
	case chargetype.FieldStatus:
		return m.Status()
	case chargetype.FieldName:
		return m.Name()
	case chargetype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChargeTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case chargetype.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case chargetype.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case chargetype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case chargetype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case chargetype.FieldVersion:
		return m.OldVersion(ctx)
	case chargetype.FieldStatus:
		return m.OldStatus(ctx)
	case chargetype.FieldName:
		return m.OldName(ctx)
	case chargetype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown ChargeType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChargeTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case chargetype.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case chargetype.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case chargetype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case chargetype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case chargetype.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case chargetype.FieldStatus:
		v, ok := value.(chargetype.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case chargetype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case chargetype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown ChargeType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChargeTypeMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, chargetype.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChargeTypeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case chargetype.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChargeTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case chargetype.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown ChargeType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChargeTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(chargetype.FieldDescription) {
		fields = append(fields, chargetype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChargeTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChargeTypeMutation) ClearField(name string) error {
	switch name {
	case chargetype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ChargeType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChargeTypeMutation) ResetField(name string) error {
	switch name {
	case chargetype.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case chargetype.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case chargetype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case chargetype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case chargetype.FieldVersion:
		m.ResetVersion()
		return nil
	case chargetype.FieldStatus:
		m.ResetStatus()
		return nil
	case chargetype.FieldName:
		m.ResetName()
		return nil
	case chargetype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown ChargeType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChargeTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.business_unit != nil {
		edges = append(edges, chargetype.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, chargetype.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChargeTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case chargetype.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case chargetype.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChargeTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChargeTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChargeTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbusiness_unit {
		edges = append(edges, chargetype.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, chargetype.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChargeTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case chargetype.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case chargetype.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChargeTypeMutation) ClearEdge(name string) error {
	switch name {
	case chargetype.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case chargetype.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown ChargeType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChargeTypeMutation) ResetEdge(name string) error {
	switch name {
	case chargetype.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case chargetype.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown ChargeType edge %s", name)
}

// CommentTypeMutation represents an operation that mutates the CommentType nodes in the graph.
type CommentTypeMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	created_at               *time.Time
	updated_at               *time.Time
	version                  *int
	addversion               *int
	status                   *commenttype.Status
	name                     *string
	severity                 *commenttype.Severity
	description              *string
	clearedFields            map[string]struct{}
	business_unit            *uuid.UUID
	clearedbusiness_unit     bool
	organization             *uuid.UUID
	clearedorganization      bool
	shipment_comments        map[uuid.UUID]struct{}
	removedshipment_comments map[uuid.UUID]struct{}
	clearedshipment_comments bool
	done                     bool
	oldValue                 func(context.Context) (*CommentType, error)
	predicates               []predicate.CommentType
}

var _ ent.Mutation = (*CommentTypeMutation)(nil)

// commenttypeOption allows management of the mutation configuration using functional options.
type commenttypeOption func(*CommentTypeMutation)

// newCommentTypeMutation creates new mutation for the CommentType entity.
func newCommentTypeMutation(c config, op Op, opts ...commenttypeOption) *CommentTypeMutation {
	m := &CommentTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeCommentType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommentTypeID sets the ID field of the mutation.
func withCommentTypeID(id uuid.UUID) commenttypeOption {
	return func(m *CommentTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *CommentType
		)
		m.oldValue = func(ctx context.Context) (*CommentType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CommentType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCommentType sets the old CommentType of the mutation.
func withCommentType(node *CommentType) commenttypeOption {
	return func(m *CommentTypeMutation) {
		m.oldValue = func(context.Context) (*CommentType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CommentType entities.
func (m *CommentTypeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommentTypeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommentTypeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CommentType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *CommentTypeMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *CommentTypeMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the CommentType entity.
// If the CommentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentTypeMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *CommentTypeMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *CommentTypeMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *CommentTypeMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the CommentType entity.
// If the CommentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentTypeMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *CommentTypeMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CommentTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CommentTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CommentType entity.
// If the CommentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CommentTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CommentTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CommentTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CommentType entity.
// If the CommentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CommentTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *CommentTypeMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *CommentTypeMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the CommentType entity.
// If the CommentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentTypeMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *CommentTypeMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *CommentTypeMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *CommentTypeMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetStatus sets the "status" field.
func (m *CommentTypeMutation) SetStatus(c commenttype.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *CommentTypeMutation) Status() (r commenttype.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CommentType entity.
// If the CommentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentTypeMutation) OldStatus(ctx context.Context) (v commenttype.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CommentTypeMutation) ResetStatus() {
	m.status = nil
}

// SetName sets the "name" field.
func (m *CommentTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CommentTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CommentType entity.
// If the CommentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CommentTypeMutation) ResetName() {
	m.name = nil
}

// SetSeverity sets the "severity" field.
func (m *CommentTypeMutation) SetSeverity(c commenttype.Severity) {
	m.severity = &c
}

// Severity returns the value of the "severity" field in the mutation.
func (m *CommentTypeMutation) Severity() (r commenttype.Severity, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old "severity" field's value of the CommentType entity.
// If the CommentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentTypeMutation) OldSeverity(ctx context.Context) (v commenttype.Severity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// ResetSeverity resets all changes to the "severity" field.
func (m *CommentTypeMutation) ResetSeverity() {
	m.severity = nil
}

// SetDescription sets the "description" field.
func (m *CommentTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CommentTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the CommentType entity.
// If the CommentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CommentTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[commenttype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CommentTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[commenttype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CommentTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, commenttype.FieldDescription)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *CommentTypeMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[commenttype.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *CommentTypeMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *CommentTypeMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *CommentTypeMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *CommentTypeMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[commenttype.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *CommentTypeMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *CommentTypeMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *CommentTypeMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// AddShipmentCommentIDs adds the "shipment_comments" edge to the ShipmentComment entity by ids.
func (m *CommentTypeMutation) AddShipmentCommentIDs(ids ...uuid.UUID) {
	if m.shipment_comments == nil {
		m.shipment_comments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.shipment_comments[ids[i]] = struct{}{}
	}
}

// ClearShipmentComments clears the "shipment_comments" edge to the ShipmentComment entity.
func (m *CommentTypeMutation) ClearShipmentComments() {
	m.clearedshipment_comments = true
}

// ShipmentCommentsCleared reports if the "shipment_comments" edge to the ShipmentComment entity was cleared.
func (m *CommentTypeMutation) ShipmentCommentsCleared() bool {
	return m.clearedshipment_comments
}

// RemoveShipmentCommentIDs removes the "shipment_comments" edge to the ShipmentComment entity by IDs.
func (m *CommentTypeMutation) RemoveShipmentCommentIDs(ids ...uuid.UUID) {
	if m.removedshipment_comments == nil {
		m.removedshipment_comments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.shipment_comments, ids[i])
		m.removedshipment_comments[ids[i]] = struct{}{}
	}
}

// RemovedShipmentComments returns the removed IDs of the "shipment_comments" edge to the ShipmentComment entity.
func (m *CommentTypeMutation) RemovedShipmentCommentsIDs() (ids []uuid.UUID) {
	for id := range m.removedshipment_comments {
		ids = append(ids, id)
	}
	return
}

// ShipmentCommentsIDs returns the "shipment_comments" edge IDs in the mutation.
func (m *CommentTypeMutation) ShipmentCommentsIDs() (ids []uuid.UUID) {
	for id := range m.shipment_comments {
		ids = append(ids, id)
	}
	return
}

// ResetShipmentComments resets all changes to the "shipment_comments" edge.
func (m *CommentTypeMutation) ResetShipmentComments() {
	m.shipment_comments = nil
	m.clearedshipment_comments = false
	m.removedshipment_comments = nil
}

// Where appends a list predicates to the CommentTypeMutation builder.
func (m *CommentTypeMutation) Where(ps ...predicate.CommentType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommentTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommentTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CommentType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommentTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommentTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CommentType).
func (m *CommentTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommentTypeMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.business_unit != nil {
		fields = append(fields, commenttype.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, commenttype.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, commenttype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, commenttype.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, commenttype.FieldVersion)
	}
	if m.status != nil {
		fields = append(fields, commenttype.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, commenttype.FieldName)
	}
	if m.severity != nil {
		fields = append(fields, commenttype.FieldSeverity)
	}
	if m.description != nil {
		fields = append(fields, commenttype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommentTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case commenttype.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case commenttype.FieldOrganizationID:
		return m.OrganizationID()
	case commenttype.FieldCreatedAt:
		return m.CreatedAt()
	case commenttype.FieldUpdatedAt:
		return m.UpdatedAt()
	case commenttype.FieldVersion:
		return m.Version()
	case commenttype.FieldStatus:
		return m.Status()
	case commenttype.FieldName:
		return m.Name()
	case commenttype.FieldSeverity:
		return m.Severity()
	case commenttype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommentTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case commenttype.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case commenttype.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case commenttype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case commenttype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case commenttype.FieldVersion:
		return m.OldVersion(ctx)
	case commenttype.FieldStatus:
		return m.OldStatus(ctx)
	case commenttype.FieldName:
		return m.OldName(ctx)
	case commenttype.FieldSeverity:
		return m.OldSeverity(ctx)
	case commenttype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown CommentType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case commenttype.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case commenttype.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case commenttype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case commenttype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case commenttype.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case commenttype.FieldStatus:
		v, ok := value.(commenttype.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case commenttype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case commenttype.FieldSeverity:
		v, ok := value.(commenttype.Severity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	case commenttype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown CommentType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommentTypeMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, commenttype.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommentTypeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case commenttype.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case commenttype.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown CommentType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommentTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(commenttype.FieldDescription) {
		fields = append(fields, commenttype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommentTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentTypeMutation) ClearField(name string) error {
	switch name {
	case commenttype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown CommentType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommentTypeMutation) ResetField(name string) error {
	switch name {
	case commenttype.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case commenttype.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case commenttype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case commenttype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case commenttype.FieldVersion:
		m.ResetVersion()
		return nil
	case commenttype.FieldStatus:
		m.ResetStatus()
		return nil
	case commenttype.FieldName:
		m.ResetName()
		return nil
	case commenttype.FieldSeverity:
		m.ResetSeverity()
		return nil
	case commenttype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown CommentType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommentTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.business_unit != nil {
		edges = append(edges, commenttype.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, commenttype.EdgeOrganization)
	}
	if m.shipment_comments != nil {
		edges = append(edges, commenttype.EdgeShipmentComments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommentTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case commenttype.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case commenttype.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case commenttype.EdgeShipmentComments:
		ids := make([]ent.Value, 0, len(m.shipment_comments))
		for id := range m.shipment_comments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommentTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedshipment_comments != nil {
		edges = append(edges, commenttype.EdgeShipmentComments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommentTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case commenttype.EdgeShipmentComments:
		ids := make([]ent.Value, 0, len(m.removedshipment_comments))
		for id := range m.removedshipment_comments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommentTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbusiness_unit {
		edges = append(edges, commenttype.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, commenttype.EdgeOrganization)
	}
	if m.clearedshipment_comments {
		edges = append(edges, commenttype.EdgeShipmentComments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommentTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case commenttype.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case commenttype.EdgeOrganization:
		return m.clearedorganization
	case commenttype.EdgeShipmentComments:
		return m.clearedshipment_comments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommentTypeMutation) ClearEdge(name string) error {
	switch name {
	case commenttype.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case commenttype.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown CommentType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommentTypeMutation) ResetEdge(name string) error {
	switch name {
	case commenttype.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case commenttype.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case commenttype.EdgeShipmentComments:
		m.ResetShipmentComments()
		return nil
	}
	return fmt.Errorf("unknown CommentType edge %s", name)
}

// CommodityMutation represents an operation that mutates the Commodity nodes in the graph.
type CommodityMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	created_at                *time.Time
	updated_at                *time.Time
	version                   *int
	addversion                *int
	status                    *commodity.Status
	name                      *string
	is_hazmat                 *bool
	unit_of_measure           *string
	min_temp                  *int8
	addmin_temp               *int8
	max_temp                  *int8
	addmax_temp               *int8
	description               *string
	clearedFields             map[string]struct{}
	business_unit             *uuid.UUID
	clearedbusiness_unit      bool
	organization              *uuid.UUID
	clearedorganization       bool
	hazardous_material        *uuid.UUID
	clearedhazardous_material bool
	done                      bool
	oldValue                  func(context.Context) (*Commodity, error)
	predicates                []predicate.Commodity
}

var _ ent.Mutation = (*CommodityMutation)(nil)

// commodityOption allows management of the mutation configuration using functional options.
type commodityOption func(*CommodityMutation)

// newCommodityMutation creates new mutation for the Commodity entity.
func newCommodityMutation(c config, op Op, opts ...commodityOption) *CommodityMutation {
	m := &CommodityMutation{
		config:        c,
		op:            op,
		typ:           TypeCommodity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommodityID sets the ID field of the mutation.
func withCommodityID(id uuid.UUID) commodityOption {
	return func(m *CommodityMutation) {
		var (
			err   error
			once  sync.Once
			value *Commodity
		)
		m.oldValue = func(ctx context.Context) (*Commodity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Commodity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCommodity sets the old Commodity of the mutation.
func withCommodity(node *Commodity) commodityOption {
	return func(m *CommodityMutation) {
		m.oldValue = func(context.Context) (*Commodity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommodityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommodityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Commodity entities.
func (m *CommodityMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommodityMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommodityMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Commodity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *CommodityMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *CommodityMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the Commodity entity.
// If the Commodity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommodityMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *CommodityMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *CommodityMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *CommodityMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Commodity entity.
// If the Commodity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommodityMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *CommodityMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CommodityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CommodityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Commodity entity.
// If the Commodity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommodityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CommodityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CommodityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CommodityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Commodity entity.
// If the Commodity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommodityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CommodityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *CommodityMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *CommodityMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Commodity entity.
// If the Commodity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommodityMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *CommodityMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *CommodityMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *CommodityMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetStatus sets the "status" field.
func (m *CommodityMutation) SetStatus(c commodity.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *CommodityMutation) Status() (r commodity.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Commodity entity.
// If the Commodity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommodityMutation) OldStatus(ctx context.Context) (v commodity.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CommodityMutation) ResetStatus() {
	m.status = nil
}

// SetName sets the "name" field.
func (m *CommodityMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CommodityMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Commodity entity.
// If the Commodity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommodityMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CommodityMutation) ResetName() {
	m.name = nil
}

// SetIsHazmat sets the "is_hazmat" field.
func (m *CommodityMutation) SetIsHazmat(b bool) {
	m.is_hazmat = &b
}

// IsHazmat returns the value of the "is_hazmat" field in the mutation.
func (m *CommodityMutation) IsHazmat() (r bool, exists bool) {
	v := m.is_hazmat
	if v == nil {
		return
	}
	return *v, true
}

// OldIsHazmat returns the old "is_hazmat" field's value of the Commodity entity.
// If the Commodity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommodityMutation) OldIsHazmat(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsHazmat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsHazmat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsHazmat: %w", err)
	}
	return oldValue.IsHazmat, nil
}

// ResetIsHazmat resets all changes to the "is_hazmat" field.
func (m *CommodityMutation) ResetIsHazmat() {
	m.is_hazmat = nil
}

// SetUnitOfMeasure sets the "unit_of_measure" field.
func (m *CommodityMutation) SetUnitOfMeasure(s string) {
	m.unit_of_measure = &s
}

// UnitOfMeasure returns the value of the "unit_of_measure" field in the mutation.
func (m *CommodityMutation) UnitOfMeasure() (r string, exists bool) {
	v := m.unit_of_measure
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitOfMeasure returns the old "unit_of_measure" field's value of the Commodity entity.
// If the Commodity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommodityMutation) OldUnitOfMeasure(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitOfMeasure is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitOfMeasure requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitOfMeasure: %w", err)
	}
	return oldValue.UnitOfMeasure, nil
}

// ClearUnitOfMeasure clears the value of the "unit_of_measure" field.
func (m *CommodityMutation) ClearUnitOfMeasure() {
	m.unit_of_measure = nil
	m.clearedFields[commodity.FieldUnitOfMeasure] = struct{}{}
}

// UnitOfMeasureCleared returns if the "unit_of_measure" field was cleared in this mutation.
func (m *CommodityMutation) UnitOfMeasureCleared() bool {
	_, ok := m.clearedFields[commodity.FieldUnitOfMeasure]
	return ok
}

// ResetUnitOfMeasure resets all changes to the "unit_of_measure" field.
func (m *CommodityMutation) ResetUnitOfMeasure() {
	m.unit_of_measure = nil
	delete(m.clearedFields, commodity.FieldUnitOfMeasure)
}

// SetMinTemp sets the "min_temp" field.
func (m *CommodityMutation) SetMinTemp(i int8) {
	m.min_temp = &i
	m.addmin_temp = nil
}

// MinTemp returns the value of the "min_temp" field in the mutation.
func (m *CommodityMutation) MinTemp() (r int8, exists bool) {
	v := m.min_temp
	if v == nil {
		return
	}
	return *v, true
}

// OldMinTemp returns the old "min_temp" field's value of the Commodity entity.
// If the Commodity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommodityMutation) OldMinTemp(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinTemp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinTemp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinTemp: %w", err)
	}
	return oldValue.MinTemp, nil
}

// AddMinTemp adds i to the "min_temp" field.
func (m *CommodityMutation) AddMinTemp(i int8) {
	if m.addmin_temp != nil {
		*m.addmin_temp += i
	} else {
		m.addmin_temp = &i
	}
}

// AddedMinTemp returns the value that was added to the "min_temp" field in this mutation.
func (m *CommodityMutation) AddedMinTemp() (r int8, exists bool) {
	v := m.addmin_temp
	if v == nil {
		return
	}
	return *v, true
}

// ClearMinTemp clears the value of the "min_temp" field.
func (m *CommodityMutation) ClearMinTemp() {
	m.min_temp = nil
	m.addmin_temp = nil
	m.clearedFields[commodity.FieldMinTemp] = struct{}{}
}

// MinTempCleared returns if the "min_temp" field was cleared in this mutation.
func (m *CommodityMutation) MinTempCleared() bool {
	_, ok := m.clearedFields[commodity.FieldMinTemp]
	return ok
}

// ResetMinTemp resets all changes to the "min_temp" field.
func (m *CommodityMutation) ResetMinTemp() {
	m.min_temp = nil
	m.addmin_temp = nil
	delete(m.clearedFields, commodity.FieldMinTemp)
}

// SetMaxTemp sets the "max_temp" field.
func (m *CommodityMutation) SetMaxTemp(i int8) {
	m.max_temp = &i
	m.addmax_temp = nil
}

// MaxTemp returns the value of the "max_temp" field in the mutation.
func (m *CommodityMutation) MaxTemp() (r int8, exists bool) {
	v := m.max_temp
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxTemp returns the old "max_temp" field's value of the Commodity entity.
// If the Commodity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommodityMutation) OldMaxTemp(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxTemp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxTemp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxTemp: %w", err)
	}
	return oldValue.MaxTemp, nil
}

// AddMaxTemp adds i to the "max_temp" field.
func (m *CommodityMutation) AddMaxTemp(i int8) {
	if m.addmax_temp != nil {
		*m.addmax_temp += i
	} else {
		m.addmax_temp = &i
	}
}

// AddedMaxTemp returns the value that was added to the "max_temp" field in this mutation.
func (m *CommodityMutation) AddedMaxTemp() (r int8, exists bool) {
	v := m.addmax_temp
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxTemp clears the value of the "max_temp" field.
func (m *CommodityMutation) ClearMaxTemp() {
	m.max_temp = nil
	m.addmax_temp = nil
	m.clearedFields[commodity.FieldMaxTemp] = struct{}{}
}

// MaxTempCleared returns if the "max_temp" field was cleared in this mutation.
func (m *CommodityMutation) MaxTempCleared() bool {
	_, ok := m.clearedFields[commodity.FieldMaxTemp]
	return ok
}

// ResetMaxTemp resets all changes to the "max_temp" field.
func (m *CommodityMutation) ResetMaxTemp() {
	m.max_temp = nil
	m.addmax_temp = nil
	delete(m.clearedFields, commodity.FieldMaxTemp)
}

// SetDescription sets the "description" field.
func (m *CommodityMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CommodityMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Commodity entity.
// If the Commodity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommodityMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CommodityMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[commodity.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CommodityMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[commodity.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CommodityMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, commodity.FieldDescription)
}

// SetHazardousMaterialID sets the "hazardous_material_id" field.
func (m *CommodityMutation) SetHazardousMaterialID(u uuid.UUID) {
	m.hazardous_material = &u
}

// HazardousMaterialID returns the value of the "hazardous_material_id" field in the mutation.
func (m *CommodityMutation) HazardousMaterialID() (r uuid.UUID, exists bool) {
	v := m.hazardous_material
	if v == nil {
		return
	}
	return *v, true
}

// OldHazardousMaterialID returns the old "hazardous_material_id" field's value of the Commodity entity.
// If the Commodity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommodityMutation) OldHazardousMaterialID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHazardousMaterialID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHazardousMaterialID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHazardousMaterialID: %w", err)
	}
	return oldValue.HazardousMaterialID, nil
}

// ClearHazardousMaterialID clears the value of the "hazardous_material_id" field.
func (m *CommodityMutation) ClearHazardousMaterialID() {
	m.hazardous_material = nil
	m.clearedFields[commodity.FieldHazardousMaterialID] = struct{}{}
}

// HazardousMaterialIDCleared returns if the "hazardous_material_id" field was cleared in this mutation.
func (m *CommodityMutation) HazardousMaterialIDCleared() bool {
	_, ok := m.clearedFields[commodity.FieldHazardousMaterialID]
	return ok
}

// ResetHazardousMaterialID resets all changes to the "hazardous_material_id" field.
func (m *CommodityMutation) ResetHazardousMaterialID() {
	m.hazardous_material = nil
	delete(m.clearedFields, commodity.FieldHazardousMaterialID)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *CommodityMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[commodity.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *CommodityMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *CommodityMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *CommodityMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *CommodityMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[commodity.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *CommodityMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *CommodityMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *CommodityMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearHazardousMaterial clears the "hazardous_material" edge to the HazardousMaterial entity.
func (m *CommodityMutation) ClearHazardousMaterial() {
	m.clearedhazardous_material = true
	m.clearedFields[commodity.FieldHazardousMaterialID] = struct{}{}
}

// HazardousMaterialCleared reports if the "hazardous_material" edge to the HazardousMaterial entity was cleared.
func (m *CommodityMutation) HazardousMaterialCleared() bool {
	return m.HazardousMaterialIDCleared() || m.clearedhazardous_material
}

// HazardousMaterialIDs returns the "hazardous_material" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HazardousMaterialID instead. It exists only for internal usage by the builders.
func (m *CommodityMutation) HazardousMaterialIDs() (ids []uuid.UUID) {
	if id := m.hazardous_material; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHazardousMaterial resets all changes to the "hazardous_material" edge.
func (m *CommodityMutation) ResetHazardousMaterial() {
	m.hazardous_material = nil
	m.clearedhazardous_material = false
}

// Where appends a list predicates to the CommodityMutation builder.
func (m *CommodityMutation) Where(ps ...predicate.Commodity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommodityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommodityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Commodity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommodityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommodityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Commodity).
func (m *CommodityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommodityMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.business_unit != nil {
		fields = append(fields, commodity.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, commodity.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, commodity.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, commodity.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, commodity.FieldVersion)
	}
	if m.status != nil {
		fields = append(fields, commodity.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, commodity.FieldName)
	}
	if m.is_hazmat != nil {
		fields = append(fields, commodity.FieldIsHazmat)
	}
	if m.unit_of_measure != nil {
		fields = append(fields, commodity.FieldUnitOfMeasure)
	}
	if m.min_temp != nil {
		fields = append(fields, commodity.FieldMinTemp)
	}
	if m.max_temp != nil {
		fields = append(fields, commodity.FieldMaxTemp)
	}
	if m.description != nil {
		fields = append(fields, commodity.FieldDescription)
	}
	if m.hazardous_material != nil {
		fields = append(fields, commodity.FieldHazardousMaterialID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommodityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case commodity.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case commodity.FieldOrganizationID:
		return m.OrganizationID()
	case commodity.FieldCreatedAt:
		return m.CreatedAt()
	case commodity.FieldUpdatedAt:
		return m.UpdatedAt()
	case commodity.FieldVersion:
		return m.Version()
	case commodity.FieldStatus:
		return m.Status()
	case commodity.FieldName:
		return m.Name()
	case commodity.FieldIsHazmat:
		return m.IsHazmat()
	case commodity.FieldUnitOfMeasure:
		return m.UnitOfMeasure()
	case commodity.FieldMinTemp:
		return m.MinTemp()
	case commodity.FieldMaxTemp:
		return m.MaxTemp()
	case commodity.FieldDescription:
		return m.Description()
	case commodity.FieldHazardousMaterialID:
		return m.HazardousMaterialID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommodityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case commodity.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case commodity.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case commodity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case commodity.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case commodity.FieldVersion:
		return m.OldVersion(ctx)
	case commodity.FieldStatus:
		return m.OldStatus(ctx)
	case commodity.FieldName:
		return m.OldName(ctx)
	case commodity.FieldIsHazmat:
		return m.OldIsHazmat(ctx)
	case commodity.FieldUnitOfMeasure:
		return m.OldUnitOfMeasure(ctx)
	case commodity.FieldMinTemp:
		return m.OldMinTemp(ctx)
	case commodity.FieldMaxTemp:
		return m.OldMaxTemp(ctx)
	case commodity.FieldDescription:
		return m.OldDescription(ctx)
	case commodity.FieldHazardousMaterialID:
		return m.OldHazardousMaterialID(ctx)
	}
	return nil, fmt.Errorf("unknown Commodity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommodityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case commodity.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case commodity.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case commodity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case commodity.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case commodity.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case commodity.FieldStatus:
		v, ok := value.(commodity.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case commodity.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case commodity.FieldIsHazmat:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsHazmat(v)
		return nil
	case commodity.FieldUnitOfMeasure:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitOfMeasure(v)
		return nil
	case commodity.FieldMinTemp:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinTemp(v)
		return nil
	case commodity.FieldMaxTemp:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxTemp(v)
		return nil
	case commodity.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case commodity.FieldHazardousMaterialID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHazardousMaterialID(v)
		return nil
	}
	return fmt.Errorf("unknown Commodity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommodityMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, commodity.FieldVersion)
	}
	if m.addmin_temp != nil {
		fields = append(fields, commodity.FieldMinTemp)
	}
	if m.addmax_temp != nil {
		fields = append(fields, commodity.FieldMaxTemp)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommodityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case commodity.FieldVersion:
		return m.AddedVersion()
	case commodity.FieldMinTemp:
		return m.AddedMinTemp()
	case commodity.FieldMaxTemp:
		return m.AddedMaxTemp()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommodityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case commodity.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case commodity.FieldMinTemp:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinTemp(v)
		return nil
	case commodity.FieldMaxTemp:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxTemp(v)
		return nil
	}
	return fmt.Errorf("unknown Commodity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommodityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(commodity.FieldUnitOfMeasure) {
		fields = append(fields, commodity.FieldUnitOfMeasure)
	}
	if m.FieldCleared(commodity.FieldMinTemp) {
		fields = append(fields, commodity.FieldMinTemp)
	}
	if m.FieldCleared(commodity.FieldMaxTemp) {
		fields = append(fields, commodity.FieldMaxTemp)
	}
	if m.FieldCleared(commodity.FieldDescription) {
		fields = append(fields, commodity.FieldDescription)
	}
	if m.FieldCleared(commodity.FieldHazardousMaterialID) {
		fields = append(fields, commodity.FieldHazardousMaterialID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommodityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommodityMutation) ClearField(name string) error {
	switch name {
	case commodity.FieldUnitOfMeasure:
		m.ClearUnitOfMeasure()
		return nil
	case commodity.FieldMinTemp:
		m.ClearMinTemp()
		return nil
	case commodity.FieldMaxTemp:
		m.ClearMaxTemp()
		return nil
	case commodity.FieldDescription:
		m.ClearDescription()
		return nil
	case commodity.FieldHazardousMaterialID:
		m.ClearHazardousMaterialID()
		return nil
	}
	return fmt.Errorf("unknown Commodity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommodityMutation) ResetField(name string) error {
	switch name {
	case commodity.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case commodity.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case commodity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case commodity.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case commodity.FieldVersion:
		m.ResetVersion()
		return nil
	case commodity.FieldStatus:
		m.ResetStatus()
		return nil
	case commodity.FieldName:
		m.ResetName()
		return nil
	case commodity.FieldIsHazmat:
		m.ResetIsHazmat()
		return nil
	case commodity.FieldUnitOfMeasure:
		m.ResetUnitOfMeasure()
		return nil
	case commodity.FieldMinTemp:
		m.ResetMinTemp()
		return nil
	case commodity.FieldMaxTemp:
		m.ResetMaxTemp()
		return nil
	case commodity.FieldDescription:
		m.ResetDescription()
		return nil
	case commodity.FieldHazardousMaterialID:
		m.ResetHazardousMaterialID()
		return nil
	}
	return fmt.Errorf("unknown Commodity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommodityMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.business_unit != nil {
		edges = append(edges, commodity.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, commodity.EdgeOrganization)
	}
	if m.hazardous_material != nil {
		edges = append(edges, commodity.EdgeHazardousMaterial)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommodityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case commodity.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case commodity.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case commodity.EdgeHazardousMaterial:
		if id := m.hazardous_material; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommodityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommodityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommodityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbusiness_unit {
		edges = append(edges, commodity.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, commodity.EdgeOrganization)
	}
	if m.clearedhazardous_material {
		edges = append(edges, commodity.EdgeHazardousMaterial)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommodityMutation) EdgeCleared(name string) bool {
	switch name {
	case commodity.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case commodity.EdgeOrganization:
		return m.clearedorganization
	case commodity.EdgeHazardousMaterial:
		return m.clearedhazardous_material
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommodityMutation) ClearEdge(name string) error {
	switch name {
	case commodity.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case commodity.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case commodity.EdgeHazardousMaterial:
		m.ClearHazardousMaterial()
		return nil
	}
	return fmt.Errorf("unknown Commodity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommodityMutation) ResetEdge(name string) error {
	switch name {
	case commodity.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case commodity.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case commodity.EdgeHazardousMaterial:
		m.ResetHazardousMaterial()
		return nil
	}
	return fmt.Errorf("unknown Commodity edge %s", name)
}

// CustomReportMutation represents an operation that mutates the CustomReport nodes in the graph.
type CustomReportMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	version              *int
	addversion           *int
	name                 *string
	description          *string
	table                *string
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	done                 bool
	oldValue             func(context.Context) (*CustomReport, error)
	predicates           []predicate.CustomReport
}

var _ ent.Mutation = (*CustomReportMutation)(nil)

// customreportOption allows management of the mutation configuration using functional options.
type customreportOption func(*CustomReportMutation)

// newCustomReportMutation creates new mutation for the CustomReport entity.
func newCustomReportMutation(c config, op Op, opts ...customreportOption) *CustomReportMutation {
	m := &CustomReportMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomReport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomReportID sets the ID field of the mutation.
func withCustomReportID(id uuid.UUID) customreportOption {
	return func(m *CustomReportMutation) {
		var (
			err   error
			once  sync.Once
			value *CustomReport
		)
		m.oldValue = func(ctx context.Context) (*CustomReport, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CustomReport.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomReport sets the old CustomReport of the mutation.
func withCustomReport(node *CustomReport) customreportOption {
	return func(m *CustomReportMutation) {
		m.oldValue = func(context.Context) (*CustomReport, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomReportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomReportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CustomReport entities.
func (m *CustomReportMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CustomReportMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CustomReportMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CustomReport.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *CustomReportMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *CustomReportMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the CustomReport entity.
// If the CustomReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomReportMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *CustomReportMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *CustomReportMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *CustomReportMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the CustomReport entity.
// If the CustomReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomReportMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *CustomReportMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CustomReportMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CustomReportMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CustomReport entity.
// If the CustomReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomReportMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CustomReportMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CustomReportMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CustomReportMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CustomReport entity.
// If the CustomReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomReportMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CustomReportMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *CustomReportMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *CustomReportMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the CustomReport entity.
// If the CustomReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomReportMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *CustomReportMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *CustomReportMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *CustomReportMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetName sets the "name" field.
func (m *CustomReportMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CustomReportMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CustomReport entity.
// If the CustomReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomReportMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CustomReportMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *CustomReportMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CustomReportMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the CustomReport entity.
// If the CustomReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomReportMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CustomReportMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[customreport.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CustomReportMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[customreport.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CustomReportMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, customreport.FieldDescription)
}

// SetTable sets the "table" field.
func (m *CustomReportMutation) SetTable(s string) {
	m.table = &s
}

// Table returns the value of the "table" field in the mutation.
func (m *CustomReportMutation) Table() (r string, exists bool) {
	v := m.table
	if v == nil {
		return
	}
	return *v, true
}

// OldTable returns the old "table" field's value of the CustomReport entity.
// If the CustomReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomReportMutation) OldTable(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTable: %w", err)
	}
	return oldValue.Table, nil
}

// ClearTable clears the value of the "table" field.
func (m *CustomReportMutation) ClearTable() {
	m.table = nil
	m.clearedFields[customreport.FieldTable] = struct{}{}
}

// TableCleared returns if the "table" field was cleared in this mutation.
func (m *CustomReportMutation) TableCleared() bool {
	_, ok := m.clearedFields[customreport.FieldTable]
	return ok
}

// ResetTable resets all changes to the "table" field.
func (m *CustomReportMutation) ResetTable() {
	m.table = nil
	delete(m.clearedFields, customreport.FieldTable)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *CustomReportMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[customreport.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *CustomReportMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *CustomReportMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *CustomReportMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *CustomReportMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[customreport.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *CustomReportMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *CustomReportMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *CustomReportMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the CustomReportMutation builder.
func (m *CustomReportMutation) Where(ps ...predicate.CustomReport) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CustomReportMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CustomReportMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CustomReport, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CustomReportMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CustomReportMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CustomReport).
func (m *CustomReportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomReportMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.business_unit != nil {
		fields = append(fields, customreport.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, customreport.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, customreport.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, customreport.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, customreport.FieldVersion)
	}
	if m.name != nil {
		fields = append(fields, customreport.FieldName)
	}
	if m.description != nil {
		fields = append(fields, customreport.FieldDescription)
	}
	if m.table != nil {
		fields = append(fields, customreport.FieldTable)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomReportMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customreport.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case customreport.FieldOrganizationID:
		return m.OrganizationID()
	case customreport.FieldCreatedAt:
		return m.CreatedAt()
	case customreport.FieldUpdatedAt:
		return m.UpdatedAt()
	case customreport.FieldVersion:
		return m.Version()
	case customreport.FieldName:
		return m.Name()
	case customreport.FieldDescription:
		return m.Description()
	case customreport.FieldTable:
		return m.Table()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomReportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customreport.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case customreport.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case customreport.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case customreport.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case customreport.FieldVersion:
		return m.OldVersion(ctx)
	case customreport.FieldName:
		return m.OldName(ctx)
	case customreport.FieldDescription:
		return m.OldDescription(ctx)
	case customreport.FieldTable:
		return m.OldTable(ctx)
	}
	return nil, fmt.Errorf("unknown CustomReport field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomReportMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customreport.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case customreport.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case customreport.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case customreport.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case customreport.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case customreport.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case customreport.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case customreport.FieldTable:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTable(v)
		return nil
	}
	return fmt.Errorf("unknown CustomReport field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomReportMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, customreport.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomReportMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case customreport.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomReportMutation) AddField(name string, value ent.Value) error {
	switch name {
	case customreport.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown CustomReport numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomReportMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(customreport.FieldDescription) {
		fields = append(fields, customreport.FieldDescription)
	}
	if m.FieldCleared(customreport.FieldTable) {
		fields = append(fields, customreport.FieldTable)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomReportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomReportMutation) ClearField(name string) error {
	switch name {
	case customreport.FieldDescription:
		m.ClearDescription()
		return nil
	case customreport.FieldTable:
		m.ClearTable()
		return nil
	}
	return fmt.Errorf("unknown CustomReport nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomReportMutation) ResetField(name string) error {
	switch name {
	case customreport.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case customreport.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case customreport.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case customreport.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case customreport.FieldVersion:
		m.ResetVersion()
		return nil
	case customreport.FieldName:
		m.ResetName()
		return nil
	case customreport.FieldDescription:
		m.ResetDescription()
		return nil
	case customreport.FieldTable:
		m.ResetTable()
		return nil
	}
	return fmt.Errorf("unknown CustomReport field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomReportMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.business_unit != nil {
		edges = append(edges, customreport.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, customreport.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomReportMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case customreport.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case customreport.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomReportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomReportMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomReportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbusiness_unit {
		edges = append(edges, customreport.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, customreport.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomReportMutation) EdgeCleared(name string) bool {
	switch name {
	case customreport.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case customreport.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomReportMutation) ClearEdge(name string) error {
	switch name {
	case customreport.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case customreport.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown CustomReport unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomReportMutation) ResetEdge(name string) error {
	switch name {
	case customreport.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case customreport.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown CustomReport edge %s", name)
}

// CustomerMutation represents an operation that mutates the Customer nodes in the graph.
type CustomerMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	created_at                *time.Time
	updated_at                *time.Time
	version                   *int
	addversion                *int
	status                    *customer.Status
	code                      *string
	name                      *string
	address_line_1            *string
	address_line_2            *string
	city                      *string
	postal_code               *string
	has_customer_portal       *bool
	auto_mark_ready_to_bill   *bool
	clearedFields             map[string]struct{}
	business_unit             *uuid.UUID
	clearedbusiness_unit      bool
	organization              *uuid.UUID
	clearedorganization       bool
	state                     *uuid.UUID
	clearedstate              bool
	shipments                 map[uuid.UUID]struct{}
	removedshipments          map[uuid.UUID]struct{}
	clearedshipments          bool
	email_profile             *uuid.UUID
	clearedemail_profile      bool
	rule_profile              *uuid.UUID
	clearedrule_profile       bool
	detention_policies        map[uuid.UUID]struct{}
	removeddetention_policies map[uuid.UUID]struct{}
	cleareddetention_policies bool
	contacts                  map[uuid.UUID]struct{}
	removedcontacts           map[uuid.UUID]struct{}
	clearedcontacts           bool
	delivery_slots            map[uuid.UUID]struct{}
	removeddelivery_slots     map[uuid.UUID]struct{}
	cleareddelivery_slots     bool
	done                      bool
	oldValue                  func(context.Context) (*Customer, error)
	predicates                []predicate.Customer
}

var _ ent.Mutation = (*CustomerMutation)(nil)

// customerOption allows management of the mutation configuration using functional options.
type customerOption func(*CustomerMutation)

// newCustomerMutation creates new mutation for the Customer entity.
func newCustomerMutation(c config, op Op, opts ...customerOption) *CustomerMutation {
	m := &CustomerMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerID sets the ID field of the mutation.
func withCustomerID(id uuid.UUID) customerOption {
	return func(m *CustomerMutation) {
		var (
			err   error
			once  sync.Once
			value *Customer
		)
		m.oldValue = func(ctx context.Context) (*Customer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Customer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomer sets the old Customer of the mutation.
func withCustomer(node *Customer) customerOption {
	return func(m *CustomerMutation) {
		m.oldValue = func(context.Context) (*Customer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Customer entities.
func (m *CustomerMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CustomerMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CustomerMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Customer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *CustomerMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *CustomerMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *CustomerMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *CustomerMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *CustomerMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *CustomerMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CustomerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CustomerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CustomerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CustomerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CustomerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CustomerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *CustomerMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *CustomerMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *CustomerMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *CustomerMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *CustomerMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetStatus sets the "status" field.
func (m *CustomerMutation) SetStatus(c customer.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *CustomerMutation) Status() (r customer.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldStatus(ctx context.Context) (v customer.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CustomerMutation) ResetStatus() {
	m.status = nil
}

// SetCode sets the "code" field.
func (m *CustomerMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *CustomerMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *CustomerMutation) ResetCode() {
	m.code = nil
}

// SetName sets the "name" field.
func (m *CustomerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CustomerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CustomerMutation) ResetName() {
	m.name = nil
}

// SetAddressLine1 sets the "address_line_1" field.
func (m *CustomerMutation) SetAddressLine1(s string) {
	m.address_line_1 = &s
}

// AddressLine1 returns the value of the "address_line_1" field in the mutation.
func (m *CustomerMutation) AddressLine1() (r string, exists bool) {
	v := m.address_line_1
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressLine1 returns the old "address_line_1" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldAddressLine1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddressLine1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddressLine1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressLine1: %w", err)
	}
	return oldValue.AddressLine1, nil
}

// ResetAddressLine1 resets all changes to the "address_line_1" field.
func (m *CustomerMutation) ResetAddressLine1() {
	m.address_line_1 = nil
}

// SetAddressLine2 sets the "address_line_2" field.
func (m *CustomerMutation) SetAddressLine2(s string) {
	m.address_line_2 = &s
}

// AddressLine2 returns the value of the "address_line_2" field in the mutation.
func (m *CustomerMutation) AddressLine2() (r string, exists bool) {
	v := m.address_line_2
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressLine2 returns the old "address_line_2" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldAddressLine2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddressLine2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddressLine2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressLine2: %w", err)
	}
	return oldValue.AddressLine2, nil
}

// ClearAddressLine2 clears the value of the "address_line_2" field.
func (m *CustomerMutation) ClearAddressLine2() {
	m.address_line_2 = nil
	m.clearedFields[customer.FieldAddressLine2] = struct{}{}
}

// AddressLine2Cleared returns if the "address_line_2" field was cleared in this mutation.
func (m *CustomerMutation) AddressLine2Cleared() bool {
	_, ok := m.clearedFields[customer.FieldAddressLine2]
	return ok
}

// ResetAddressLine2 resets all changes to the "address_line_2" field.
func (m *CustomerMutation) ResetAddressLine2() {
	m.address_line_2 = nil
	delete(m.clearedFields, customer.FieldAddressLine2)
}

// SetCity sets the "city" field.
func (m *CustomerMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *CustomerMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *CustomerMutation) ResetCity() {
	m.city = nil
}

// SetStateID sets the "state_id" field.
func (m *CustomerMutation) SetStateID(u uuid.UUID) {
	m.state = &u
}

// StateID returns the value of the "state_id" field in the mutation.
func (m *CustomerMutation) StateID() (r uuid.UUID, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldStateID returns the old "state_id" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldStateID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStateID: %w", err)
	}
	return oldValue.StateID, nil
}

// ResetStateID resets all changes to the "state_id" field.
func (m *CustomerMutation) ResetStateID() {
	m.state = nil
}

// SetPostalCode sets the "postal_code" field.
func (m *CustomerMutation) SetPostalCode(s string) {
	m.postal_code = &s
}

// PostalCode returns the value of the "postal_code" field in the mutation.
func (m *CustomerMutation) PostalCode() (r string, exists bool) {
	v := m.postal_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPostalCode returns the old "postal_code" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldPostalCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostalCode: %w", err)
	}
	return oldValue.PostalCode, nil
}

// ResetPostalCode resets all changes to the "postal_code" field.
func (m *CustomerMutation) ResetPostalCode() {
	m.postal_code = nil
}

// SetHasCustomerPortal sets the "has_customer_portal" field.
func (m *CustomerMutation) SetHasCustomerPortal(b bool) {
	m.has_customer_portal = &b
}

// HasCustomerPortal returns the value of the "has_customer_portal" field in the mutation.
func (m *CustomerMutation) HasCustomerPortal() (r bool, exists bool) {
	v := m.has_customer_portal
	if v == nil {
		return
	}
	return *v, true
}

// OldHasCustomerPortal returns the old "has_customer_portal" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldHasCustomerPortal(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasCustomerPortal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasCustomerPortal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasCustomerPortal: %w", err)
	}
	return oldValue.HasCustomerPortal, nil
}

// ResetHasCustomerPortal resets all changes to the "has_customer_portal" field.
func (m *CustomerMutation) ResetHasCustomerPortal() {
	m.has_customer_portal = nil
}

// SetAutoMarkReadyToBill sets the "auto_mark_ready_to_bill" field.
func (m *CustomerMutation) SetAutoMarkReadyToBill(b bool) {
	m.auto_mark_ready_to_bill = &b
}

// AutoMarkReadyToBill returns the value of the "auto_mark_ready_to_bill" field in the mutation.
func (m *CustomerMutation) AutoMarkReadyToBill() (r bool, exists bool) {
	v := m.auto_mark_ready_to_bill
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoMarkReadyToBill returns the old "auto_mark_ready_to_bill" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldAutoMarkReadyToBill(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoMarkReadyToBill is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoMarkReadyToBill requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoMarkReadyToBill: %w", err)
	}
	return oldValue.AutoMarkReadyToBill, nil
}

// ResetAutoMarkReadyToBill resets all changes to the "auto_mark_ready_to_bill" field.
func (m *CustomerMutation) ResetAutoMarkReadyToBill() {
	m.auto_mark_ready_to_bill = nil
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *CustomerMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[customer.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *CustomerMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *CustomerMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *CustomerMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *CustomerMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[customer.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *CustomerMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *CustomerMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *CustomerMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearState clears the "state" edge to the UsState entity.
func (m *CustomerMutation) ClearState() {
	m.clearedstate = true
	m.clearedFields[customer.FieldStateID] = struct{}{}
}

// StateCleared reports if the "state" edge to the UsState entity was cleared.
func (m *CustomerMutation) StateCleared() bool {
	return m.clearedstate
}

// StateIDs returns the "state" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StateID instead. It exists only for internal usage by the builders.
func (m *CustomerMutation) StateIDs() (ids []uuid.UUID) {
	if id := m.state; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetState resets all changes to the "state" edge.
func (m *CustomerMutation) ResetState() {
	m.state = nil
	m.clearedstate = false
}

// AddShipmentIDs adds the "shipments" edge to the Shipment entity by ids.
func (m *CustomerMutation) AddShipmentIDs(ids ...uuid.UUID) {
	if m.shipments == nil {
		m.shipments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.shipments[ids[i]] = struct{}{}
	}
}

// ClearShipments clears the "shipments" edge to the Shipment entity.
func (m *CustomerMutation) ClearShipments() {
	m.clearedshipments = true
}

// ShipmentsCleared reports if the "shipments" edge to the Shipment entity was cleared.
func (m *CustomerMutation) ShipmentsCleared() bool {
	return m.clearedshipments
}

// RemoveShipmentIDs removes the "shipments" edge to the Shipment entity by IDs.
func (m *CustomerMutation) RemoveShipmentIDs(ids ...uuid.UUID) {
	if m.removedshipments == nil {
		m.removedshipments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.shipments, ids[i])
		m.removedshipments[ids[i]] = struct{}{}
	}
}

// RemovedShipments returns the removed IDs of the "shipments" edge to the Shipment entity.
func (m *CustomerMutation) RemovedShipmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedshipments {
		ids = append(ids, id)
	}
	return
}

// ShipmentsIDs returns the "shipments" edge IDs in the mutation.
func (m *CustomerMutation) ShipmentsIDs() (ids []uuid.UUID) {
	for id := range m.shipments {
		ids = append(ids, id)
	}
	return
}

// ResetShipments resets all changes to the "shipments" edge.
func (m *CustomerMutation) ResetShipments() {
	m.shipments = nil
	m.clearedshipments = false
	m.removedshipments = nil
}

// SetEmailProfileID sets the "email_profile" edge to the CustomerEmailProfile entity by id.
func (m *CustomerMutation) SetEmailProfileID(id uuid.UUID) {
	m.email_profile = &id
}

// ClearEmailProfile clears the "email_profile" edge to the CustomerEmailProfile entity.
func (m *CustomerMutation) ClearEmailProfile() {
	m.clearedemail_profile = true
}

// EmailProfileCleared reports if the "email_profile" edge to the CustomerEmailProfile entity was cleared.
func (m *CustomerMutation) EmailProfileCleared() bool {
	return m.clearedemail_profile
}

// EmailProfileID returns the "email_profile" edge ID in the mutation.
func (m *CustomerMutation) EmailProfileID() (id uuid.UUID, exists bool) {
	if m.email_profile != nil {
		return *m.email_profile, true
	}
	return
}

// EmailProfileIDs returns the "email_profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmailProfileID instead. It exists only for internal usage by the builders.
func (m *CustomerMutation) EmailProfileIDs() (ids []uuid.UUID) {
	if id := m.email_profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmailProfile resets all changes to the "email_profile" edge.
func (m *CustomerMutation) ResetEmailProfile() {
	m.email_profile = nil
	m.clearedemail_profile = false
}

// SetRuleProfileID sets the "rule_profile" edge to the CustomerRuleProfile entity by id.
func (m *CustomerMutation) SetRuleProfileID(id uuid.UUID) {
	m.rule_profile = &id
}

// ClearRuleProfile clears the "rule_profile" edge to the CustomerRuleProfile entity.
func (m *CustomerMutation) ClearRuleProfile() {
	m.clearedrule_profile = true
}

// RuleProfileCleared reports if the "rule_profile" edge to the CustomerRuleProfile entity was cleared.
func (m *CustomerMutation) RuleProfileCleared() bool {
	return m.clearedrule_profile
}

// RuleProfileID returns the "rule_profile" edge ID in the mutation.
func (m *CustomerMutation) RuleProfileID() (id uuid.UUID, exists bool) {
	if m.rule_profile != nil {
		return *m.rule_profile, true
	}
	return
}

// RuleProfileIDs returns the "rule_profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RuleProfileID instead. It exists only for internal usage by the builders.
func (m *CustomerMutation) RuleProfileIDs() (ids []uuid.UUID) {
	if id := m.rule_profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRuleProfile resets all changes to the "rule_profile" edge.
func (m *CustomerMutation) ResetRuleProfile() {
	m.rule_profile = nil
	m.clearedrule_profile = false
}

// AddDetentionPolicyIDs adds the "detention_policies" edge to the CustomerDetentionPolicy entity by ids.
func (m *CustomerMutation) AddDetentionPolicyIDs(ids ...uuid.UUID) {
	if m.detention_policies == nil {
		m.detention_policies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.detention_policies[ids[i]] = struct{}{}
	}
}

// ClearDetentionPolicies clears the "detention_policies" edge to the CustomerDetentionPolicy entity.
func (m *CustomerMutation) ClearDetentionPolicies() {
	m.cleareddetention_policies = true
}

// DetentionPoliciesCleared reports if the "detention_policies" edge to the CustomerDetentionPolicy entity was cleared.
func (m *CustomerMutation) DetentionPoliciesCleared() bool {
	return m.cleareddetention_policies
}

// RemoveDetentionPolicyIDs removes the "detention_policies" edge to the CustomerDetentionPolicy entity by IDs.
func (m *CustomerMutation) RemoveDetentionPolicyIDs(ids ...uuid.UUID) {
	if m.removeddetention_policies == nil {
		m.removeddetention_policies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.detention_policies, ids[i])
		m.removeddetention_policies[ids[i]] = struct{}{}
	}
}

// RemovedDetentionPolicies returns the removed IDs of the "detention_policies" edge to the CustomerDetentionPolicy entity.
func (m *CustomerMutation) RemovedDetentionPoliciesIDs() (ids []uuid.UUID) {
	for id := range m.removeddetention_policies {
		ids = append(ids, id)
	}
	return
}

// DetentionPoliciesIDs returns the "detention_policies" edge IDs in the mutation.
func (m *CustomerMutation) DetentionPoliciesIDs() (ids []uuid.UUID) {
	for id := range m.detention_policies {
		ids = append(ids, id)
	}
	return
}

// ResetDetentionPolicies resets all changes to the "detention_policies" edge.
func (m *CustomerMutation) ResetDetentionPolicies() {
	m.detention_policies = nil
	m.cleareddetention_policies = false
	m.removeddetention_policies = nil
}

// AddContactIDs adds the "contacts" edge to the CustomerContact entity by ids.
func (m *CustomerMutation) AddContactIDs(ids ...uuid.UUID) {
	if m.contacts == nil {
		m.contacts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.contacts[ids[i]] = struct{}{}
	}
}

// ClearContacts clears the "contacts" edge to the CustomerContact entity.
func (m *CustomerMutation) ClearContacts() {
	m.clearedcontacts = true
}

// ContactsCleared reports if the "contacts" edge to the CustomerContact entity was cleared.
func (m *CustomerMutation) ContactsCleared() bool {
	return m.clearedcontacts
}

// RemoveContactIDs removes the "contacts" edge to the CustomerContact entity by IDs.
func (m *CustomerMutation) RemoveContactIDs(ids ...uuid.UUID) {
	if m.removedcontacts == nil {
		m.removedcontacts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.contacts, ids[i])
		m.removedcontacts[ids[i]] = struct{}{}
	}
}

// RemovedContacts returns the removed IDs of the "contacts" edge to the CustomerContact entity.
func (m *CustomerMutation) RemovedContactsIDs() (ids []uuid.UUID) {
	for id := range m.removedcontacts {
		ids = append(ids, id)
	}
	return
}

// ContactsIDs returns the "contacts" edge IDs in the mutation.
func (m *CustomerMutation) ContactsIDs() (ids []uuid.UUID) {
	for id := range m.contacts {
		ids = append(ids, id)
	}
	return
}

// ResetContacts resets all changes to the "contacts" edge.
func (m *CustomerMutation) ResetContacts() {
	m.contacts = nil
	m.clearedcontacts = false
	m.removedcontacts = nil
}

// AddDeliverySlotIDs adds the "delivery_slots" edge to the DeliverySlot entity by ids.
func (m *CustomerMutation) AddDeliverySlotIDs(ids ...uuid.UUID) {
	if m.delivery_slots == nil {
		m.delivery_slots = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.delivery_slots[ids[i]] = struct{}{}
	}
}

// ClearDeliverySlots clears the "delivery_slots" edge to the DeliverySlot entity.
func (m *CustomerMutation) ClearDeliverySlots() {
	m.cleareddelivery_slots = true
}

// DeliverySlotsCleared reports if the "delivery_slots" edge to the DeliverySlot entity was cleared.
func (m *CustomerMutation) DeliverySlotsCleared() bool {
	return m.cleareddelivery_slots
}

// RemoveDeliverySlotIDs removes the "delivery_slots" edge to the DeliverySlot entity by IDs.
func (m *CustomerMutation) RemoveDeliverySlotIDs(ids ...uuid.UUID) {
	if m.removeddelivery_slots == nil {
		m.removeddelivery_slots = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.delivery_slots, ids[i])
		m.removeddelivery_slots[ids[i]] = struct{}{}
	}
}

// RemovedDeliverySlots returns the removed IDs of the "delivery_slots" edge to the DeliverySlot entity.
func (m *CustomerMutation) RemovedDeliverySlotsIDs() (ids []uuid.UUID) {
	for id := range m.removeddelivery_slots {
		ids = append(ids, id)
	}
	return
}

// DeliverySlotsIDs returns the "delivery_slots" edge IDs in the mutation.
func (m *CustomerMutation) DeliverySlotsIDs() (ids []uuid.UUID) {
	for id := range m.delivery_slots {
		ids = append(ids, id)
	}
	return
}

// ResetDeliverySlots resets all changes to the "delivery_slots" edge.
func (m *CustomerMutation) ResetDeliverySlots() {
	m.delivery_slots = nil
	m.cleareddelivery_slots = false
	m.removeddelivery_slots = nil
}

// Where appends a list predicates to the CustomerMutation builder.
func (m *CustomerMutation) Where(ps ...predicate.Customer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CustomerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CustomerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Customer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CustomerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CustomerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Customer).
func (m *CustomerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomerMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.business_unit != nil {
		fields = append(fields, customer.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, customer.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, customer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, customer.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, customer.FieldVersion)
	}
	if m.status != nil {
		fields = append(fields, customer.FieldStatus)
	}
	if m.code != nil {
		fields = append(fields, customer.FieldCode)
	}
	if m.name != nil {
		fields = append(fields, customer.FieldName)
	}
	if m.address_line_1 != nil {
		fields = append(fields, customer.FieldAddressLine1)
	}
	if m.address_line_2 != nil {
		fields = append(fields, customer.FieldAddressLine2)
	}
	if m.city != nil {
		fields = append(fields, customer.FieldCity)
	}
	if m.state != nil {
		fields = append(fields, customer.FieldStateID)
	}
	if m.postal_code != nil {
		fields = append(fields, customer.FieldPostalCode)
	}
	if m.has_customer_portal != nil {
		fields = append(fields, customer.FieldHasCustomerPortal)
	}
	if m.auto_mark_ready_to_bill != nil {
		fields = append(fields, customer.FieldAutoMarkReadyToBill)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customer.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case customer.FieldOrganizationID:
		return m.OrganizationID()
	case customer.FieldCreatedAt:
		return m.CreatedAt()
	case customer.FieldUpdatedAt:
		return m.UpdatedAt()
	case customer.FieldVersion:
		return m.Version()
	case customer.FieldStatus:
		return m.Status()
	case customer.FieldCode:
		return m.Code()
	case customer.FieldName:
		return m.Name()
	case customer.FieldAddressLine1:
		return m.AddressLine1()
	case customer.FieldAddressLine2:
		return m.AddressLine2()
	case customer.FieldCity:
		return m.City()
	case customer.FieldStateID:
		return m.StateID()
	case customer.FieldPostalCode:
		return m.PostalCode()
	case customer.FieldHasCustomerPortal:
		return m.HasCustomerPortal()
	case customer.FieldAutoMarkReadyToBill:
		return m.AutoMarkReadyToBill()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customer.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case customer.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case customer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case customer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case customer.FieldVersion:
		return m.OldVersion(ctx)
	case customer.FieldStatus:
		return m.OldStatus(ctx)
	case customer.FieldCode:
		return m.OldCode(ctx)
	case customer.FieldName:
		return m.OldName(ctx)
	case customer.FieldAddressLine1:
		return m.OldAddressLine1(ctx)
	case customer.FieldAddressLine2:
		return m.OldAddressLine2(ctx)
	case customer.FieldCity:
		return m.OldCity(ctx)
	case customer.FieldStateID:
		return m.OldStateID(ctx)
	case customer.FieldPostalCode:
		return m.OldPostalCode(ctx)
	case customer.FieldHasCustomerPortal:
		return m.OldHasCustomerPortal(ctx)
	case customer.FieldAutoMarkReadyToBill:
		return m.OldAutoMarkReadyToBill(ctx)
	}
	return nil, fmt.Errorf("unknown Customer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customer.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case customer.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case customer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case customer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case customer.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case customer.FieldStatus:
		v, ok := value.(customer.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case customer.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case customer.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case customer.FieldAddressLine1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressLine1(v)
		return nil
	case customer.FieldAddressLine2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressLine2(v)
		return nil
	case customer.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case customer.FieldStateID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStateID(v)
		return nil
	case customer.FieldPostalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostalCode(v)
		return nil
	case customer.FieldHasCustomerPortal:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasCustomerPortal(v)
		return nil
	case customer.FieldAutoMarkReadyToBill:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoMarkReadyToBill(v)
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomerMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, customer.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case customer.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case customer.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Customer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(customer.FieldAddressLine2) {
		fields = append(fields, customer.FieldAddressLine2)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerMutation) ClearField(name string) error {
	switch name {
	case customer.FieldAddressLine2:
		m.ClearAddressLine2()
		return nil
	}
	return fmt.Errorf("unknown Customer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomerMutation) ResetField(name string) error {
	switch name {
	case customer.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case customer.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case customer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case customer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case customer.FieldVersion:
		m.ResetVersion()
		return nil
	case customer.FieldStatus:
		m.ResetStatus()
		return nil
	case customer.FieldCode:
		m.ResetCode()
		return nil
	case customer.FieldName:
		m.ResetName()
		return nil
	case customer.FieldAddressLine1:
		m.ResetAddressLine1()
		return nil
	case customer.FieldAddressLine2:
		m.ResetAddressLine2()
		return nil
	case customer.FieldCity:
		m.ResetCity()
		return nil
	case customer.FieldStateID:
		m.ResetStateID()
		return nil
	case customer.FieldPostalCode:
		m.ResetPostalCode()
		return nil
	case customer.FieldHasCustomerPortal:
		m.ResetHasCustomerPortal()
		return nil
	case customer.FieldAutoMarkReadyToBill:
		m.ResetAutoMarkReadyToBill()
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomerMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.business_unit != nil {
		edges = append(edges, customer.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, customer.EdgeOrganization)
	}
	if m.state != nil {
		edges = append(edges, customer.EdgeState)
	}
	if m.shipments != nil {
		edges = append(edges, customer.EdgeShipments)
	}
	if m.email_profile != nil {
		edges = append(edges, customer.EdgeEmailProfile)
	}
	if m.rule_profile != nil {
		edges = append(edges, customer.EdgeRuleProfile)
	}
	if m.detention_policies != nil {
		edges = append(edges, customer.EdgeDetentionPolicies)
	}
	if m.contacts != nil {
		edges = append(edges, customer.EdgeContacts)
	}
	if m.delivery_slots != nil {
		edges = append(edges, customer.EdgeDeliverySlots)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case customer.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case customer.EdgeState:
		if id := m.state; id != nil {
			return []ent.Value{*id}
		}
	case customer.EdgeShipments:
		ids := make([]ent.Value, 0, len(m.shipments))
		for id := range m.shipments {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeEmailProfile:
		if id := m.email_profile; id != nil {
			return []ent.Value{*id}
		}
	case customer.EdgeRuleProfile:
		if id := m.rule_profile; id != nil {
			return []ent.Value{*id}
		}
	case customer.EdgeDetentionPolicies:
		ids := make([]ent.Value, 0, len(m.detention_policies))
		for id := range m.detention_policies {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeContacts:
		ids := make([]ent.Value, 0, len(m.contacts))
		for id := range m.contacts {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeDeliverySlots:
		ids := make([]ent.Value, 0, len(m.delivery_slots))
		for id := range m.delivery_slots {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedshipments != nil {
		edges = append(edges, customer.EdgeShipments)
	}
	if m.removeddetention_policies != nil {
		edges = append(edges, customer.EdgeDetentionPolicies)
	}
	if m.removedcontacts != nil {
		edges = append(edges, customer.EdgeContacts)
	}
	if m.removeddelivery_slots != nil {
		edges = append(edges, customer.EdgeDeliverySlots)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeShipments:
		ids := make([]ent.Value, 0, len(m.removedshipments))
		for id := range m.removedshipments {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeDetentionPolicies:
		ids := make([]ent.Value, 0, len(m.removeddetention_policies))
		for id := range m.removeddetention_policies {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeContacts:
		ids := make([]ent.Value, 0, len(m.removedcontacts))
		for id := range m.removedcontacts {
			ids = append(ids, id)
		}
		return ids
	case customer.EdgeDeliverySlots:
		ids := make([]ent.Value, 0, len(m.removeddelivery_slots))
		for id := range m.removeddelivery_slots {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedbusiness_unit {
		edges = append(edges, customer.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, customer.EdgeOrganization)
	}
	if m.clearedstate {
		edges = append(edges, customer.EdgeState)
	}
	if m.clearedshipments {
		edges = append(edges, customer.EdgeShipments)
	}
	if m.clearedemail_profile {
		edges = append(edges, customer.EdgeEmailProfile)
	}
	if m.clearedrule_profile {
		edges = append(edges, customer.EdgeRuleProfile)
	}
	if m.cleareddetention_policies {
		edges = append(edges, customer.EdgeDetentionPolicies)
	}
	if m.clearedcontacts {
		edges = append(edges, customer.EdgeContacts)
	}
	if m.cleareddelivery_slots {
		edges = append(edges, customer.EdgeDeliverySlots)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomerMutation) EdgeCleared(name string) bool {
	switch name {
	case customer.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case customer.EdgeOrganization:
		return m.clearedorganization
	case customer.EdgeState:
		return m.clearedstate
	case customer.EdgeShipments:
		return m.clearedshipments
	case customer.EdgeEmailProfile:
		return m.clearedemail_profile
	case customer.EdgeRuleProfile:
		return m.clearedrule_profile
	case customer.EdgeDetentionPolicies:
		return m.cleareddetention_policies
	case customer.EdgeContacts:
		return m.clearedcontacts
	case customer.EdgeDeliverySlots:
		return m.cleareddelivery_slots
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomerMutation) ClearEdge(name string) error {
	switch name {
	case customer.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case customer.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case customer.EdgeState:
		m.ClearState()
		return nil
	case customer.EdgeEmailProfile:
		m.ClearEmailProfile()
		return nil
	case customer.EdgeRuleProfile:
		m.ClearRuleProfile()
		return nil
	}
	return fmt.Errorf("unknown Customer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomerMutation) ResetEdge(name string) error {
	switch name {
	case customer.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case customer.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case customer.EdgeState:
		m.ResetState()
		return nil
	case customer.EdgeShipments:
		m.ResetShipments()
		return nil
	case customer.EdgeEmailProfile:
		m.ResetEmailProfile()
		return nil
	case customer.EdgeRuleProfile:
		m.ResetRuleProfile()
		return nil
	case customer.EdgeDetentionPolicies:
		m.ResetDetentionPolicies()
		return nil
	case customer.EdgeContacts:
		m.ResetContacts()
		return nil
	case customer.EdgeDeliverySlots:
		m.ResetDeliverySlots()
		return nil
	}
	return fmt.Errorf("unknown Customer edge %s", name)
}

// CustomerContactMutation represents an operation that mutates the CustomerContact nodes in the graph.
type CustomerContactMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	version              *int
	addversion           *int
	name                 *string
	email                *string
	title                *string
	phone_number         *string
	is_payable_contact   *bool
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	customer             *uuid.UUID
	clearedcustomer      bool
	done                 bool
	oldValue             func(context.Context) (*CustomerContact, error)
	predicates           []predicate.CustomerContact
}

var _ ent.Mutation = (*CustomerContactMutation)(nil)

// customercontactOption allows management of the mutation configuration using functional options.
type customercontactOption func(*CustomerContactMutation)

// newCustomerContactMutation creates new mutation for the CustomerContact entity.
func newCustomerContactMutation(c config, op Op, opts ...customercontactOption) *CustomerContactMutation {
	m := &CustomerContactMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomerContact,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerContactID sets the ID field of the mutation.
func withCustomerContactID(id uuid.UUID) customercontactOption {
	return func(m *CustomerContactMutation) {
		var (
			err   error
			once  sync.Once
			value *CustomerContact
		)
		m.oldValue = func(ctx context.Context) (*CustomerContact, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CustomerContact.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomerContact sets the old CustomerContact of the mutation.
func withCustomerContact(node *CustomerContact) customercontactOption {
	return func(m *CustomerContactMutation) {
		m.oldValue = func(context.Context) (*CustomerContact, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerContactMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerContactMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CustomerContact entities.
func (m *CustomerContactMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CustomerContactMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CustomerContactMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CustomerContact.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *CustomerContactMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *CustomerContactMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the CustomerContact entity.
// If the CustomerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerContactMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *CustomerContactMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *CustomerContactMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *CustomerContactMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the CustomerContact entity.
// If the CustomerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerContactMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *CustomerContactMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CustomerContactMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CustomerContactMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CustomerContact entity.
// If the CustomerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerContactMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CustomerContactMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CustomerContactMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CustomerContactMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CustomerContact entity.
// If the CustomerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerContactMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CustomerContactMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *CustomerContactMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *CustomerContactMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the CustomerContact entity.
// If the CustomerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerContactMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *CustomerContactMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *CustomerContactMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *CustomerContactMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetCustomerID sets the "customer_id" field.
func (m *CustomerContactMutation) SetCustomerID(u uuid.UUID) {
	m.customer = &u
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *CustomerContactMutation) CustomerID() (r uuid.UUID, exists bool) {
	v := m.customer
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the CustomerContact entity.
// If the CustomerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerContactMutation) OldCustomerID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *CustomerContactMutation) ResetCustomerID() {
	m.customer = nil
}

// SetName sets the "name" field.
func (m *CustomerContactMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CustomerContactMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CustomerContact entity.
// If the CustomerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerContactMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CustomerContactMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *CustomerContactMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *CustomerContactMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the CustomerContact entity.
// If the CustomerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerContactMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *CustomerContactMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[customercontact.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *CustomerContactMutation) EmailCleared() bool {
	_, ok := m.clearedFields[customercontact.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *CustomerContactMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, customercontact.FieldEmail)
}

// SetTitle sets the "title" field.
func (m *CustomerContactMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *CustomerContactMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the CustomerContact entity.
// If the CustomerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerContactMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *CustomerContactMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[customercontact.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *CustomerContactMutation) TitleCleared() bool {
	_, ok := m.clearedFields[customercontact.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *CustomerContactMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, customercontact.FieldTitle)
}

// SetPhoneNumber sets the "phone_number" field.
func (m *CustomerContactMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *CustomerContactMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the CustomerContact entity.
// If the CustomerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerContactMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ClearPhoneNumber clears the value of the "phone_number" field.
func (m *CustomerContactMutation) ClearPhoneNumber() {
	m.phone_number = nil
	m.clearedFields[customercontact.FieldPhoneNumber] = struct{}{}
}

// PhoneNumberCleared returns if the "phone_number" field was cleared in this mutation.
func (m *CustomerContactMutation) PhoneNumberCleared() bool {
	_, ok := m.clearedFields[customercontact.FieldPhoneNumber]
	return ok
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *CustomerContactMutation) ResetPhoneNumber() {
	m.phone_number = nil
	delete(m.clearedFields, customercontact.FieldPhoneNumber)
}

// SetIsPayableContact sets the "is_payable_contact" field.
func (m *CustomerContactMutation) SetIsPayableContact(b bool) {
	m.is_payable_contact = &b
}

// IsPayableContact returns the value of the "is_payable_contact" field in the mutation.
func (m *CustomerContactMutation) IsPayableContact() (r bool, exists bool) {
	v := m.is_payable_contact
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPayableContact returns the old "is_payable_contact" field's value of the CustomerContact entity.
// If the CustomerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerContactMutation) OldIsPayableContact(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPayableContact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPayableContact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPayableContact: %w", err)
	}
	return oldValue.IsPayableContact, nil
}

// ResetIsPayableContact resets all changes to the "is_payable_contact" field.
func (m *CustomerContactMutation) ResetIsPayableContact() {
	m.is_payable_contact = nil
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *CustomerContactMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[customercontact.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *CustomerContactMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *CustomerContactMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *CustomerContactMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *CustomerContactMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[customercontact.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *CustomerContactMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *CustomerContactMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *CustomerContactMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *CustomerContactMutation) ClearCustomer() {
	m.clearedcustomer = true
	m.clearedFields[customercontact.FieldCustomerID] = struct{}{}
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *CustomerContactMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *CustomerContactMutation) CustomerIDs() (ids []uuid.UUID) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *CustomerContactMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// Where appends a list predicates to the CustomerContactMutation builder.
func (m *CustomerContactMutation) Where(ps ...predicate.CustomerContact) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CustomerContactMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CustomerContactMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CustomerContact, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CustomerContactMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CustomerContactMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CustomerContact).
func (m *CustomerContactMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomerContactMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.business_unit != nil {
		fields = append(fields, customercontact.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, customercontact.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, customercontact.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, customercontact.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, customercontact.FieldVersion)
	}
	if m.customer != nil {
		fields = append(fields, customercontact.FieldCustomerID)
	}
	if m.name != nil {
		fields = append(fields, customercontact.FieldName)
	}
	if m.email != nil {
		fields = append(fields, customercontact.FieldEmail)
	}
	if m.title != nil {
		fields = append(fields, customercontact.FieldTitle)
	}
	if m.phone_number != nil {
		fields = append(fields, customercontact.FieldPhoneNumber)
	}
	if m.is_payable_contact != nil {
		fields = append(fields, customercontact.FieldIsPayableContact)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomerContactMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customercontact.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case customercontact.FieldOrganizationID:
		return m.OrganizationID()
	case customercontact.FieldCreatedAt:
		return m.CreatedAt()
	case customercontact.FieldUpdatedAt:
		return m.UpdatedAt()
	case customercontact.FieldVersion:
		return m.Version()
	case customercontact.FieldCustomerID:
		return m.CustomerID()
	case customercontact.FieldName:
		return m.Name()
	case customercontact.FieldEmail:
		return m.Email()
	case customercontact.FieldTitle:
		return m.Title()
	case customercontact.FieldPhoneNumber:
		return m.PhoneNumber()
	case customercontact.FieldIsPayableContact:
		return m.IsPayableContact()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomerContactMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customercontact.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case customercontact.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case customercontact.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case customercontact.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case customercontact.FieldVersion:
		return m.OldVersion(ctx)
	case customercontact.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case customercontact.FieldName:
		return m.OldName(ctx)
	case customercontact.FieldEmail:
		return m.OldEmail(ctx)
	case customercontact.FieldTitle:
		return m.OldTitle(ctx)
	case customercontact.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case customercontact.FieldIsPayableContact:
		return m.OldIsPayableContact(ctx)
	}
	return nil, fmt.Errorf("unknown CustomerContact field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerContactMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customercontact.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case customercontact.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case customercontact.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case customercontact.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case customercontact.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case customercontact.FieldCustomerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case customercontact.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case customercontact.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case customercontact.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case customercontact.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case customercontact.FieldIsPayableContact:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPayableContact(v)
		return nil
	}
	return fmt.Errorf("unknown CustomerContact field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomerContactMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, customercontact.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomerContactMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case customercontact.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerContactMutation) AddField(name string, value ent.Value) error {
	switch name {
	case customercontact.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown CustomerContact numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomerContactMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(customercontact.FieldEmail) {
		fields = append(fields, customercontact.FieldEmail)
	}
	if m.FieldCleared(customercontact.FieldTitle) {
		fields = append(fields, customercontact.FieldTitle)
	}
	if m.FieldCleared(customercontact.FieldPhoneNumber) {
		fields = append(fields, customercontact.FieldPhoneNumber)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomerContactMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerContactMutation) ClearField(name string) error {
	switch name {
	case customercontact.FieldEmail:
		m.ClearEmail()
		return nil
	case customercontact.FieldTitle:
		m.ClearTitle()
		return nil
	case customercontact.FieldPhoneNumber:
		m.ClearPhoneNumber()
		return nil
	}
	return fmt.Errorf("unknown CustomerContact nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomerContactMutation) ResetField(name string) error {
	switch name {
	case customercontact.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case customercontact.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case customercontact.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case customercontact.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case customercontact.FieldVersion:
		m.ResetVersion()
		return nil
	case customercontact.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case customercontact.FieldName:
		m.ResetName()
		return nil
	case customercontact.FieldEmail:
		m.ResetEmail()
		return nil
	case customercontact.FieldTitle:
		m.ResetTitle()
		return nil
	case customercontact.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case customercontact.FieldIsPayableContact:
		m.ResetIsPayableContact()
		return nil
	}
	return fmt.Errorf("unknown CustomerContact field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomerContactMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.business_unit != nil {
		edges = append(edges, customercontact.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, customercontact.EdgeOrganization)
	}
	if m.customer != nil {
		edges = append(edges, customercontact.EdgeCustomer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomerContactMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case customercontact.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case customercontact.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case customercontact.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomerContactMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomerContactMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomerContactMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbusiness_unit {
		edges = append(edges, customercontact.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, customercontact.EdgeOrganization)
	}
	if m.clearedcustomer {
		edges = append(edges, customercontact.EdgeCustomer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomerContactMutation) EdgeCleared(name string) bool {
	switch name {
	case customercontact.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case customercontact.EdgeOrganization:
		return m.clearedorganization
	case customercontact.EdgeCustomer:
		return m.clearedcustomer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomerContactMutation) ClearEdge(name string) error {
	switch name {
	case customercontact.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case customercontact.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case customercontact.EdgeCustomer:
		m.ClearCustomer()
		return nil
	}
	return fmt.Errorf("unknown CustomerContact unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomerContactMutation) ResetEdge(name string) error {
	switch name {
	case customercontact.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case customercontact.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case customercontact.EdgeCustomer:
		m.ResetCustomer()
		return nil
	}
	return fmt.Errorf("unknown CustomerContact edge %s", name)
}

// CustomerDetentionPolicyMutation represents an operation that mutates the CustomerDetentionPolicy nodes in the graph.
type CustomerDetentionPolicyMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	created_at                *time.Time
	updated_at                *time.Time
	version                   *int
	addversion                *int
	status                    *customerdetentionpolicy.Status
	application_scope         *customerdetentionpolicy.ApplicationScope
	charge_free_time          *int
	addcharge_free_time       *int
	payment_free_time         *int
	addpayment_free_time      *int
	late_arrival_policy       *bool
	grace_period              *int
	addgrace_period           *int
	units                     *int
	addunits                  *int
	amount                    *float64
	addamount                 *float64
	notes                     *string
	effective_date            **pgtype.Date
	expiration_date           **pgtype.Date
	clearedFields             map[string]struct{}
	business_unit             *uuid.UUID
	clearedbusiness_unit      bool
	organization              *uuid.UUID
	clearedorganization       bool
	customer                  *uuid.UUID
	clearedcustomer           bool
	commodity                 *uuid.UUID
	clearedcommodity          bool
	revenue_code              *uuid.UUID
	clearedrevenue_code       bool
	shipment_type             *uuid.UUID
	clearedshipment_type      bool
	accessorial_charge        *uuid.UUID
	clearedaccessorial_charge bool
	done                      bool
	oldValue                  func(context.Context) (*CustomerDetentionPolicy, error)
	predicates                []predicate.CustomerDetentionPolicy
}

var _ ent.Mutation = (*CustomerDetentionPolicyMutation)(nil)

// customerdetentionpolicyOption allows management of the mutation configuration using functional options.
type customerdetentionpolicyOption func(*CustomerDetentionPolicyMutation)

// newCustomerDetentionPolicyMutation creates new mutation for the CustomerDetentionPolicy entity.
func newCustomerDetentionPolicyMutation(c config, op Op, opts ...customerdetentionpolicyOption) *CustomerDetentionPolicyMutation {
	m := &CustomerDetentionPolicyMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomerDetentionPolicy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerDetentionPolicyID sets the ID field of the mutation.
func withCustomerDetentionPolicyID(id uuid.UUID) customerdetentionpolicyOption {
	return func(m *CustomerDetentionPolicyMutation) {
		var (
			err   error
			once  sync.Once
			value *CustomerDetentionPolicy
		)
		m.oldValue = func(ctx context.Context) (*CustomerDetentionPolicy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CustomerDetentionPolicy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomerDetentionPolicy sets the old CustomerDetentionPolicy of the mutation.
func withCustomerDetentionPolicy(node *CustomerDetentionPolicy) customerdetentionpolicyOption {
	return func(m *CustomerDetentionPolicyMutation) {
		m.oldValue = func(context.Context) (*CustomerDetentionPolicy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerDetentionPolicyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerDetentionPolicyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CustomerDetentionPolicy entities.
func (m *CustomerDetentionPolicyMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CustomerDetentionPolicyMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CustomerDetentionPolicyMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CustomerDetentionPolicy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *CustomerDetentionPolicyMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *CustomerDetentionPolicyMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the CustomerDetentionPolicy entity.
// If the CustomerDetentionPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerDetentionPolicyMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *CustomerDetentionPolicyMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *CustomerDetentionPolicyMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *CustomerDetentionPolicyMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the CustomerDetentionPolicy entity.
// If the CustomerDetentionPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerDetentionPolicyMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *CustomerDetentionPolicyMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CustomerDetentionPolicyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CustomerDetentionPolicyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CustomerDetentionPolicy entity.
// If the CustomerDetentionPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerDetentionPolicyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CustomerDetentionPolicyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CustomerDetentionPolicyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CustomerDetentionPolicyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CustomerDetentionPolicy entity.
// If the CustomerDetentionPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerDetentionPolicyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CustomerDetentionPolicyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *CustomerDetentionPolicyMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *CustomerDetentionPolicyMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the CustomerDetentionPolicy entity.
// If the CustomerDetentionPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerDetentionPolicyMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *CustomerDetentionPolicyMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *CustomerDetentionPolicyMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *CustomerDetentionPolicyMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetStatus sets the "status" field.
func (m *CustomerDetentionPolicyMutation) SetStatus(c customerdetentionpolicy.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *CustomerDetentionPolicyMutation) Status() (r customerdetentionpolicy.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CustomerDetentionPolicy entity.
// If the CustomerDetentionPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerDetentionPolicyMutation) OldStatus(ctx context.Context) (v customerdetentionpolicy.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CustomerDetentionPolicyMutation) ResetStatus() {
	m.status = nil
}

// SetCustomerID sets the "customer_id" field.
func (m *CustomerDetentionPolicyMutation) SetCustomerID(u uuid.UUID) {
	m.customer = &u
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *CustomerDetentionPolicyMutation) CustomerID() (r uuid.UUID, exists bool) {
	v := m.customer
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the CustomerDetentionPolicy entity.
// If the CustomerDetentionPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerDetentionPolicyMutation) OldCustomerID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *CustomerDetentionPolicyMutation) ResetCustomerID() {
	m.customer = nil
}

// SetCommodityID sets the "commodity_id" field.
func (m *CustomerDetentionPolicyMutation) SetCommodityID(u uuid.UUID) {
	m.commodity = &u
}

// CommodityID returns the value of the "commodity_id" field in the mutation.
func (m *CustomerDetentionPolicyMutation) CommodityID() (r uuid.UUID, exists bool) {
	v := m.commodity
	if v == nil {
		return
	}
	return *v, true
}

// OldCommodityID returns the old "commodity_id" field's value of the CustomerDetentionPolicy entity.
// If the CustomerDetentionPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerDetentionPolicyMutation) OldCommodityID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommodityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommodityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommodityID: %w", err)
	}
	return oldValue.CommodityID, nil
}

// ClearCommodityID clears the value of the "commodity_id" field.
func (m *CustomerDetentionPolicyMutation) ClearCommodityID() {
	m.commodity = nil
	m.clearedFields[customerdetentionpolicy.FieldCommodityID] = struct{}{}
}

// CommodityIDCleared returns if the "commodity_id" field was cleared in this mutation.
func (m *CustomerDetentionPolicyMutation) CommodityIDCleared() bool {
	_, ok := m.clearedFields[customerdetentionpolicy.FieldCommodityID]
	return ok
}

// ResetCommodityID resets all changes to the "commodity_id" field.
func (m *CustomerDetentionPolicyMutation) ResetCommodityID() {
	m.commodity = nil
	delete(m.clearedFields, customerdetentionpolicy.FieldCommodityID)
}

// SetRevenueCodeID sets the "revenue_code_id" field.
func (m *CustomerDetentionPolicyMutation) SetRevenueCodeID(u uuid.UUID) {
	m.revenue_code = &u
}

// RevenueCodeID returns the value of the "revenue_code_id" field in the mutation.
func (m *CustomerDetentionPolicyMutation) RevenueCodeID() (r uuid.UUID, exists bool) {
	v := m.revenue_code
	if v == nil {
		return
	}
	return *v, true
}

// OldRevenueCodeID returns the old "revenue_code_id" field's value of the CustomerDetentionPolicy entity.
// If the CustomerDetentionPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerDetentionPolicyMutation) OldRevenueCodeID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevenueCodeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevenueCodeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevenueCodeID: %w", err)
	}
	return oldValue.RevenueCodeID, nil
}

// ClearRevenueCodeID clears the value of the "revenue_code_id" field.
func (m *CustomerDetentionPolicyMutation) ClearRevenueCodeID() {
	m.revenue_code = nil
	m.clearedFields[customerdetentionpolicy.FieldRevenueCodeID] = struct{}{}
}

// RevenueCodeIDCleared returns if the "revenue_code_id" field was cleared in this mutation.
func (m *CustomerDetentionPolicyMutation) RevenueCodeIDCleared() bool {
	_, ok := m.clearedFields[customerdetentionpolicy.FieldRevenueCodeID]
	return ok
}

// ResetRevenueCodeID resets all changes to the "revenue_code_id" field.
func (m *CustomerDetentionPolicyMutation) ResetRevenueCodeID() {
	m.revenue_code = nil
	delete(m.clearedFields, customerdetentionpolicy.FieldRevenueCodeID)
}

// SetShipmentTypeID sets the "shipment_type_id" field.
func (m *CustomerDetentionPolicyMutation) SetShipmentTypeID(u uuid.UUID) {
	m.shipment_type = &u
}

// ShipmentTypeID returns the value of the "shipment_type_id" field in the mutation.
func (m *CustomerDetentionPolicyMutation) ShipmentTypeID() (r uuid.UUID, exists bool) {
	v := m.shipment_type
	if v == nil {
		return
	}
	return *v, true
}

// OldShipmentTypeID returns the old "shipment_type_id" field's value of the CustomerDetentionPolicy entity.
// If the CustomerDetentionPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerDetentionPolicyMutation) OldShipmentTypeID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShipmentTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShipmentTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipmentTypeID: %w", err)
	}
	return oldValue.ShipmentTypeID, nil
}

// ClearShipmentTypeID clears the value of the "shipment_type_id" field.
func (m *CustomerDetentionPolicyMutation) ClearShipmentTypeID() {
	m.shipment_type = nil
	m.clearedFields[customerdetentionpolicy.FieldShipmentTypeID] = struct{}{}
}

// ShipmentTypeIDCleared returns if the "shipment_type_id" field was cleared in this mutation.
func (m *CustomerDetentionPolicyMutation) ShipmentTypeIDCleared() bool {
	_, ok := m.clearedFields[customerdetentionpolicy.FieldShipmentTypeID]
	return ok
}

// ResetShipmentTypeID resets all changes to the "shipment_type_id" field.
func (m *CustomerDetentionPolicyMutation) ResetShipmentTypeID() {
	m.shipment_type = nil
	delete(m.clearedFields, customerdetentionpolicy.FieldShipmentTypeID)
}

// SetApplicationScope sets the "application_scope" field.
func (m *CustomerDetentionPolicyMutation) SetApplicationScope(cs customerdetentionpolicy.ApplicationScope) {
	m.application_scope = &cs
}

// ApplicationScope returns the value of the "application_scope" field in the mutation.
func (m *CustomerDetentionPolicyMutation) ApplicationScope() (r customerdetentionpolicy.ApplicationScope, exists bool) {
	v := m.application_scope
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicationScope returns the old "application_scope" field's value of the CustomerDetentionPolicy entity.
// If the CustomerDetentionPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerDetentionPolicyMutation) OldApplicationScope(ctx context.Context) (v customerdetentionpolicy.ApplicationScope, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicationScope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicationScope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicationScope: %w", err)
	}
	return oldValue.ApplicationScope, nil
}

// ResetApplicationScope resets all changes to the "application_scope" field.
func (m *CustomerDetentionPolicyMutation) ResetApplicationScope() {
	m.application_scope = nil
}

// SetChargeFreeTime sets the "charge_free_time" field.
func (m *CustomerDetentionPolicyMutation) SetChargeFreeTime(i int) {
	m.charge_free_time = &i
	m.addcharge_free_time = nil
}

// ChargeFreeTime returns the value of the "charge_free_time" field in the mutation.
func (m *CustomerDetentionPolicyMutation) ChargeFreeTime() (r int, exists bool) {
	v := m.charge_free_time
	if v == nil {
		return
	}
	return *v, true
}

// OldChargeFreeTime returns the old "charge_free_time" field's value of the CustomerDetentionPolicy entity.
// If the CustomerDetentionPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerDetentionPolicyMutation) OldChargeFreeTime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChargeFreeTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChargeFreeTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChargeFreeTime: %w", err)
	}
	return oldValue.ChargeFreeTime, nil
}

// AddChargeFreeTime adds i to the "charge_free_time" field.
func (m *CustomerDetentionPolicyMutation) AddChargeFreeTime(i int) {
	if m.addcharge_free_time != nil {
		*m.addcharge_free_time += i
	} else {
		m.addcharge_free_time = &i
	}
}

// AddedChargeFreeTime returns the value that was added to the "charge_free_time" field in this mutation.
func (m *CustomerDetentionPolicyMutation) AddedChargeFreeTime() (r int, exists bool) {
	v := m.addcharge_free_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearChargeFreeTime clears the value of the "charge_free_time" field.
func (m *CustomerDetentionPolicyMutation) ClearChargeFreeTime() {
	m.charge_free_time = nil
	m.addcharge_free_time = nil
	m.clearedFields[customerdetentionpolicy.FieldChargeFreeTime] = struct{}{}
}

// ChargeFreeTimeCleared returns if the "charge_free_time" field was cleared in this mutation.
func (m *CustomerDetentionPolicyMutation) ChargeFreeTimeCleared() bool {
	_, ok := m.clearedFields[customerdetentionpolicy.FieldChargeFreeTime]
	return ok
}

// ResetChargeFreeTime resets all changes to the "charge_free_time" field.
func (m *CustomerDetentionPolicyMutation) ResetChargeFreeTime() {
	m.charge_free_time = nil
	m.addcharge_free_time = nil
	delete(m.clearedFields, customerdetentionpolicy.FieldChargeFreeTime)
}

// SetPaymentFreeTime sets the "payment_free_time" field.
func (m *CustomerDetentionPolicyMutation) SetPaymentFreeTime(i int) {
	m.payment_free_time = &i
	m.addpayment_free_time = nil
}

// PaymentFreeTime returns the value of the "payment_free_time" field in the mutation.
func (m *CustomerDetentionPolicyMutation) PaymentFreeTime() (r int, exists bool) {
	v := m.payment_free_time
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentFreeTime returns the old "payment_free_time" field's value of the CustomerDetentionPolicy entity.
// If the CustomerDetentionPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerDetentionPolicyMutation) OldPaymentFreeTime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentFreeTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentFreeTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentFreeTime: %w", err)
	}
	return oldValue.PaymentFreeTime, nil
}

// AddPaymentFreeTime adds i to the "payment_free_time" field.
func (m *CustomerDetentionPolicyMutation) AddPaymentFreeTime(i int) {
	if m.addpayment_free_time != nil {
		*m.addpayment_free_time += i
	} else {
		m.addpayment_free_time = &i
	}
}

// AddedPaymentFreeTime returns the value that was added to the "payment_free_time" field in this mutation.
func (m *CustomerDetentionPolicyMutation) AddedPaymentFreeTime() (r int, exists bool) {
	v := m.addpayment_free_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearPaymentFreeTime clears the value of the "payment_free_time" field.
func (m *CustomerDetentionPolicyMutation) ClearPaymentFreeTime() {
	m.payment_free_time = nil
	m.addpayment_free_time = nil
	m.clearedFields[customerdetentionpolicy.FieldPaymentFreeTime] = struct{}{}
}

// PaymentFreeTimeCleared returns if the "payment_free_time" field was cleared in this mutation.
func (m *CustomerDetentionPolicyMutation) PaymentFreeTimeCleared() bool {
	_, ok := m.clearedFields[customerdetentionpolicy.FieldPaymentFreeTime]
	return ok
}

// ResetPaymentFreeTime resets all changes to the "payment_free_time" field.
func (m *CustomerDetentionPolicyMutation) ResetPaymentFreeTime() {
	m.payment_free_time = nil
	m.addpayment_free_time = nil
	delete(m.clearedFields, customerdetentionpolicy.FieldPaymentFreeTime)
}

// SetLateArrivalPolicy sets the "late_arrival_policy" field.
func (m *CustomerDetentionPolicyMutation) SetLateArrivalPolicy(b bool) {
	m.late_arrival_policy = &b
}

// LateArrivalPolicy returns the value of the "late_arrival_policy" field in the mutation.
func (m *CustomerDetentionPolicyMutation) LateArrivalPolicy() (r bool, exists bool) {
	v := m.late_arrival_policy
	if v == nil {
		return
	}
	return *v, true
}

// OldLateArrivalPolicy returns the old "late_arrival_policy" field's value of the CustomerDetentionPolicy entity.
// If the CustomerDetentionPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerDetentionPolicyMutation) OldLateArrivalPolicy(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLateArrivalPolicy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLateArrivalPolicy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLateArrivalPolicy: %w", err)
	}
	return oldValue.LateArrivalPolicy, nil
}

// ClearLateArrivalPolicy clears the value of the "late_arrival_policy" field.
func (m *CustomerDetentionPolicyMutation) ClearLateArrivalPolicy() {
	m.late_arrival_policy = nil
	m.clearedFields[customerdetentionpolicy.FieldLateArrivalPolicy] = struct{}{}
}

// LateArrivalPolicyCleared returns if the "late_arrival_policy" field was cleared in this mutation.
func (m *CustomerDetentionPolicyMutation) LateArrivalPolicyCleared() bool {
	_, ok := m.clearedFields[customerdetentionpolicy.FieldLateArrivalPolicy]
	return ok
}

// ResetLateArrivalPolicy resets all changes to the "late_arrival_policy" field.
func (m *CustomerDetentionPolicyMutation) ResetLateArrivalPolicy() {
	m.late_arrival_policy = nil
	delete(m.clearedFields, customerdetentionpolicy.FieldLateArrivalPolicy)
}

// SetGracePeriod sets the "grace_period" field.
func (m *CustomerDetentionPolicyMutation) SetGracePeriod(i int) {
	m.grace_period = &i
	m.addgrace_period = nil
}

// GracePeriod returns the value of the "grace_period" field in the mutation.
func (m *CustomerDetentionPolicyMutation) GracePeriod() (r int, exists bool) {
	v := m.grace_period
	if v == nil {
		return
	}
	return *v, true
}

// OldGracePeriod returns the old "grace_period" field's value of the CustomerDetentionPolicy entity.
// If the CustomerDetentionPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerDetentionPolicyMutation) OldGracePeriod(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGracePeriod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGracePeriod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGracePeriod: %w", err)
	}
	return oldValue.GracePeriod, nil
}

// AddGracePeriod adds i to the "grace_period" field.
func (m *CustomerDetentionPolicyMutation) AddGracePeriod(i int) {
	if m.addgrace_period != nil {
		*m.addgrace_period += i
	} else {
		m.addgrace_period = &i
	}
}

// AddedGracePeriod returns the value that was added to the "grace_period" field in this mutation.
func (m *CustomerDetentionPolicyMutation) AddedGracePeriod() (r int, exists bool) {
	v := m.addgrace_period
	if v == nil {
		return
	}
	return *v, true
}

// ClearGracePeriod clears the value of the "grace_period" field.
func (m *CustomerDetentionPolicyMutation) ClearGracePeriod() {
	m.grace_period = nil
	m.addgrace_period = nil
	m.clearedFields[customerdetentionpolicy.FieldGracePeriod] = struct{}{}
}

// GracePeriodCleared returns if the "grace_period" field was cleared in this mutation.
func (m *CustomerDetentionPolicyMutation) GracePeriodCleared() bool {
	_, ok := m.clearedFields[customerdetentionpolicy.FieldGracePeriod]
	return ok
}

// ResetGracePeriod resets all changes to the "grace_period" field.
func (m *CustomerDetentionPolicyMutation) ResetGracePeriod() {
	m.grace_period = nil
	m.addgrace_period = nil
	delete(m.clearedFields, customerdetentionpolicy.FieldGracePeriod)
}

// SetAccessorialChargeID sets the "accessorial_charge_id" field.
func (m *CustomerDetentionPolicyMutation) SetAccessorialChargeID(u uuid.UUID) {
	m.accessorial_charge = &u
}

// AccessorialChargeID returns the value of the "accessorial_charge_id" field in the mutation.
func (m *CustomerDetentionPolicyMutation) AccessorialChargeID() (r uuid.UUID, exists bool) {
	v := m.accessorial_charge
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessorialChargeID returns the old "accessorial_charge_id" field's value of the CustomerDetentionPolicy entity.
// If the CustomerDetentionPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerDetentionPolicyMutation) OldAccessorialChargeID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessorialChargeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessorialChargeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessorialChargeID: %w", err)
	}
	return oldValue.AccessorialChargeID, nil
}

// ClearAccessorialChargeID clears the value of the "accessorial_charge_id" field.
func (m *CustomerDetentionPolicyMutation) ClearAccessorialChargeID() {
	m.accessorial_charge = nil
	m.clearedFields[customerdetentionpolicy.FieldAccessorialChargeID] = struct{}{}
}

// AccessorialChargeIDCleared returns if the "accessorial_charge_id" field was cleared in this mutation.
func (m *CustomerDetentionPolicyMutation) AccessorialChargeIDCleared() bool {
	_, ok := m.clearedFields[customerdetentionpolicy.FieldAccessorialChargeID]
	return ok
}

// ResetAccessorialChargeID resets all changes to the "accessorial_charge_id" field.
func (m *CustomerDetentionPolicyMutation) ResetAccessorialChargeID() {
	m.accessorial_charge = nil
	delete(m.clearedFields, customerdetentionpolicy.FieldAccessorialChargeID)
}

// SetUnits sets the "units" field.
func (m *CustomerDetentionPolicyMutation) SetUnits(i int) {
	m.units = &i
	m.addunits = nil
}

// Units returns the value of the "units" field in the mutation.
func (m *CustomerDetentionPolicyMutation) Units() (r int, exists bool) {
	v := m.units
	if v == nil {
		return
	}
	return *v, true
}

// OldUnits returns the old "units" field's value of the CustomerDetentionPolicy entity.
// If the CustomerDetentionPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerDetentionPolicyMutation) OldUnits(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnits: %w", err)
	}
	return oldValue.Units, nil
}

// AddUnits adds i to the "units" field.
func (m *CustomerDetentionPolicyMutation) AddUnits(i int) {
	if m.addunits != nil {
		*m.addunits += i
	} else {
		m.addunits = &i
	}
}

// AddedUnits returns the value that was added to the "units" field in this mutation.
func (m *CustomerDetentionPolicyMutation) AddedUnits() (r int, exists bool) {
	v := m.addunits
	if v == nil {
		return
	}
	return *v, true
}

// ClearUnits clears the value of the "units" field.
func (m *CustomerDetentionPolicyMutation) ClearUnits() {
	m.units = nil
	m.addunits = nil
	m.clearedFields[customerdetentionpolicy.FieldUnits] = struct{}{}
}

// UnitsCleared returns if the "units" field was cleared in this mutation.
func (m *CustomerDetentionPolicyMutation) UnitsCleared() bool {
	_, ok := m.clearedFields[customerdetentionpolicy.FieldUnits]
	return ok
}

// ResetUnits resets all changes to the "units" field.
func (m *CustomerDetentionPolicyMutation) ResetUnits() {
	m.units = nil
	m.addunits = nil
	delete(m.clearedFields, customerdetentionpolicy.FieldUnits)
}

// SetAmount sets the "amount" field.
func (m *CustomerDetentionPolicyMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *CustomerDetentionPolicyMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the CustomerDetentionPolicy entity.
// If the CustomerDetentionPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerDetentionPolicyMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *CustomerDetentionPolicyMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *CustomerDetentionPolicyMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *CustomerDetentionPolicyMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetNotes sets the "notes" field.
func (m *CustomerDetentionPolicyMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *CustomerDetentionPolicyMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the CustomerDetentionPolicy entity.
// If the CustomerDetentionPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerDetentionPolicyMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *CustomerDetentionPolicyMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[customerdetentionpolicy.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *CustomerDetentionPolicyMutation) NotesCleared() bool {
	_, ok := m.clearedFields[customerdetentionpolicy.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *CustomerDetentionPolicyMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, customerdetentionpolicy.FieldNotes)
}

// SetEffectiveDate sets the "effective_date" field.
func (m *CustomerDetentionPolicyMutation) SetEffectiveDate(pg *pgtype.Date) {
	m.effective_date = &pg
}

// EffectiveDate returns the value of the "effective_date" field in the mutation.
func (m *CustomerDetentionPolicyMutation) EffectiveDate() (r *pgtype.Date, exists bool) {
	v := m.effective_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectiveDate returns the old "effective_date" field's value of the CustomerDetentionPolicy entity.
// If the CustomerDetentionPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerDetentionPolicyMutation) OldEffectiveDate(ctx context.Context) (v *pgtype.Date, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectiveDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectiveDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectiveDate: %w", err)
	}
	return oldValue.EffectiveDate, nil
}

// ClearEffectiveDate clears the value of the "effective_date" field.
func (m *CustomerDetentionPolicyMutation) ClearEffectiveDate() {
	m.effective_date = nil
	m.clearedFields[customerdetentionpolicy.FieldEffectiveDate] = struct{}{}
}

// EffectiveDateCleared returns if the "effective_date" field was cleared in this mutation.
func (m *CustomerDetentionPolicyMutation) EffectiveDateCleared() bool {
	_, ok := m.clearedFields[customerdetentionpolicy.FieldEffectiveDate]
	return ok
}

// ResetEffectiveDate resets all changes to the "effective_date" field.
func (m *CustomerDetentionPolicyMutation) ResetEffectiveDate() {
	m.effective_date = nil
	delete(m.clearedFields, customerdetentionpolicy.FieldEffectiveDate)
}

// SetExpirationDate sets the "expiration_date" field.
func (m *CustomerDetentionPolicyMutation) SetExpirationDate(pg *pgtype.Date) {
	m.expiration_date = &pg
}

// ExpirationDate returns the value of the "expiration_date" field in the mutation.
func (m *CustomerDetentionPolicyMutation) ExpirationDate() (r *pgtype.Date, exists bool) {
	v := m.expiration_date
	if v == nil {
		return
	}
	return *v, true
}

// OldExpirationDate returns the old "expiration_date" field's value of the CustomerDetentionPolicy entity.
// If the CustomerDetentionPolicy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerDetentionPolicyMutation) OldExpirationDate(ctx context.Context) (v *pgtype.Date, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpirationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpirationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpirationDate: %w", err)
	}
	return oldValue.ExpirationDate, nil
}

// ClearExpirationDate clears the value of the "expiration_date" field.
func (m *CustomerDetentionPolicyMutation) ClearExpirationDate() {
	m.expiration_date = nil
	m.clearedFields[customerdetentionpolicy.FieldExpirationDate] = struct{}{}
}

// ExpirationDateCleared returns if the "expiration_date" field was cleared in this mutation.
func (m *CustomerDetentionPolicyMutation) ExpirationDateCleared() bool {
	_, ok := m.clearedFields[customerdetentionpolicy.FieldExpirationDate]
	return ok
}

// ResetExpirationDate resets all changes to the "expiration_date" field.
func (m *CustomerDetentionPolicyMutation) ResetExpirationDate() {
	m.expiration_date = nil
	delete(m.clearedFields, customerdetentionpolicy.FieldExpirationDate)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *CustomerDetentionPolicyMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[customerdetentionpolicy.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *CustomerDetentionPolicyMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *CustomerDetentionPolicyMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *CustomerDetentionPolicyMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *CustomerDetentionPolicyMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[customerdetentionpolicy.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *CustomerDetentionPolicyMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *CustomerDetentionPolicyMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *CustomerDetentionPolicyMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *CustomerDetentionPolicyMutation) ClearCustomer() {
	m.clearedcustomer = true
	m.clearedFields[customerdetentionpolicy.FieldCustomerID] = struct{}{}
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *CustomerDetentionPolicyMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *CustomerDetentionPolicyMutation) CustomerIDs() (ids []uuid.UUID) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *CustomerDetentionPolicyMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// ClearCommodity clears the "commodity" edge to the Commodity entity.
func (m *CustomerDetentionPolicyMutation) ClearCommodity() {
	m.clearedcommodity = true
	m.clearedFields[customerdetentionpolicy.FieldCommodityID] = struct{}{}
}

// CommodityCleared reports if the "commodity" edge to the Commodity entity was cleared.
func (m *CustomerDetentionPolicyMutation) CommodityCleared() bool {
	return m.CommodityIDCleared() || m.clearedcommodity
}

// CommodityIDs returns the "commodity" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CommodityID instead. It exists only for internal usage by the builders.
func (m *CustomerDetentionPolicyMutation) CommodityIDs() (ids []uuid.UUID) {
	if id := m.commodity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCommodity resets all changes to the "commodity" edge.
func (m *CustomerDetentionPolicyMutation) ResetCommodity() {
	m.commodity = nil
	m.clearedcommodity = false
}

// ClearRevenueCode clears the "revenue_code" edge to the RevenueCode entity.
func (m *CustomerDetentionPolicyMutation) ClearRevenueCode() {
	m.clearedrevenue_code = true
	m.clearedFields[customerdetentionpolicy.FieldRevenueCodeID] = struct{}{}
}

// RevenueCodeCleared reports if the "revenue_code" edge to the RevenueCode entity was cleared.
func (m *CustomerDetentionPolicyMutation) RevenueCodeCleared() bool {
	return m.RevenueCodeIDCleared() || m.clearedrevenue_code
}

// RevenueCodeIDs returns the "revenue_code" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RevenueCodeID instead. It exists only for internal usage by the builders.
func (m *CustomerDetentionPolicyMutation) RevenueCodeIDs() (ids []uuid.UUID) {
	if id := m.revenue_code; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRevenueCode resets all changes to the "revenue_code" edge.
func (m *CustomerDetentionPolicyMutation) ResetRevenueCode() {
	m.revenue_code = nil
	m.clearedrevenue_code = false
}

// ClearShipmentType clears the "shipment_type" edge to the ShipmentType entity.
func (m *CustomerDetentionPolicyMutation) ClearShipmentType() {
	m.clearedshipment_type = true
	m.clearedFields[customerdetentionpolicy.FieldShipmentTypeID] = struct{}{}
}

// ShipmentTypeCleared reports if the "shipment_type" edge to the ShipmentType entity was cleared.
func (m *CustomerDetentionPolicyMutation) ShipmentTypeCleared() bool {
	return m.ShipmentTypeIDCleared() || m.clearedshipment_type
}

// ShipmentTypeIDs returns the "shipment_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentTypeID instead. It exists only for internal usage by the builders.
func (m *CustomerDetentionPolicyMutation) ShipmentTypeIDs() (ids []uuid.UUID) {
	if id := m.shipment_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipmentType resets all changes to the "shipment_type" edge.
func (m *CustomerDetentionPolicyMutation) ResetShipmentType() {
	m.shipment_type = nil
	m.clearedshipment_type = false
}

// ClearAccessorialCharge clears the "accessorial_charge" edge to the AccessorialCharge entity.
func (m *CustomerDetentionPolicyMutation) ClearAccessorialCharge() {
	m.clearedaccessorial_charge = true
	m.clearedFields[customerdetentionpolicy.FieldAccessorialChargeID] = struct{}{}
}

// AccessorialChargeCleared reports if the "accessorial_charge" edge to the AccessorialCharge entity was cleared.
func (m *CustomerDetentionPolicyMutation) AccessorialChargeCleared() bool {
	return m.AccessorialChargeIDCleared() || m.clearedaccessorial_charge
}

// AccessorialChargeIDs returns the "accessorial_charge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccessorialChargeID instead. It exists only for internal usage by the builders.
func (m *CustomerDetentionPolicyMutation) AccessorialChargeIDs() (ids []uuid.UUID) {
	if id := m.accessorial_charge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccessorialCharge resets all changes to the "accessorial_charge" edge.
func (m *CustomerDetentionPolicyMutation) ResetAccessorialCharge() {
	m.accessorial_charge = nil
	m.clearedaccessorial_charge = false
}

// Where appends a list predicates to the CustomerDetentionPolicyMutation builder.
func (m *CustomerDetentionPolicyMutation) Where(ps ...predicate.CustomerDetentionPolicy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CustomerDetentionPolicyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CustomerDetentionPolicyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CustomerDetentionPolicy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CustomerDetentionPolicyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CustomerDetentionPolicyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CustomerDetentionPolicy).
func (m *CustomerDetentionPolicyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomerDetentionPolicyMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.business_unit != nil {
		fields = append(fields, customerdetentionpolicy.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, customerdetentionpolicy.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, customerdetentionpolicy.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, customerdetentionpolicy.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, customerdetentionpolicy.FieldVersion)
	}
	if m.status != nil {
		fields = append(fields, customerdetentionpolicy.FieldStatus)
	}
	if m.customer != nil {
		fields = append(fields, customerdetentionpolicy.FieldCustomerID)
	}
	if m.commodity != nil {
		fields = append(fields, customerdetentionpolicy.FieldCommodityID)
	}
	if m.revenue_code != nil {
		fields = append(fields, customerdetentionpolicy.FieldRevenueCodeID)
	}
	if m.shipment_type != nil {
		fields = append(fields, customerdetentionpolicy.FieldShipmentTypeID)
	}
	if m.application_scope != nil {
		fields = append(fields, customerdetentionpolicy.FieldApplicationScope)
	}
	if m.charge_free_time != nil {
		fields = append(fields, customerdetentionpolicy.FieldChargeFreeTime)
	}
	if m.payment_free_time != nil {
		fields = append(fields, customerdetentionpolicy.FieldPaymentFreeTime)
	}
	if m.late_arrival_policy != nil {
		fields = append(fields, customerdetentionpolicy.FieldLateArrivalPolicy)
	}
	if m.grace_period != nil {
		fields = append(fields, customerdetentionpolicy.FieldGracePeriod)
	}
	if m.accessorial_charge != nil {
		fields = append(fields, customerdetentionpolicy.FieldAccessorialChargeID)
	}
	if m.units != nil {
		fields = append(fields, customerdetentionpolicy.FieldUnits)
	}
	if m.amount != nil {
		fields = append(fields, customerdetentionpolicy.FieldAmount)
	}
	if m.notes != nil {
		fields = append(fields, customerdetentionpolicy.FieldNotes)
	}
	if m.effective_date != nil {
		fields = append(fields, customerdetentionpolicy.FieldEffectiveDate)
	}
	if m.expiration_date != nil {
		fields = append(fields, customerdetentionpolicy.FieldExpirationDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomerDetentionPolicyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customerdetentionpolicy.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case customerdetentionpolicy.FieldOrganizationID:
		return m.OrganizationID()
	case customerdetentionpolicy.FieldCreatedAt:
		return m.CreatedAt()
	case customerdetentionpolicy.FieldUpdatedAt:
		return m.UpdatedAt()
	case customerdetentionpolicy.FieldVersion:
		return m.Version()
	case customerdetentionpolicy.FieldStatus:
		return m.Status()
	case customerdetentionpolicy.FieldCustomerID:
		return m.CustomerID()
	case customerdetentionpolicy.FieldCommodityID:
		return m.CommodityID()
	case customerdetentionpolicy.FieldRevenueCodeID:
		return m.RevenueCodeID()
	case customerdetentionpolicy.FieldShipmentTypeID:
		return m.ShipmentTypeID()
	case customerdetentionpolicy.FieldApplicationScope:
		return m.ApplicationScope()
	case customerdetentionpolicy.FieldChargeFreeTime:
		return m.ChargeFreeTime()
	case customerdetentionpolicy.FieldPaymentFreeTime:
		return m.PaymentFreeTime()
	case customerdetentionpolicy.FieldLateArrivalPolicy:
		return m.LateArrivalPolicy()
	case customerdetentionpolicy.FieldGracePeriod:
		return m.GracePeriod()
	case customerdetentionpolicy.FieldAccessorialChargeID:
		return m.AccessorialChargeID()
	case customerdetentionpolicy.FieldUnits:
		return m.Units()
	case customerdetentionpolicy.FieldAmount:
		return m.Amount()
	case customerdetentionpolicy.FieldNotes:
		return m.Notes()
	case customerdetentionpolicy.FieldEffectiveDate:
		return m.EffectiveDate()
	case customerdetentionpolicy.FieldExpirationDate:
		return m.ExpirationDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomerDetentionPolicyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customerdetentionpolicy.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case customerdetentionpolicy.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case customerdetentionpolicy.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case customerdetentionpolicy.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case customerdetentionpolicy.FieldVersion:
		return m.OldVersion(ctx)
	case customerdetentionpolicy.FieldStatus:
		return m.OldStatus(ctx)
	case customerdetentionpolicy.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case customerdetentionpolicy.FieldCommodityID:
		return m.OldCommodityID(ctx)
	case customerdetentionpolicy.FieldRevenueCodeID:
		return m.OldRevenueCodeID(ctx)
	case customerdetentionpolicy.FieldShipmentTypeID:
		return m.OldShipmentTypeID(ctx)
	case customerdetentionpolicy.FieldApplicationScope:
		return m.OldApplicationScope(ctx)
	case customerdetentionpolicy.FieldChargeFreeTime:
		return m.OldChargeFreeTime(ctx)
	case customerdetentionpolicy.FieldPaymentFreeTime:
		return m.OldPaymentFreeTime(ctx)
	case customerdetentionpolicy.FieldLateArrivalPolicy:
		return m.OldLateArrivalPolicy(ctx)
	case customerdetentionpolicy.FieldGracePeriod:
		return m.OldGracePeriod(ctx)
	case customerdetentionpolicy.FieldAccessorialChargeID:
		return m.OldAccessorialChargeID(ctx)
	case customerdetentionpolicy.FieldUnits:
		return m.OldUnits(ctx)
	case customerdetentionpolicy.FieldAmount:
		return m.OldAmount(ctx)
	case customerdetentionpolicy.FieldNotes:
		return m.OldNotes(ctx)
	case customerdetentionpolicy.FieldEffectiveDate:
		return m.OldEffectiveDate(ctx)
	case customerdetentionpolicy.FieldExpirationDate:
		return m.OldExpirationDate(ctx)
	}
	return nil, fmt.Errorf("unknown CustomerDetentionPolicy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerDetentionPolicyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customerdetentionpolicy.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case customerdetentionpolicy.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case customerdetentionpolicy.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case customerdetentionpolicy.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case customerdetentionpolicy.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case customerdetentionpolicy.FieldStatus:
		v, ok := value.(customerdetentionpolicy.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case customerdetentionpolicy.FieldCustomerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case customerdetentionpolicy.FieldCommodityID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommodityID(v)
		return nil
	case customerdetentionpolicy.FieldRevenueCodeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevenueCodeID(v)
		return nil
	case customerdetentionpolicy.FieldShipmentTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipmentTypeID(v)
		return nil
	case customerdetentionpolicy.FieldApplicationScope:
		v, ok := value.(customerdetentionpolicy.ApplicationScope)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicationScope(v)
		return nil
	case customerdetentionpolicy.FieldChargeFreeTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChargeFreeTime(v)
		return nil
	case customerdetentionpolicy.FieldPaymentFreeTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentFreeTime(v)
		return nil
	case customerdetentionpolicy.FieldLateArrivalPolicy:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLateArrivalPolicy(v)
		return nil
	case customerdetentionpolicy.FieldGracePeriod:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGracePeriod(v)
		return nil
	case customerdetentionpolicy.FieldAccessorialChargeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessorialChargeID(v)
		return nil
	case customerdetentionpolicy.FieldUnits:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnits(v)
		return nil
	case customerdetentionpolicy.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case customerdetentionpolicy.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case customerdetentionpolicy.FieldEffectiveDate:
		v, ok := value.(*pgtype.Date)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectiveDate(v)
		return nil
	case customerdetentionpolicy.FieldExpirationDate:
		v, ok := value.(*pgtype.Date)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpirationDate(v)
		return nil
	}
	return fmt.Errorf("unknown CustomerDetentionPolicy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomerDetentionPolicyMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, customerdetentionpolicy.FieldVersion)
	}
	if m.addcharge_free_time != nil {
		fields = append(fields, customerdetentionpolicy.FieldChargeFreeTime)
	}
	if m.addpayment_free_time != nil {
		fields = append(fields, customerdetentionpolicy.FieldPaymentFreeTime)
	}
	if m.addgrace_period != nil {
		fields = append(fields, customerdetentionpolicy.FieldGracePeriod)
	}
	if m.addunits != nil {
		fields = append(fields, customerdetentionpolicy.FieldUnits)
	}
	if m.addamount != nil {
		fields = append(fields, customerdetentionpolicy.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomerDetentionPolicyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case customerdetentionpolicy.FieldVersion:
		return m.AddedVersion()
	case customerdetentionpolicy.FieldChargeFreeTime:
		return m.AddedChargeFreeTime()
	case customerdetentionpolicy.FieldPaymentFreeTime:
		return m.AddedPaymentFreeTime()
	case customerdetentionpolicy.FieldGracePeriod:
		return m.AddedGracePeriod()
	case customerdetentionpolicy.FieldUnits:
		return m.AddedUnits()
	case customerdetentionpolicy.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerDetentionPolicyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case customerdetentionpolicy.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case customerdetentionpolicy.FieldChargeFreeTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChargeFreeTime(v)
		return nil
	case customerdetentionpolicy.FieldPaymentFreeTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPaymentFreeTime(v)
		return nil
	case customerdetentionpolicy.FieldGracePeriod:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGracePeriod(v)
		return nil
	case customerdetentionpolicy.FieldUnits:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnits(v)
		return nil
	case customerdetentionpolicy.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown CustomerDetentionPolicy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomerDetentionPolicyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(customerdetentionpolicy.FieldCommodityID) {
		fields = append(fields, customerdetentionpolicy.FieldCommodityID)
	}
	if m.FieldCleared(customerdetentionpolicy.FieldRevenueCodeID) {
		fields = append(fields, customerdetentionpolicy.FieldRevenueCodeID)
	}
	if m.FieldCleared(customerdetentionpolicy.FieldShipmentTypeID) {
		fields = append(fields, customerdetentionpolicy.FieldShipmentTypeID)
	}
	if m.FieldCleared(customerdetentionpolicy.FieldChargeFreeTime) {
		fields = append(fields, customerdetentionpolicy.FieldChargeFreeTime)
	}
	if m.FieldCleared(customerdetentionpolicy.FieldPaymentFreeTime) {
		fields = append(fields, customerdetentionpolicy.FieldPaymentFreeTime)
	}
	if m.FieldCleared(customerdetentionpolicy.FieldLateArrivalPolicy) {
		fields = append(fields, customerdetentionpolicy.FieldLateArrivalPolicy)
	}
	if m.FieldCleared(customerdetentionpolicy.FieldGracePeriod) {
		fields = append(fields, customerdetentionpolicy.FieldGracePeriod)
	}
	if m.FieldCleared(customerdetentionpolicy.FieldAccessorialChargeID) {
		fields = append(fields, customerdetentionpolicy.FieldAccessorialChargeID)
	}
	if m.FieldCleared(customerdetentionpolicy.FieldUnits) {
		fields = append(fields, customerdetentionpolicy.FieldUnits)
	}
	if m.FieldCleared(customerdetentionpolicy.FieldNotes) {
		fields = append(fields, customerdetentionpolicy.FieldNotes)
	}
	if m.FieldCleared(customerdetentionpolicy.FieldEffectiveDate) {
		fields = append(fields, customerdetentionpolicy.FieldEffectiveDate)
	}
	if m.FieldCleared(customerdetentionpolicy.FieldExpirationDate) {
		fields = append(fields, customerdetentionpolicy.FieldExpirationDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomerDetentionPolicyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerDetentionPolicyMutation) ClearField(name string) error {
	switch name {
	case customerdetentionpolicy.FieldCommodityID:
		m.ClearCommodityID()
		return nil
	case customerdetentionpolicy.FieldRevenueCodeID:
		m.ClearRevenueCodeID()
		return nil
	case customerdetentionpolicy.FieldShipmentTypeID:
		m.ClearShipmentTypeID()
		return nil
	case customerdetentionpolicy.FieldChargeFreeTime:
		m.ClearChargeFreeTime()
		return nil
	case customerdetentionpolicy.FieldPaymentFreeTime:
		m.ClearPaymentFreeTime()
		return nil
	case customerdetentionpolicy.FieldLateArrivalPolicy:
		m.ClearLateArrivalPolicy()
		return nil
	case customerdetentionpolicy.FieldGracePeriod:
		m.ClearGracePeriod()
		return nil
	case customerdetentionpolicy.FieldAccessorialChargeID:
		m.ClearAccessorialChargeID()
		return nil
	case customerdetentionpolicy.FieldUnits:
		m.ClearUnits()
		return nil
	case customerdetentionpolicy.FieldNotes:
		m.ClearNotes()
		return nil
	case customerdetentionpolicy.FieldEffectiveDate:
		m.ClearEffectiveDate()
		return nil
	case customerdetentionpolicy.FieldExpirationDate:
		m.ClearExpirationDate()
		return nil
	}
	return fmt.Errorf("unknown CustomerDetentionPolicy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomerDetentionPolicyMutation) ResetField(name string) error {
	switch name {
	case customerdetentionpolicy.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case customerdetentionpolicy.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case customerdetentionpolicy.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case customerdetentionpolicy.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case customerdetentionpolicy.FieldVersion:
		m.ResetVersion()
		return nil
	case customerdetentionpolicy.FieldStatus:
		m.ResetStatus()
		return nil
	case customerdetentionpolicy.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case customerdetentionpolicy.FieldCommodityID:
		m.ResetCommodityID()
		return nil
	case customerdetentionpolicy.FieldRevenueCodeID:
		m.ResetRevenueCodeID()
		return nil
	case customerdetentionpolicy.FieldShipmentTypeID:
		m.ResetShipmentTypeID()
		return nil
	case customerdetentionpolicy.FieldApplicationScope:
		m.ResetApplicationScope()
		return nil
	case customerdetentionpolicy.FieldChargeFreeTime:
		m.ResetChargeFreeTime()
		return nil
	case customerdetentionpolicy.FieldPaymentFreeTime:
		m.ResetPaymentFreeTime()
		return nil
	case customerdetentionpolicy.FieldLateArrivalPolicy:
		m.ResetLateArrivalPolicy()
		return nil
	case customerdetentionpolicy.FieldGracePeriod:
		m.ResetGracePeriod()
		return nil
	case customerdetentionpolicy.FieldAccessorialChargeID:
		m.ResetAccessorialChargeID()
		return nil
	case customerdetentionpolicy.FieldUnits:
		m.ResetUnits()
		return nil
	case customerdetentionpolicy.FieldAmount:
		m.ResetAmount()
		return nil
	case customerdetentionpolicy.FieldNotes:
		m.ResetNotes()
		return nil
	case customerdetentionpolicy.FieldEffectiveDate:
		m.ResetEffectiveDate()
		return nil
	case customerdetentionpolicy.FieldExpirationDate:
		m.ResetExpirationDate()
		return nil
	}
	return fmt.Errorf("unknown CustomerDetentionPolicy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomerDetentionPolicyMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.business_unit != nil {
		edges = append(edges, customerdetentionpolicy.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, customerdetentionpolicy.EdgeOrganization)
	}
	if m.customer != nil {
		edges = append(edges, customerdetentionpolicy.EdgeCustomer)
	}
	if m.commodity != nil {
		edges = append(edges, customerdetentionpolicy.EdgeCommodity)
	}
	if m.revenue_code != nil {
		edges = append(edges, customerdetentionpolicy.EdgeRevenueCode)
	}
	if m.shipment_type != nil {
		edges = append(edges, customerdetentionpolicy.EdgeShipmentType)
	}
	if m.accessorial_charge != nil {
		edges = append(edges, customerdetentionpolicy.EdgeAccessorialCharge)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomerDetentionPolicyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case customerdetentionpolicy.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case customerdetentionpolicy.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case customerdetentionpolicy.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	case customerdetentionpolicy.EdgeCommodity:
		if id := m.commodity; id != nil {
			return []ent.Value{*id}
		}
	case customerdetentionpolicy.EdgeRevenueCode:
		if id := m.revenue_code; id != nil {
			return []ent.Value{*id}
		}
	case customerdetentionpolicy.EdgeShipmentType:
		if id := m.shipment_type; id != nil {
			return []ent.Value{*id}
		}
	case customerdetentionpolicy.EdgeAccessorialCharge:
		if id := m.accessorial_charge; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomerDetentionPolicyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomerDetentionPolicyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomerDetentionPolicyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedbusiness_unit {
		edges = append(edges, customerdetentionpolicy.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, customerdetentionpolicy.EdgeOrganization)
	}
	if m.clearedcustomer {
		edges = append(edges, customerdetentionpolicy.EdgeCustomer)
	}
	if m.clearedcommodity {
		edges = append(edges, customerdetentionpolicy.EdgeCommodity)
	}
	if m.clearedrevenue_code {
		edges = append(edges, customerdetentionpolicy.EdgeRevenueCode)
	}
	if m.clearedshipment_type {
		edges = append(edges, customerdetentionpolicy.EdgeShipmentType)
	}
	if m.clearedaccessorial_charge {
		edges = append(edges, customerdetentionpolicy.EdgeAccessorialCharge)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomerDetentionPolicyMutation) EdgeCleared(name string) bool {
	switch name {
	case customerdetentionpolicy.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case customerdetentionpolicy.EdgeOrganization:
		return m.clearedorganization
	case customerdetentionpolicy.EdgeCustomer:
		return m.clearedcustomer
	case customerdetentionpolicy.EdgeCommodity:
		return m.clearedcommodity
	case customerdetentionpolicy.EdgeRevenueCode:
		return m.clearedrevenue_code
	case customerdetentionpolicy.EdgeShipmentType:
		return m.clearedshipment_type
	case customerdetentionpolicy.EdgeAccessorialCharge:
		return m.clearedaccessorial_charge
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomerDetentionPolicyMutation) ClearEdge(name string) error {
	switch name {
	case customerdetentionpolicy.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case customerdetentionpolicy.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case customerdetentionpolicy.EdgeCustomer:
		m.ClearCustomer()
		return nil
	case customerdetentionpolicy.EdgeCommodity:
		m.ClearCommodity()
		return nil
	case customerdetentionpolicy.EdgeRevenueCode:
		m.ClearRevenueCode()
		return nil
	case customerdetentionpolicy.EdgeShipmentType:
		m.ClearShipmentType()
		return nil
	case customerdetentionpolicy.EdgeAccessorialCharge:
		m.ClearAccessorialCharge()
		return nil
	}
	return fmt.Errorf("unknown CustomerDetentionPolicy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomerDetentionPolicyMutation) ResetEdge(name string) error {
	switch name {
	case customerdetentionpolicy.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case customerdetentionpolicy.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case customerdetentionpolicy.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case customerdetentionpolicy.EdgeCommodity:
		m.ResetCommodity()
		return nil
	case customerdetentionpolicy.EdgeRevenueCode:
		m.ResetRevenueCode()
		return nil
	case customerdetentionpolicy.EdgeShipmentType:
		m.ResetShipmentType()
		return nil
	case customerdetentionpolicy.EdgeAccessorialCharge:
		m.ResetAccessorialCharge()
		return nil
	}
	return fmt.Errorf("unknown CustomerDetentionPolicy edge %s", name)
}

// CustomerEmailProfileMutation represents an operation that mutates the CustomerEmailProfile nodes in the graph.
type CustomerEmailProfileMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	version              *int
	addversion           *int
	subject              *string
	email_recipients     *string
	email_cc_recipients  *string
	attachment_name      *string
	email_format         *customeremailprofile.EmailFormat
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	customer             *uuid.UUID
	clearedcustomer      bool
	email_profile        *uuid.UUID
	clearedemail_profile bool
	done                 bool
	oldValue             func(context.Context) (*CustomerEmailProfile, error)
	predicates           []predicate.CustomerEmailProfile
}

var _ ent.Mutation = (*CustomerEmailProfileMutation)(nil)

// customeremailprofileOption allows management of the mutation configuration using functional options.
type customeremailprofileOption func(*CustomerEmailProfileMutation)

// newCustomerEmailProfileMutation creates new mutation for the CustomerEmailProfile entity.
func newCustomerEmailProfileMutation(c config, op Op, opts ...customeremailprofileOption) *CustomerEmailProfileMutation {
	m := &CustomerEmailProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomerEmailProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerEmailProfileID sets the ID field of the mutation.
func withCustomerEmailProfileID(id uuid.UUID) customeremailprofileOption {
	return func(m *CustomerEmailProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *CustomerEmailProfile
		)
		m.oldValue = func(ctx context.Context) (*CustomerEmailProfile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CustomerEmailProfile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomerEmailProfile sets the old CustomerEmailProfile of the mutation.
func withCustomerEmailProfile(node *CustomerEmailProfile) customeremailprofileOption {
	return func(m *CustomerEmailProfileMutation) {
		m.oldValue = func(context.Context) (*CustomerEmailProfile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerEmailProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerEmailProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CustomerEmailProfile entities.
func (m *CustomerEmailProfileMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CustomerEmailProfileMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CustomerEmailProfileMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CustomerEmailProfile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *CustomerEmailProfileMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *CustomerEmailProfileMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the CustomerEmailProfile entity.
// If the CustomerEmailProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerEmailProfileMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *CustomerEmailProfileMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *CustomerEmailProfileMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *CustomerEmailProfileMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the CustomerEmailProfile entity.
// If the CustomerEmailProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerEmailProfileMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *CustomerEmailProfileMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CustomerEmailProfileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CustomerEmailProfileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CustomerEmailProfile entity.
// If the CustomerEmailProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerEmailProfileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CustomerEmailProfileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CustomerEmailProfileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CustomerEmailProfileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CustomerEmailProfile entity.
// If the CustomerEmailProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerEmailProfileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CustomerEmailProfileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *CustomerEmailProfileMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *CustomerEmailProfileMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the CustomerEmailProfile entity.
// If the CustomerEmailProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerEmailProfileMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *CustomerEmailProfileMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *CustomerEmailProfileMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *CustomerEmailProfileMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetCustomerID sets the "customer_id" field.
func (m *CustomerEmailProfileMutation) SetCustomerID(u uuid.UUID) {
	m.customer = &u
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *CustomerEmailProfileMutation) CustomerID() (r uuid.UUID, exists bool) {
	v := m.customer
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the CustomerEmailProfile entity.
// If the CustomerEmailProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerEmailProfileMutation) OldCustomerID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *CustomerEmailProfileMutation) ResetCustomerID() {
	m.customer = nil
}

// SetSubject sets the "subject" field.
func (m *CustomerEmailProfileMutation) SetSubject(s string) {
	m.subject = &s
}

// Subject returns the value of the "subject" field in the mutation.
func (m *CustomerEmailProfileMutation) Subject() (r string, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubject returns the old "subject" field's value of the CustomerEmailProfile entity.
// If the CustomerEmailProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerEmailProfileMutation) OldSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubject: %w", err)
	}
	return oldValue.Subject, nil
}

// ClearSubject clears the value of the "subject" field.
func (m *CustomerEmailProfileMutation) ClearSubject() {
	m.subject = nil
	m.clearedFields[customeremailprofile.FieldSubject] = struct{}{}
}

// SubjectCleared returns if the "subject" field was cleared in this mutation.
func (m *CustomerEmailProfileMutation) SubjectCleared() bool {
	_, ok := m.clearedFields[customeremailprofile.FieldSubject]
	return ok
}

// ResetSubject resets all changes to the "subject" field.
func (m *CustomerEmailProfileMutation) ResetSubject() {
	m.subject = nil
	delete(m.clearedFields, customeremailprofile.FieldSubject)
}

// SetEmailProfileID sets the "email_profile_id" field.
func (m *CustomerEmailProfileMutation) SetEmailProfileID(u uuid.UUID) {
	m.email_profile = &u
}

// EmailProfileID returns the value of the "email_profile_id" field in the mutation.
func (m *CustomerEmailProfileMutation) EmailProfileID() (r uuid.UUID, exists bool) {
	v := m.email_profile
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailProfileID returns the old "email_profile_id" field's value of the CustomerEmailProfile entity.
// If the CustomerEmailProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerEmailProfileMutation) OldEmailProfileID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailProfileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailProfileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailProfileID: %w", err)
	}
	return oldValue.EmailProfileID, nil
}

// ClearEmailProfileID clears the value of the "email_profile_id" field.
func (m *CustomerEmailProfileMutation) ClearEmailProfileID() {
	m.email_profile = nil
	m.clearedFields[customeremailprofile.FieldEmailProfileID] = struct{}{}
}

// EmailProfileIDCleared returns if the "email_profile_id" field was cleared in this mutation.
func (m *CustomerEmailProfileMutation) EmailProfileIDCleared() bool {
	_, ok := m.clearedFields[customeremailprofile.FieldEmailProfileID]
	return ok
}

// ResetEmailProfileID resets all changes to the "email_profile_id" field.
func (m *CustomerEmailProfileMutation) ResetEmailProfileID() {
	m.email_profile = nil
	delete(m.clearedFields, customeremailprofile.FieldEmailProfileID)
}

// SetEmailRecipients sets the "email_recipients" field.
func (m *CustomerEmailProfileMutation) SetEmailRecipients(s string) {
	m.email_recipients = &s
}

// EmailRecipients returns the value of the "email_recipients" field in the mutation.
func (m *CustomerEmailProfileMutation) EmailRecipients() (r string, exists bool) {
	v := m.email_recipients
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailRecipients returns the old "email_recipients" field's value of the CustomerEmailProfile entity.
// If the CustomerEmailProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerEmailProfileMutation) OldEmailRecipients(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailRecipients is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailRecipients requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailRecipients: %w", err)
	}
	return oldValue.EmailRecipients, nil
}

// ResetEmailRecipients resets all changes to the "email_recipients" field.
func (m *CustomerEmailProfileMutation) ResetEmailRecipients() {
	m.email_recipients = nil
}

// SetEmailCcRecipients sets the "email_cc_recipients" field.
func (m *CustomerEmailProfileMutation) SetEmailCcRecipients(s string) {
	m.email_cc_recipients = &s
}

// EmailCcRecipients returns the value of the "email_cc_recipients" field in the mutation.
func (m *CustomerEmailProfileMutation) EmailCcRecipients() (r string, exists bool) {
	v := m.email_cc_recipients
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailCcRecipients returns the old "email_cc_recipients" field's value of the CustomerEmailProfile entity.
// If the CustomerEmailProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerEmailProfileMutation) OldEmailCcRecipients(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailCcRecipients is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailCcRecipients requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailCcRecipients: %w", err)
	}
	return oldValue.EmailCcRecipients, nil
}

// ClearEmailCcRecipients clears the value of the "email_cc_recipients" field.
func (m *CustomerEmailProfileMutation) ClearEmailCcRecipients() {
	m.email_cc_recipients = nil
	m.clearedFields[customeremailprofile.FieldEmailCcRecipients] = struct{}{}
}

// EmailCcRecipientsCleared returns if the "email_cc_recipients" field was cleared in this mutation.
func (m *CustomerEmailProfileMutation) EmailCcRecipientsCleared() bool {
	_, ok := m.clearedFields[customeremailprofile.FieldEmailCcRecipients]
	return ok
}

// ResetEmailCcRecipients resets all changes to the "email_cc_recipients" field.
func (m *CustomerEmailProfileMutation) ResetEmailCcRecipients() {
	m.email_cc_recipients = nil
	delete(m.clearedFields, customeremailprofile.FieldEmailCcRecipients)
}

// SetAttachmentName sets the "attachment_name" field.
func (m *CustomerEmailProfileMutation) SetAttachmentName(s string) {
	m.attachment_name = &s
}

// AttachmentName returns the value of the "attachment_name" field in the mutation.
func (m *CustomerEmailProfileMutation) AttachmentName() (r string, exists bool) {
	v := m.attachment_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAttachmentName returns the old "attachment_name" field's value of the CustomerEmailProfile entity.
// If the CustomerEmailProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerEmailProfileMutation) OldAttachmentName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttachmentName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttachmentName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttachmentName: %w", err)
	}
	return oldValue.AttachmentName, nil
}

// ClearAttachmentName clears the value of the "attachment_name" field.
func (m *CustomerEmailProfileMutation) ClearAttachmentName() {
	m.attachment_name = nil
	m.clearedFields[customeremailprofile.FieldAttachmentName] = struct{}{}
}

// AttachmentNameCleared returns if the "attachment_name" field was cleared in this mutation.
func (m *CustomerEmailProfileMutation) AttachmentNameCleared() bool {
	_, ok := m.clearedFields[customeremailprofile.FieldAttachmentName]
	return ok
}

// ResetAttachmentName resets all changes to the "attachment_name" field.
func (m *CustomerEmailProfileMutation) ResetAttachmentName() {
	m.attachment_name = nil
	delete(m.clearedFields, customeremailprofile.FieldAttachmentName)
}

// SetEmailFormat sets the "email_format" field.
func (m *CustomerEmailProfileMutation) SetEmailFormat(cf customeremailprofile.EmailFormat) {
	m.email_format = &cf
}

// EmailFormat returns the value of the "email_format" field in the mutation.
func (m *CustomerEmailProfileMutation) EmailFormat() (r customeremailprofile.EmailFormat, exists bool) {
	v := m.email_format
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailFormat returns the old "email_format" field's value of the CustomerEmailProfile entity.
// If the CustomerEmailProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerEmailProfileMutation) OldEmailFormat(ctx context.Context) (v customeremailprofile.EmailFormat, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailFormat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailFormat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailFormat: %w", err)
	}
	return oldValue.EmailFormat, nil
}

// ResetEmailFormat resets all changes to the "email_format" field.
func (m *CustomerEmailProfileMutation) ResetEmailFormat() {
	m.email_format = nil
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *CustomerEmailProfileMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[customeremailprofile.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *CustomerEmailProfileMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *CustomerEmailProfileMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *CustomerEmailProfileMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *CustomerEmailProfileMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[customeremailprofile.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *CustomerEmailProfileMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *CustomerEmailProfileMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *CustomerEmailProfileMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *CustomerEmailProfileMutation) ClearCustomer() {
	m.clearedcustomer = true
	m.clearedFields[customeremailprofile.FieldCustomerID] = struct{}{}
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *CustomerEmailProfileMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *CustomerEmailProfileMutation) CustomerIDs() (ids []uuid.UUID) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *CustomerEmailProfileMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// ClearEmailProfile clears the "email_profile" edge to the EmailProfile entity.
func (m *CustomerEmailProfileMutation) ClearEmailProfile() {
	m.clearedemail_profile = true
	m.clearedFields[customeremailprofile.FieldEmailProfileID] = struct{}{}
}

// EmailProfileCleared reports if the "email_profile" edge to the EmailProfile entity was cleared.
func (m *CustomerEmailProfileMutation) EmailProfileCleared() bool {
	return m.EmailProfileIDCleared() || m.clearedemail_profile
}

// EmailProfileIDs returns the "email_profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmailProfileID instead. It exists only for internal usage by the builders.
func (m *CustomerEmailProfileMutation) EmailProfileIDs() (ids []uuid.UUID) {
	if id := m.email_profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmailProfile resets all changes to the "email_profile" edge.
func (m *CustomerEmailProfileMutation) ResetEmailProfile() {
	m.email_profile = nil
	m.clearedemail_profile = false
}

// Where appends a list predicates to the CustomerEmailProfileMutation builder.
func (m *CustomerEmailProfileMutation) Where(ps ...predicate.CustomerEmailProfile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CustomerEmailProfileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CustomerEmailProfileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CustomerEmailProfile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CustomerEmailProfileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CustomerEmailProfileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CustomerEmailProfile).
func (m *CustomerEmailProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomerEmailProfileMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.business_unit != nil {
		fields = append(fields, customeremailprofile.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, customeremailprofile.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, customeremailprofile.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, customeremailprofile.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, customeremailprofile.FieldVersion)
	}
	if m.customer != nil {
		fields = append(fields, customeremailprofile.FieldCustomerID)
	}
	if m.subject != nil {
		fields = append(fields, customeremailprofile.FieldSubject)
	}
	if m.email_profile != nil {
		fields = append(fields, customeremailprofile.FieldEmailProfileID)
	}
	if m.email_recipients != nil {
		fields = append(fields, customeremailprofile.FieldEmailRecipients)
	}
	if m.email_cc_recipients != nil {
		fields = append(fields, customeremailprofile.FieldEmailCcRecipients)
	}
	if m.attachment_name != nil {
		fields = append(fields, customeremailprofile.FieldAttachmentName)
	}
	if m.email_format != nil {
		fields = append(fields, customeremailprofile.FieldEmailFormat)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomerEmailProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customeremailprofile.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case customeremailprofile.FieldOrganizationID:
		return m.OrganizationID()
	case customeremailprofile.FieldCreatedAt:
		return m.CreatedAt()
	case customeremailprofile.FieldUpdatedAt:
		return m.UpdatedAt()
	case customeremailprofile.FieldVersion:
		return m.Version()
	case customeremailprofile.FieldCustomerID:
		return m.CustomerID()
	case customeremailprofile.FieldSubject:
		return m.Subject()
	case customeremailprofile.FieldEmailProfileID:
		return m.EmailProfileID()
	case customeremailprofile.FieldEmailRecipients:
		return m.EmailRecipients()
	case customeremailprofile.FieldEmailCcRecipients:
		return m.EmailCcRecipients()
	case customeremailprofile.FieldAttachmentName:
		return m.AttachmentName()
	case customeremailprofile.FieldEmailFormat:
		return m.EmailFormat()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomerEmailProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customeremailprofile.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case customeremailprofile.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case customeremailprofile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case customeremailprofile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case customeremailprofile.FieldVersion:
		return m.OldVersion(ctx)
	case customeremailprofile.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case customeremailprofile.FieldSubject:
		return m.OldSubject(ctx)
	case customeremailprofile.FieldEmailProfileID:
		return m.OldEmailProfileID(ctx)
	case customeremailprofile.FieldEmailRecipients:
		return m.OldEmailRecipients(ctx)
	case customeremailprofile.FieldEmailCcRecipients:
		return m.OldEmailCcRecipients(ctx)
	case customeremailprofile.FieldAttachmentName:
		return m.OldAttachmentName(ctx)
	case customeremailprofile.FieldEmailFormat:
		return m.OldEmailFormat(ctx)
	}
	return nil, fmt.Errorf("unknown CustomerEmailProfile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerEmailProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customeremailprofile.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case customeremailprofile.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case customeremailprofile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case customeremailprofile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case customeremailprofile.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case customeremailprofile.FieldCustomerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case customeremailprofile.FieldSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubject(v)
		return nil
	case customeremailprofile.FieldEmailProfileID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailProfileID(v)
		return nil
	case customeremailprofile.FieldEmailRecipients:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailRecipients(v)
		return nil
	case customeremailprofile.FieldEmailCcRecipients:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailCcRecipients(v)
		return nil
	case customeremailprofile.FieldAttachmentName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttachmentName(v)
		return nil
	case customeremailprofile.FieldEmailFormat:
		v, ok := value.(customeremailprofile.EmailFormat)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailFormat(v)
		return nil
	}
	return fmt.Errorf("unknown CustomerEmailProfile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomerEmailProfileMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, customeremailprofile.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomerEmailProfileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case customeremailprofile.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerEmailProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case customeremailprofile.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown CustomerEmailProfile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomerEmailProfileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(customeremailprofile.FieldSubject) {
		fields = append(fields, customeremailprofile.FieldSubject)
	}
	if m.FieldCleared(customeremailprofile.FieldEmailProfileID) {
		fields = append(fields, customeremailprofile.FieldEmailProfileID)
	}
	if m.FieldCleared(customeremailprofile.FieldEmailCcRecipients) {
		fields = append(fields, customeremailprofile.FieldEmailCcRecipients)
	}
	if m.FieldCleared(customeremailprofile.FieldAttachmentName) {
		fields = append(fields, customeremailprofile.FieldAttachmentName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomerEmailProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerEmailProfileMutation) ClearField(name string) error {
	switch name {
	case customeremailprofile.FieldSubject:
		m.ClearSubject()
		return nil
	case customeremailprofile.FieldEmailProfileID:
		m.ClearEmailProfileID()
		return nil
	case customeremailprofile.FieldEmailCcRecipients:
		m.ClearEmailCcRecipients()
		return nil
	case customeremailprofile.FieldAttachmentName:
		m.ClearAttachmentName()
		return nil
	}
	return fmt.Errorf("unknown CustomerEmailProfile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomerEmailProfileMutation) ResetField(name string) error {
	switch name {
	case customeremailprofile.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case customeremailprofile.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case customeremailprofile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case customeremailprofile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case customeremailprofile.FieldVersion:
		m.ResetVersion()
		return nil
	case customeremailprofile.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case customeremailprofile.FieldSubject:
		m.ResetSubject()
		return nil
	case customeremailprofile.FieldEmailProfileID:
		m.ResetEmailProfileID()
		return nil
	case customeremailprofile.FieldEmailRecipients:
		m.ResetEmailRecipients()
		return nil
	case customeremailprofile.FieldEmailCcRecipients:
		m.ResetEmailCcRecipients()
		return nil
	case customeremailprofile.FieldAttachmentName:
		m.ResetAttachmentName()
		return nil
	case customeremailprofile.FieldEmailFormat:
		m.ResetEmailFormat()
		return nil
	}
	return fmt.Errorf("unknown CustomerEmailProfile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomerEmailProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.business_unit != nil {
		edges = append(edges, customeremailprofile.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, customeremailprofile.EdgeOrganization)
	}
	if m.customer != nil {
		edges = append(edges, customeremailprofile.EdgeCustomer)
	}
	if m.email_profile != nil {
		edges = append(edges, customeremailprofile.EdgeEmailProfile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomerEmailProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case customeremailprofile.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case customeremailprofile.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case customeremailprofile.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	case customeremailprofile.EdgeEmailProfile:
		if id := m.email_profile; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomerEmailProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomerEmailProfileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomerEmailProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedbusiness_unit {
		edges = append(edges, customeremailprofile.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, customeremailprofile.EdgeOrganization)
	}
	if m.clearedcustomer {
		edges = append(edges, customeremailprofile.EdgeCustomer)
	}
	if m.clearedemail_profile {
		edges = append(edges, customeremailprofile.EdgeEmailProfile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomerEmailProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case customeremailprofile.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case customeremailprofile.EdgeOrganization:
		return m.clearedorganization
	case customeremailprofile.EdgeCustomer:
		return m.clearedcustomer
	case customeremailprofile.EdgeEmailProfile:
		return m.clearedemail_profile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomerEmailProfileMutation) ClearEdge(name string) error {
	switch name {
	case customeremailprofile.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case customeremailprofile.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case customeremailprofile.EdgeCustomer:
		m.ClearCustomer()
		return nil
	case customeremailprofile.EdgeEmailProfile:
		m.ClearEmailProfile()
		return nil
	}
	return fmt.Errorf("unknown CustomerEmailProfile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomerEmailProfileMutation) ResetEdge(name string) error {
	switch name {
	case customeremailprofile.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case customeremailprofile.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case customeremailprofile.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case customeremailprofile.EdgeEmailProfile:
		m.ResetEmailProfile()
		return nil
	}
	return fmt.Errorf("unknown CustomerEmailProfile edge %s", name)
}

// CustomerRuleProfileMutation represents an operation that mutates the CustomerRuleProfile nodes in the graph.
type CustomerRuleProfileMutation struct {
	config
	op                              Op
	typ                             string
	id                              *uuid.UUID
	created_at                      *time.Time
	updated_at                      *time.Time
	version                         *int
	addversion                      *int
	billing_cycle                   *customerruleprofile.BillingCycle
	clearedFields                   map[string]struct{}
	business_unit                   *uuid.UUID
	clearedbusiness_unit            bool
	organization                    *uuid.UUID
	clearedorganization             bool
	customer                        *uuid.UUID
	clearedcustomer                 bool
	document_classifications        map[uuid.UUID]struct{}
	removeddocument_classifications map[uuid.UUID]struct{}
	cleareddocument_classifications bool
	done                            bool
	oldValue                        func(context.Context) (*CustomerRuleProfile, error)
	predicates                      []predicate.CustomerRuleProfile
}

var _ ent.Mutation = (*CustomerRuleProfileMutation)(nil)

// customerruleprofileOption allows management of the mutation configuration using functional options.
type customerruleprofileOption func(*CustomerRuleProfileMutation)

// newCustomerRuleProfileMutation creates new mutation for the CustomerRuleProfile entity.
func newCustomerRuleProfileMutation(c config, op Op, opts ...customerruleprofileOption) *CustomerRuleProfileMutation {
	m := &CustomerRuleProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomerRuleProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerRuleProfileID sets the ID field of the mutation.
func withCustomerRuleProfileID(id uuid.UUID) customerruleprofileOption {
	return func(m *CustomerRuleProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *CustomerRuleProfile
		)
		m.oldValue = func(ctx context.Context) (*CustomerRuleProfile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CustomerRuleProfile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomerRuleProfile sets the old CustomerRuleProfile of the mutation.
func withCustomerRuleProfile(node *CustomerRuleProfile) customerruleprofileOption {
	return func(m *CustomerRuleProfileMutation) {
		m.oldValue = func(context.Context) (*CustomerRuleProfile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerRuleProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerRuleProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CustomerRuleProfile entities.
func (m *CustomerRuleProfileMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CustomerRuleProfileMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CustomerRuleProfileMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CustomerRuleProfile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *CustomerRuleProfileMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *CustomerRuleProfileMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the CustomerRuleProfile entity.
// If the CustomerRuleProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerRuleProfileMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *CustomerRuleProfileMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *CustomerRuleProfileMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *CustomerRuleProfileMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the CustomerRuleProfile entity.
// If the CustomerRuleProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerRuleProfileMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *CustomerRuleProfileMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CustomerRuleProfileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CustomerRuleProfileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CustomerRuleProfile entity.
// If the CustomerRuleProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerRuleProfileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CustomerRuleProfileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CustomerRuleProfileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CustomerRuleProfileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CustomerRuleProfile entity.
// If the CustomerRuleProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerRuleProfileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CustomerRuleProfileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *CustomerRuleProfileMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *CustomerRuleProfileMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the CustomerRuleProfile entity.
// If the CustomerRuleProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerRuleProfileMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *CustomerRuleProfileMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *CustomerRuleProfileMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *CustomerRuleProfileMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetCustomerID sets the "customer_id" field.
func (m *CustomerRuleProfileMutation) SetCustomerID(u uuid.UUID) {
	m.customer = &u
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *CustomerRuleProfileMutation) CustomerID() (r uuid.UUID, exists bool) {
	v := m.customer
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the CustomerRuleProfile entity.
// If the CustomerRuleProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerRuleProfileMutation) OldCustomerID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *CustomerRuleProfileMutation) ResetCustomerID() {
	m.customer = nil
}

// SetBillingCycle sets the "billing_cycle" field.
func (m *CustomerRuleProfileMutation) SetBillingCycle(cc customerruleprofile.BillingCycle) {
	m.billing_cycle = &cc
}

// BillingCycle returns the value of the "billing_cycle" field in the mutation.
func (m *CustomerRuleProfileMutation) BillingCycle() (r customerruleprofile.BillingCycle, exists bool) {
	v := m.billing_cycle
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingCycle returns the old "billing_cycle" field's value of the CustomerRuleProfile entity.
// If the CustomerRuleProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerRuleProfileMutation) OldBillingCycle(ctx context.Context) (v customerruleprofile.BillingCycle, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingCycle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingCycle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingCycle: %w", err)
	}
	return oldValue.BillingCycle, nil
}

// ResetBillingCycle resets all changes to the "billing_cycle" field.
func (m *CustomerRuleProfileMutation) ResetBillingCycle() {
	m.billing_cycle = nil
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *CustomerRuleProfileMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[customerruleprofile.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *CustomerRuleProfileMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *CustomerRuleProfileMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *CustomerRuleProfileMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *CustomerRuleProfileMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[customerruleprofile.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *CustomerRuleProfileMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *CustomerRuleProfileMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *CustomerRuleProfileMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *CustomerRuleProfileMutation) ClearCustomer() {
	m.clearedcustomer = true
	m.clearedFields[customerruleprofile.FieldCustomerID] = struct{}{}
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *CustomerRuleProfileMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *CustomerRuleProfileMutation) CustomerIDs() (ids []uuid.UUID) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *CustomerRuleProfileMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// AddDocumentClassificationIDs adds the "document_classifications" edge to the DocumentClassification entity by ids.
func (m *CustomerRuleProfileMutation) AddDocumentClassificationIDs(ids ...uuid.UUID) {
	if m.document_classifications == nil {
		m.document_classifications = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.document_classifications[ids[i]] = struct{}{}
	}
}

// ClearDocumentClassifications clears the "document_classifications" edge to the DocumentClassification entity.
func (m *CustomerRuleProfileMutation) ClearDocumentClassifications() {
	m.cleareddocument_classifications = true
}

// DocumentClassificationsCleared reports if the "document_classifications" edge to the DocumentClassification entity was cleared.
func (m *CustomerRuleProfileMutation) DocumentClassificationsCleared() bool {
	return m.cleareddocument_classifications
}

// RemoveDocumentClassificationIDs removes the "document_classifications" edge to the DocumentClassification entity by IDs.
func (m *CustomerRuleProfileMutation) RemoveDocumentClassificationIDs(ids ...uuid.UUID) {
	if m.removeddocument_classifications == nil {
		m.removeddocument_classifications = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.document_classifications, ids[i])
		m.removeddocument_classifications[ids[i]] = struct{}{}
	}
}

// RemovedDocumentClassifications returns the removed IDs of the "document_classifications" edge to the DocumentClassification entity.
func (m *CustomerRuleProfileMutation) RemovedDocumentClassificationsIDs() (ids []uuid.UUID) {
	for id := range m.removeddocument_classifications {
		ids = append(ids, id)
	}
	return
}

// DocumentClassificationsIDs returns the "document_classifications" edge IDs in the mutation.
func (m *CustomerRuleProfileMutation) DocumentClassificationsIDs() (ids []uuid.UUID) {
	for id := range m.document_classifications {
		ids = append(ids, id)
	}
	return
}

// ResetDocumentClassifications resets all changes to the "document_classifications" edge.
func (m *CustomerRuleProfileMutation) ResetDocumentClassifications() {
	m.document_classifications = nil
	m.cleareddocument_classifications = false
	m.removeddocument_classifications = nil
}

// Where appends a list predicates to the CustomerRuleProfileMutation builder.
func (m *CustomerRuleProfileMutation) Where(ps ...predicate.CustomerRuleProfile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CustomerRuleProfileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CustomerRuleProfileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CustomerRuleProfile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CustomerRuleProfileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CustomerRuleProfileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CustomerRuleProfile).
func (m *CustomerRuleProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomerRuleProfileMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.business_unit != nil {
		fields = append(fields, customerruleprofile.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, customerruleprofile.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, customerruleprofile.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, customerruleprofile.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, customerruleprofile.FieldVersion)
	}
	if m.customer != nil {
		fields = append(fields, customerruleprofile.FieldCustomerID)
	}
	if m.billing_cycle != nil {
		fields = append(fields, customerruleprofile.FieldBillingCycle)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomerRuleProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customerruleprofile.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case customerruleprofile.FieldOrganizationID:
		return m.OrganizationID()
	case customerruleprofile.FieldCreatedAt:
		return m.CreatedAt()
	case customerruleprofile.FieldUpdatedAt:
		return m.UpdatedAt()
	case customerruleprofile.FieldVersion:
		return m.Version()
	case customerruleprofile.FieldCustomerID:
		return m.CustomerID()
	case customerruleprofile.FieldBillingCycle:
		return m.BillingCycle()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomerRuleProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customerruleprofile.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case customerruleprofile.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case customerruleprofile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case customerruleprofile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case customerruleprofile.FieldVersion:
		return m.OldVersion(ctx)
	case customerruleprofile.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case customerruleprofile.FieldBillingCycle:
		return m.OldBillingCycle(ctx)
	}
	return nil, fmt.Errorf("unknown CustomerRuleProfile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerRuleProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customerruleprofile.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case customerruleprofile.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case customerruleprofile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case customerruleprofile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case customerruleprofile.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case customerruleprofile.FieldCustomerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case customerruleprofile.FieldBillingCycle:
		v, ok := value.(customerruleprofile.BillingCycle)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingCycle(v)
		return nil
	}
	return fmt.Errorf("unknown CustomerRuleProfile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomerRuleProfileMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, customerruleprofile.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomerRuleProfileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case customerruleprofile.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerRuleProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case customerruleprofile.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown CustomerRuleProfile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomerRuleProfileMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomerRuleProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerRuleProfileMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CustomerRuleProfile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomerRuleProfileMutation) ResetField(name string) error {
	switch name {
	case customerruleprofile.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case customerruleprofile.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case customerruleprofile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case customerruleprofile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case customerruleprofile.FieldVersion:
		m.ResetVersion()
		return nil
	case customerruleprofile.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case customerruleprofile.FieldBillingCycle:
		m.ResetBillingCycle()
		return nil
	}
	return fmt.Errorf("unknown CustomerRuleProfile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomerRuleProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.business_unit != nil {
		edges = append(edges, customerruleprofile.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, customerruleprofile.EdgeOrganization)
	}
	if m.customer != nil {
		edges = append(edges, customerruleprofile.EdgeCustomer)
	}
	if m.document_classifications != nil {
		edges = append(edges, customerruleprofile.EdgeDocumentClassifications)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomerRuleProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case customerruleprofile.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case customerruleprofile.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case customerruleprofile.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	case customerruleprofile.EdgeDocumentClassifications:
		ids := make([]ent.Value, 0, len(m.document_classifications))
		for id := range m.document_classifications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomerRuleProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removeddocument_classifications != nil {
		edges = append(edges, customerruleprofile.EdgeDocumentClassifications)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomerRuleProfileMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case customerruleprofile.EdgeDocumentClassifications:
		ids := make([]ent.Value, 0, len(m.removeddocument_classifications))
		for id := range m.removeddocument_classifications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomerRuleProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedbusiness_unit {
		edges = append(edges, customerruleprofile.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, customerruleprofile.EdgeOrganization)
	}
	if m.clearedcustomer {
		edges = append(edges, customerruleprofile.EdgeCustomer)
	}
	if m.cleareddocument_classifications {
		edges = append(edges, customerruleprofile.EdgeDocumentClassifications)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomerRuleProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case customerruleprofile.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case customerruleprofile.EdgeOrganization:
		return m.clearedorganization
	case customerruleprofile.EdgeCustomer:
		return m.clearedcustomer
	case customerruleprofile.EdgeDocumentClassifications:
		return m.cleareddocument_classifications
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomerRuleProfileMutation) ClearEdge(name string) error {
	switch name {
	case customerruleprofile.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case customerruleprofile.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case customerruleprofile.EdgeCustomer:
		m.ClearCustomer()
		return nil
	}
	return fmt.Errorf("unknown CustomerRuleProfile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomerRuleProfileMutation) ResetEdge(name string) error {
	switch name {
	case customerruleprofile.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case customerruleprofile.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case customerruleprofile.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case customerruleprofile.EdgeDocumentClassifications:
		m.ResetDocumentClassifications()
		return nil
	}
	return fmt.Errorf("unknown CustomerRuleProfile edge %s", name)
}

// DelayCodeMutation represents an operation that mutates the DelayCode nodes in the graph.
type DelayCodeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	version              *int
	addversion           *int
	status               *delaycode.Status
	code                 *string
	description          *string
	f_carrier_or_driver  *bool
	color                *string
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	done                 bool
	oldValue             func(context.Context) (*DelayCode, error)
	predicates           []predicate.DelayCode
}

var _ ent.Mutation = (*DelayCodeMutation)(nil)

// delaycodeOption allows management of the mutation configuration using functional options.
type delaycodeOption func(*DelayCodeMutation)

// newDelayCodeMutation creates new mutation for the DelayCode entity.
func newDelayCodeMutation(c config, op Op, opts ...delaycodeOption) *DelayCodeMutation {
	m := &DelayCodeMutation{
		config:        c,
		op:            op,
		typ:           TypeDelayCode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDelayCodeID sets the ID field of the mutation.
func withDelayCodeID(id uuid.UUID) delaycodeOption {
	return func(m *DelayCodeMutation) {
		var (
			err   error
			once  sync.Once
			value *DelayCode
		)
		m.oldValue = func(ctx context.Context) (*DelayCode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DelayCode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDelayCode sets the old DelayCode of the mutation.
func withDelayCode(node *DelayCode) delaycodeOption {
	return func(m *DelayCodeMutation) {
		m.oldValue = func(context.Context) (*DelayCode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DelayCodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DelayCodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DelayCode entities.
func (m *DelayCodeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DelayCodeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DelayCodeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DelayCode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *DelayCodeMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *DelayCodeMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the DelayCode entity.
// If the DelayCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelayCodeMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *DelayCodeMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *DelayCodeMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *DelayCodeMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the DelayCode entity.
// If the DelayCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelayCodeMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *DelayCodeMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DelayCodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DelayCodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DelayCode entity.
// If the DelayCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelayCodeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DelayCodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DelayCodeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DelayCodeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DelayCode entity.
// If the DelayCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelayCodeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DelayCodeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *DelayCodeMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *DelayCodeMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the DelayCode entity.
// If the DelayCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelayCodeMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *DelayCodeMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *DelayCodeMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *DelayCodeMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetStatus sets the "status" field.
func (m *DelayCodeMutation) SetStatus(d delaycode.Status) {
	m.status = &d
}

// Status returns the value of the "status" field in the mutation.
func (m *DelayCodeMutation) Status() (r delaycode.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the DelayCode entity.
// If the DelayCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelayCodeMutation) OldStatus(ctx context.Context) (v delaycode.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *DelayCodeMutation) ResetStatus() {
	m.status = nil
}

// SetCode sets the "code" field.
func (m *DelayCodeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *DelayCodeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the DelayCode entity.
// If the DelayCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelayCodeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *DelayCodeMutation) ResetCode() {
	m.code = nil
}

// SetDescription sets the "description" field.
func (m *DelayCodeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DelayCodeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the DelayCode entity.
// If the DelayCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelayCodeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *DelayCodeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[delaycode.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *DelayCodeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[delaycode.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *DelayCodeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, delaycode.FieldDescription)
}

// SetFCarrierOrDriver sets the "f_carrier_or_driver" field.
func (m *DelayCodeMutation) SetFCarrierOrDriver(b bool) {
	m.f_carrier_or_driver = &b
}

// FCarrierOrDriver returns the value of the "f_carrier_or_driver" field in the mutation.
func (m *DelayCodeMutation) FCarrierOrDriver() (r bool, exists bool) {
	v := m.f_carrier_or_driver
	if v == nil {
		return
	}
	return *v, true
}

// OldFCarrierOrDriver returns the old "f_carrier_or_driver" field's value of the DelayCode entity.
// If the DelayCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelayCodeMutation) OldFCarrierOrDriver(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFCarrierOrDriver is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFCarrierOrDriver requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFCarrierOrDriver: %w", err)
	}
	return oldValue.FCarrierOrDriver, nil
}

// ClearFCarrierOrDriver clears the value of the "f_carrier_or_driver" field.
func (m *DelayCodeMutation) ClearFCarrierOrDriver() {
	m.f_carrier_or_driver = nil
	m.clearedFields[delaycode.FieldFCarrierOrDriver] = struct{}{}
}

// FCarrierOrDriverCleared returns if the "f_carrier_or_driver" field was cleared in this mutation.
func (m *DelayCodeMutation) FCarrierOrDriverCleared() bool {
	_, ok := m.clearedFields[delaycode.FieldFCarrierOrDriver]
	return ok
}

// ResetFCarrierOrDriver resets all changes to the "f_carrier_or_driver" field.
func (m *DelayCodeMutation) ResetFCarrierOrDriver() {
	m.f_carrier_or_driver = nil
	delete(m.clearedFields, delaycode.FieldFCarrierOrDriver)
}

// SetColor sets the "color" field.
func (m *DelayCodeMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *DelayCodeMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the DelayCode entity.
// If the DelayCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelayCodeMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *DelayCodeMutation) ClearColor() {
	m.color = nil
	m.clearedFields[delaycode.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *DelayCodeMutation) ColorCleared() bool {
	_, ok := m.clearedFields[delaycode.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *DelayCodeMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, delaycode.FieldColor)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *DelayCodeMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[delaycode.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *DelayCodeMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *DelayCodeMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *DelayCodeMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *DelayCodeMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[delaycode.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *DelayCodeMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *DelayCodeMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *DelayCodeMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the DelayCodeMutation builder.
func (m *DelayCodeMutation) Where(ps ...predicate.DelayCode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DelayCodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DelayCodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DelayCode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DelayCodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DelayCodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DelayCode).
func (m *DelayCodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DelayCodeMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.business_unit != nil {
		fields = append(fields, delaycode.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, delaycode.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, delaycode.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, delaycode.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, delaycode.FieldVersion)
	}
	if m.status != nil {
		fields = append(fields, delaycode.FieldStatus)
	}
	if m.code != nil {
		fields = append(fields, delaycode.FieldCode)
	}
	if m.description != nil {
		fields = append(fields, delaycode.FieldDescription)
	}
	if m.f_carrier_or_driver != nil {
		fields = append(fields, delaycode.FieldFCarrierOrDriver)
	}
	if m.color != nil {
		fields = append(fields, delaycode.FieldColor)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DelayCodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case delaycode.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case delaycode.FieldOrganizationID:
		return m.OrganizationID()
	case delaycode.FieldCreatedAt:
		return m.CreatedAt()
	case delaycode.FieldUpdatedAt:
		return m.UpdatedAt()
	case delaycode.FieldVersion:
		return m.Version()
	case delaycode.FieldStatus:
		return m.Status()
	case delaycode.FieldCode:
		return m.Code()
	case delaycode.FieldDescription:
		return m.Description()
	case delaycode.FieldFCarrierOrDriver:
		return m.FCarrierOrDriver()
	case delaycode.FieldColor:
		return m.Color()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DelayCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case delaycode.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case delaycode.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case delaycode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case delaycode.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case delaycode.FieldVersion:
		return m.OldVersion(ctx)
	case delaycode.FieldStatus:
		return m.OldStatus(ctx)
	case delaycode.FieldCode:
		return m.OldCode(ctx)
	case delaycode.FieldDescription:
		return m.OldDescription(ctx)
	case delaycode.FieldFCarrierOrDriver:
		return m.OldFCarrierOrDriver(ctx)
	case delaycode.FieldColor:
		return m.OldColor(ctx)
	}
	return nil, fmt.Errorf("unknown DelayCode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DelayCodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case delaycode.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case delaycode.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case delaycode.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case delaycode.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case delaycode.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case delaycode.FieldStatus:
		v, ok := value.(delaycode.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case delaycode.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case delaycode.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case delaycode.FieldFCarrierOrDriver:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFCarrierOrDriver(v)
		return nil
	case delaycode.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	}
	return fmt.Errorf("unknown DelayCode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DelayCodeMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, delaycode.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DelayCodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case delaycode.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DelayCodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case delaycode.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown DelayCode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DelayCodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(delaycode.FieldDescription) {
		fields = append(fields, delaycode.FieldDescription)
	}
	if m.FieldCleared(delaycode.FieldFCarrierOrDriver) {
		fields = append(fields, delaycode.FieldFCarrierOrDriver)
	}
	if m.FieldCleared(delaycode.FieldColor) {
		fields = append(fields, delaycode.FieldColor)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DelayCodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DelayCodeMutation) ClearField(name string) error {
	switch name {
	case delaycode.FieldDescription:
		m.ClearDescription()
		return nil
	case delaycode.FieldFCarrierOrDriver:
		m.ClearFCarrierOrDriver()
		return nil
	case delaycode.FieldColor:
		m.ClearColor()
		return nil
	}
	return fmt.Errorf("unknown DelayCode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DelayCodeMutation) ResetField(name string) error {
	switch name {
	case delaycode.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case delaycode.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case delaycode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case delaycode.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case delaycode.FieldVersion:
		m.ResetVersion()
		return nil
	case delaycode.FieldStatus:
		m.ResetStatus()
		return nil
	case delaycode.FieldCode:
		m.ResetCode()
		return nil
	case delaycode.FieldDescription:
		m.ResetDescription()
		return nil
	case delaycode.FieldFCarrierOrDriver:
		m.ResetFCarrierOrDriver()
		return nil
	case delaycode.FieldColor:
		m.ResetColor()
		return nil
	}
	return fmt.Errorf("unknown DelayCode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DelayCodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.business_unit != nil {
		edges = append(edges, delaycode.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, delaycode.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DelayCodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case delaycode.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case delaycode.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DelayCodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DelayCodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DelayCodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbusiness_unit {
		edges = append(edges, delaycode.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, delaycode.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DelayCodeMutation) EdgeCleared(name string) bool {
	switch name {
	case delaycode.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case delaycode.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DelayCodeMutation) ClearEdge(name string) error {
	switch name {
	case delaycode.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case delaycode.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown DelayCode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DelayCodeMutation) ResetEdge(name string) error {
	switch name {
	case delaycode.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case delaycode.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown DelayCode edge %s", name)
}

// DeliverySlotMutation represents an operation that mutates the DeliverySlot nodes in the graph.
type DeliverySlotMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	version              *int
	addversion           *int
	day_of_week          *deliveryslot.DayOfWeek
	start_time           **types.TimeOnly
	end_time             **types.TimeOnly
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	customer             *uuid.UUID
	clearedcustomer      bool
	location             *uuid.UUID
	clearedlocation      bool
	done                 bool
	oldValue             func(context.Context) (*DeliverySlot, error)
	predicates           []predicate.DeliverySlot
}

var _ ent.Mutation = (*DeliverySlotMutation)(nil)

// deliveryslotOption allows management of the mutation configuration using functional options.
type deliveryslotOption func(*DeliverySlotMutation)

// newDeliverySlotMutation creates new mutation for the DeliverySlot entity.
func newDeliverySlotMutation(c config, op Op, opts ...deliveryslotOption) *DeliverySlotMutation {
	m := &DeliverySlotMutation{
		config:        c,
		op:            op,
		typ:           TypeDeliverySlot,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeliverySlotID sets the ID field of the mutation.
func withDeliverySlotID(id uuid.UUID) deliveryslotOption {
	return func(m *DeliverySlotMutation) {
		var (
			err   error
			once  sync.Once
			value *DeliverySlot
		)
		m.oldValue = func(ctx context.Context) (*DeliverySlot, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeliverySlot.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeliverySlot sets the old DeliverySlot of the mutation.
func withDeliverySlot(node *DeliverySlot) deliveryslotOption {
	return func(m *DeliverySlotMutation) {
		m.oldValue = func(context.Context) (*DeliverySlot, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeliverySlotMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeliverySlotMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeliverySlot entities.
func (m *DeliverySlotMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeliverySlotMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeliverySlotMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeliverySlot.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *DeliverySlotMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *DeliverySlotMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the DeliverySlot entity.
// If the DeliverySlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliverySlotMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *DeliverySlotMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *DeliverySlotMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *DeliverySlotMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the DeliverySlot entity.
// If the DeliverySlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliverySlotMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *DeliverySlotMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DeliverySlotMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeliverySlotMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DeliverySlot entity.
// If the DeliverySlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliverySlotMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeliverySlotMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeliverySlotMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeliverySlotMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DeliverySlot entity.
// If the DeliverySlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliverySlotMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeliverySlotMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *DeliverySlotMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *DeliverySlotMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the DeliverySlot entity.
// If the DeliverySlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliverySlotMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *DeliverySlotMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *DeliverySlotMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *DeliverySlotMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetCustomerID sets the "customer_id" field.
func (m *DeliverySlotMutation) SetCustomerID(u uuid.UUID) {
	m.customer = &u
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *DeliverySlotMutation) CustomerID() (r uuid.UUID, exists bool) {
	v := m.customer
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the DeliverySlot entity.
// If the DeliverySlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliverySlotMutation) OldCustomerID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *DeliverySlotMutation) ResetCustomerID() {
	m.customer = nil
}

// SetLocationID sets the "location_id" field.
func (m *DeliverySlotMutation) SetLocationID(u uuid.UUID) {
	m.location = &u
}

// LocationID returns the value of the "location_id" field in the mutation.
func (m *DeliverySlotMutation) LocationID() (r uuid.UUID, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationID returns the old "location_id" field's value of the DeliverySlot entity.
// If the DeliverySlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliverySlotMutation) OldLocationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationID: %w", err)
	}
	return oldValue.LocationID, nil
}

// ResetLocationID resets all changes to the "location_id" field.
func (m *DeliverySlotMutation) ResetLocationID() {
	m.location = nil
}

// SetDayOfWeek sets the "day_of_week" field.
func (m *DeliverySlotMutation) SetDayOfWeek(dow deliveryslot.DayOfWeek) {
	m.day_of_week = &dow
}

// DayOfWeek returns the value of the "day_of_week" field in the mutation.
func (m *DeliverySlotMutation) DayOfWeek() (r deliveryslot.DayOfWeek, exists bool) {
	v := m.day_of_week
	if v == nil {
		return
	}
	return *v, true
}

// OldDayOfWeek returns the old "day_of_week" field's value of the DeliverySlot entity.
// If the DeliverySlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliverySlotMutation) OldDayOfWeek(ctx context.Context) (v deliveryslot.DayOfWeek, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDayOfWeek is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDayOfWeek requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDayOfWeek: %w", err)
	}
	return oldValue.DayOfWeek, nil
}

// ResetDayOfWeek resets all changes to the "day_of_week" field.
func (m *DeliverySlotMutation) ResetDayOfWeek() {
	m.day_of_week = nil
}

// SetStartTime sets the "start_time" field.
func (m *DeliverySlotMutation) SetStartTime(to *types.TimeOnly) {
	m.start_time = &to
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *DeliverySlotMutation) StartTime() (r *types.TimeOnly, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the DeliverySlot entity.
// If the DeliverySlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliverySlotMutation) OldStartTime(ctx context.Context) (v *types.TimeOnly, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *DeliverySlotMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *DeliverySlotMutation) SetEndTime(to *types.TimeOnly) {
	m.end_time = &to
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *DeliverySlotMutation) EndTime() (r *types.TimeOnly, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the DeliverySlot entity.
// If the DeliverySlot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliverySlotMutation) OldEndTime(ctx context.Context) (v *types.TimeOnly, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *DeliverySlotMutation) ResetEndTime() {
	m.end_time = nil
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *DeliverySlotMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[deliveryslot.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *DeliverySlotMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *DeliverySlotMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *DeliverySlotMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *DeliverySlotMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[deliveryslot.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *DeliverySlotMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *DeliverySlotMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *DeliverySlotMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *DeliverySlotMutation) ClearCustomer() {
	m.clearedcustomer = true
	m.clearedFields[deliveryslot.FieldCustomerID] = struct{}{}
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *DeliverySlotMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *DeliverySlotMutation) CustomerIDs() (ids []uuid.UUID) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *DeliverySlotMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// ClearLocation clears the "location" edge to the Location entity.
func (m *DeliverySlotMutation) ClearLocation() {
	m.clearedlocation = true
	m.clearedFields[deliveryslot.FieldLocationID] = struct{}{}
}

// LocationCleared reports if the "location" edge to the Location entity was cleared.
func (m *DeliverySlotMutation) LocationCleared() bool {
	return m.clearedlocation
}

// LocationIDs returns the "location" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LocationID instead. It exists only for internal usage by the builders.
func (m *DeliverySlotMutation) LocationIDs() (ids []uuid.UUID) {
	if id := m.location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocation resets all changes to the "location" edge.
func (m *DeliverySlotMutation) ResetLocation() {
	m.location = nil
	m.clearedlocation = false
}

// Where appends a list predicates to the DeliverySlotMutation builder.
func (m *DeliverySlotMutation) Where(ps ...predicate.DeliverySlot) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeliverySlotMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeliverySlotMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeliverySlot, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeliverySlotMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeliverySlotMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeliverySlot).
func (m *DeliverySlotMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeliverySlotMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.business_unit != nil {
		fields = append(fields, deliveryslot.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, deliveryslot.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, deliveryslot.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, deliveryslot.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, deliveryslot.FieldVersion)
	}
	if m.customer != nil {
		fields = append(fields, deliveryslot.FieldCustomerID)
	}
	if m.location != nil {
		fields = append(fields, deliveryslot.FieldLocationID)
	}
	if m.day_of_week != nil {
		fields = append(fields, deliveryslot.FieldDayOfWeek)
	}
	if m.start_time != nil {
		fields = append(fields, deliveryslot.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, deliveryslot.FieldEndTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeliverySlotMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deliveryslot.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case deliveryslot.FieldOrganizationID:
		return m.OrganizationID()
	case deliveryslot.FieldCreatedAt:
		return m.CreatedAt()
	case deliveryslot.FieldUpdatedAt:
		return m.UpdatedAt()
	case deliveryslot.FieldVersion:
		return m.Version()
	case deliveryslot.FieldCustomerID:
		return m.CustomerID()
	case deliveryslot.FieldLocationID:
		return m.LocationID()
	case deliveryslot.FieldDayOfWeek:
		return m.DayOfWeek()
	case deliveryslot.FieldStartTime:
		return m.StartTime()
	case deliveryslot.FieldEndTime:
		return m.EndTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeliverySlotMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deliveryslot.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case deliveryslot.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case deliveryslot.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case deliveryslot.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case deliveryslot.FieldVersion:
		return m.OldVersion(ctx)
	case deliveryslot.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case deliveryslot.FieldLocationID:
		return m.OldLocationID(ctx)
	case deliveryslot.FieldDayOfWeek:
		return m.OldDayOfWeek(ctx)
	case deliveryslot.FieldStartTime:
		return m.OldStartTime(ctx)
	case deliveryslot.FieldEndTime:
		return m.OldEndTime(ctx)
	}
	return nil, fmt.Errorf("unknown DeliverySlot field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeliverySlotMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deliveryslot.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case deliveryslot.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case deliveryslot.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case deliveryslot.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case deliveryslot.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case deliveryslot.FieldCustomerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case deliveryslot.FieldLocationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationID(v)
		return nil
	case deliveryslot.FieldDayOfWeek:
		v, ok := value.(deliveryslot.DayOfWeek)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDayOfWeek(v)
		return nil
	case deliveryslot.FieldStartTime:
		v, ok := value.(*types.TimeOnly)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case deliveryslot.FieldEndTime:
		v, ok := value.(*types.TimeOnly)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	}
	return fmt.Errorf("unknown DeliverySlot field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeliverySlotMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, deliveryslot.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeliverySlotMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case deliveryslot.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeliverySlotMutation) AddField(name string, value ent.Value) error {
	switch name {
	case deliveryslot.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown DeliverySlot numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeliverySlotMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeliverySlotMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeliverySlotMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DeliverySlot nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeliverySlotMutation) ResetField(name string) error {
	switch name {
	case deliveryslot.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case deliveryslot.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case deliveryslot.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case deliveryslot.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case deliveryslot.FieldVersion:
		m.ResetVersion()
		return nil
	case deliveryslot.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case deliveryslot.FieldLocationID:
		m.ResetLocationID()
		return nil
	case deliveryslot.FieldDayOfWeek:
		m.ResetDayOfWeek()
		return nil
	case deliveryslot.FieldStartTime:
		m.ResetStartTime()
		return nil
	case deliveryslot.FieldEndTime:
		m.ResetEndTime()
		return nil
	}
	return fmt.Errorf("unknown DeliverySlot field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeliverySlotMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.business_unit != nil {
		edges = append(edges, deliveryslot.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, deliveryslot.EdgeOrganization)
	}
	if m.customer != nil {
		edges = append(edges, deliveryslot.EdgeCustomer)
	}
	if m.location != nil {
		edges = append(edges, deliveryslot.EdgeLocation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeliverySlotMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deliveryslot.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case deliveryslot.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case deliveryslot.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	case deliveryslot.EdgeLocation:
		if id := m.location; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeliverySlotMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeliverySlotMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeliverySlotMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedbusiness_unit {
		edges = append(edges, deliveryslot.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, deliveryslot.EdgeOrganization)
	}
	if m.clearedcustomer {
		edges = append(edges, deliveryslot.EdgeCustomer)
	}
	if m.clearedlocation {
		edges = append(edges, deliveryslot.EdgeLocation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeliverySlotMutation) EdgeCleared(name string) bool {
	switch name {
	case deliveryslot.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case deliveryslot.EdgeOrganization:
		return m.clearedorganization
	case deliveryslot.EdgeCustomer:
		return m.clearedcustomer
	case deliveryslot.EdgeLocation:
		return m.clearedlocation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeliverySlotMutation) ClearEdge(name string) error {
	switch name {
	case deliveryslot.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case deliveryslot.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case deliveryslot.EdgeCustomer:
		m.ClearCustomer()
		return nil
	case deliveryslot.EdgeLocation:
		m.ClearLocation()
		return nil
	}
	return fmt.Errorf("unknown DeliverySlot unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeliverySlotMutation) ResetEdge(name string) error {
	switch name {
	case deliveryslot.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case deliveryslot.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case deliveryslot.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case deliveryslot.EdgeLocation:
		m.ResetLocation()
		return nil
	}
	return fmt.Errorf("unknown DeliverySlot edge %s", name)
}

// DispatchControlMutation represents an operation that mutates the DispatchControl nodes in the graph.
type DispatchControlMutation struct {
	config
	op                              Op
	typ                             string
	id                              *uuid.UUID
	created_at                      *time.Time
	updated_at                      *time.Time
	record_service_incident         *dispatchcontrol.RecordServiceIncident
	deadhead_target                 *float64
	adddeadhead_target              *float64
	max_shipment_weight_limit       *int32
	addmax_shipment_weight_limit    *int32
	grace_period                    *uint8
	addgrace_period                 *int8
	enforce_worker_assign           *bool
	trailer_continuity              *bool
	dupe_trailer_check              *bool
	maintenance_compliance          *bool
	regulatory_check                *bool
	prev_shipment_on_hold           *bool
	worker_time_away_restriction    *bool
	tractor_worker_fleet_constraint *bool
	clearedFields                   map[string]struct{}
	organization                    *uuid.UUID
	clearedorganization             bool
	business_unit                   *uuid.UUID
	clearedbusiness_unit            bool
	done                            bool
	oldValue                        func(context.Context) (*DispatchControl, error)
	predicates                      []predicate.DispatchControl
}

var _ ent.Mutation = (*DispatchControlMutation)(nil)

// dispatchcontrolOption allows management of the mutation configuration using functional options.
type dispatchcontrolOption func(*DispatchControlMutation)

// newDispatchControlMutation creates new mutation for the DispatchControl entity.
func newDispatchControlMutation(c config, op Op, opts ...dispatchcontrolOption) *DispatchControlMutation {
	m := &DispatchControlMutation{
		config:        c,
		op:            op,
		typ:           TypeDispatchControl,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDispatchControlID sets the ID field of the mutation.
func withDispatchControlID(id uuid.UUID) dispatchcontrolOption {
	return func(m *DispatchControlMutation) {
		var (
			err   error
			once  sync.Once
			value *DispatchControl
		)
		m.oldValue = func(ctx context.Context) (*DispatchControl, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DispatchControl.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDispatchControl sets the old DispatchControl of the mutation.
func withDispatchControl(node *DispatchControl) dispatchcontrolOption {
	return func(m *DispatchControlMutation) {
		m.oldValue = func(context.Context) (*DispatchControl, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DispatchControlMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DispatchControlMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DispatchControl entities.
func (m *DispatchControlMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DispatchControlMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DispatchControlMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DispatchControl.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DispatchControlMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DispatchControlMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DispatchControl entity.
// If the DispatchControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DispatchControlMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DispatchControlMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DispatchControlMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DispatchControlMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DispatchControl entity.
// If the DispatchControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DispatchControlMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DispatchControlMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetRecordServiceIncident sets the "record_service_incident" field.
func (m *DispatchControlMutation) SetRecordServiceIncident(dsi dispatchcontrol.RecordServiceIncident) {
	m.record_service_incident = &dsi
}

// RecordServiceIncident returns the value of the "record_service_incident" field in the mutation.
func (m *DispatchControlMutation) RecordServiceIncident() (r dispatchcontrol.RecordServiceIncident, exists bool) {
	v := m.record_service_incident
	if v == nil {
		return
	}
	return *v, true
}

// OldRecordServiceIncident returns the old "record_service_incident" field's value of the DispatchControl entity.
// If the DispatchControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DispatchControlMutation) OldRecordServiceIncident(ctx context.Context) (v dispatchcontrol.RecordServiceIncident, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecordServiceIncident is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecordServiceIncident requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecordServiceIncident: %w", err)
	}
	return oldValue.RecordServiceIncident, nil
}

// ResetRecordServiceIncident resets all changes to the "record_service_incident" field.
func (m *DispatchControlMutation) ResetRecordServiceIncident() {
	m.record_service_incident = nil
}

// SetDeadheadTarget sets the "deadhead_target" field.
func (m *DispatchControlMutation) SetDeadheadTarget(f float64) {
	m.deadhead_target = &f
	m.adddeadhead_target = nil
}

// DeadheadTarget returns the value of the "deadhead_target" field in the mutation.
func (m *DispatchControlMutation) DeadheadTarget() (r float64, exists bool) {
	v := m.deadhead_target
	if v == nil {
		return
	}
	return *v, true
}

// OldDeadheadTarget returns the old "deadhead_target" field's value of the DispatchControl entity.
// If the DispatchControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DispatchControlMutation) OldDeadheadTarget(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeadheadTarget is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeadheadTarget requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeadheadTarget: %w", err)
	}
	return oldValue.DeadheadTarget, nil
}

// AddDeadheadTarget adds f to the "deadhead_target" field.
func (m *DispatchControlMutation) AddDeadheadTarget(f float64) {
	if m.adddeadhead_target != nil {
		*m.adddeadhead_target += f
	} else {
		m.adddeadhead_target = &f
	}
}

// AddedDeadheadTarget returns the value that was added to the "deadhead_target" field in this mutation.
func (m *DispatchControlMutation) AddedDeadheadTarget() (r float64, exists bool) {
	v := m.adddeadhead_target
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeadheadTarget resets all changes to the "deadhead_target" field.
func (m *DispatchControlMutation) ResetDeadheadTarget() {
	m.deadhead_target = nil
	m.adddeadhead_target = nil
}

// SetMaxShipmentWeightLimit sets the "max_shipment_weight_limit" field.
func (m *DispatchControlMutation) SetMaxShipmentWeightLimit(i int32) {
	m.max_shipment_weight_limit = &i
	m.addmax_shipment_weight_limit = nil
}

// MaxShipmentWeightLimit returns the value of the "max_shipment_weight_limit" field in the mutation.
func (m *DispatchControlMutation) MaxShipmentWeightLimit() (r int32, exists bool) {
	v := m.max_shipment_weight_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxShipmentWeightLimit returns the old "max_shipment_weight_limit" field's value of the DispatchControl entity.
// If the DispatchControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DispatchControlMutation) OldMaxShipmentWeightLimit(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxShipmentWeightLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxShipmentWeightLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxShipmentWeightLimit: %w", err)
	}
	return oldValue.MaxShipmentWeightLimit, nil
}

// AddMaxShipmentWeightLimit adds i to the "max_shipment_weight_limit" field.
func (m *DispatchControlMutation) AddMaxShipmentWeightLimit(i int32) {
	if m.addmax_shipment_weight_limit != nil {
		*m.addmax_shipment_weight_limit += i
	} else {
		m.addmax_shipment_weight_limit = &i
	}
}

// AddedMaxShipmentWeightLimit returns the value that was added to the "max_shipment_weight_limit" field in this mutation.
func (m *DispatchControlMutation) AddedMaxShipmentWeightLimit() (r int32, exists bool) {
	v := m.addmax_shipment_weight_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxShipmentWeightLimit resets all changes to the "max_shipment_weight_limit" field.
func (m *DispatchControlMutation) ResetMaxShipmentWeightLimit() {
	m.max_shipment_weight_limit = nil
	m.addmax_shipment_weight_limit = nil
}

// SetGracePeriod sets the "grace_period" field.
func (m *DispatchControlMutation) SetGracePeriod(u uint8) {
	m.grace_period = &u
	m.addgrace_period = nil
}

// GracePeriod returns the value of the "grace_period" field in the mutation.
func (m *DispatchControlMutation) GracePeriod() (r uint8, exists bool) {
	v := m.grace_period
	if v == nil {
		return
	}
	return *v, true
}

// OldGracePeriod returns the old "grace_period" field's value of the DispatchControl entity.
// If the DispatchControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DispatchControlMutation) OldGracePeriod(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGracePeriod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGracePeriod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGracePeriod: %w", err)
	}
	return oldValue.GracePeriod, nil
}

// AddGracePeriod adds u to the "grace_period" field.
func (m *DispatchControlMutation) AddGracePeriod(u int8) {
	if m.addgrace_period != nil {
		*m.addgrace_period += u
	} else {
		m.addgrace_period = &u
	}
}

// AddedGracePeriod returns the value that was added to the "grace_period" field in this mutation.
func (m *DispatchControlMutation) AddedGracePeriod() (r int8, exists bool) {
	v := m.addgrace_period
	if v == nil {
		return
	}
	return *v, true
}

// ResetGracePeriod resets all changes to the "grace_period" field.
func (m *DispatchControlMutation) ResetGracePeriod() {
	m.grace_period = nil
	m.addgrace_period = nil
}

// SetEnforceWorkerAssign sets the "enforce_worker_assign" field.
func (m *DispatchControlMutation) SetEnforceWorkerAssign(b bool) {
	m.enforce_worker_assign = &b
}

// EnforceWorkerAssign returns the value of the "enforce_worker_assign" field in the mutation.
func (m *DispatchControlMutation) EnforceWorkerAssign() (r bool, exists bool) {
	v := m.enforce_worker_assign
	if v == nil {
		return
	}
	return *v, true
}

// OldEnforceWorkerAssign returns the old "enforce_worker_assign" field's value of the DispatchControl entity.
// If the DispatchControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DispatchControlMutation) OldEnforceWorkerAssign(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnforceWorkerAssign is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnforceWorkerAssign requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnforceWorkerAssign: %w", err)
	}
	return oldValue.EnforceWorkerAssign, nil
}

// ResetEnforceWorkerAssign resets all changes to the "enforce_worker_assign" field.
func (m *DispatchControlMutation) ResetEnforceWorkerAssign() {
	m.enforce_worker_assign = nil
}

// SetTrailerContinuity sets the "trailer_continuity" field.
func (m *DispatchControlMutation) SetTrailerContinuity(b bool) {
	m.trailer_continuity = &b
}

// TrailerContinuity returns the value of the "trailer_continuity" field in the mutation.
func (m *DispatchControlMutation) TrailerContinuity() (r bool, exists bool) {
	v := m.trailer_continuity
	if v == nil {
		return
	}
	return *v, true
}

// OldTrailerContinuity returns the old "trailer_continuity" field's value of the DispatchControl entity.
// If the DispatchControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DispatchControlMutation) OldTrailerContinuity(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrailerContinuity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrailerContinuity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrailerContinuity: %w", err)
	}
	return oldValue.TrailerContinuity, nil
}

// ResetTrailerContinuity resets all changes to the "trailer_continuity" field.
func (m *DispatchControlMutation) ResetTrailerContinuity() {
	m.trailer_continuity = nil
}

// SetDupeTrailerCheck sets the "dupe_trailer_check" field.
func (m *DispatchControlMutation) SetDupeTrailerCheck(b bool) {
	m.dupe_trailer_check = &b
}

// DupeTrailerCheck returns the value of the "dupe_trailer_check" field in the mutation.
func (m *DispatchControlMutation) DupeTrailerCheck() (r bool, exists bool) {
	v := m.dupe_trailer_check
	if v == nil {
		return
	}
	return *v, true
}

// OldDupeTrailerCheck returns the old "dupe_trailer_check" field's value of the DispatchControl entity.
// If the DispatchControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DispatchControlMutation) OldDupeTrailerCheck(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDupeTrailerCheck is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDupeTrailerCheck requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDupeTrailerCheck: %w", err)
	}
	return oldValue.DupeTrailerCheck, nil
}

// ResetDupeTrailerCheck resets all changes to the "dupe_trailer_check" field.
func (m *DispatchControlMutation) ResetDupeTrailerCheck() {
	m.dupe_trailer_check = nil
}

// SetMaintenanceCompliance sets the "maintenance_compliance" field.
func (m *DispatchControlMutation) SetMaintenanceCompliance(b bool) {
	m.maintenance_compliance = &b
}

// MaintenanceCompliance returns the value of the "maintenance_compliance" field in the mutation.
func (m *DispatchControlMutation) MaintenanceCompliance() (r bool, exists bool) {
	v := m.maintenance_compliance
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintenanceCompliance returns the old "maintenance_compliance" field's value of the DispatchControl entity.
// If the DispatchControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DispatchControlMutation) OldMaintenanceCompliance(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintenanceCompliance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintenanceCompliance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintenanceCompliance: %w", err)
	}
	return oldValue.MaintenanceCompliance, nil
}

// ResetMaintenanceCompliance resets all changes to the "maintenance_compliance" field.
func (m *DispatchControlMutation) ResetMaintenanceCompliance() {
	m.maintenance_compliance = nil
}

// SetRegulatoryCheck sets the "regulatory_check" field.
func (m *DispatchControlMutation) SetRegulatoryCheck(b bool) {
	m.regulatory_check = &b
}

// RegulatoryCheck returns the value of the "regulatory_check" field in the mutation.
func (m *DispatchControlMutation) RegulatoryCheck() (r bool, exists bool) {
	v := m.regulatory_check
	if v == nil {
		return
	}
	return *v, true
}

// OldRegulatoryCheck returns the old "regulatory_check" field's value of the DispatchControl entity.
// If the DispatchControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DispatchControlMutation) OldRegulatoryCheck(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegulatoryCheck is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegulatoryCheck requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegulatoryCheck: %w", err)
	}
	return oldValue.RegulatoryCheck, nil
}

// ResetRegulatoryCheck resets all changes to the "regulatory_check" field.
func (m *DispatchControlMutation) ResetRegulatoryCheck() {
	m.regulatory_check = nil
}

// SetPrevShipmentOnHold sets the "prev_shipment_on_hold" field.
func (m *DispatchControlMutation) SetPrevShipmentOnHold(b bool) {
	m.prev_shipment_on_hold = &b
}

// PrevShipmentOnHold returns the value of the "prev_shipment_on_hold" field in the mutation.
func (m *DispatchControlMutation) PrevShipmentOnHold() (r bool, exists bool) {
	v := m.prev_shipment_on_hold
	if v == nil {
		return
	}
	return *v, true
}

// OldPrevShipmentOnHold returns the old "prev_shipment_on_hold" field's value of the DispatchControl entity.
// If the DispatchControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DispatchControlMutation) OldPrevShipmentOnHold(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrevShipmentOnHold is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrevShipmentOnHold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrevShipmentOnHold: %w", err)
	}
	return oldValue.PrevShipmentOnHold, nil
}

// ResetPrevShipmentOnHold resets all changes to the "prev_shipment_on_hold" field.
func (m *DispatchControlMutation) ResetPrevShipmentOnHold() {
	m.prev_shipment_on_hold = nil
}

// SetWorkerTimeAwayRestriction sets the "worker_time_away_restriction" field.
func (m *DispatchControlMutation) SetWorkerTimeAwayRestriction(b bool) {
	m.worker_time_away_restriction = &b
}

// WorkerTimeAwayRestriction returns the value of the "worker_time_away_restriction" field in the mutation.
func (m *DispatchControlMutation) WorkerTimeAwayRestriction() (r bool, exists bool) {
	v := m.worker_time_away_restriction
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkerTimeAwayRestriction returns the old "worker_time_away_restriction" field's value of the DispatchControl entity.
// If the DispatchControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DispatchControlMutation) OldWorkerTimeAwayRestriction(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkerTimeAwayRestriction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkerTimeAwayRestriction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkerTimeAwayRestriction: %w", err)
	}
	return oldValue.WorkerTimeAwayRestriction, nil
}

// ResetWorkerTimeAwayRestriction resets all changes to the "worker_time_away_restriction" field.
func (m *DispatchControlMutation) ResetWorkerTimeAwayRestriction() {
	m.worker_time_away_restriction = nil
}

// SetTractorWorkerFleetConstraint sets the "tractor_worker_fleet_constraint" field.
func (m *DispatchControlMutation) SetTractorWorkerFleetConstraint(b bool) {
	m.tractor_worker_fleet_constraint = &b
}

// TractorWorkerFleetConstraint returns the value of the "tractor_worker_fleet_constraint" field in the mutation.
func (m *DispatchControlMutation) TractorWorkerFleetConstraint() (r bool, exists bool) {
	v := m.tractor_worker_fleet_constraint
	if v == nil {
		return
	}
	return *v, true
}

// OldTractorWorkerFleetConstraint returns the old "tractor_worker_fleet_constraint" field's value of the DispatchControl entity.
// If the DispatchControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DispatchControlMutation) OldTractorWorkerFleetConstraint(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTractorWorkerFleetConstraint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTractorWorkerFleetConstraint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTractorWorkerFleetConstraint: %w", err)
	}
	return oldValue.TractorWorkerFleetConstraint, nil
}

// ResetTractorWorkerFleetConstraint resets all changes to the "tractor_worker_fleet_constraint" field.
func (m *DispatchControlMutation) ResetTractorWorkerFleetConstraint() {
	m.tractor_worker_fleet_constraint = nil
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *DispatchControlMutation) SetOrganizationID(id uuid.UUID) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *DispatchControlMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *DispatchControlMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *DispatchControlMutation) OrganizationID() (id uuid.UUID, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *DispatchControlMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *DispatchControlMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// SetBusinessUnitID sets the "business_unit" edge to the BusinessUnit entity by id.
func (m *DispatchControlMutation) SetBusinessUnitID(id uuid.UUID) {
	m.business_unit = &id
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *DispatchControlMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *DispatchControlMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitID returns the "business_unit" edge ID in the mutation.
func (m *DispatchControlMutation) BusinessUnitID() (id uuid.UUID, exists bool) {
	if m.business_unit != nil {
		return *m.business_unit, true
	}
	return
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *DispatchControlMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *DispatchControlMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// Where appends a list predicates to the DispatchControlMutation builder.
func (m *DispatchControlMutation) Where(ps ...predicate.DispatchControl) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DispatchControlMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DispatchControlMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DispatchControl, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DispatchControlMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DispatchControlMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DispatchControl).
func (m *DispatchControlMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DispatchControlMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, dispatchcontrol.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dispatchcontrol.FieldUpdatedAt)
	}
	if m.record_service_incident != nil {
		fields = append(fields, dispatchcontrol.FieldRecordServiceIncident)
	}
	if m.deadhead_target != nil {
		fields = append(fields, dispatchcontrol.FieldDeadheadTarget)
	}
	if m.max_shipment_weight_limit != nil {
		fields = append(fields, dispatchcontrol.FieldMaxShipmentWeightLimit)
	}
	if m.grace_period != nil {
		fields = append(fields, dispatchcontrol.FieldGracePeriod)
	}
	if m.enforce_worker_assign != nil {
		fields = append(fields, dispatchcontrol.FieldEnforceWorkerAssign)
	}
	if m.trailer_continuity != nil {
		fields = append(fields, dispatchcontrol.FieldTrailerContinuity)
	}
	if m.dupe_trailer_check != nil {
		fields = append(fields, dispatchcontrol.FieldDupeTrailerCheck)
	}
	if m.maintenance_compliance != nil {
		fields = append(fields, dispatchcontrol.FieldMaintenanceCompliance)
	}
	if m.regulatory_check != nil {
		fields = append(fields, dispatchcontrol.FieldRegulatoryCheck)
	}
	if m.prev_shipment_on_hold != nil {
		fields = append(fields, dispatchcontrol.FieldPrevShipmentOnHold)
	}
	if m.worker_time_away_restriction != nil {
		fields = append(fields, dispatchcontrol.FieldWorkerTimeAwayRestriction)
	}
	if m.tractor_worker_fleet_constraint != nil {
		fields = append(fields, dispatchcontrol.FieldTractorWorkerFleetConstraint)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DispatchControlMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dispatchcontrol.FieldCreatedAt:
		return m.CreatedAt()
	case dispatchcontrol.FieldUpdatedAt:
		return m.UpdatedAt()
	case dispatchcontrol.FieldRecordServiceIncident:
		return m.RecordServiceIncident()
	case dispatchcontrol.FieldDeadheadTarget:
		return m.DeadheadTarget()
	case dispatchcontrol.FieldMaxShipmentWeightLimit:
		return m.MaxShipmentWeightLimit()
	case dispatchcontrol.FieldGracePeriod:
		return m.GracePeriod()
	case dispatchcontrol.FieldEnforceWorkerAssign:
		return m.EnforceWorkerAssign()
	case dispatchcontrol.FieldTrailerContinuity:
		return m.TrailerContinuity()
	case dispatchcontrol.FieldDupeTrailerCheck:
		return m.DupeTrailerCheck()
	case dispatchcontrol.FieldMaintenanceCompliance:
		return m.MaintenanceCompliance()
	case dispatchcontrol.FieldRegulatoryCheck:
		return m.RegulatoryCheck()
	case dispatchcontrol.FieldPrevShipmentOnHold:
		return m.PrevShipmentOnHold()
	case dispatchcontrol.FieldWorkerTimeAwayRestriction:
		return m.WorkerTimeAwayRestriction()
	case dispatchcontrol.FieldTractorWorkerFleetConstraint:
		return m.TractorWorkerFleetConstraint()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DispatchControlMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dispatchcontrol.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dispatchcontrol.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dispatchcontrol.FieldRecordServiceIncident:
		return m.OldRecordServiceIncident(ctx)
	case dispatchcontrol.FieldDeadheadTarget:
		return m.OldDeadheadTarget(ctx)
	case dispatchcontrol.FieldMaxShipmentWeightLimit:
		return m.OldMaxShipmentWeightLimit(ctx)
	case dispatchcontrol.FieldGracePeriod:
		return m.OldGracePeriod(ctx)
	case dispatchcontrol.FieldEnforceWorkerAssign:
		return m.OldEnforceWorkerAssign(ctx)
	case dispatchcontrol.FieldTrailerContinuity:
		return m.OldTrailerContinuity(ctx)
	case dispatchcontrol.FieldDupeTrailerCheck:
		return m.OldDupeTrailerCheck(ctx)
	case dispatchcontrol.FieldMaintenanceCompliance:
		return m.OldMaintenanceCompliance(ctx)
	case dispatchcontrol.FieldRegulatoryCheck:
		return m.OldRegulatoryCheck(ctx)
	case dispatchcontrol.FieldPrevShipmentOnHold:
		return m.OldPrevShipmentOnHold(ctx)
	case dispatchcontrol.FieldWorkerTimeAwayRestriction:
		return m.OldWorkerTimeAwayRestriction(ctx)
	case dispatchcontrol.FieldTractorWorkerFleetConstraint:
		return m.OldTractorWorkerFleetConstraint(ctx)
	}
	return nil, fmt.Errorf("unknown DispatchControl field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DispatchControlMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dispatchcontrol.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dispatchcontrol.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dispatchcontrol.FieldRecordServiceIncident:
		v, ok := value.(dispatchcontrol.RecordServiceIncident)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecordServiceIncident(v)
		return nil
	case dispatchcontrol.FieldDeadheadTarget:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeadheadTarget(v)
		return nil
	case dispatchcontrol.FieldMaxShipmentWeightLimit:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxShipmentWeightLimit(v)
		return nil
	case dispatchcontrol.FieldGracePeriod:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGracePeriod(v)
		return nil
	case dispatchcontrol.FieldEnforceWorkerAssign:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnforceWorkerAssign(v)
		return nil
	case dispatchcontrol.FieldTrailerContinuity:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrailerContinuity(v)
		return nil
	case dispatchcontrol.FieldDupeTrailerCheck:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDupeTrailerCheck(v)
		return nil
	case dispatchcontrol.FieldMaintenanceCompliance:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintenanceCompliance(v)
		return nil
	case dispatchcontrol.FieldRegulatoryCheck:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegulatoryCheck(v)
		return nil
	case dispatchcontrol.FieldPrevShipmentOnHold:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrevShipmentOnHold(v)
		return nil
	case dispatchcontrol.FieldWorkerTimeAwayRestriction:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkerTimeAwayRestriction(v)
		return nil
	case dispatchcontrol.FieldTractorWorkerFleetConstraint:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTractorWorkerFleetConstraint(v)
		return nil
	}
	return fmt.Errorf("unknown DispatchControl field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DispatchControlMutation) AddedFields() []string {
	var fields []string
	if m.adddeadhead_target != nil {
		fields = append(fields, dispatchcontrol.FieldDeadheadTarget)
	}
	if m.addmax_shipment_weight_limit != nil {
		fields = append(fields, dispatchcontrol.FieldMaxShipmentWeightLimit)
	}
	if m.addgrace_period != nil {
		fields = append(fields, dispatchcontrol.FieldGracePeriod)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DispatchControlMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dispatchcontrol.FieldDeadheadTarget:
		return m.AddedDeadheadTarget()
	case dispatchcontrol.FieldMaxShipmentWeightLimit:
		return m.AddedMaxShipmentWeightLimit()
	case dispatchcontrol.FieldGracePeriod:
		return m.AddedGracePeriod()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DispatchControlMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dispatchcontrol.FieldDeadheadTarget:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeadheadTarget(v)
		return nil
	case dispatchcontrol.FieldMaxShipmentWeightLimit:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxShipmentWeightLimit(v)
		return nil
	case dispatchcontrol.FieldGracePeriod:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGracePeriod(v)
		return nil
	}
	return fmt.Errorf("unknown DispatchControl numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DispatchControlMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DispatchControlMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DispatchControlMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DispatchControl nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DispatchControlMutation) ResetField(name string) error {
	switch name {
	case dispatchcontrol.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dispatchcontrol.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dispatchcontrol.FieldRecordServiceIncident:
		m.ResetRecordServiceIncident()
		return nil
	case dispatchcontrol.FieldDeadheadTarget:
		m.ResetDeadheadTarget()
		return nil
	case dispatchcontrol.FieldMaxShipmentWeightLimit:
		m.ResetMaxShipmentWeightLimit()
		return nil
	case dispatchcontrol.FieldGracePeriod:
		m.ResetGracePeriod()
		return nil
	case dispatchcontrol.FieldEnforceWorkerAssign:
		m.ResetEnforceWorkerAssign()
		return nil
	case dispatchcontrol.FieldTrailerContinuity:
		m.ResetTrailerContinuity()
		return nil
	case dispatchcontrol.FieldDupeTrailerCheck:
		m.ResetDupeTrailerCheck()
		return nil
	case dispatchcontrol.FieldMaintenanceCompliance:
		m.ResetMaintenanceCompliance()
		return nil
	case dispatchcontrol.FieldRegulatoryCheck:
		m.ResetRegulatoryCheck()
		return nil
	case dispatchcontrol.FieldPrevShipmentOnHold:
		m.ResetPrevShipmentOnHold()
		return nil
	case dispatchcontrol.FieldWorkerTimeAwayRestriction:
		m.ResetWorkerTimeAwayRestriction()
		return nil
	case dispatchcontrol.FieldTractorWorkerFleetConstraint:
		m.ResetTractorWorkerFleetConstraint()
		return nil
	}
	return fmt.Errorf("unknown DispatchControl field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DispatchControlMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.organization != nil {
		edges = append(edges, dispatchcontrol.EdgeOrganization)
	}
	if m.business_unit != nil {
		edges = append(edges, dispatchcontrol.EdgeBusinessUnit)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DispatchControlMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dispatchcontrol.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case dispatchcontrol.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DispatchControlMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DispatchControlMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DispatchControlMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorganization {
		edges = append(edges, dispatchcontrol.EdgeOrganization)
	}
	if m.clearedbusiness_unit {
		edges = append(edges, dispatchcontrol.EdgeBusinessUnit)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DispatchControlMutation) EdgeCleared(name string) bool {
	switch name {
	case dispatchcontrol.EdgeOrganization:
		return m.clearedorganization
	case dispatchcontrol.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DispatchControlMutation) ClearEdge(name string) error {
	switch name {
	case dispatchcontrol.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case dispatchcontrol.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	}
	return fmt.Errorf("unknown DispatchControl unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DispatchControlMutation) ResetEdge(name string) error {
	switch name {
	case dispatchcontrol.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case dispatchcontrol.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	}
	return fmt.Errorf("unknown DispatchControl edge %s", name)
}

// DivisionCodeMutation represents an operation that mutates the DivisionCode nodes in the graph.
type DivisionCodeMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	created_at             *time.Time
	updated_at             *time.Time
	version                *int
	addversion             *int
	status                 *divisioncode.Status
	code                   *string
	description            *string
	clearedFields          map[string]struct{}
	business_unit          *uuid.UUID
	clearedbusiness_unit   bool
	organization           *uuid.UUID
	clearedorganization    bool
	cash_account           *uuid.UUID
	clearedcash_account    bool
	ap_account             *uuid.UUID
	clearedap_account      bool
	expense_account        *uuid.UUID
	clearedexpense_account bool
	done                   bool
	oldValue               func(context.Context) (*DivisionCode, error)
	predicates             []predicate.DivisionCode
}

var _ ent.Mutation = (*DivisionCodeMutation)(nil)

// divisioncodeOption allows management of the mutation configuration using functional options.
type divisioncodeOption func(*DivisionCodeMutation)

// newDivisionCodeMutation creates new mutation for the DivisionCode entity.
func newDivisionCodeMutation(c config, op Op, opts ...divisioncodeOption) *DivisionCodeMutation {
	m := &DivisionCodeMutation{
		config:        c,
		op:            op,
		typ:           TypeDivisionCode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDivisionCodeID sets the ID field of the mutation.
func withDivisionCodeID(id uuid.UUID) divisioncodeOption {
	return func(m *DivisionCodeMutation) {
		var (
			err   error
			once  sync.Once
			value *DivisionCode
		)
		m.oldValue = func(ctx context.Context) (*DivisionCode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DivisionCode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDivisionCode sets the old DivisionCode of the mutation.
func withDivisionCode(node *DivisionCode) divisioncodeOption {
	return func(m *DivisionCodeMutation) {
		m.oldValue = func(context.Context) (*DivisionCode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DivisionCodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DivisionCodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DivisionCode entities.
func (m *DivisionCodeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DivisionCodeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DivisionCodeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DivisionCode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *DivisionCodeMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *DivisionCodeMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the DivisionCode entity.
// If the DivisionCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionCodeMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *DivisionCodeMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *DivisionCodeMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *DivisionCodeMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the DivisionCode entity.
// If the DivisionCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionCodeMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *DivisionCodeMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DivisionCodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DivisionCodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DivisionCode entity.
// If the DivisionCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionCodeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DivisionCodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DivisionCodeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DivisionCodeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DivisionCode entity.
// If the DivisionCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionCodeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DivisionCodeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *DivisionCodeMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *DivisionCodeMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the DivisionCode entity.
// If the DivisionCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionCodeMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *DivisionCodeMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *DivisionCodeMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *DivisionCodeMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetStatus sets the "status" field.
func (m *DivisionCodeMutation) SetStatus(d divisioncode.Status) {
	m.status = &d
}

// Status returns the value of the "status" field in the mutation.
func (m *DivisionCodeMutation) Status() (r divisioncode.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the DivisionCode entity.
// If the DivisionCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionCodeMutation) OldStatus(ctx context.Context) (v divisioncode.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *DivisionCodeMutation) ResetStatus() {
	m.status = nil
}

// SetCode sets the "code" field.
func (m *DivisionCodeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *DivisionCodeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the DivisionCode entity.
// If the DivisionCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionCodeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *DivisionCodeMutation) ResetCode() {
	m.code = nil
}

// SetDescription sets the "description" field.
func (m *DivisionCodeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DivisionCodeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the DivisionCode entity.
// If the DivisionCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionCodeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *DivisionCodeMutation) ResetDescription() {
	m.description = nil
}

// SetCashAccountID sets the "cash_account_id" field.
func (m *DivisionCodeMutation) SetCashAccountID(u uuid.UUID) {
	m.cash_account = &u
}

// CashAccountID returns the value of the "cash_account_id" field in the mutation.
func (m *DivisionCodeMutation) CashAccountID() (r uuid.UUID, exists bool) {
	v := m.cash_account
	if v == nil {
		return
	}
	return *v, true
}

// OldCashAccountID returns the old "cash_account_id" field's value of the DivisionCode entity.
// If the DivisionCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionCodeMutation) OldCashAccountID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCashAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCashAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCashAccountID: %w", err)
	}
	return oldValue.CashAccountID, nil
}

// ClearCashAccountID clears the value of the "cash_account_id" field.
func (m *DivisionCodeMutation) ClearCashAccountID() {
	m.cash_account = nil
	m.clearedFields[divisioncode.FieldCashAccountID] = struct{}{}
}

// CashAccountIDCleared returns if the "cash_account_id" field was cleared in this mutation.
func (m *DivisionCodeMutation) CashAccountIDCleared() bool {
	_, ok := m.clearedFields[divisioncode.FieldCashAccountID]
	return ok
}

// ResetCashAccountID resets all changes to the "cash_account_id" field.
func (m *DivisionCodeMutation) ResetCashAccountID() {
	m.cash_account = nil
	delete(m.clearedFields, divisioncode.FieldCashAccountID)
}

// SetApAccountID sets the "ap_account_id" field.
func (m *DivisionCodeMutation) SetApAccountID(u uuid.UUID) {
	m.ap_account = &u
}

// ApAccountID returns the value of the "ap_account_id" field in the mutation.
func (m *DivisionCodeMutation) ApAccountID() (r uuid.UUID, exists bool) {
	v := m.ap_account
	if v == nil {
		return
	}
	return *v, true
}

// OldApAccountID returns the old "ap_account_id" field's value of the DivisionCode entity.
// If the DivisionCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionCodeMutation) OldApAccountID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApAccountID: %w", err)
	}
	return oldValue.ApAccountID, nil
}

// ClearApAccountID clears the value of the "ap_account_id" field.
func (m *DivisionCodeMutation) ClearApAccountID() {
	m.ap_account = nil
	m.clearedFields[divisioncode.FieldApAccountID] = struct{}{}
}

// ApAccountIDCleared returns if the "ap_account_id" field was cleared in this mutation.
func (m *DivisionCodeMutation) ApAccountIDCleared() bool {
	_, ok := m.clearedFields[divisioncode.FieldApAccountID]
	return ok
}

// ResetApAccountID resets all changes to the "ap_account_id" field.
func (m *DivisionCodeMutation) ResetApAccountID() {
	m.ap_account = nil
	delete(m.clearedFields, divisioncode.FieldApAccountID)
}

// SetExpenseAccountID sets the "expense_account_id" field.
func (m *DivisionCodeMutation) SetExpenseAccountID(u uuid.UUID) {
	m.expense_account = &u
}

// ExpenseAccountID returns the value of the "expense_account_id" field in the mutation.
func (m *DivisionCodeMutation) ExpenseAccountID() (r uuid.UUID, exists bool) {
	v := m.expense_account
	if v == nil {
		return
	}
	return *v, true
}

// OldExpenseAccountID returns the old "expense_account_id" field's value of the DivisionCode entity.
// If the DivisionCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionCodeMutation) OldExpenseAccountID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpenseAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpenseAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpenseAccountID: %w", err)
	}
	return oldValue.ExpenseAccountID, nil
}

// ClearExpenseAccountID clears the value of the "expense_account_id" field.
func (m *DivisionCodeMutation) ClearExpenseAccountID() {
	m.expense_account = nil
	m.clearedFields[divisioncode.FieldExpenseAccountID] = struct{}{}
}

// ExpenseAccountIDCleared returns if the "expense_account_id" field was cleared in this mutation.
func (m *DivisionCodeMutation) ExpenseAccountIDCleared() bool {
	_, ok := m.clearedFields[divisioncode.FieldExpenseAccountID]
	return ok
}

// ResetExpenseAccountID resets all changes to the "expense_account_id" field.
func (m *DivisionCodeMutation) ResetExpenseAccountID() {
	m.expense_account = nil
	delete(m.clearedFields, divisioncode.FieldExpenseAccountID)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *DivisionCodeMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[divisioncode.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *DivisionCodeMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *DivisionCodeMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *DivisionCodeMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *DivisionCodeMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[divisioncode.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *DivisionCodeMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *DivisionCodeMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *DivisionCodeMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearCashAccount clears the "cash_account" edge to the GeneralLedgerAccount entity.
func (m *DivisionCodeMutation) ClearCashAccount() {
	m.clearedcash_account = true
	m.clearedFields[divisioncode.FieldCashAccountID] = struct{}{}
}

// CashAccountCleared reports if the "cash_account" edge to the GeneralLedgerAccount entity was cleared.
func (m *DivisionCodeMutation) CashAccountCleared() bool {
	return m.CashAccountIDCleared() || m.clearedcash_account
}

// CashAccountIDs returns the "cash_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CashAccountID instead. It exists only for internal usage by the builders.
func (m *DivisionCodeMutation) CashAccountIDs() (ids []uuid.UUID) {
	if id := m.cash_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCashAccount resets all changes to the "cash_account" edge.
func (m *DivisionCodeMutation) ResetCashAccount() {
	m.cash_account = nil
	m.clearedcash_account = false
}

// ClearApAccount clears the "ap_account" edge to the GeneralLedgerAccount entity.
func (m *DivisionCodeMutation) ClearApAccount() {
	m.clearedap_account = true
	m.clearedFields[divisioncode.FieldApAccountID] = struct{}{}
}

// ApAccountCleared reports if the "ap_account" edge to the GeneralLedgerAccount entity was cleared.
func (m *DivisionCodeMutation) ApAccountCleared() bool {
	return m.ApAccountIDCleared() || m.clearedap_account
}

// ApAccountIDs returns the "ap_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ApAccountID instead. It exists only for internal usage by the builders.
func (m *DivisionCodeMutation) ApAccountIDs() (ids []uuid.UUID) {
	if id := m.ap_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApAccount resets all changes to the "ap_account" edge.
func (m *DivisionCodeMutation) ResetApAccount() {
	m.ap_account = nil
	m.clearedap_account = false
}

// ClearExpenseAccount clears the "expense_account" edge to the GeneralLedgerAccount entity.
func (m *DivisionCodeMutation) ClearExpenseAccount() {
	m.clearedexpense_account = true
	m.clearedFields[divisioncode.FieldExpenseAccountID] = struct{}{}
}

// ExpenseAccountCleared reports if the "expense_account" edge to the GeneralLedgerAccount entity was cleared.
func (m *DivisionCodeMutation) ExpenseAccountCleared() bool {
	return m.ExpenseAccountIDCleared() || m.clearedexpense_account
}

// ExpenseAccountIDs returns the "expense_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExpenseAccountID instead. It exists only for internal usage by the builders.
func (m *DivisionCodeMutation) ExpenseAccountIDs() (ids []uuid.UUID) {
	if id := m.expense_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExpenseAccount resets all changes to the "expense_account" edge.
func (m *DivisionCodeMutation) ResetExpenseAccount() {
	m.expense_account = nil
	m.clearedexpense_account = false
}

// Where appends a list predicates to the DivisionCodeMutation builder.
func (m *DivisionCodeMutation) Where(ps ...predicate.DivisionCode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DivisionCodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DivisionCodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DivisionCode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DivisionCodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DivisionCodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DivisionCode).
func (m *DivisionCodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DivisionCodeMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.business_unit != nil {
		fields = append(fields, divisioncode.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, divisioncode.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, divisioncode.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, divisioncode.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, divisioncode.FieldVersion)
	}
	if m.status != nil {
		fields = append(fields, divisioncode.FieldStatus)
	}
	if m.code != nil {
		fields = append(fields, divisioncode.FieldCode)
	}
	if m.description != nil {
		fields = append(fields, divisioncode.FieldDescription)
	}
	if m.cash_account != nil {
		fields = append(fields, divisioncode.FieldCashAccountID)
	}
	if m.ap_account != nil {
		fields = append(fields, divisioncode.FieldApAccountID)
	}
	if m.expense_account != nil {
		fields = append(fields, divisioncode.FieldExpenseAccountID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DivisionCodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case divisioncode.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case divisioncode.FieldOrganizationID:
		return m.OrganizationID()
	case divisioncode.FieldCreatedAt:
		return m.CreatedAt()
	case divisioncode.FieldUpdatedAt:
		return m.UpdatedAt()
	case divisioncode.FieldVersion:
		return m.Version()
	case divisioncode.FieldStatus:
		return m.Status()
	case divisioncode.FieldCode:
		return m.Code()
	case divisioncode.FieldDescription:
		return m.Description()
	case divisioncode.FieldCashAccountID:
		return m.CashAccountID()
	case divisioncode.FieldApAccountID:
		return m.ApAccountID()
	case divisioncode.FieldExpenseAccountID:
		return m.ExpenseAccountID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DivisionCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case divisioncode.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case divisioncode.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case divisioncode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case divisioncode.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case divisioncode.FieldVersion:
		return m.OldVersion(ctx)
	case divisioncode.FieldStatus:
		return m.OldStatus(ctx)
	case divisioncode.FieldCode:
		return m.OldCode(ctx)
	case divisioncode.FieldDescription:
		return m.OldDescription(ctx)
	case divisioncode.FieldCashAccountID:
		return m.OldCashAccountID(ctx)
	case divisioncode.FieldApAccountID:
		return m.OldApAccountID(ctx)
	case divisioncode.FieldExpenseAccountID:
		return m.OldExpenseAccountID(ctx)
	}
	return nil, fmt.Errorf("unknown DivisionCode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DivisionCodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case divisioncode.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case divisioncode.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case divisioncode.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case divisioncode.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case divisioncode.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case divisioncode.FieldStatus:
		v, ok := value.(divisioncode.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case divisioncode.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case divisioncode.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case divisioncode.FieldCashAccountID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCashAccountID(v)
		return nil
	case divisioncode.FieldApAccountID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApAccountID(v)
		return nil
	case divisioncode.FieldExpenseAccountID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpenseAccountID(v)
		return nil
	}
	return fmt.Errorf("unknown DivisionCode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DivisionCodeMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, divisioncode.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DivisionCodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case divisioncode.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DivisionCodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case divisioncode.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown DivisionCode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DivisionCodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(divisioncode.FieldCashAccountID) {
		fields = append(fields, divisioncode.FieldCashAccountID)
	}
	if m.FieldCleared(divisioncode.FieldApAccountID) {
		fields = append(fields, divisioncode.FieldApAccountID)
	}
	if m.FieldCleared(divisioncode.FieldExpenseAccountID) {
		fields = append(fields, divisioncode.FieldExpenseAccountID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DivisionCodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DivisionCodeMutation) ClearField(name string) error {
	switch name {
	case divisioncode.FieldCashAccountID:
		m.ClearCashAccountID()
		return nil
	case divisioncode.FieldApAccountID:
		m.ClearApAccountID()
		return nil
	case divisioncode.FieldExpenseAccountID:
		m.ClearExpenseAccountID()
		return nil
	}
	return fmt.Errorf("unknown DivisionCode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DivisionCodeMutation) ResetField(name string) error {
	switch name {
	case divisioncode.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case divisioncode.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case divisioncode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case divisioncode.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case divisioncode.FieldVersion:
		m.ResetVersion()
		return nil
	case divisioncode.FieldStatus:
		m.ResetStatus()
		return nil
	case divisioncode.FieldCode:
		m.ResetCode()
		return nil
	case divisioncode.FieldDescription:
		m.ResetDescription()
		return nil
	case divisioncode.FieldCashAccountID:
		m.ResetCashAccountID()
		return nil
	case divisioncode.FieldApAccountID:
		m.ResetApAccountID()
		return nil
	case divisioncode.FieldExpenseAccountID:
		m.ResetExpenseAccountID()
		return nil
	}
	return fmt.Errorf("unknown DivisionCode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DivisionCodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.business_unit != nil {
		edges = append(edges, divisioncode.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, divisioncode.EdgeOrganization)
	}
	if m.cash_account != nil {
		edges = append(edges, divisioncode.EdgeCashAccount)
	}
	if m.ap_account != nil {
		edges = append(edges, divisioncode.EdgeApAccount)
	}
	if m.expense_account != nil {
		edges = append(edges, divisioncode.EdgeExpenseAccount)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DivisionCodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case divisioncode.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case divisioncode.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case divisioncode.EdgeCashAccount:
		if id := m.cash_account; id != nil {
			return []ent.Value{*id}
		}
	case divisioncode.EdgeApAccount:
		if id := m.ap_account; id != nil {
			return []ent.Value{*id}
		}
	case divisioncode.EdgeExpenseAccount:
		if id := m.expense_account; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DivisionCodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DivisionCodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DivisionCodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedbusiness_unit {
		edges = append(edges, divisioncode.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, divisioncode.EdgeOrganization)
	}
	if m.clearedcash_account {
		edges = append(edges, divisioncode.EdgeCashAccount)
	}
	if m.clearedap_account {
		edges = append(edges, divisioncode.EdgeApAccount)
	}
	if m.clearedexpense_account {
		edges = append(edges, divisioncode.EdgeExpenseAccount)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DivisionCodeMutation) EdgeCleared(name string) bool {
	switch name {
	case divisioncode.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case divisioncode.EdgeOrganization:
		return m.clearedorganization
	case divisioncode.EdgeCashAccount:
		return m.clearedcash_account
	case divisioncode.EdgeApAccount:
		return m.clearedap_account
	case divisioncode.EdgeExpenseAccount:
		return m.clearedexpense_account
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DivisionCodeMutation) ClearEdge(name string) error {
	switch name {
	case divisioncode.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case divisioncode.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case divisioncode.EdgeCashAccount:
		m.ClearCashAccount()
		return nil
	case divisioncode.EdgeApAccount:
		m.ClearApAccount()
		return nil
	case divisioncode.EdgeExpenseAccount:
		m.ClearExpenseAccount()
		return nil
	}
	return fmt.Errorf("unknown DivisionCode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DivisionCodeMutation) ResetEdge(name string) error {
	switch name {
	case divisioncode.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case divisioncode.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case divisioncode.EdgeCashAccount:
		m.ResetCashAccount()
		return nil
	case divisioncode.EdgeApAccount:
		m.ResetApAccount()
		return nil
	case divisioncode.EdgeExpenseAccount:
		m.ResetExpenseAccount()
		return nil
	}
	return fmt.Errorf("unknown DivisionCode edge %s", name)
}

// DocumentClassificationMutation represents an operation that mutates the DocumentClassification nodes in the graph.
type DocumentClassificationMutation struct {
	config
	op                            Op
	typ                           string
	id                            *uuid.UUID
	created_at                    *time.Time
	updated_at                    *time.Time
	version                       *int
	addversion                    *int
	status                        *documentclassification.Status
	code                          *string
	description                   *string
	color                         *string
	clearedFields                 map[string]struct{}
	business_unit                 *uuid.UUID
	clearedbusiness_unit          bool
	organization                  *uuid.UUID
	clearedorganization           bool
	shipment_documentation        map[uuid.UUID]struct{}
	removedshipment_documentation map[uuid.UUID]struct{}
	clearedshipment_documentation bool
	customer_rule_profile         *uuid.UUID
	clearedcustomer_rule_profile  bool
	done                          bool
	oldValue                      func(context.Context) (*DocumentClassification, error)
	predicates                    []predicate.DocumentClassification
}

var _ ent.Mutation = (*DocumentClassificationMutation)(nil)

// documentclassificationOption allows management of the mutation configuration using functional options.
type documentclassificationOption func(*DocumentClassificationMutation)

// newDocumentClassificationMutation creates new mutation for the DocumentClassification entity.
func newDocumentClassificationMutation(c config, op Op, opts ...documentclassificationOption) *DocumentClassificationMutation {
	m := &DocumentClassificationMutation{
		config:        c,
		op:            op,
		typ:           TypeDocumentClassification,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDocumentClassificationID sets the ID field of the mutation.
func withDocumentClassificationID(id uuid.UUID) documentclassificationOption {
	return func(m *DocumentClassificationMutation) {
		var (
			err   error
			once  sync.Once
			value *DocumentClassification
		)
		m.oldValue = func(ctx context.Context) (*DocumentClassification, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DocumentClassification.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDocumentClassification sets the old DocumentClassification of the mutation.
func withDocumentClassification(node *DocumentClassification) documentclassificationOption {
	return func(m *DocumentClassificationMutation) {
		m.oldValue = func(context.Context) (*DocumentClassification, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DocumentClassificationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DocumentClassificationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DocumentClassification entities.
func (m *DocumentClassificationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DocumentClassificationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DocumentClassificationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DocumentClassification.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *DocumentClassificationMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *DocumentClassificationMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the DocumentClassification entity.
// If the DocumentClassification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentClassificationMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *DocumentClassificationMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *DocumentClassificationMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *DocumentClassificationMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the DocumentClassification entity.
// If the DocumentClassification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentClassificationMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *DocumentClassificationMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DocumentClassificationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DocumentClassificationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DocumentClassification entity.
// If the DocumentClassification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentClassificationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DocumentClassificationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DocumentClassificationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DocumentClassificationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DocumentClassification entity.
// If the DocumentClassification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentClassificationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DocumentClassificationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *DocumentClassificationMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *DocumentClassificationMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the DocumentClassification entity.
// If the DocumentClassification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentClassificationMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *DocumentClassificationMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *DocumentClassificationMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *DocumentClassificationMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetStatus sets the "status" field.
func (m *DocumentClassificationMutation) SetStatus(d documentclassification.Status) {
	m.status = &d
}

// Status returns the value of the "status" field in the mutation.
func (m *DocumentClassificationMutation) Status() (r documentclassification.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the DocumentClassification entity.
// If the DocumentClassification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentClassificationMutation) OldStatus(ctx context.Context) (v documentclassification.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *DocumentClassificationMutation) ResetStatus() {
	m.status = nil
}

// SetCode sets the "code" field.
func (m *DocumentClassificationMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *DocumentClassificationMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the DocumentClassification entity.
// If the DocumentClassification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentClassificationMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *DocumentClassificationMutation) ResetCode() {
	m.code = nil
}

// SetDescription sets the "description" field.
func (m *DocumentClassificationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DocumentClassificationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the DocumentClassification entity.
// If the DocumentClassification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentClassificationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *DocumentClassificationMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[documentclassification.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *DocumentClassificationMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[documentclassification.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *DocumentClassificationMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, documentclassification.FieldDescription)
}

// SetColor sets the "color" field.
func (m *DocumentClassificationMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *DocumentClassificationMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the DocumentClassification entity.
// If the DocumentClassification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentClassificationMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *DocumentClassificationMutation) ClearColor() {
	m.color = nil
	m.clearedFields[documentclassification.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *DocumentClassificationMutation) ColorCleared() bool {
	_, ok := m.clearedFields[documentclassification.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *DocumentClassificationMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, documentclassification.FieldColor)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *DocumentClassificationMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[documentclassification.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *DocumentClassificationMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *DocumentClassificationMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *DocumentClassificationMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *DocumentClassificationMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[documentclassification.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *DocumentClassificationMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *DocumentClassificationMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *DocumentClassificationMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// AddShipmentDocumentationIDs adds the "shipment_documentation" edge to the ShipmentDocumentation entity by ids.
func (m *DocumentClassificationMutation) AddShipmentDocumentationIDs(ids ...uuid.UUID) {
	if m.shipment_documentation == nil {
		m.shipment_documentation = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.shipment_documentation[ids[i]] = struct{}{}
	}
}

// ClearShipmentDocumentation clears the "shipment_documentation" edge to the ShipmentDocumentation entity.
func (m *DocumentClassificationMutation) ClearShipmentDocumentation() {
	m.clearedshipment_documentation = true
}

// ShipmentDocumentationCleared reports if the "shipment_documentation" edge to the ShipmentDocumentation entity was cleared.
func (m *DocumentClassificationMutation) ShipmentDocumentationCleared() bool {
	return m.clearedshipment_documentation
}

// RemoveShipmentDocumentationIDs removes the "shipment_documentation" edge to the ShipmentDocumentation entity by IDs.
func (m *DocumentClassificationMutation) RemoveShipmentDocumentationIDs(ids ...uuid.UUID) {
	if m.removedshipment_documentation == nil {
		m.removedshipment_documentation = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.shipment_documentation, ids[i])
		m.removedshipment_documentation[ids[i]] = struct{}{}
	}
}

// RemovedShipmentDocumentation returns the removed IDs of the "shipment_documentation" edge to the ShipmentDocumentation entity.
func (m *DocumentClassificationMutation) RemovedShipmentDocumentationIDs() (ids []uuid.UUID) {
	for id := range m.removedshipment_documentation {
		ids = append(ids, id)
	}
	return
}

// ShipmentDocumentationIDs returns the "shipment_documentation" edge IDs in the mutation.
func (m *DocumentClassificationMutation) ShipmentDocumentationIDs() (ids []uuid.UUID) {
	for id := range m.shipment_documentation {
		ids = append(ids, id)
	}
	return
}

// ResetShipmentDocumentation resets all changes to the "shipment_documentation" edge.
func (m *DocumentClassificationMutation) ResetShipmentDocumentation() {
	m.shipment_documentation = nil
	m.clearedshipment_documentation = false
	m.removedshipment_documentation = nil
}

// SetCustomerRuleProfileID sets the "customer_rule_profile" edge to the CustomerRuleProfile entity by id.
func (m *DocumentClassificationMutation) SetCustomerRuleProfileID(id uuid.UUID) {
	m.customer_rule_profile = &id
}

// ClearCustomerRuleProfile clears the "customer_rule_profile" edge to the CustomerRuleProfile entity.
func (m *DocumentClassificationMutation) ClearCustomerRuleProfile() {
	m.clearedcustomer_rule_profile = true
}

// CustomerRuleProfileCleared reports if the "customer_rule_profile" edge to the CustomerRuleProfile entity was cleared.
func (m *DocumentClassificationMutation) CustomerRuleProfileCleared() bool {
	return m.clearedcustomer_rule_profile
}

// CustomerRuleProfileID returns the "customer_rule_profile" edge ID in the mutation.
func (m *DocumentClassificationMutation) CustomerRuleProfileID() (id uuid.UUID, exists bool) {
	if m.customer_rule_profile != nil {
		return *m.customer_rule_profile, true
	}
	return
}

// CustomerRuleProfileIDs returns the "customer_rule_profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerRuleProfileID instead. It exists only for internal usage by the builders.
func (m *DocumentClassificationMutation) CustomerRuleProfileIDs() (ids []uuid.UUID) {
	if id := m.customer_rule_profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomerRuleProfile resets all changes to the "customer_rule_profile" edge.
func (m *DocumentClassificationMutation) ResetCustomerRuleProfile() {
	m.customer_rule_profile = nil
	m.clearedcustomer_rule_profile = false
}

// Where appends a list predicates to the DocumentClassificationMutation builder.
func (m *DocumentClassificationMutation) Where(ps ...predicate.DocumentClassification) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DocumentClassificationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DocumentClassificationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DocumentClassification, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DocumentClassificationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DocumentClassificationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DocumentClassification).
func (m *DocumentClassificationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DocumentClassificationMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.business_unit != nil {
		fields = append(fields, documentclassification.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, documentclassification.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, documentclassification.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, documentclassification.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, documentclassification.FieldVersion)
	}
	if m.status != nil {
		fields = append(fields, documentclassification.FieldStatus)
	}
	if m.code != nil {
		fields = append(fields, documentclassification.FieldCode)
	}
	if m.description != nil {
		fields = append(fields, documentclassification.FieldDescription)
	}
	if m.color != nil {
		fields = append(fields, documentclassification.FieldColor)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DocumentClassificationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case documentclassification.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case documentclassification.FieldOrganizationID:
		return m.OrganizationID()
	case documentclassification.FieldCreatedAt:
		return m.CreatedAt()
	case documentclassification.FieldUpdatedAt:
		return m.UpdatedAt()
	case documentclassification.FieldVersion:
		return m.Version()
	case documentclassification.FieldStatus:
		return m.Status()
	case documentclassification.FieldCode:
		return m.Code()
	case documentclassification.FieldDescription:
		return m.Description()
	case documentclassification.FieldColor:
		return m.Color()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DocumentClassificationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case documentclassification.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case documentclassification.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case documentclassification.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case documentclassification.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case documentclassification.FieldVersion:
		return m.OldVersion(ctx)
	case documentclassification.FieldStatus:
		return m.OldStatus(ctx)
	case documentclassification.FieldCode:
		return m.OldCode(ctx)
	case documentclassification.FieldDescription:
		return m.OldDescription(ctx)
	case documentclassification.FieldColor:
		return m.OldColor(ctx)
	}
	return nil, fmt.Errorf("unknown DocumentClassification field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocumentClassificationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case documentclassification.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case documentclassification.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case documentclassification.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case documentclassification.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case documentclassification.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case documentclassification.FieldStatus:
		v, ok := value.(documentclassification.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case documentclassification.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case documentclassification.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case documentclassification.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	}
	return fmt.Errorf("unknown DocumentClassification field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DocumentClassificationMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, documentclassification.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DocumentClassificationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case documentclassification.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocumentClassificationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case documentclassification.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown DocumentClassification numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DocumentClassificationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(documentclassification.FieldDescription) {
		fields = append(fields, documentclassification.FieldDescription)
	}
	if m.FieldCleared(documentclassification.FieldColor) {
		fields = append(fields, documentclassification.FieldColor)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DocumentClassificationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DocumentClassificationMutation) ClearField(name string) error {
	switch name {
	case documentclassification.FieldDescription:
		m.ClearDescription()
		return nil
	case documentclassification.FieldColor:
		m.ClearColor()
		return nil
	}
	return fmt.Errorf("unknown DocumentClassification nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DocumentClassificationMutation) ResetField(name string) error {
	switch name {
	case documentclassification.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case documentclassification.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case documentclassification.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case documentclassification.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case documentclassification.FieldVersion:
		m.ResetVersion()
		return nil
	case documentclassification.FieldStatus:
		m.ResetStatus()
		return nil
	case documentclassification.FieldCode:
		m.ResetCode()
		return nil
	case documentclassification.FieldDescription:
		m.ResetDescription()
		return nil
	case documentclassification.FieldColor:
		m.ResetColor()
		return nil
	}
	return fmt.Errorf("unknown DocumentClassification field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DocumentClassificationMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.business_unit != nil {
		edges = append(edges, documentclassification.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, documentclassification.EdgeOrganization)
	}
	if m.shipment_documentation != nil {
		edges = append(edges, documentclassification.EdgeShipmentDocumentation)
	}
	if m.customer_rule_profile != nil {
		edges = append(edges, documentclassification.EdgeCustomerRuleProfile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DocumentClassificationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case documentclassification.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case documentclassification.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case documentclassification.EdgeShipmentDocumentation:
		ids := make([]ent.Value, 0, len(m.shipment_documentation))
		for id := range m.shipment_documentation {
			ids = append(ids, id)
		}
		return ids
	case documentclassification.EdgeCustomerRuleProfile:
		if id := m.customer_rule_profile; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DocumentClassificationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedshipment_documentation != nil {
		edges = append(edges, documentclassification.EdgeShipmentDocumentation)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DocumentClassificationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case documentclassification.EdgeShipmentDocumentation:
		ids := make([]ent.Value, 0, len(m.removedshipment_documentation))
		for id := range m.removedshipment_documentation {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DocumentClassificationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedbusiness_unit {
		edges = append(edges, documentclassification.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, documentclassification.EdgeOrganization)
	}
	if m.clearedshipment_documentation {
		edges = append(edges, documentclassification.EdgeShipmentDocumentation)
	}
	if m.clearedcustomer_rule_profile {
		edges = append(edges, documentclassification.EdgeCustomerRuleProfile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DocumentClassificationMutation) EdgeCleared(name string) bool {
	switch name {
	case documentclassification.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case documentclassification.EdgeOrganization:
		return m.clearedorganization
	case documentclassification.EdgeShipmentDocumentation:
		return m.clearedshipment_documentation
	case documentclassification.EdgeCustomerRuleProfile:
		return m.clearedcustomer_rule_profile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DocumentClassificationMutation) ClearEdge(name string) error {
	switch name {
	case documentclassification.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case documentclassification.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case documentclassification.EdgeCustomerRuleProfile:
		m.ClearCustomerRuleProfile()
		return nil
	}
	return fmt.Errorf("unknown DocumentClassification unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DocumentClassificationMutation) ResetEdge(name string) error {
	switch name {
	case documentclassification.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case documentclassification.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case documentclassification.EdgeShipmentDocumentation:
		m.ResetShipmentDocumentation()
		return nil
	case documentclassification.EdgeCustomerRuleProfile:
		m.ResetCustomerRuleProfile()
		return nil
	}
	return fmt.Errorf("unknown DocumentClassification edge %s", name)
}

// EmailControlMutation represents an operation that mutates the EmailControl nodes in the graph.
type EmailControlMutation struct {
	config
	op                           Op
	typ                          string
	id                           *uuid.UUID
	created_at                   *time.Time
	updated_at                   *time.Time
	clearedFields                map[string]struct{}
	organization                 *uuid.UUID
	clearedorganization          bool
	business_unit                *uuid.UUID
	clearedbusiness_unit         bool
	billing_email_profile        *uuid.UUID
	clearedbilling_email_profile bool
	rate_email_profile           *uuid.UUID
	clearedrate_email_profile    bool
	done                         bool
	oldValue                     func(context.Context) (*EmailControl, error)
	predicates                   []predicate.EmailControl
}

var _ ent.Mutation = (*EmailControlMutation)(nil)

// emailcontrolOption allows management of the mutation configuration using functional options.
type emailcontrolOption func(*EmailControlMutation)

// newEmailControlMutation creates new mutation for the EmailControl entity.
func newEmailControlMutation(c config, op Op, opts ...emailcontrolOption) *EmailControlMutation {
	m := &EmailControlMutation{
		config:        c,
		op:            op,
		typ:           TypeEmailControl,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmailControlID sets the ID field of the mutation.
func withEmailControlID(id uuid.UUID) emailcontrolOption {
	return func(m *EmailControlMutation) {
		var (
			err   error
			once  sync.Once
			value *EmailControl
		)
		m.oldValue = func(ctx context.Context) (*EmailControl, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EmailControl.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmailControl sets the old EmailControl of the mutation.
func withEmailControl(node *EmailControl) emailcontrolOption {
	return func(m *EmailControlMutation) {
		m.oldValue = func(context.Context) (*EmailControl, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmailControlMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmailControlMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EmailControl entities.
func (m *EmailControlMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmailControlMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmailControlMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EmailControl.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EmailControlMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EmailControlMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EmailControl entity.
// If the EmailControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailControlMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EmailControlMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EmailControlMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EmailControlMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EmailControl entity.
// If the EmailControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailControlMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EmailControlMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetBillingEmailProfileID sets the "billing_email_profile_id" field.
func (m *EmailControlMutation) SetBillingEmailProfileID(u uuid.UUID) {
	m.billing_email_profile = &u
}

// BillingEmailProfileID returns the value of the "billing_email_profile_id" field in the mutation.
func (m *EmailControlMutation) BillingEmailProfileID() (r uuid.UUID, exists bool) {
	v := m.billing_email_profile
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingEmailProfileID returns the old "billing_email_profile_id" field's value of the EmailControl entity.
// If the EmailControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailControlMutation) OldBillingEmailProfileID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingEmailProfileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingEmailProfileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingEmailProfileID: %w", err)
	}
	return oldValue.BillingEmailProfileID, nil
}

// ClearBillingEmailProfileID clears the value of the "billing_email_profile_id" field.
func (m *EmailControlMutation) ClearBillingEmailProfileID() {
	m.billing_email_profile = nil
	m.clearedFields[emailcontrol.FieldBillingEmailProfileID] = struct{}{}
}

// BillingEmailProfileIDCleared returns if the "billing_email_profile_id" field was cleared in this mutation.
func (m *EmailControlMutation) BillingEmailProfileIDCleared() bool {
	_, ok := m.clearedFields[emailcontrol.FieldBillingEmailProfileID]
	return ok
}

// ResetBillingEmailProfileID resets all changes to the "billing_email_profile_id" field.
func (m *EmailControlMutation) ResetBillingEmailProfileID() {
	m.billing_email_profile = nil
	delete(m.clearedFields, emailcontrol.FieldBillingEmailProfileID)
}

// SetRateExpirtationEmailProfileID sets the "rate_expirtation_email_profile_id" field.
func (m *EmailControlMutation) SetRateExpirtationEmailProfileID(u uuid.UUID) {
	m.rate_email_profile = &u
}

// RateExpirtationEmailProfileID returns the value of the "rate_expirtation_email_profile_id" field in the mutation.
func (m *EmailControlMutation) RateExpirtationEmailProfileID() (r uuid.UUID, exists bool) {
	v := m.rate_email_profile
	if v == nil {
		return
	}
	return *v, true
}

// OldRateExpirtationEmailProfileID returns the old "rate_expirtation_email_profile_id" field's value of the EmailControl entity.
// If the EmailControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailControlMutation) OldRateExpirtationEmailProfileID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRateExpirtationEmailProfileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRateExpirtationEmailProfileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRateExpirtationEmailProfileID: %w", err)
	}
	return oldValue.RateExpirtationEmailProfileID, nil
}

// ClearRateExpirtationEmailProfileID clears the value of the "rate_expirtation_email_profile_id" field.
func (m *EmailControlMutation) ClearRateExpirtationEmailProfileID() {
	m.rate_email_profile = nil
	m.clearedFields[emailcontrol.FieldRateExpirtationEmailProfileID] = struct{}{}
}

// RateExpirtationEmailProfileIDCleared returns if the "rate_expirtation_email_profile_id" field was cleared in this mutation.
func (m *EmailControlMutation) RateExpirtationEmailProfileIDCleared() bool {
	_, ok := m.clearedFields[emailcontrol.FieldRateExpirtationEmailProfileID]
	return ok
}

// ResetRateExpirtationEmailProfileID resets all changes to the "rate_expirtation_email_profile_id" field.
func (m *EmailControlMutation) ResetRateExpirtationEmailProfileID() {
	m.rate_email_profile = nil
	delete(m.clearedFields, emailcontrol.FieldRateExpirtationEmailProfileID)
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *EmailControlMutation) SetOrganizationID(id uuid.UUID) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *EmailControlMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *EmailControlMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *EmailControlMutation) OrganizationID() (id uuid.UUID, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *EmailControlMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *EmailControlMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// SetBusinessUnitID sets the "business_unit" edge to the BusinessUnit entity by id.
func (m *EmailControlMutation) SetBusinessUnitID(id uuid.UUID) {
	m.business_unit = &id
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *EmailControlMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *EmailControlMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitID returns the "business_unit" edge ID in the mutation.
func (m *EmailControlMutation) BusinessUnitID() (id uuid.UUID, exists bool) {
	if m.business_unit != nil {
		return *m.business_unit, true
	}
	return
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *EmailControlMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *EmailControlMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearBillingEmailProfile clears the "billing_email_profile" edge to the EmailProfile entity.
func (m *EmailControlMutation) ClearBillingEmailProfile() {
	m.clearedbilling_email_profile = true
	m.clearedFields[emailcontrol.FieldBillingEmailProfileID] = struct{}{}
}

// BillingEmailProfileCleared reports if the "billing_email_profile" edge to the EmailProfile entity was cleared.
func (m *EmailControlMutation) BillingEmailProfileCleared() bool {
	return m.BillingEmailProfileIDCleared() || m.clearedbilling_email_profile
}

// BillingEmailProfileIDs returns the "billing_email_profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BillingEmailProfileID instead. It exists only for internal usage by the builders.
func (m *EmailControlMutation) BillingEmailProfileIDs() (ids []uuid.UUID) {
	if id := m.billing_email_profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBillingEmailProfile resets all changes to the "billing_email_profile" edge.
func (m *EmailControlMutation) ResetBillingEmailProfile() {
	m.billing_email_profile = nil
	m.clearedbilling_email_profile = false
}

// SetRateEmailProfileID sets the "rate_email_profile" edge to the EmailProfile entity by id.
func (m *EmailControlMutation) SetRateEmailProfileID(id uuid.UUID) {
	m.rate_email_profile = &id
}

// ClearRateEmailProfile clears the "rate_email_profile" edge to the EmailProfile entity.
func (m *EmailControlMutation) ClearRateEmailProfile() {
	m.clearedrate_email_profile = true
	m.clearedFields[emailcontrol.FieldRateExpirtationEmailProfileID] = struct{}{}
}

// RateEmailProfileCleared reports if the "rate_email_profile" edge to the EmailProfile entity was cleared.
func (m *EmailControlMutation) RateEmailProfileCleared() bool {
	return m.RateExpirtationEmailProfileIDCleared() || m.clearedrate_email_profile
}

// RateEmailProfileID returns the "rate_email_profile" edge ID in the mutation.
func (m *EmailControlMutation) RateEmailProfileID() (id uuid.UUID, exists bool) {
	if m.rate_email_profile != nil {
		return *m.rate_email_profile, true
	}
	return
}

// RateEmailProfileIDs returns the "rate_email_profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RateEmailProfileID instead. It exists only for internal usage by the builders.
func (m *EmailControlMutation) RateEmailProfileIDs() (ids []uuid.UUID) {
	if id := m.rate_email_profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRateEmailProfile resets all changes to the "rate_email_profile" edge.
func (m *EmailControlMutation) ResetRateEmailProfile() {
	m.rate_email_profile = nil
	m.clearedrate_email_profile = false
}

// Where appends a list predicates to the EmailControlMutation builder.
func (m *EmailControlMutation) Where(ps ...predicate.EmailControl) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmailControlMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmailControlMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EmailControl, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmailControlMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmailControlMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EmailControl).
func (m *EmailControlMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmailControlMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, emailcontrol.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, emailcontrol.FieldUpdatedAt)
	}
	if m.billing_email_profile != nil {
		fields = append(fields, emailcontrol.FieldBillingEmailProfileID)
	}
	if m.rate_email_profile != nil {
		fields = append(fields, emailcontrol.FieldRateExpirtationEmailProfileID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmailControlMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case emailcontrol.FieldCreatedAt:
		return m.CreatedAt()
	case emailcontrol.FieldUpdatedAt:
		return m.UpdatedAt()
	case emailcontrol.FieldBillingEmailProfileID:
		return m.BillingEmailProfileID()
	case emailcontrol.FieldRateExpirtationEmailProfileID:
		return m.RateExpirtationEmailProfileID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmailControlMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case emailcontrol.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case emailcontrol.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case emailcontrol.FieldBillingEmailProfileID:
		return m.OldBillingEmailProfileID(ctx)
	case emailcontrol.FieldRateExpirtationEmailProfileID:
		return m.OldRateExpirtationEmailProfileID(ctx)
	}
	return nil, fmt.Errorf("unknown EmailControl field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailControlMutation) SetField(name string, value ent.Value) error {
	switch name {
	case emailcontrol.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case emailcontrol.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case emailcontrol.FieldBillingEmailProfileID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingEmailProfileID(v)
		return nil
	case emailcontrol.FieldRateExpirtationEmailProfileID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRateExpirtationEmailProfileID(v)
		return nil
	}
	return fmt.Errorf("unknown EmailControl field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmailControlMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmailControlMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailControlMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EmailControl numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmailControlMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(emailcontrol.FieldBillingEmailProfileID) {
		fields = append(fields, emailcontrol.FieldBillingEmailProfileID)
	}
	if m.FieldCleared(emailcontrol.FieldRateExpirtationEmailProfileID) {
		fields = append(fields, emailcontrol.FieldRateExpirtationEmailProfileID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmailControlMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmailControlMutation) ClearField(name string) error {
	switch name {
	case emailcontrol.FieldBillingEmailProfileID:
		m.ClearBillingEmailProfileID()
		return nil
	case emailcontrol.FieldRateExpirtationEmailProfileID:
		m.ClearRateExpirtationEmailProfileID()
		return nil
	}
	return fmt.Errorf("unknown EmailControl nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmailControlMutation) ResetField(name string) error {
	switch name {
	case emailcontrol.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case emailcontrol.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case emailcontrol.FieldBillingEmailProfileID:
		m.ResetBillingEmailProfileID()
		return nil
	case emailcontrol.FieldRateExpirtationEmailProfileID:
		m.ResetRateExpirtationEmailProfileID()
		return nil
	}
	return fmt.Errorf("unknown EmailControl field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmailControlMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.organization != nil {
		edges = append(edges, emailcontrol.EdgeOrganization)
	}
	if m.business_unit != nil {
		edges = append(edges, emailcontrol.EdgeBusinessUnit)
	}
	if m.billing_email_profile != nil {
		edges = append(edges, emailcontrol.EdgeBillingEmailProfile)
	}
	if m.rate_email_profile != nil {
		edges = append(edges, emailcontrol.EdgeRateEmailProfile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmailControlMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case emailcontrol.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case emailcontrol.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case emailcontrol.EdgeBillingEmailProfile:
		if id := m.billing_email_profile; id != nil {
			return []ent.Value{*id}
		}
	case emailcontrol.EdgeRateEmailProfile:
		if id := m.rate_email_profile; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmailControlMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmailControlMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmailControlMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedorganization {
		edges = append(edges, emailcontrol.EdgeOrganization)
	}
	if m.clearedbusiness_unit {
		edges = append(edges, emailcontrol.EdgeBusinessUnit)
	}
	if m.clearedbilling_email_profile {
		edges = append(edges, emailcontrol.EdgeBillingEmailProfile)
	}
	if m.clearedrate_email_profile {
		edges = append(edges, emailcontrol.EdgeRateEmailProfile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmailControlMutation) EdgeCleared(name string) bool {
	switch name {
	case emailcontrol.EdgeOrganization:
		return m.clearedorganization
	case emailcontrol.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case emailcontrol.EdgeBillingEmailProfile:
		return m.clearedbilling_email_profile
	case emailcontrol.EdgeRateEmailProfile:
		return m.clearedrate_email_profile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmailControlMutation) ClearEdge(name string) error {
	switch name {
	case emailcontrol.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case emailcontrol.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case emailcontrol.EdgeBillingEmailProfile:
		m.ClearBillingEmailProfile()
		return nil
	case emailcontrol.EdgeRateEmailProfile:
		m.ClearRateEmailProfile()
		return nil
	}
	return fmt.Errorf("unknown EmailControl unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmailControlMutation) ResetEdge(name string) error {
	switch name {
	case emailcontrol.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case emailcontrol.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case emailcontrol.EdgeBillingEmailProfile:
		m.ResetBillingEmailProfile()
		return nil
	case emailcontrol.EdgeRateEmailProfile:
		m.ResetRateEmailProfile()
		return nil
	}
	return fmt.Errorf("unknown EmailControl edge %s", name)
}

// EmailProfileMutation represents an operation that mutates the EmailProfile nodes in the graph.
type EmailProfileMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	version              *int
	addversion           *int
	name                 *string
	email                *string
	protocol             *emailprofile.Protocol
	host                 *string
	port                 *int16
	addport              *int16
	username             *string
	password             *string
	is_default           *bool
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	done                 bool
	oldValue             func(context.Context) (*EmailProfile, error)
	predicates           []predicate.EmailProfile
}

var _ ent.Mutation = (*EmailProfileMutation)(nil)

// emailprofileOption allows management of the mutation configuration using functional options.
type emailprofileOption func(*EmailProfileMutation)

// newEmailProfileMutation creates new mutation for the EmailProfile entity.
func newEmailProfileMutation(c config, op Op, opts ...emailprofileOption) *EmailProfileMutation {
	m := &EmailProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeEmailProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmailProfileID sets the ID field of the mutation.
func withEmailProfileID(id uuid.UUID) emailprofileOption {
	return func(m *EmailProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *EmailProfile
		)
		m.oldValue = func(ctx context.Context) (*EmailProfile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EmailProfile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmailProfile sets the old EmailProfile of the mutation.
func withEmailProfile(node *EmailProfile) emailprofileOption {
	return func(m *EmailProfileMutation) {
		m.oldValue = func(context.Context) (*EmailProfile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmailProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmailProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EmailProfile entities.
func (m *EmailProfileMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmailProfileMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmailProfileMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EmailProfile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *EmailProfileMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *EmailProfileMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the EmailProfile entity.
// If the EmailProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailProfileMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *EmailProfileMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *EmailProfileMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *EmailProfileMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the EmailProfile entity.
// If the EmailProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailProfileMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *EmailProfileMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EmailProfileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EmailProfileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EmailProfile entity.
// If the EmailProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailProfileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EmailProfileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EmailProfileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EmailProfileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EmailProfile entity.
// If the EmailProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailProfileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EmailProfileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *EmailProfileMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *EmailProfileMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the EmailProfile entity.
// If the EmailProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailProfileMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *EmailProfileMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *EmailProfileMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *EmailProfileMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetName sets the "name" field.
func (m *EmailProfileMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EmailProfileMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the EmailProfile entity.
// If the EmailProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailProfileMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EmailProfileMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *EmailProfileMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *EmailProfileMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the EmailProfile entity.
// If the EmailProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailProfileMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *EmailProfileMutation) ResetEmail() {
	m.email = nil
}

// SetProtocol sets the "protocol" field.
func (m *EmailProfileMutation) SetProtocol(e emailprofile.Protocol) {
	m.protocol = &e
}

// Protocol returns the value of the "protocol" field in the mutation.
func (m *EmailProfileMutation) Protocol() (r emailprofile.Protocol, exists bool) {
	v := m.protocol
	if v == nil {
		return
	}
	return *v, true
}

// OldProtocol returns the old "protocol" field's value of the EmailProfile entity.
// If the EmailProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailProfileMutation) OldProtocol(ctx context.Context) (v emailprofile.Protocol, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProtocol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProtocol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProtocol: %w", err)
	}
	return oldValue.Protocol, nil
}

// ClearProtocol clears the value of the "protocol" field.
func (m *EmailProfileMutation) ClearProtocol() {
	m.protocol = nil
	m.clearedFields[emailprofile.FieldProtocol] = struct{}{}
}

// ProtocolCleared returns if the "protocol" field was cleared in this mutation.
func (m *EmailProfileMutation) ProtocolCleared() bool {
	_, ok := m.clearedFields[emailprofile.FieldProtocol]
	return ok
}

// ResetProtocol resets all changes to the "protocol" field.
func (m *EmailProfileMutation) ResetProtocol() {
	m.protocol = nil
	delete(m.clearedFields, emailprofile.FieldProtocol)
}

// SetHost sets the "host" field.
func (m *EmailProfileMutation) SetHost(s string) {
	m.host = &s
}

// Host returns the value of the "host" field in the mutation.
func (m *EmailProfileMutation) Host() (r string, exists bool) {
	v := m.host
	if v == nil {
		return
	}
	return *v, true
}

// OldHost returns the old "host" field's value of the EmailProfile entity.
// If the EmailProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailProfileMutation) OldHost(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHost: %w", err)
	}
	return oldValue.Host, nil
}

// ClearHost clears the value of the "host" field.
func (m *EmailProfileMutation) ClearHost() {
	m.host = nil
	m.clearedFields[emailprofile.FieldHost] = struct{}{}
}

// HostCleared returns if the "host" field was cleared in this mutation.
func (m *EmailProfileMutation) HostCleared() bool {
	_, ok := m.clearedFields[emailprofile.FieldHost]
	return ok
}

// ResetHost resets all changes to the "host" field.
func (m *EmailProfileMutation) ResetHost() {
	m.host = nil
	delete(m.clearedFields, emailprofile.FieldHost)
}

// SetPort sets the "port" field.
func (m *EmailProfileMutation) SetPort(i int16) {
	m.port = &i
	m.addport = nil
}

// Port returns the value of the "port" field in the mutation.
func (m *EmailProfileMutation) Port() (r int16, exists bool) {
	v := m.port
	if v == nil {
		return
	}
	return *v, true
}

// OldPort returns the old "port" field's value of the EmailProfile entity.
// If the EmailProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailProfileMutation) OldPort(ctx context.Context) (v int16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPort: %w", err)
	}
	return oldValue.Port, nil
}

// AddPort adds i to the "port" field.
func (m *EmailProfileMutation) AddPort(i int16) {
	if m.addport != nil {
		*m.addport += i
	} else {
		m.addport = &i
	}
}

// AddedPort returns the value that was added to the "port" field in this mutation.
func (m *EmailProfileMutation) AddedPort() (r int16, exists bool) {
	v := m.addport
	if v == nil {
		return
	}
	return *v, true
}

// ClearPort clears the value of the "port" field.
func (m *EmailProfileMutation) ClearPort() {
	m.port = nil
	m.addport = nil
	m.clearedFields[emailprofile.FieldPort] = struct{}{}
}

// PortCleared returns if the "port" field was cleared in this mutation.
func (m *EmailProfileMutation) PortCleared() bool {
	_, ok := m.clearedFields[emailprofile.FieldPort]
	return ok
}

// ResetPort resets all changes to the "port" field.
func (m *EmailProfileMutation) ResetPort() {
	m.port = nil
	m.addport = nil
	delete(m.clearedFields, emailprofile.FieldPort)
}

// SetUsername sets the "username" field.
func (m *EmailProfileMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *EmailProfileMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the EmailProfile entity.
// If the EmailProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailProfileMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *EmailProfileMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[emailprofile.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *EmailProfileMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[emailprofile.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *EmailProfileMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, emailprofile.FieldUsername)
}

// SetPassword sets the "password" field.
func (m *EmailProfileMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *EmailProfileMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the EmailProfile entity.
// If the EmailProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailProfileMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *EmailProfileMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[emailprofile.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *EmailProfileMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[emailprofile.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *EmailProfileMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, emailprofile.FieldPassword)
}

// SetIsDefault sets the "is_default" field.
func (m *EmailProfileMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *EmailProfileMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the EmailProfile entity.
// If the EmailProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailProfileMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *EmailProfileMutation) ResetIsDefault() {
	m.is_default = nil
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *EmailProfileMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[emailprofile.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *EmailProfileMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *EmailProfileMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *EmailProfileMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *EmailProfileMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[emailprofile.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *EmailProfileMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *EmailProfileMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *EmailProfileMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the EmailProfileMutation builder.
func (m *EmailProfileMutation) Where(ps ...predicate.EmailProfile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmailProfileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmailProfileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EmailProfile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmailProfileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmailProfileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EmailProfile).
func (m *EmailProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmailProfileMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.business_unit != nil {
		fields = append(fields, emailprofile.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, emailprofile.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, emailprofile.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, emailprofile.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, emailprofile.FieldVersion)
	}
	if m.name != nil {
		fields = append(fields, emailprofile.FieldName)
	}
	if m.email != nil {
		fields = append(fields, emailprofile.FieldEmail)
	}
	if m.protocol != nil {
		fields = append(fields, emailprofile.FieldProtocol)
	}
	if m.host != nil {
		fields = append(fields, emailprofile.FieldHost)
	}
	if m.port != nil {
		fields = append(fields, emailprofile.FieldPort)
	}
	if m.username != nil {
		fields = append(fields, emailprofile.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, emailprofile.FieldPassword)
	}
	if m.is_default != nil {
		fields = append(fields, emailprofile.FieldIsDefault)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmailProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case emailprofile.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case emailprofile.FieldOrganizationID:
		return m.OrganizationID()
	case emailprofile.FieldCreatedAt:
		return m.CreatedAt()
	case emailprofile.FieldUpdatedAt:
		return m.UpdatedAt()
	case emailprofile.FieldVersion:
		return m.Version()
	case emailprofile.FieldName:
		return m.Name()
	case emailprofile.FieldEmail:
		return m.Email()
	case emailprofile.FieldProtocol:
		return m.Protocol()
	case emailprofile.FieldHost:
		return m.Host()
	case emailprofile.FieldPort:
		return m.Port()
	case emailprofile.FieldUsername:
		return m.Username()
	case emailprofile.FieldPassword:
		return m.Password()
	case emailprofile.FieldIsDefault:
		return m.IsDefault()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmailProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case emailprofile.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case emailprofile.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case emailprofile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case emailprofile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case emailprofile.FieldVersion:
		return m.OldVersion(ctx)
	case emailprofile.FieldName:
		return m.OldName(ctx)
	case emailprofile.FieldEmail:
		return m.OldEmail(ctx)
	case emailprofile.FieldProtocol:
		return m.OldProtocol(ctx)
	case emailprofile.FieldHost:
		return m.OldHost(ctx)
	case emailprofile.FieldPort:
		return m.OldPort(ctx)
	case emailprofile.FieldUsername:
		return m.OldUsername(ctx)
	case emailprofile.FieldPassword:
		return m.OldPassword(ctx)
	case emailprofile.FieldIsDefault:
		return m.OldIsDefault(ctx)
	}
	return nil, fmt.Errorf("unknown EmailProfile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case emailprofile.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case emailprofile.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case emailprofile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case emailprofile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case emailprofile.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case emailprofile.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case emailprofile.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case emailprofile.FieldProtocol:
		v, ok := value.(emailprofile.Protocol)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProtocol(v)
		return nil
	case emailprofile.FieldHost:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHost(v)
		return nil
	case emailprofile.FieldPort:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPort(v)
		return nil
	case emailprofile.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case emailprofile.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case emailprofile.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	}
	return fmt.Errorf("unknown EmailProfile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmailProfileMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, emailprofile.FieldVersion)
	}
	if m.addport != nil {
		fields = append(fields, emailprofile.FieldPort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmailProfileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case emailprofile.FieldVersion:
		return m.AddedVersion()
	case emailprofile.FieldPort:
		return m.AddedPort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case emailprofile.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case emailprofile.FieldPort:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPort(v)
		return nil
	}
	return fmt.Errorf("unknown EmailProfile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmailProfileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(emailprofile.FieldProtocol) {
		fields = append(fields, emailprofile.FieldProtocol)
	}
	if m.FieldCleared(emailprofile.FieldHost) {
		fields = append(fields, emailprofile.FieldHost)
	}
	if m.FieldCleared(emailprofile.FieldPort) {
		fields = append(fields, emailprofile.FieldPort)
	}
	if m.FieldCleared(emailprofile.FieldUsername) {
		fields = append(fields, emailprofile.FieldUsername)
	}
	if m.FieldCleared(emailprofile.FieldPassword) {
		fields = append(fields, emailprofile.FieldPassword)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmailProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmailProfileMutation) ClearField(name string) error {
	switch name {
	case emailprofile.FieldProtocol:
		m.ClearProtocol()
		return nil
	case emailprofile.FieldHost:
		m.ClearHost()
		return nil
	case emailprofile.FieldPort:
		m.ClearPort()
		return nil
	case emailprofile.FieldUsername:
		m.ClearUsername()
		return nil
	case emailprofile.FieldPassword:
		m.ClearPassword()
		return nil
	}
	return fmt.Errorf("unknown EmailProfile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmailProfileMutation) ResetField(name string) error {
	switch name {
	case emailprofile.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case emailprofile.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case emailprofile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case emailprofile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case emailprofile.FieldVersion:
		m.ResetVersion()
		return nil
	case emailprofile.FieldName:
		m.ResetName()
		return nil
	case emailprofile.FieldEmail:
		m.ResetEmail()
		return nil
	case emailprofile.FieldProtocol:
		m.ResetProtocol()
		return nil
	case emailprofile.FieldHost:
		m.ResetHost()
		return nil
	case emailprofile.FieldPort:
		m.ResetPort()
		return nil
	case emailprofile.FieldUsername:
		m.ResetUsername()
		return nil
	case emailprofile.FieldPassword:
		m.ResetPassword()
		return nil
	case emailprofile.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	}
	return fmt.Errorf("unknown EmailProfile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmailProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.business_unit != nil {
		edges = append(edges, emailprofile.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, emailprofile.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmailProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case emailprofile.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case emailprofile.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmailProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmailProfileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmailProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbusiness_unit {
		edges = append(edges, emailprofile.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, emailprofile.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmailProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case emailprofile.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case emailprofile.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmailProfileMutation) ClearEdge(name string) error {
	switch name {
	case emailprofile.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case emailprofile.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown EmailProfile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmailProfileMutation) ResetEdge(name string) error {
	switch name {
	case emailprofile.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case emailprofile.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown EmailProfile edge %s", name)
}

// EquipmentManufactuerMutation represents an operation that mutates the EquipmentManufactuer nodes in the graph.
type EquipmentManufactuerMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	version              *int
	addversion           *int
	status               *equipmentmanufactuer.Status
	name                 *string
	description          *string
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	done                 bool
	oldValue             func(context.Context) (*EquipmentManufactuer, error)
	predicates           []predicate.EquipmentManufactuer
}

var _ ent.Mutation = (*EquipmentManufactuerMutation)(nil)

// equipmentmanufactuerOption allows management of the mutation configuration using functional options.
type equipmentmanufactuerOption func(*EquipmentManufactuerMutation)

// newEquipmentManufactuerMutation creates new mutation for the EquipmentManufactuer entity.
func newEquipmentManufactuerMutation(c config, op Op, opts ...equipmentmanufactuerOption) *EquipmentManufactuerMutation {
	m := &EquipmentManufactuerMutation{
		config:        c,
		op:            op,
		typ:           TypeEquipmentManufactuer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEquipmentManufactuerID sets the ID field of the mutation.
func withEquipmentManufactuerID(id uuid.UUID) equipmentmanufactuerOption {
	return func(m *EquipmentManufactuerMutation) {
		var (
			err   error
			once  sync.Once
			value *EquipmentManufactuer
		)
		m.oldValue = func(ctx context.Context) (*EquipmentManufactuer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EquipmentManufactuer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEquipmentManufactuer sets the old EquipmentManufactuer of the mutation.
func withEquipmentManufactuer(node *EquipmentManufactuer) equipmentmanufactuerOption {
	return func(m *EquipmentManufactuerMutation) {
		m.oldValue = func(context.Context) (*EquipmentManufactuer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EquipmentManufactuerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EquipmentManufactuerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EquipmentManufactuer entities.
func (m *EquipmentManufactuerMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EquipmentManufactuerMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EquipmentManufactuerMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EquipmentManufactuer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *EquipmentManufactuerMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *EquipmentManufactuerMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the EquipmentManufactuer entity.
// If the EquipmentManufactuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentManufactuerMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *EquipmentManufactuerMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *EquipmentManufactuerMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *EquipmentManufactuerMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the EquipmentManufactuer entity.
// If the EquipmentManufactuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentManufactuerMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *EquipmentManufactuerMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EquipmentManufactuerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EquipmentManufactuerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EquipmentManufactuer entity.
// If the EquipmentManufactuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentManufactuerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EquipmentManufactuerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EquipmentManufactuerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EquipmentManufactuerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EquipmentManufactuer entity.
// If the EquipmentManufactuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentManufactuerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EquipmentManufactuerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *EquipmentManufactuerMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *EquipmentManufactuerMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the EquipmentManufactuer entity.
// If the EquipmentManufactuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentManufactuerMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *EquipmentManufactuerMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *EquipmentManufactuerMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *EquipmentManufactuerMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetStatus sets the "status" field.
func (m *EquipmentManufactuerMutation) SetStatus(e equipmentmanufactuer.Status) {
	m.status = &e
}

// Status returns the value of the "status" field in the mutation.
func (m *EquipmentManufactuerMutation) Status() (r equipmentmanufactuer.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the EquipmentManufactuer entity.
// If the EquipmentManufactuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentManufactuerMutation) OldStatus(ctx context.Context) (v equipmentmanufactuer.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *EquipmentManufactuerMutation) ResetStatus() {
	m.status = nil
}

// SetName sets the "name" field.
func (m *EquipmentManufactuerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EquipmentManufactuerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the EquipmentManufactuer entity.
// If the EquipmentManufactuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentManufactuerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EquipmentManufactuerMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *EquipmentManufactuerMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EquipmentManufactuerMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the EquipmentManufactuer entity.
// If the EquipmentManufactuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentManufactuerMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *EquipmentManufactuerMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[equipmentmanufactuer.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *EquipmentManufactuerMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[equipmentmanufactuer.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *EquipmentManufactuerMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, equipmentmanufactuer.FieldDescription)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *EquipmentManufactuerMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[equipmentmanufactuer.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *EquipmentManufactuerMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *EquipmentManufactuerMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *EquipmentManufactuerMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *EquipmentManufactuerMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[equipmentmanufactuer.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *EquipmentManufactuerMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *EquipmentManufactuerMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *EquipmentManufactuerMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the EquipmentManufactuerMutation builder.
func (m *EquipmentManufactuerMutation) Where(ps ...predicate.EquipmentManufactuer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EquipmentManufactuerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EquipmentManufactuerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EquipmentManufactuer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EquipmentManufactuerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EquipmentManufactuerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EquipmentManufactuer).
func (m *EquipmentManufactuerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EquipmentManufactuerMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.business_unit != nil {
		fields = append(fields, equipmentmanufactuer.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, equipmentmanufactuer.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, equipmentmanufactuer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, equipmentmanufactuer.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, equipmentmanufactuer.FieldVersion)
	}
	if m.status != nil {
		fields = append(fields, equipmentmanufactuer.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, equipmentmanufactuer.FieldName)
	}
	if m.description != nil {
		fields = append(fields, equipmentmanufactuer.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EquipmentManufactuerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case equipmentmanufactuer.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case equipmentmanufactuer.FieldOrganizationID:
		return m.OrganizationID()
	case equipmentmanufactuer.FieldCreatedAt:
		return m.CreatedAt()
	case equipmentmanufactuer.FieldUpdatedAt:
		return m.UpdatedAt()
	case equipmentmanufactuer.FieldVersion:
		return m.Version()
	case equipmentmanufactuer.FieldStatus:
		return m.Status()
	case equipmentmanufactuer.FieldName:
		return m.Name()
	case equipmentmanufactuer.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EquipmentManufactuerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case equipmentmanufactuer.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case equipmentmanufactuer.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case equipmentmanufactuer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case equipmentmanufactuer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case equipmentmanufactuer.FieldVersion:
		return m.OldVersion(ctx)
	case equipmentmanufactuer.FieldStatus:
		return m.OldStatus(ctx)
	case equipmentmanufactuer.FieldName:
		return m.OldName(ctx)
	case equipmentmanufactuer.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown EquipmentManufactuer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EquipmentManufactuerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case equipmentmanufactuer.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case equipmentmanufactuer.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case equipmentmanufactuer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case equipmentmanufactuer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case equipmentmanufactuer.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case equipmentmanufactuer.FieldStatus:
		v, ok := value.(equipmentmanufactuer.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case equipmentmanufactuer.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case equipmentmanufactuer.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown EquipmentManufactuer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EquipmentManufactuerMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, equipmentmanufactuer.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EquipmentManufactuerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case equipmentmanufactuer.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EquipmentManufactuerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case equipmentmanufactuer.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown EquipmentManufactuer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EquipmentManufactuerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(equipmentmanufactuer.FieldDescription) {
		fields = append(fields, equipmentmanufactuer.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EquipmentManufactuerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EquipmentManufactuerMutation) ClearField(name string) error {
	switch name {
	case equipmentmanufactuer.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown EquipmentManufactuer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EquipmentManufactuerMutation) ResetField(name string) error {
	switch name {
	case equipmentmanufactuer.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case equipmentmanufactuer.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case equipmentmanufactuer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case equipmentmanufactuer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case equipmentmanufactuer.FieldVersion:
		m.ResetVersion()
		return nil
	case equipmentmanufactuer.FieldStatus:
		m.ResetStatus()
		return nil
	case equipmentmanufactuer.FieldName:
		m.ResetName()
		return nil
	case equipmentmanufactuer.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown EquipmentManufactuer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EquipmentManufactuerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.business_unit != nil {
		edges = append(edges, equipmentmanufactuer.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, equipmentmanufactuer.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EquipmentManufactuerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case equipmentmanufactuer.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case equipmentmanufactuer.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EquipmentManufactuerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EquipmentManufactuerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EquipmentManufactuerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbusiness_unit {
		edges = append(edges, equipmentmanufactuer.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, equipmentmanufactuer.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EquipmentManufactuerMutation) EdgeCleared(name string) bool {
	switch name {
	case equipmentmanufactuer.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case equipmentmanufactuer.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EquipmentManufactuerMutation) ClearEdge(name string) error {
	switch name {
	case equipmentmanufactuer.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case equipmentmanufactuer.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown EquipmentManufactuer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EquipmentManufactuerMutation) ResetEdge(name string) error {
	switch name {
	case equipmentmanufactuer.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case equipmentmanufactuer.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown EquipmentManufactuer edge %s", name)
}

// EquipmentTypeMutation represents an operation that mutates the EquipmentType nodes in the graph.
type EquipmentTypeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	version              *int
	addversion           *int
	status               *equipmenttype.Status
	code                 *string
	description          *string
	cost_per_mile        *float64
	addcost_per_mile     *float64
	equipment_class      *equipmenttype.EquipmentClass
	fixed_cost           *float64
	addfixed_cost        *float64
	variable_cost        *float64
	addvariable_cost     *float64
	height               *float64
	addheight            *float64
	length               *float64
	addlength            *float64
	width                *float64
	addwidth             *float64
	weight               *float64
	addweight            *float64
	idling_fuel_usage    *float64
	addidling_fuel_usage *float64
	exempt_from_tolls    *bool
	color                *string
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	done                 bool
	oldValue             func(context.Context) (*EquipmentType, error)
	predicates           []predicate.EquipmentType
}

var _ ent.Mutation = (*EquipmentTypeMutation)(nil)

// equipmenttypeOption allows management of the mutation configuration using functional options.
type equipmenttypeOption func(*EquipmentTypeMutation)

// newEquipmentTypeMutation creates new mutation for the EquipmentType entity.
func newEquipmentTypeMutation(c config, op Op, opts ...equipmenttypeOption) *EquipmentTypeMutation {
	m := &EquipmentTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeEquipmentType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEquipmentTypeID sets the ID field of the mutation.
func withEquipmentTypeID(id uuid.UUID) equipmenttypeOption {
	return func(m *EquipmentTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *EquipmentType
		)
		m.oldValue = func(ctx context.Context) (*EquipmentType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EquipmentType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEquipmentType sets the old EquipmentType of the mutation.
func withEquipmentType(node *EquipmentType) equipmenttypeOption {
	return func(m *EquipmentTypeMutation) {
		m.oldValue = func(context.Context) (*EquipmentType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EquipmentTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EquipmentTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EquipmentType entities.
func (m *EquipmentTypeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EquipmentTypeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EquipmentTypeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EquipmentType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *EquipmentTypeMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *EquipmentTypeMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the EquipmentType entity.
// If the EquipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentTypeMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *EquipmentTypeMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *EquipmentTypeMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *EquipmentTypeMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the EquipmentType entity.
// If the EquipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentTypeMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *EquipmentTypeMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EquipmentTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EquipmentTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EquipmentType entity.
// If the EquipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EquipmentTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EquipmentTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EquipmentTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EquipmentType entity.
// If the EquipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EquipmentTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *EquipmentTypeMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *EquipmentTypeMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the EquipmentType entity.
// If the EquipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentTypeMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *EquipmentTypeMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *EquipmentTypeMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *EquipmentTypeMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetStatus sets the "status" field.
func (m *EquipmentTypeMutation) SetStatus(e equipmenttype.Status) {
	m.status = &e
}

// Status returns the value of the "status" field in the mutation.
func (m *EquipmentTypeMutation) Status() (r equipmenttype.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the EquipmentType entity.
// If the EquipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentTypeMutation) OldStatus(ctx context.Context) (v equipmenttype.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *EquipmentTypeMutation) ResetStatus() {
	m.status = nil
}

// SetCode sets the "code" field.
func (m *EquipmentTypeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *EquipmentTypeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the EquipmentType entity.
// If the EquipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentTypeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *EquipmentTypeMutation) ResetCode() {
	m.code = nil
}

// SetDescription sets the "description" field.
func (m *EquipmentTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EquipmentTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the EquipmentType entity.
// If the EquipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *EquipmentTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[equipmenttype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *EquipmentTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[equipmenttype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *EquipmentTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, equipmenttype.FieldDescription)
}

// SetCostPerMile sets the "cost_per_mile" field.
func (m *EquipmentTypeMutation) SetCostPerMile(f float64) {
	m.cost_per_mile = &f
	m.addcost_per_mile = nil
}

// CostPerMile returns the value of the "cost_per_mile" field in the mutation.
func (m *EquipmentTypeMutation) CostPerMile() (r float64, exists bool) {
	v := m.cost_per_mile
	if v == nil {
		return
	}
	return *v, true
}

// OldCostPerMile returns the old "cost_per_mile" field's value of the EquipmentType entity.
// If the EquipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentTypeMutation) OldCostPerMile(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCostPerMile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCostPerMile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCostPerMile: %w", err)
	}
	return oldValue.CostPerMile, nil
}

// AddCostPerMile adds f to the "cost_per_mile" field.
func (m *EquipmentTypeMutation) AddCostPerMile(f float64) {
	if m.addcost_per_mile != nil {
		*m.addcost_per_mile += f
	} else {
		m.addcost_per_mile = &f
	}
}

// AddedCostPerMile returns the value that was added to the "cost_per_mile" field in this mutation.
func (m *EquipmentTypeMutation) AddedCostPerMile() (r float64, exists bool) {
	v := m.addcost_per_mile
	if v == nil {
		return
	}
	return *v, true
}

// ClearCostPerMile clears the value of the "cost_per_mile" field.
func (m *EquipmentTypeMutation) ClearCostPerMile() {
	m.cost_per_mile = nil
	m.addcost_per_mile = nil
	m.clearedFields[equipmenttype.FieldCostPerMile] = struct{}{}
}

// CostPerMileCleared returns if the "cost_per_mile" field was cleared in this mutation.
func (m *EquipmentTypeMutation) CostPerMileCleared() bool {
	_, ok := m.clearedFields[equipmenttype.FieldCostPerMile]
	return ok
}

// ResetCostPerMile resets all changes to the "cost_per_mile" field.
func (m *EquipmentTypeMutation) ResetCostPerMile() {
	m.cost_per_mile = nil
	m.addcost_per_mile = nil
	delete(m.clearedFields, equipmenttype.FieldCostPerMile)
}

// SetEquipmentClass sets the "equipment_class" field.
func (m *EquipmentTypeMutation) SetEquipmentClass(ec equipmenttype.EquipmentClass) {
	m.equipment_class = &ec
}

// EquipmentClass returns the value of the "equipment_class" field in the mutation.
func (m *EquipmentTypeMutation) EquipmentClass() (r equipmenttype.EquipmentClass, exists bool) {
	v := m.equipment_class
	if v == nil {
		return
	}
	return *v, true
}

// OldEquipmentClass returns the old "equipment_class" field's value of the EquipmentType entity.
// If the EquipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentTypeMutation) OldEquipmentClass(ctx context.Context) (v equipmenttype.EquipmentClass, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEquipmentClass is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEquipmentClass requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEquipmentClass: %w", err)
	}
	return oldValue.EquipmentClass, nil
}

// ResetEquipmentClass resets all changes to the "equipment_class" field.
func (m *EquipmentTypeMutation) ResetEquipmentClass() {
	m.equipment_class = nil
}

// SetFixedCost sets the "fixed_cost" field.
func (m *EquipmentTypeMutation) SetFixedCost(f float64) {
	m.fixed_cost = &f
	m.addfixed_cost = nil
}

// FixedCost returns the value of the "fixed_cost" field in the mutation.
func (m *EquipmentTypeMutation) FixedCost() (r float64, exists bool) {
	v := m.fixed_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldFixedCost returns the old "fixed_cost" field's value of the EquipmentType entity.
// If the EquipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentTypeMutation) OldFixedCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFixedCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFixedCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFixedCost: %w", err)
	}
	return oldValue.FixedCost, nil
}

// AddFixedCost adds f to the "fixed_cost" field.
func (m *EquipmentTypeMutation) AddFixedCost(f float64) {
	if m.addfixed_cost != nil {
		*m.addfixed_cost += f
	} else {
		m.addfixed_cost = &f
	}
}

// AddedFixedCost returns the value that was added to the "fixed_cost" field in this mutation.
func (m *EquipmentTypeMutation) AddedFixedCost() (r float64, exists bool) {
	v := m.addfixed_cost
	if v == nil {
		return
	}
	return *v, true
}

// ClearFixedCost clears the value of the "fixed_cost" field.
func (m *EquipmentTypeMutation) ClearFixedCost() {
	m.fixed_cost = nil
	m.addfixed_cost = nil
	m.clearedFields[equipmenttype.FieldFixedCost] = struct{}{}
}

// FixedCostCleared returns if the "fixed_cost" field was cleared in this mutation.
func (m *EquipmentTypeMutation) FixedCostCleared() bool {
	_, ok := m.clearedFields[equipmenttype.FieldFixedCost]
	return ok
}

// ResetFixedCost resets all changes to the "fixed_cost" field.
func (m *EquipmentTypeMutation) ResetFixedCost() {
	m.fixed_cost = nil
	m.addfixed_cost = nil
	delete(m.clearedFields, equipmenttype.FieldFixedCost)
}

// SetVariableCost sets the "variable_cost" field.
func (m *EquipmentTypeMutation) SetVariableCost(f float64) {
	m.variable_cost = &f
	m.addvariable_cost = nil
}

// VariableCost returns the value of the "variable_cost" field in the mutation.
func (m *EquipmentTypeMutation) VariableCost() (r float64, exists bool) {
	v := m.variable_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldVariableCost returns the old "variable_cost" field's value of the EquipmentType entity.
// If the EquipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentTypeMutation) OldVariableCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVariableCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVariableCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVariableCost: %w", err)
	}
	return oldValue.VariableCost, nil
}

// AddVariableCost adds f to the "variable_cost" field.
func (m *EquipmentTypeMutation) AddVariableCost(f float64) {
	if m.addvariable_cost != nil {
		*m.addvariable_cost += f
	} else {
		m.addvariable_cost = &f
	}
}

// AddedVariableCost returns the value that was added to the "variable_cost" field in this mutation.
func (m *EquipmentTypeMutation) AddedVariableCost() (r float64, exists bool) {
	v := m.addvariable_cost
	if v == nil {
		return
	}
	return *v, true
}

// ClearVariableCost clears the value of the "variable_cost" field.
func (m *EquipmentTypeMutation) ClearVariableCost() {
	m.variable_cost = nil
	m.addvariable_cost = nil
	m.clearedFields[equipmenttype.FieldVariableCost] = struct{}{}
}

// VariableCostCleared returns if the "variable_cost" field was cleared in this mutation.
func (m *EquipmentTypeMutation) VariableCostCleared() bool {
	_, ok := m.clearedFields[equipmenttype.FieldVariableCost]
	return ok
}

// ResetVariableCost resets all changes to the "variable_cost" field.
func (m *EquipmentTypeMutation) ResetVariableCost() {
	m.variable_cost = nil
	m.addvariable_cost = nil
	delete(m.clearedFields, equipmenttype.FieldVariableCost)
}

// SetHeight sets the "height" field.
func (m *EquipmentTypeMutation) SetHeight(f float64) {
	m.height = &f
	m.addheight = nil
}

// Height returns the value of the "height" field in the mutation.
func (m *EquipmentTypeMutation) Height() (r float64, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "height" field's value of the EquipmentType entity.
// If the EquipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentTypeMutation) OldHeight(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// AddHeight adds f to the "height" field.
func (m *EquipmentTypeMutation) AddHeight(f float64) {
	if m.addheight != nil {
		*m.addheight += f
	} else {
		m.addheight = &f
	}
}

// AddedHeight returns the value that was added to the "height" field in this mutation.
func (m *EquipmentTypeMutation) AddedHeight() (r float64, exists bool) {
	v := m.addheight
	if v == nil {
		return
	}
	return *v, true
}

// ClearHeight clears the value of the "height" field.
func (m *EquipmentTypeMutation) ClearHeight() {
	m.height = nil
	m.addheight = nil
	m.clearedFields[equipmenttype.FieldHeight] = struct{}{}
}

// HeightCleared returns if the "height" field was cleared in this mutation.
func (m *EquipmentTypeMutation) HeightCleared() bool {
	_, ok := m.clearedFields[equipmenttype.FieldHeight]
	return ok
}

// ResetHeight resets all changes to the "height" field.
func (m *EquipmentTypeMutation) ResetHeight() {
	m.height = nil
	m.addheight = nil
	delete(m.clearedFields, equipmenttype.FieldHeight)
}

// SetLength sets the "length" field.
func (m *EquipmentTypeMutation) SetLength(f float64) {
	m.length = &f
	m.addlength = nil
}

// Length returns the value of the "length" field in the mutation.
func (m *EquipmentTypeMutation) Length() (r float64, exists bool) {
	v := m.length
	if v == nil {
		return
	}
	return *v, true
}

// OldLength returns the old "length" field's value of the EquipmentType entity.
// If the EquipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentTypeMutation) OldLength(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLength is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLength requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLength: %w", err)
	}
	return oldValue.Length, nil
}

// AddLength adds f to the "length" field.
func (m *EquipmentTypeMutation) AddLength(f float64) {
	if m.addlength != nil {
		*m.addlength += f
	} else {
		m.addlength = &f
	}
}

// AddedLength returns the value that was added to the "length" field in this mutation.
func (m *EquipmentTypeMutation) AddedLength() (r float64, exists bool) {
	v := m.addlength
	if v == nil {
		return
	}
	return *v, true
}

// ClearLength clears the value of the "length" field.
func (m *EquipmentTypeMutation) ClearLength() {
	m.length = nil
	m.addlength = nil
	m.clearedFields[equipmenttype.FieldLength] = struct{}{}
}

// LengthCleared returns if the "length" field was cleared in this mutation.
func (m *EquipmentTypeMutation) LengthCleared() bool {
	_, ok := m.clearedFields[equipmenttype.FieldLength]
	return ok
}

// ResetLength resets all changes to the "length" field.
func (m *EquipmentTypeMutation) ResetLength() {
	m.length = nil
	m.addlength = nil
	delete(m.clearedFields, equipmenttype.FieldLength)
}

// SetWidth sets the "width" field.
func (m *EquipmentTypeMutation) SetWidth(f float64) {
	m.width = &f
	m.addwidth = nil
}

// Width returns the value of the "width" field in the mutation.
func (m *EquipmentTypeMutation) Width() (r float64, exists bool) {
	v := m.width
	if v == nil {
		return
	}
	return *v, true
}

// OldWidth returns the old "width" field's value of the EquipmentType entity.
// If the EquipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentTypeMutation) OldWidth(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWidth: %w", err)
	}
	return oldValue.Width, nil
}

// AddWidth adds f to the "width" field.
func (m *EquipmentTypeMutation) AddWidth(f float64) {
	if m.addwidth != nil {
		*m.addwidth += f
	} else {
		m.addwidth = &f
	}
}

// AddedWidth returns the value that was added to the "width" field in this mutation.
func (m *EquipmentTypeMutation) AddedWidth() (r float64, exists bool) {
	v := m.addwidth
	if v == nil {
		return
	}
	return *v, true
}

// ClearWidth clears the value of the "width" field.
func (m *EquipmentTypeMutation) ClearWidth() {
	m.width = nil
	m.addwidth = nil
	m.clearedFields[equipmenttype.FieldWidth] = struct{}{}
}

// WidthCleared returns if the "width" field was cleared in this mutation.
func (m *EquipmentTypeMutation) WidthCleared() bool {
	_, ok := m.clearedFields[equipmenttype.FieldWidth]
	return ok
}

// ResetWidth resets all changes to the "width" field.
func (m *EquipmentTypeMutation) ResetWidth() {
	m.width = nil
	m.addwidth = nil
	delete(m.clearedFields, equipmenttype.FieldWidth)
}

// SetWeight sets the "weight" field.
func (m *EquipmentTypeMutation) SetWeight(f float64) {
	m.weight = &f
	m.addweight = nil
}

// Weight returns the value of the "weight" field in the mutation.
func (m *EquipmentTypeMutation) Weight() (r float64, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old "weight" field's value of the EquipmentType entity.
// If the EquipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentTypeMutation) OldWeight(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds f to the "weight" field.
func (m *EquipmentTypeMutation) AddWeight(f float64) {
	if m.addweight != nil {
		*m.addweight += f
	} else {
		m.addweight = &f
	}
}

// AddedWeight returns the value that was added to the "weight" field in this mutation.
func (m *EquipmentTypeMutation) AddedWeight() (r float64, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ClearWeight clears the value of the "weight" field.
func (m *EquipmentTypeMutation) ClearWeight() {
	m.weight = nil
	m.addweight = nil
	m.clearedFields[equipmenttype.FieldWeight] = struct{}{}
}

// WeightCleared returns if the "weight" field was cleared in this mutation.
func (m *EquipmentTypeMutation) WeightCleared() bool {
	_, ok := m.clearedFields[equipmenttype.FieldWeight]
	return ok
}

// ResetWeight resets all changes to the "weight" field.
func (m *EquipmentTypeMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
	delete(m.clearedFields, equipmenttype.FieldWeight)
}

// SetIdlingFuelUsage sets the "idling_fuel_usage" field.
func (m *EquipmentTypeMutation) SetIdlingFuelUsage(f float64) {
	m.idling_fuel_usage = &f
	m.addidling_fuel_usage = nil
}

// IdlingFuelUsage returns the value of the "idling_fuel_usage" field in the mutation.
func (m *EquipmentTypeMutation) IdlingFuelUsage() (r float64, exists bool) {
	v := m.idling_fuel_usage
	if v == nil {
		return
	}
	return *v, true
}

// OldIdlingFuelUsage returns the old "idling_fuel_usage" field's value of the EquipmentType entity.
// If the EquipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentTypeMutation) OldIdlingFuelUsage(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdlingFuelUsage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdlingFuelUsage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdlingFuelUsage: %w", err)
	}
	return oldValue.IdlingFuelUsage, nil
}

// AddIdlingFuelUsage adds f to the "idling_fuel_usage" field.
func (m *EquipmentTypeMutation) AddIdlingFuelUsage(f float64) {
	if m.addidling_fuel_usage != nil {
		*m.addidling_fuel_usage += f
	} else {
		m.addidling_fuel_usage = &f
	}
}

// AddedIdlingFuelUsage returns the value that was added to the "idling_fuel_usage" field in this mutation.
func (m *EquipmentTypeMutation) AddedIdlingFuelUsage() (r float64, exists bool) {
	v := m.addidling_fuel_usage
	if v == nil {
		return
	}
	return *v, true
}

// ClearIdlingFuelUsage clears the value of the "idling_fuel_usage" field.
func (m *EquipmentTypeMutation) ClearIdlingFuelUsage() {
	m.idling_fuel_usage = nil
	m.addidling_fuel_usage = nil
	m.clearedFields[equipmenttype.FieldIdlingFuelUsage] = struct{}{}
}

// IdlingFuelUsageCleared returns if the "idling_fuel_usage" field was cleared in this mutation.
func (m *EquipmentTypeMutation) IdlingFuelUsageCleared() bool {
	_, ok := m.clearedFields[equipmenttype.FieldIdlingFuelUsage]
	return ok
}

// ResetIdlingFuelUsage resets all changes to the "idling_fuel_usage" field.
func (m *EquipmentTypeMutation) ResetIdlingFuelUsage() {
	m.idling_fuel_usage = nil
	m.addidling_fuel_usage = nil
	delete(m.clearedFields, equipmenttype.FieldIdlingFuelUsage)
}

// SetExemptFromTolls sets the "exempt_from_tolls" field.
func (m *EquipmentTypeMutation) SetExemptFromTolls(b bool) {
	m.exempt_from_tolls = &b
}

// ExemptFromTolls returns the value of the "exempt_from_tolls" field in the mutation.
func (m *EquipmentTypeMutation) ExemptFromTolls() (r bool, exists bool) {
	v := m.exempt_from_tolls
	if v == nil {
		return
	}
	return *v, true
}

// OldExemptFromTolls returns the old "exempt_from_tolls" field's value of the EquipmentType entity.
// If the EquipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentTypeMutation) OldExemptFromTolls(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExemptFromTolls is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExemptFromTolls requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExemptFromTolls: %w", err)
	}
	return oldValue.ExemptFromTolls, nil
}

// ResetExemptFromTolls resets all changes to the "exempt_from_tolls" field.
func (m *EquipmentTypeMutation) ResetExemptFromTolls() {
	m.exempt_from_tolls = nil
}

// SetColor sets the "color" field.
func (m *EquipmentTypeMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *EquipmentTypeMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the EquipmentType entity.
// If the EquipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentTypeMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *EquipmentTypeMutation) ClearColor() {
	m.color = nil
	m.clearedFields[equipmenttype.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *EquipmentTypeMutation) ColorCleared() bool {
	_, ok := m.clearedFields[equipmenttype.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *EquipmentTypeMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, equipmenttype.FieldColor)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *EquipmentTypeMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[equipmenttype.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *EquipmentTypeMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *EquipmentTypeMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *EquipmentTypeMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *EquipmentTypeMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[equipmenttype.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *EquipmentTypeMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *EquipmentTypeMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *EquipmentTypeMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the EquipmentTypeMutation builder.
func (m *EquipmentTypeMutation) Where(ps ...predicate.EquipmentType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EquipmentTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EquipmentTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EquipmentType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EquipmentTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EquipmentTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EquipmentType).
func (m *EquipmentTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EquipmentTypeMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.business_unit != nil {
		fields = append(fields, equipmenttype.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, equipmenttype.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, equipmenttype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, equipmenttype.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, equipmenttype.FieldVersion)
	}
	if m.status != nil {
		fields = append(fields, equipmenttype.FieldStatus)
	}
	if m.code != nil {
		fields = append(fields, equipmenttype.FieldCode)
	}
	if m.description != nil {
		fields = append(fields, equipmenttype.FieldDescription)
	}
	if m.cost_per_mile != nil {
		fields = append(fields, equipmenttype.FieldCostPerMile)
	}
	if m.equipment_class != nil {
		fields = append(fields, equipmenttype.FieldEquipmentClass)
	}
	if m.fixed_cost != nil {
		fields = append(fields, equipmenttype.FieldFixedCost)
	}
	if m.variable_cost != nil {
		fields = append(fields, equipmenttype.FieldVariableCost)
	}
	if m.height != nil {
		fields = append(fields, equipmenttype.FieldHeight)
	}
	if m.length != nil {
		fields = append(fields, equipmenttype.FieldLength)
	}
	if m.width != nil {
		fields = append(fields, equipmenttype.FieldWidth)
	}
	if m.weight != nil {
		fields = append(fields, equipmenttype.FieldWeight)
	}
	if m.idling_fuel_usage != nil {
		fields = append(fields, equipmenttype.FieldIdlingFuelUsage)
	}
	if m.exempt_from_tolls != nil {
		fields = append(fields, equipmenttype.FieldExemptFromTolls)
	}
	if m.color != nil {
		fields = append(fields, equipmenttype.FieldColor)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EquipmentTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case equipmenttype.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case equipmenttype.FieldOrganizationID:
		return m.OrganizationID()
	case equipmenttype.FieldCreatedAt:
		return m.CreatedAt()
	case equipmenttype.FieldUpdatedAt:
		return m.UpdatedAt()
	case equipmenttype.FieldVersion:
		return m.Version()
	case equipmenttype.FieldStatus:
		return m.Status()
	case equipmenttype.FieldCode:
		return m.Code()
	case equipmenttype.FieldDescription:
		return m.Description()
	case equipmenttype.FieldCostPerMile:
		return m.CostPerMile()
	case equipmenttype.FieldEquipmentClass:
		return m.EquipmentClass()
	case equipmenttype.FieldFixedCost:
		return m.FixedCost()
	case equipmenttype.FieldVariableCost:
		return m.VariableCost()
	case equipmenttype.FieldHeight:
		return m.Height()
	case equipmenttype.FieldLength:
		return m.Length()
	case equipmenttype.FieldWidth:
		return m.Width()
	case equipmenttype.FieldWeight:
		return m.Weight()
	case equipmenttype.FieldIdlingFuelUsage:
		return m.IdlingFuelUsage()
	case equipmenttype.FieldExemptFromTolls:
		return m.ExemptFromTolls()
	case equipmenttype.FieldColor:
		return m.Color()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EquipmentTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case equipmenttype.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case equipmenttype.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case equipmenttype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case equipmenttype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case equipmenttype.FieldVersion:
		return m.OldVersion(ctx)
	case equipmenttype.FieldStatus:
		return m.OldStatus(ctx)
	case equipmenttype.FieldCode:
		return m.OldCode(ctx)
	case equipmenttype.FieldDescription:
		return m.OldDescription(ctx)
	case equipmenttype.FieldCostPerMile:
		return m.OldCostPerMile(ctx)
	case equipmenttype.FieldEquipmentClass:
		return m.OldEquipmentClass(ctx)
	case equipmenttype.FieldFixedCost:
		return m.OldFixedCost(ctx)
	case equipmenttype.FieldVariableCost:
		return m.OldVariableCost(ctx)
	case equipmenttype.FieldHeight:
		return m.OldHeight(ctx)
	case equipmenttype.FieldLength:
		return m.OldLength(ctx)
	case equipmenttype.FieldWidth:
		return m.OldWidth(ctx)
	case equipmenttype.FieldWeight:
		return m.OldWeight(ctx)
	case equipmenttype.FieldIdlingFuelUsage:
		return m.OldIdlingFuelUsage(ctx)
	case equipmenttype.FieldExemptFromTolls:
		return m.OldExemptFromTolls(ctx)
	case equipmenttype.FieldColor:
		return m.OldColor(ctx)
	}
	return nil, fmt.Errorf("unknown EquipmentType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EquipmentTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case equipmenttype.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case equipmenttype.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case equipmenttype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case equipmenttype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case equipmenttype.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case equipmenttype.FieldStatus:
		v, ok := value.(equipmenttype.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case equipmenttype.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case equipmenttype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case equipmenttype.FieldCostPerMile:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCostPerMile(v)
		return nil
	case equipmenttype.FieldEquipmentClass:
		v, ok := value.(equipmenttype.EquipmentClass)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEquipmentClass(v)
		return nil
	case equipmenttype.FieldFixedCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFixedCost(v)
		return nil
	case equipmenttype.FieldVariableCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVariableCost(v)
		return nil
	case equipmenttype.FieldHeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case equipmenttype.FieldLength:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLength(v)
		return nil
	case equipmenttype.FieldWidth:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWidth(v)
		return nil
	case equipmenttype.FieldWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case equipmenttype.FieldIdlingFuelUsage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdlingFuelUsage(v)
		return nil
	case equipmenttype.FieldExemptFromTolls:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExemptFromTolls(v)
		return nil
	case equipmenttype.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	}
	return fmt.Errorf("unknown EquipmentType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EquipmentTypeMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, equipmenttype.FieldVersion)
	}
	if m.addcost_per_mile != nil {
		fields = append(fields, equipmenttype.FieldCostPerMile)
	}
	if m.addfixed_cost != nil {
		fields = append(fields, equipmenttype.FieldFixedCost)
	}
	if m.addvariable_cost != nil {
		fields = append(fields, equipmenttype.FieldVariableCost)
	}
	if m.addheight != nil {
		fields = append(fields, equipmenttype.FieldHeight)
	}
	if m.addlength != nil {
		fields = append(fields, equipmenttype.FieldLength)
	}
	if m.addwidth != nil {
		fields = append(fields, equipmenttype.FieldWidth)
	}
	if m.addweight != nil {
		fields = append(fields, equipmenttype.FieldWeight)
	}
	if m.addidling_fuel_usage != nil {
		fields = append(fields, equipmenttype.FieldIdlingFuelUsage)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EquipmentTypeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case equipmenttype.FieldVersion:
		return m.AddedVersion()
	case equipmenttype.FieldCostPerMile:
		return m.AddedCostPerMile()
	case equipmenttype.FieldFixedCost:
		return m.AddedFixedCost()
	case equipmenttype.FieldVariableCost:
		return m.AddedVariableCost()
	case equipmenttype.FieldHeight:
		return m.AddedHeight()
	case equipmenttype.FieldLength:
		return m.AddedLength()
	case equipmenttype.FieldWidth:
		return m.AddedWidth()
	case equipmenttype.FieldWeight:
		return m.AddedWeight()
	case equipmenttype.FieldIdlingFuelUsage:
		return m.AddedIdlingFuelUsage()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EquipmentTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case equipmenttype.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case equipmenttype.FieldCostPerMile:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCostPerMile(v)
		return nil
	case equipmenttype.FieldFixedCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFixedCost(v)
		return nil
	case equipmenttype.FieldVariableCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVariableCost(v)
		return nil
	case equipmenttype.FieldHeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeight(v)
		return nil
	case equipmenttype.FieldLength:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLength(v)
		return nil
	case equipmenttype.FieldWidth:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWidth(v)
		return nil
	case equipmenttype.FieldWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	case equipmenttype.FieldIdlingFuelUsage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIdlingFuelUsage(v)
		return nil
	}
	return fmt.Errorf("unknown EquipmentType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EquipmentTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(equipmenttype.FieldDescription) {
		fields = append(fields, equipmenttype.FieldDescription)
	}
	if m.FieldCleared(equipmenttype.FieldCostPerMile) {
		fields = append(fields, equipmenttype.FieldCostPerMile)
	}
	if m.FieldCleared(equipmenttype.FieldFixedCost) {
		fields = append(fields, equipmenttype.FieldFixedCost)
	}
	if m.FieldCleared(equipmenttype.FieldVariableCost) {
		fields = append(fields, equipmenttype.FieldVariableCost)
	}
	if m.FieldCleared(equipmenttype.FieldHeight) {
		fields = append(fields, equipmenttype.FieldHeight)
	}
	if m.FieldCleared(equipmenttype.FieldLength) {
		fields = append(fields, equipmenttype.FieldLength)
	}
	if m.FieldCleared(equipmenttype.FieldWidth) {
		fields = append(fields, equipmenttype.FieldWidth)
	}
	if m.FieldCleared(equipmenttype.FieldWeight) {
		fields = append(fields, equipmenttype.FieldWeight)
	}
	if m.FieldCleared(equipmenttype.FieldIdlingFuelUsage) {
		fields = append(fields, equipmenttype.FieldIdlingFuelUsage)
	}
	if m.FieldCleared(equipmenttype.FieldColor) {
		fields = append(fields, equipmenttype.FieldColor)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EquipmentTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EquipmentTypeMutation) ClearField(name string) error {
	switch name {
	case equipmenttype.FieldDescription:
		m.ClearDescription()
		return nil
	case equipmenttype.FieldCostPerMile:
		m.ClearCostPerMile()
		return nil
	case equipmenttype.FieldFixedCost:
		m.ClearFixedCost()
		return nil
	case equipmenttype.FieldVariableCost:
		m.ClearVariableCost()
		return nil
	case equipmenttype.FieldHeight:
		m.ClearHeight()
		return nil
	case equipmenttype.FieldLength:
		m.ClearLength()
		return nil
	case equipmenttype.FieldWidth:
		m.ClearWidth()
		return nil
	case equipmenttype.FieldWeight:
		m.ClearWeight()
		return nil
	case equipmenttype.FieldIdlingFuelUsage:
		m.ClearIdlingFuelUsage()
		return nil
	case equipmenttype.FieldColor:
		m.ClearColor()
		return nil
	}
	return fmt.Errorf("unknown EquipmentType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EquipmentTypeMutation) ResetField(name string) error {
	switch name {
	case equipmenttype.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case equipmenttype.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case equipmenttype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case equipmenttype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case equipmenttype.FieldVersion:
		m.ResetVersion()
		return nil
	case equipmenttype.FieldStatus:
		m.ResetStatus()
		return nil
	case equipmenttype.FieldCode:
		m.ResetCode()
		return nil
	case equipmenttype.FieldDescription:
		m.ResetDescription()
		return nil
	case equipmenttype.FieldCostPerMile:
		m.ResetCostPerMile()
		return nil
	case equipmenttype.FieldEquipmentClass:
		m.ResetEquipmentClass()
		return nil
	case equipmenttype.FieldFixedCost:
		m.ResetFixedCost()
		return nil
	case equipmenttype.FieldVariableCost:
		m.ResetVariableCost()
		return nil
	case equipmenttype.FieldHeight:
		m.ResetHeight()
		return nil
	case equipmenttype.FieldLength:
		m.ResetLength()
		return nil
	case equipmenttype.FieldWidth:
		m.ResetWidth()
		return nil
	case equipmenttype.FieldWeight:
		m.ResetWeight()
		return nil
	case equipmenttype.FieldIdlingFuelUsage:
		m.ResetIdlingFuelUsage()
		return nil
	case equipmenttype.FieldExemptFromTolls:
		m.ResetExemptFromTolls()
		return nil
	case equipmenttype.FieldColor:
		m.ResetColor()
		return nil
	}
	return fmt.Errorf("unknown EquipmentType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EquipmentTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.business_unit != nil {
		edges = append(edges, equipmenttype.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, equipmenttype.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EquipmentTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case equipmenttype.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case equipmenttype.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EquipmentTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EquipmentTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EquipmentTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbusiness_unit {
		edges = append(edges, equipmenttype.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, equipmenttype.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EquipmentTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case equipmenttype.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case equipmenttype.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EquipmentTypeMutation) ClearEdge(name string) error {
	switch name {
	case equipmenttype.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case equipmenttype.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown EquipmentType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EquipmentTypeMutation) ResetEdge(name string) error {
	switch name {
	case equipmenttype.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case equipmenttype.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown EquipmentType edge %s", name)
}

// FeasibilityToolControlMutation represents an operation that mutates the FeasibilityToolControl nodes in the graph.
type FeasibilityToolControlMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	otp_operator         *feasibilitytoolcontrol.OtpOperator
	otp_value            *float64
	addotp_value         *float64
	mpw_operator         *feasibilitytoolcontrol.MpwOperator
	mpw_value            *float64
	addmpw_value         *float64
	mpd_operator         *feasibilitytoolcontrol.MpdOperator
	mpd_value            *float64
	addmpd_value         *float64
	mpg_operator         *feasibilitytoolcontrol.MpgOperator
	mpg_value            *float64
	addmpg_value         *float64
	clearedFields        map[string]struct{}
	organization         *uuid.UUID
	clearedorganization  bool
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	done                 bool
	oldValue             func(context.Context) (*FeasibilityToolControl, error)
	predicates           []predicate.FeasibilityToolControl
}

var _ ent.Mutation = (*FeasibilityToolControlMutation)(nil)

// feasibilitytoolcontrolOption allows management of the mutation configuration using functional options.
type feasibilitytoolcontrolOption func(*FeasibilityToolControlMutation)

// newFeasibilityToolControlMutation creates new mutation for the FeasibilityToolControl entity.
func newFeasibilityToolControlMutation(c config, op Op, opts ...feasibilitytoolcontrolOption) *FeasibilityToolControlMutation {
	m := &FeasibilityToolControlMutation{
		config:        c,
		op:            op,
		typ:           TypeFeasibilityToolControl,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeasibilityToolControlID sets the ID field of the mutation.
func withFeasibilityToolControlID(id uuid.UUID) feasibilitytoolcontrolOption {
	return func(m *FeasibilityToolControlMutation) {
		var (
			err   error
			once  sync.Once
			value *FeasibilityToolControl
		)
		m.oldValue = func(ctx context.Context) (*FeasibilityToolControl, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FeasibilityToolControl.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeasibilityToolControl sets the old FeasibilityToolControl of the mutation.
func withFeasibilityToolControl(node *FeasibilityToolControl) feasibilitytoolcontrolOption {
	return func(m *FeasibilityToolControlMutation) {
		m.oldValue = func(context.Context) (*FeasibilityToolControl, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeasibilityToolControlMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeasibilityToolControlMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FeasibilityToolControl entities.
func (m *FeasibilityToolControlMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeasibilityToolControlMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeasibilityToolControlMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FeasibilityToolControl.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FeasibilityToolControlMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FeasibilityToolControlMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FeasibilityToolControl entity.
// If the FeasibilityToolControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeasibilityToolControlMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FeasibilityToolControlMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FeasibilityToolControlMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FeasibilityToolControlMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FeasibilityToolControl entity.
// If the FeasibilityToolControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeasibilityToolControlMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FeasibilityToolControlMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOtpOperator sets the "otp_operator" field.
func (m *FeasibilityToolControlMutation) SetOtpOperator(fo feasibilitytoolcontrol.OtpOperator) {
	m.otp_operator = &fo
}

// OtpOperator returns the value of the "otp_operator" field in the mutation.
func (m *FeasibilityToolControlMutation) OtpOperator() (r feasibilitytoolcontrol.OtpOperator, exists bool) {
	v := m.otp_operator
	if v == nil {
		return
	}
	return *v, true
}

// OldOtpOperator returns the old "otp_operator" field's value of the FeasibilityToolControl entity.
// If the FeasibilityToolControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeasibilityToolControlMutation) OldOtpOperator(ctx context.Context) (v feasibilitytoolcontrol.OtpOperator, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtpOperator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtpOperator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtpOperator: %w", err)
	}
	return oldValue.OtpOperator, nil
}

// ResetOtpOperator resets all changes to the "otp_operator" field.
func (m *FeasibilityToolControlMutation) ResetOtpOperator() {
	m.otp_operator = nil
}

// SetOtpValue sets the "otp_value" field.
func (m *FeasibilityToolControlMutation) SetOtpValue(f float64) {
	m.otp_value = &f
	m.addotp_value = nil
}

// OtpValue returns the value of the "otp_value" field in the mutation.
func (m *FeasibilityToolControlMutation) OtpValue() (r float64, exists bool) {
	v := m.otp_value
	if v == nil {
		return
	}
	return *v, true
}

// OldOtpValue returns the old "otp_value" field's value of the FeasibilityToolControl entity.
// If the FeasibilityToolControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeasibilityToolControlMutation) OldOtpValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtpValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtpValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtpValue: %w", err)
	}
	return oldValue.OtpValue, nil
}

// AddOtpValue adds f to the "otp_value" field.
func (m *FeasibilityToolControlMutation) AddOtpValue(f float64) {
	if m.addotp_value != nil {
		*m.addotp_value += f
	} else {
		m.addotp_value = &f
	}
}

// AddedOtpValue returns the value that was added to the "otp_value" field in this mutation.
func (m *FeasibilityToolControlMutation) AddedOtpValue() (r float64, exists bool) {
	v := m.addotp_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetOtpValue resets all changes to the "otp_value" field.
func (m *FeasibilityToolControlMutation) ResetOtpValue() {
	m.otp_value = nil
	m.addotp_value = nil
}

// SetMpwOperator sets the "mpw_operator" field.
func (m *FeasibilityToolControlMutation) SetMpwOperator(fo feasibilitytoolcontrol.MpwOperator) {
	m.mpw_operator = &fo
}

// MpwOperator returns the value of the "mpw_operator" field in the mutation.
func (m *FeasibilityToolControlMutation) MpwOperator() (r feasibilitytoolcontrol.MpwOperator, exists bool) {
	v := m.mpw_operator
	if v == nil {
		return
	}
	return *v, true
}

// OldMpwOperator returns the old "mpw_operator" field's value of the FeasibilityToolControl entity.
// If the FeasibilityToolControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeasibilityToolControlMutation) OldMpwOperator(ctx context.Context) (v feasibilitytoolcontrol.MpwOperator, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMpwOperator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMpwOperator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMpwOperator: %w", err)
	}
	return oldValue.MpwOperator, nil
}

// ResetMpwOperator resets all changes to the "mpw_operator" field.
func (m *FeasibilityToolControlMutation) ResetMpwOperator() {
	m.mpw_operator = nil
}

// SetMpwValue sets the "mpw_value" field.
func (m *FeasibilityToolControlMutation) SetMpwValue(f float64) {
	m.mpw_value = &f
	m.addmpw_value = nil
}

// MpwValue returns the value of the "mpw_value" field in the mutation.
func (m *FeasibilityToolControlMutation) MpwValue() (r float64, exists bool) {
	v := m.mpw_value
	if v == nil {
		return
	}
	return *v, true
}

// OldMpwValue returns the old "mpw_value" field's value of the FeasibilityToolControl entity.
// If the FeasibilityToolControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeasibilityToolControlMutation) OldMpwValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMpwValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMpwValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMpwValue: %w", err)
	}
	return oldValue.MpwValue, nil
}

// AddMpwValue adds f to the "mpw_value" field.
func (m *FeasibilityToolControlMutation) AddMpwValue(f float64) {
	if m.addmpw_value != nil {
		*m.addmpw_value += f
	} else {
		m.addmpw_value = &f
	}
}

// AddedMpwValue returns the value that was added to the "mpw_value" field in this mutation.
func (m *FeasibilityToolControlMutation) AddedMpwValue() (r float64, exists bool) {
	v := m.addmpw_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetMpwValue resets all changes to the "mpw_value" field.
func (m *FeasibilityToolControlMutation) ResetMpwValue() {
	m.mpw_value = nil
	m.addmpw_value = nil
}

// SetMpdOperator sets the "mpd_operator" field.
func (m *FeasibilityToolControlMutation) SetMpdOperator(fo feasibilitytoolcontrol.MpdOperator) {
	m.mpd_operator = &fo
}

// MpdOperator returns the value of the "mpd_operator" field in the mutation.
func (m *FeasibilityToolControlMutation) MpdOperator() (r feasibilitytoolcontrol.MpdOperator, exists bool) {
	v := m.mpd_operator
	if v == nil {
		return
	}
	return *v, true
}

// OldMpdOperator returns the old "mpd_operator" field's value of the FeasibilityToolControl entity.
// If the FeasibilityToolControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeasibilityToolControlMutation) OldMpdOperator(ctx context.Context) (v feasibilitytoolcontrol.MpdOperator, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMpdOperator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMpdOperator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMpdOperator: %w", err)
	}
	return oldValue.MpdOperator, nil
}

// ResetMpdOperator resets all changes to the "mpd_operator" field.
func (m *FeasibilityToolControlMutation) ResetMpdOperator() {
	m.mpd_operator = nil
}

// SetMpdValue sets the "mpd_value" field.
func (m *FeasibilityToolControlMutation) SetMpdValue(f float64) {
	m.mpd_value = &f
	m.addmpd_value = nil
}

// MpdValue returns the value of the "mpd_value" field in the mutation.
func (m *FeasibilityToolControlMutation) MpdValue() (r float64, exists bool) {
	v := m.mpd_value
	if v == nil {
		return
	}
	return *v, true
}

// OldMpdValue returns the old "mpd_value" field's value of the FeasibilityToolControl entity.
// If the FeasibilityToolControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeasibilityToolControlMutation) OldMpdValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMpdValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMpdValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMpdValue: %w", err)
	}
	return oldValue.MpdValue, nil
}

// AddMpdValue adds f to the "mpd_value" field.
func (m *FeasibilityToolControlMutation) AddMpdValue(f float64) {
	if m.addmpd_value != nil {
		*m.addmpd_value += f
	} else {
		m.addmpd_value = &f
	}
}

// AddedMpdValue returns the value that was added to the "mpd_value" field in this mutation.
func (m *FeasibilityToolControlMutation) AddedMpdValue() (r float64, exists bool) {
	v := m.addmpd_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetMpdValue resets all changes to the "mpd_value" field.
func (m *FeasibilityToolControlMutation) ResetMpdValue() {
	m.mpd_value = nil
	m.addmpd_value = nil
}

// SetMpgOperator sets the "mpg_operator" field.
func (m *FeasibilityToolControlMutation) SetMpgOperator(fo feasibilitytoolcontrol.MpgOperator) {
	m.mpg_operator = &fo
}

// MpgOperator returns the value of the "mpg_operator" field in the mutation.
func (m *FeasibilityToolControlMutation) MpgOperator() (r feasibilitytoolcontrol.MpgOperator, exists bool) {
	v := m.mpg_operator
	if v == nil {
		return
	}
	return *v, true
}

// OldMpgOperator returns the old "mpg_operator" field's value of the FeasibilityToolControl entity.
// If the FeasibilityToolControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeasibilityToolControlMutation) OldMpgOperator(ctx context.Context) (v feasibilitytoolcontrol.MpgOperator, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMpgOperator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMpgOperator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMpgOperator: %w", err)
	}
	return oldValue.MpgOperator, nil
}

// ResetMpgOperator resets all changes to the "mpg_operator" field.
func (m *FeasibilityToolControlMutation) ResetMpgOperator() {
	m.mpg_operator = nil
}

// SetMpgValue sets the "mpg_value" field.
func (m *FeasibilityToolControlMutation) SetMpgValue(f float64) {
	m.mpg_value = &f
	m.addmpg_value = nil
}

// MpgValue returns the value of the "mpg_value" field in the mutation.
func (m *FeasibilityToolControlMutation) MpgValue() (r float64, exists bool) {
	v := m.mpg_value
	if v == nil {
		return
	}
	return *v, true
}

// OldMpgValue returns the old "mpg_value" field's value of the FeasibilityToolControl entity.
// If the FeasibilityToolControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeasibilityToolControlMutation) OldMpgValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMpgValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMpgValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMpgValue: %w", err)
	}
	return oldValue.MpgValue, nil
}

// AddMpgValue adds f to the "mpg_value" field.
func (m *FeasibilityToolControlMutation) AddMpgValue(f float64) {
	if m.addmpg_value != nil {
		*m.addmpg_value += f
	} else {
		m.addmpg_value = &f
	}
}

// AddedMpgValue returns the value that was added to the "mpg_value" field in this mutation.
func (m *FeasibilityToolControlMutation) AddedMpgValue() (r float64, exists bool) {
	v := m.addmpg_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetMpgValue resets all changes to the "mpg_value" field.
func (m *FeasibilityToolControlMutation) ResetMpgValue() {
	m.mpg_value = nil
	m.addmpg_value = nil
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *FeasibilityToolControlMutation) SetOrganizationID(id uuid.UUID) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *FeasibilityToolControlMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *FeasibilityToolControlMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *FeasibilityToolControlMutation) OrganizationID() (id uuid.UUID, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *FeasibilityToolControlMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *FeasibilityToolControlMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// SetBusinessUnitID sets the "business_unit" edge to the BusinessUnit entity by id.
func (m *FeasibilityToolControlMutation) SetBusinessUnitID(id uuid.UUID) {
	m.business_unit = &id
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *FeasibilityToolControlMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *FeasibilityToolControlMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitID returns the "business_unit" edge ID in the mutation.
func (m *FeasibilityToolControlMutation) BusinessUnitID() (id uuid.UUID, exists bool) {
	if m.business_unit != nil {
		return *m.business_unit, true
	}
	return
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *FeasibilityToolControlMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *FeasibilityToolControlMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// Where appends a list predicates to the FeasibilityToolControlMutation builder.
func (m *FeasibilityToolControlMutation) Where(ps ...predicate.FeasibilityToolControl) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeasibilityToolControlMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeasibilityToolControlMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FeasibilityToolControl, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeasibilityToolControlMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeasibilityToolControlMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FeasibilityToolControl).
func (m *FeasibilityToolControlMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeasibilityToolControlMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, feasibilitytoolcontrol.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, feasibilitytoolcontrol.FieldUpdatedAt)
	}
	if m.otp_operator != nil {
		fields = append(fields, feasibilitytoolcontrol.FieldOtpOperator)
	}
	if m.otp_value != nil {
		fields = append(fields, feasibilitytoolcontrol.FieldOtpValue)
	}
	if m.mpw_operator != nil {
		fields = append(fields, feasibilitytoolcontrol.FieldMpwOperator)
	}
	if m.mpw_value != nil {
		fields = append(fields, feasibilitytoolcontrol.FieldMpwValue)
	}
	if m.mpd_operator != nil {
		fields = append(fields, feasibilitytoolcontrol.FieldMpdOperator)
	}
	if m.mpd_value != nil {
		fields = append(fields, feasibilitytoolcontrol.FieldMpdValue)
	}
	if m.mpg_operator != nil {
		fields = append(fields, feasibilitytoolcontrol.FieldMpgOperator)
	}
	if m.mpg_value != nil {
		fields = append(fields, feasibilitytoolcontrol.FieldMpgValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeasibilityToolControlMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case feasibilitytoolcontrol.FieldCreatedAt:
		return m.CreatedAt()
	case feasibilitytoolcontrol.FieldUpdatedAt:
		return m.UpdatedAt()
	case feasibilitytoolcontrol.FieldOtpOperator:
		return m.OtpOperator()
	case feasibilitytoolcontrol.FieldOtpValue:
		return m.OtpValue()
	case feasibilitytoolcontrol.FieldMpwOperator:
		return m.MpwOperator()
	case feasibilitytoolcontrol.FieldMpwValue:
		return m.MpwValue()
	case feasibilitytoolcontrol.FieldMpdOperator:
		return m.MpdOperator()
	case feasibilitytoolcontrol.FieldMpdValue:
		return m.MpdValue()
	case feasibilitytoolcontrol.FieldMpgOperator:
		return m.MpgOperator()
	case feasibilitytoolcontrol.FieldMpgValue:
		return m.MpgValue()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeasibilityToolControlMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case feasibilitytoolcontrol.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case feasibilitytoolcontrol.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case feasibilitytoolcontrol.FieldOtpOperator:
		return m.OldOtpOperator(ctx)
	case feasibilitytoolcontrol.FieldOtpValue:
		return m.OldOtpValue(ctx)
	case feasibilitytoolcontrol.FieldMpwOperator:
		return m.OldMpwOperator(ctx)
	case feasibilitytoolcontrol.FieldMpwValue:
		return m.OldMpwValue(ctx)
	case feasibilitytoolcontrol.FieldMpdOperator:
		return m.OldMpdOperator(ctx)
	case feasibilitytoolcontrol.FieldMpdValue:
		return m.OldMpdValue(ctx)
	case feasibilitytoolcontrol.FieldMpgOperator:
		return m.OldMpgOperator(ctx)
	case feasibilitytoolcontrol.FieldMpgValue:
		return m.OldMpgValue(ctx)
	}
	return nil, fmt.Errorf("unknown FeasibilityToolControl field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeasibilityToolControlMutation) SetField(name string, value ent.Value) error {
	switch name {
	case feasibilitytoolcontrol.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case feasibilitytoolcontrol.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case feasibilitytoolcontrol.FieldOtpOperator:
		v, ok := value.(feasibilitytoolcontrol.OtpOperator)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtpOperator(v)
		return nil
	case feasibilitytoolcontrol.FieldOtpValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtpValue(v)
		return nil
	case feasibilitytoolcontrol.FieldMpwOperator:
		v, ok := value.(feasibilitytoolcontrol.MpwOperator)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMpwOperator(v)
		return nil
	case feasibilitytoolcontrol.FieldMpwValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMpwValue(v)
		return nil
	case feasibilitytoolcontrol.FieldMpdOperator:
		v, ok := value.(feasibilitytoolcontrol.MpdOperator)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMpdOperator(v)
		return nil
	case feasibilitytoolcontrol.FieldMpdValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMpdValue(v)
		return nil
	case feasibilitytoolcontrol.FieldMpgOperator:
		v, ok := value.(feasibilitytoolcontrol.MpgOperator)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMpgOperator(v)
		return nil
	case feasibilitytoolcontrol.FieldMpgValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMpgValue(v)
		return nil
	}
	return fmt.Errorf("unknown FeasibilityToolControl field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeasibilityToolControlMutation) AddedFields() []string {
	var fields []string
	if m.addotp_value != nil {
		fields = append(fields, feasibilitytoolcontrol.FieldOtpValue)
	}
	if m.addmpw_value != nil {
		fields = append(fields, feasibilitytoolcontrol.FieldMpwValue)
	}
	if m.addmpd_value != nil {
		fields = append(fields, feasibilitytoolcontrol.FieldMpdValue)
	}
	if m.addmpg_value != nil {
		fields = append(fields, feasibilitytoolcontrol.FieldMpgValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeasibilityToolControlMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case feasibilitytoolcontrol.FieldOtpValue:
		return m.AddedOtpValue()
	case feasibilitytoolcontrol.FieldMpwValue:
		return m.AddedMpwValue()
	case feasibilitytoolcontrol.FieldMpdValue:
		return m.AddedMpdValue()
	case feasibilitytoolcontrol.FieldMpgValue:
		return m.AddedMpgValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeasibilityToolControlMutation) AddField(name string, value ent.Value) error {
	switch name {
	case feasibilitytoolcontrol.FieldOtpValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOtpValue(v)
		return nil
	case feasibilitytoolcontrol.FieldMpwValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMpwValue(v)
		return nil
	case feasibilitytoolcontrol.FieldMpdValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMpdValue(v)
		return nil
	case feasibilitytoolcontrol.FieldMpgValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMpgValue(v)
		return nil
	}
	return fmt.Errorf("unknown FeasibilityToolControl numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeasibilityToolControlMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeasibilityToolControlMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeasibilityToolControlMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FeasibilityToolControl nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeasibilityToolControlMutation) ResetField(name string) error {
	switch name {
	case feasibilitytoolcontrol.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case feasibilitytoolcontrol.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case feasibilitytoolcontrol.FieldOtpOperator:
		m.ResetOtpOperator()
		return nil
	case feasibilitytoolcontrol.FieldOtpValue:
		m.ResetOtpValue()
		return nil
	case feasibilitytoolcontrol.FieldMpwOperator:
		m.ResetMpwOperator()
		return nil
	case feasibilitytoolcontrol.FieldMpwValue:
		m.ResetMpwValue()
		return nil
	case feasibilitytoolcontrol.FieldMpdOperator:
		m.ResetMpdOperator()
		return nil
	case feasibilitytoolcontrol.FieldMpdValue:
		m.ResetMpdValue()
		return nil
	case feasibilitytoolcontrol.FieldMpgOperator:
		m.ResetMpgOperator()
		return nil
	case feasibilitytoolcontrol.FieldMpgValue:
		m.ResetMpgValue()
		return nil
	}
	return fmt.Errorf("unknown FeasibilityToolControl field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeasibilityToolControlMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.organization != nil {
		edges = append(edges, feasibilitytoolcontrol.EdgeOrganization)
	}
	if m.business_unit != nil {
		edges = append(edges, feasibilitytoolcontrol.EdgeBusinessUnit)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeasibilityToolControlMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case feasibilitytoolcontrol.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case feasibilitytoolcontrol.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeasibilityToolControlMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeasibilityToolControlMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeasibilityToolControlMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorganization {
		edges = append(edges, feasibilitytoolcontrol.EdgeOrganization)
	}
	if m.clearedbusiness_unit {
		edges = append(edges, feasibilitytoolcontrol.EdgeBusinessUnit)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeasibilityToolControlMutation) EdgeCleared(name string) bool {
	switch name {
	case feasibilitytoolcontrol.EdgeOrganization:
		return m.clearedorganization
	case feasibilitytoolcontrol.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeasibilityToolControlMutation) ClearEdge(name string) error {
	switch name {
	case feasibilitytoolcontrol.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case feasibilitytoolcontrol.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	}
	return fmt.Errorf("unknown FeasibilityToolControl unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeasibilityToolControlMutation) ResetEdge(name string) error {
	switch name {
	case feasibilitytoolcontrol.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case feasibilitytoolcontrol.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	}
	return fmt.Errorf("unknown FeasibilityToolControl edge %s", name)
}

// FeatureFlagMutation represents an operation that mutates the FeatureFlag nodes in the graph.
type FeatureFlagMutation struct {
	config
	op                               Op
	typ                              string
	id                               *uuid.UUID
	created_at                       *time.Time
	updated_at                       *time.Time
	name                             *string
	code                             *string
	beta                             *bool
	description                      *string
	preview_picture_url              *string
	clearedFields                    map[string]struct{}
	organization_feature_flag        map[uuid.UUID]struct{}
	removedorganization_feature_flag map[uuid.UUID]struct{}
	clearedorganization_feature_flag bool
	done                             bool
	oldValue                         func(context.Context) (*FeatureFlag, error)
	predicates                       []predicate.FeatureFlag
}

var _ ent.Mutation = (*FeatureFlagMutation)(nil)

// featureflagOption allows management of the mutation configuration using functional options.
type featureflagOption func(*FeatureFlagMutation)

// newFeatureFlagMutation creates new mutation for the FeatureFlag entity.
func newFeatureFlagMutation(c config, op Op, opts ...featureflagOption) *FeatureFlagMutation {
	m := &FeatureFlagMutation{
		config:        c,
		op:            op,
		typ:           TypeFeatureFlag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeatureFlagID sets the ID field of the mutation.
func withFeatureFlagID(id uuid.UUID) featureflagOption {
	return func(m *FeatureFlagMutation) {
		var (
			err   error
			once  sync.Once
			value *FeatureFlag
		)
		m.oldValue = func(ctx context.Context) (*FeatureFlag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FeatureFlag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeatureFlag sets the old FeatureFlag of the mutation.
func withFeatureFlag(node *FeatureFlag) featureflagOption {
	return func(m *FeatureFlagMutation) {
		m.oldValue = func(context.Context) (*FeatureFlag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeatureFlagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeatureFlagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FeatureFlag entities.
func (m *FeatureFlagMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeatureFlagMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeatureFlagMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FeatureFlag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FeatureFlagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FeatureFlagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FeatureFlag entity.
// If the FeatureFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureFlagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FeatureFlagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FeatureFlagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FeatureFlagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FeatureFlag entity.
// If the FeatureFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureFlagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FeatureFlagMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *FeatureFlagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FeatureFlagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the FeatureFlag entity.
// If the FeatureFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureFlagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FeatureFlagMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *FeatureFlagMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *FeatureFlagMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the FeatureFlag entity.
// If the FeatureFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureFlagMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *FeatureFlagMutation) ResetCode() {
	m.code = nil
}

// SetBeta sets the "beta" field.
func (m *FeatureFlagMutation) SetBeta(b bool) {
	m.beta = &b
}

// Beta returns the value of the "beta" field in the mutation.
func (m *FeatureFlagMutation) Beta() (r bool, exists bool) {
	v := m.beta
	if v == nil {
		return
	}
	return *v, true
}

// OldBeta returns the old "beta" field's value of the FeatureFlag entity.
// If the FeatureFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureFlagMutation) OldBeta(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBeta is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBeta requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBeta: %w", err)
	}
	return oldValue.Beta, nil
}

// ResetBeta resets all changes to the "beta" field.
func (m *FeatureFlagMutation) ResetBeta() {
	m.beta = nil
}

// SetDescription sets the "description" field.
func (m *FeatureFlagMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FeatureFlagMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the FeatureFlag entity.
// If the FeatureFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureFlagMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *FeatureFlagMutation) ResetDescription() {
	m.description = nil
}

// SetPreviewPictureURL sets the "preview_picture_url" field.
func (m *FeatureFlagMutation) SetPreviewPictureURL(s string) {
	m.preview_picture_url = &s
}

// PreviewPictureURL returns the value of the "preview_picture_url" field in the mutation.
func (m *FeatureFlagMutation) PreviewPictureURL() (r string, exists bool) {
	v := m.preview_picture_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPreviewPictureURL returns the old "preview_picture_url" field's value of the FeatureFlag entity.
// If the FeatureFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeatureFlagMutation) OldPreviewPictureURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreviewPictureURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreviewPictureURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreviewPictureURL: %w", err)
	}
	return oldValue.PreviewPictureURL, nil
}

// ClearPreviewPictureURL clears the value of the "preview_picture_url" field.
func (m *FeatureFlagMutation) ClearPreviewPictureURL() {
	m.preview_picture_url = nil
	m.clearedFields[featureflag.FieldPreviewPictureURL] = struct{}{}
}

// PreviewPictureURLCleared returns if the "preview_picture_url" field was cleared in this mutation.
func (m *FeatureFlagMutation) PreviewPictureURLCleared() bool {
	_, ok := m.clearedFields[featureflag.FieldPreviewPictureURL]
	return ok
}

// ResetPreviewPictureURL resets all changes to the "preview_picture_url" field.
func (m *FeatureFlagMutation) ResetPreviewPictureURL() {
	m.preview_picture_url = nil
	delete(m.clearedFields, featureflag.FieldPreviewPictureURL)
}

// AddOrganizationFeatureFlagIDs adds the "organization_feature_flag" edge to the OrganizationFeatureFlag entity by ids.
func (m *FeatureFlagMutation) AddOrganizationFeatureFlagIDs(ids ...uuid.UUID) {
	if m.organization_feature_flag == nil {
		m.organization_feature_flag = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.organization_feature_flag[ids[i]] = struct{}{}
	}
}

// ClearOrganizationFeatureFlag clears the "organization_feature_flag" edge to the OrganizationFeatureFlag entity.
func (m *FeatureFlagMutation) ClearOrganizationFeatureFlag() {
	m.clearedorganization_feature_flag = true
}

// OrganizationFeatureFlagCleared reports if the "organization_feature_flag" edge to the OrganizationFeatureFlag entity was cleared.
func (m *FeatureFlagMutation) OrganizationFeatureFlagCleared() bool {
	return m.clearedorganization_feature_flag
}

// RemoveOrganizationFeatureFlagIDs removes the "organization_feature_flag" edge to the OrganizationFeatureFlag entity by IDs.
func (m *FeatureFlagMutation) RemoveOrganizationFeatureFlagIDs(ids ...uuid.UUID) {
	if m.removedorganization_feature_flag == nil {
		m.removedorganization_feature_flag = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.organization_feature_flag, ids[i])
		m.removedorganization_feature_flag[ids[i]] = struct{}{}
	}
}

// RemovedOrganizationFeatureFlag returns the removed IDs of the "organization_feature_flag" edge to the OrganizationFeatureFlag entity.
func (m *FeatureFlagMutation) RemovedOrganizationFeatureFlagIDs() (ids []uuid.UUID) {
	for id := range m.removedorganization_feature_flag {
		ids = append(ids, id)
	}
	return
}

// OrganizationFeatureFlagIDs returns the "organization_feature_flag" edge IDs in the mutation.
func (m *FeatureFlagMutation) OrganizationFeatureFlagIDs() (ids []uuid.UUID) {
	for id := range m.organization_feature_flag {
		ids = append(ids, id)
	}
	return
}

// ResetOrganizationFeatureFlag resets all changes to the "organization_feature_flag" edge.
func (m *FeatureFlagMutation) ResetOrganizationFeatureFlag() {
	m.organization_feature_flag = nil
	m.clearedorganization_feature_flag = false
	m.removedorganization_feature_flag = nil
}

// Where appends a list predicates to the FeatureFlagMutation builder.
func (m *FeatureFlagMutation) Where(ps ...predicate.FeatureFlag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeatureFlagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeatureFlagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FeatureFlag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeatureFlagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeatureFlagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FeatureFlag).
func (m *FeatureFlagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeatureFlagMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, featureflag.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, featureflag.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, featureflag.FieldName)
	}
	if m.code != nil {
		fields = append(fields, featureflag.FieldCode)
	}
	if m.beta != nil {
		fields = append(fields, featureflag.FieldBeta)
	}
	if m.description != nil {
		fields = append(fields, featureflag.FieldDescription)
	}
	if m.preview_picture_url != nil {
		fields = append(fields, featureflag.FieldPreviewPictureURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeatureFlagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case featureflag.FieldCreatedAt:
		return m.CreatedAt()
	case featureflag.FieldUpdatedAt:
		return m.UpdatedAt()
	case featureflag.FieldName:
		return m.Name()
	case featureflag.FieldCode:
		return m.Code()
	case featureflag.FieldBeta:
		return m.Beta()
	case featureflag.FieldDescription:
		return m.Description()
	case featureflag.FieldPreviewPictureURL:
		return m.PreviewPictureURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeatureFlagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case featureflag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case featureflag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case featureflag.FieldName:
		return m.OldName(ctx)
	case featureflag.FieldCode:
		return m.OldCode(ctx)
	case featureflag.FieldBeta:
		return m.OldBeta(ctx)
	case featureflag.FieldDescription:
		return m.OldDescription(ctx)
	case featureflag.FieldPreviewPictureURL:
		return m.OldPreviewPictureURL(ctx)
	}
	return nil, fmt.Errorf("unknown FeatureFlag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeatureFlagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case featureflag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case featureflag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case featureflag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case featureflag.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case featureflag.FieldBeta:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBeta(v)
		return nil
	case featureflag.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case featureflag.FieldPreviewPictureURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreviewPictureURL(v)
		return nil
	}
	return fmt.Errorf("unknown FeatureFlag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeatureFlagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeatureFlagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeatureFlagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FeatureFlag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeatureFlagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(featureflag.FieldPreviewPictureURL) {
		fields = append(fields, featureflag.FieldPreviewPictureURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeatureFlagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeatureFlagMutation) ClearField(name string) error {
	switch name {
	case featureflag.FieldPreviewPictureURL:
		m.ClearPreviewPictureURL()
		return nil
	}
	return fmt.Errorf("unknown FeatureFlag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeatureFlagMutation) ResetField(name string) error {
	switch name {
	case featureflag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case featureflag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case featureflag.FieldName:
		m.ResetName()
		return nil
	case featureflag.FieldCode:
		m.ResetCode()
		return nil
	case featureflag.FieldBeta:
		m.ResetBeta()
		return nil
	case featureflag.FieldDescription:
		m.ResetDescription()
		return nil
	case featureflag.FieldPreviewPictureURL:
		m.ResetPreviewPictureURL()
		return nil
	}
	return fmt.Errorf("unknown FeatureFlag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeatureFlagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.organization_feature_flag != nil {
		edges = append(edges, featureflag.EdgeOrganizationFeatureFlag)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeatureFlagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case featureflag.EdgeOrganizationFeatureFlag:
		ids := make([]ent.Value, 0, len(m.organization_feature_flag))
		for id := range m.organization_feature_flag {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeatureFlagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedorganization_feature_flag != nil {
		edges = append(edges, featureflag.EdgeOrganizationFeatureFlag)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeatureFlagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case featureflag.EdgeOrganizationFeatureFlag:
		ids := make([]ent.Value, 0, len(m.removedorganization_feature_flag))
		for id := range m.removedorganization_feature_flag {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeatureFlagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedorganization_feature_flag {
		edges = append(edges, featureflag.EdgeOrganizationFeatureFlag)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeatureFlagMutation) EdgeCleared(name string) bool {
	switch name {
	case featureflag.EdgeOrganizationFeatureFlag:
		return m.clearedorganization_feature_flag
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeatureFlagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown FeatureFlag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeatureFlagMutation) ResetEdge(name string) error {
	switch name {
	case featureflag.EdgeOrganizationFeatureFlag:
		m.ResetOrganizationFeatureFlag()
		return nil
	}
	return fmt.Errorf("unknown FeatureFlag edge %s", name)
}

// FleetCodeMutation represents an operation that mutates the FleetCode nodes in the graph.
type FleetCodeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	version              *int
	addversion           *int
	status               *fleetcode.Status
	code                 *string
	description          *string
	revenue_goal         *float64
	addrevenue_goal      *float64
	deadhead_goal        *float64
	adddeadhead_goal     *float64
	mileage_goal         *float64
	addmileage_goal      *float64
	color                *string
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	manager              *uuid.UUID
	clearedmanager       bool
	done                 bool
	oldValue             func(context.Context) (*FleetCode, error)
	predicates           []predicate.FleetCode
}

var _ ent.Mutation = (*FleetCodeMutation)(nil)

// fleetcodeOption allows management of the mutation configuration using functional options.
type fleetcodeOption func(*FleetCodeMutation)

// newFleetCodeMutation creates new mutation for the FleetCode entity.
func newFleetCodeMutation(c config, op Op, opts ...fleetcodeOption) *FleetCodeMutation {
	m := &FleetCodeMutation{
		config:        c,
		op:            op,
		typ:           TypeFleetCode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFleetCodeID sets the ID field of the mutation.
func withFleetCodeID(id uuid.UUID) fleetcodeOption {
	return func(m *FleetCodeMutation) {
		var (
			err   error
			once  sync.Once
			value *FleetCode
		)
		m.oldValue = func(ctx context.Context) (*FleetCode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FleetCode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFleetCode sets the old FleetCode of the mutation.
func withFleetCode(node *FleetCode) fleetcodeOption {
	return func(m *FleetCodeMutation) {
		m.oldValue = func(context.Context) (*FleetCode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FleetCodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FleetCodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FleetCode entities.
func (m *FleetCodeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FleetCodeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FleetCodeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FleetCode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *FleetCodeMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *FleetCodeMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the FleetCode entity.
// If the FleetCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FleetCodeMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *FleetCodeMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *FleetCodeMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *FleetCodeMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the FleetCode entity.
// If the FleetCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FleetCodeMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *FleetCodeMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FleetCodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FleetCodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FleetCode entity.
// If the FleetCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FleetCodeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FleetCodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FleetCodeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FleetCodeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FleetCode entity.
// If the FleetCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FleetCodeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FleetCodeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *FleetCodeMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *FleetCodeMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the FleetCode entity.
// If the FleetCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FleetCodeMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *FleetCodeMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *FleetCodeMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *FleetCodeMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetStatus sets the "status" field.
func (m *FleetCodeMutation) SetStatus(f fleetcode.Status) {
	m.status = &f
}

// Status returns the value of the "status" field in the mutation.
func (m *FleetCodeMutation) Status() (r fleetcode.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the FleetCode entity.
// If the FleetCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FleetCodeMutation) OldStatus(ctx context.Context) (v fleetcode.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *FleetCodeMutation) ResetStatus() {
	m.status = nil
}

// SetCode sets the "code" field.
func (m *FleetCodeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *FleetCodeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the FleetCode entity.
// If the FleetCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FleetCodeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *FleetCodeMutation) ResetCode() {
	m.code = nil
}

// SetDescription sets the "description" field.
func (m *FleetCodeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FleetCodeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the FleetCode entity.
// If the FleetCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FleetCodeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *FleetCodeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[fleetcode.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *FleetCodeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[fleetcode.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *FleetCodeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, fleetcode.FieldDescription)
}

// SetRevenueGoal sets the "revenue_goal" field.
func (m *FleetCodeMutation) SetRevenueGoal(f float64) {
	m.revenue_goal = &f
	m.addrevenue_goal = nil
}

// RevenueGoal returns the value of the "revenue_goal" field in the mutation.
func (m *FleetCodeMutation) RevenueGoal() (r float64, exists bool) {
	v := m.revenue_goal
	if v == nil {
		return
	}
	return *v, true
}

// OldRevenueGoal returns the old "revenue_goal" field's value of the FleetCode entity.
// If the FleetCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FleetCodeMutation) OldRevenueGoal(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevenueGoal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevenueGoal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevenueGoal: %w", err)
	}
	return oldValue.RevenueGoal, nil
}

// AddRevenueGoal adds f to the "revenue_goal" field.
func (m *FleetCodeMutation) AddRevenueGoal(f float64) {
	if m.addrevenue_goal != nil {
		*m.addrevenue_goal += f
	} else {
		m.addrevenue_goal = &f
	}
}

// AddedRevenueGoal returns the value that was added to the "revenue_goal" field in this mutation.
func (m *FleetCodeMutation) AddedRevenueGoal() (r float64, exists bool) {
	v := m.addrevenue_goal
	if v == nil {
		return
	}
	return *v, true
}

// ClearRevenueGoal clears the value of the "revenue_goal" field.
func (m *FleetCodeMutation) ClearRevenueGoal() {
	m.revenue_goal = nil
	m.addrevenue_goal = nil
	m.clearedFields[fleetcode.FieldRevenueGoal] = struct{}{}
}

// RevenueGoalCleared returns if the "revenue_goal" field was cleared in this mutation.
func (m *FleetCodeMutation) RevenueGoalCleared() bool {
	_, ok := m.clearedFields[fleetcode.FieldRevenueGoal]
	return ok
}

// ResetRevenueGoal resets all changes to the "revenue_goal" field.
func (m *FleetCodeMutation) ResetRevenueGoal() {
	m.revenue_goal = nil
	m.addrevenue_goal = nil
	delete(m.clearedFields, fleetcode.FieldRevenueGoal)
}

// SetDeadheadGoal sets the "deadhead_goal" field.
func (m *FleetCodeMutation) SetDeadheadGoal(f float64) {
	m.deadhead_goal = &f
	m.adddeadhead_goal = nil
}

// DeadheadGoal returns the value of the "deadhead_goal" field in the mutation.
func (m *FleetCodeMutation) DeadheadGoal() (r float64, exists bool) {
	v := m.deadhead_goal
	if v == nil {
		return
	}
	return *v, true
}

// OldDeadheadGoal returns the old "deadhead_goal" field's value of the FleetCode entity.
// If the FleetCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FleetCodeMutation) OldDeadheadGoal(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeadheadGoal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeadheadGoal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeadheadGoal: %w", err)
	}
	return oldValue.DeadheadGoal, nil
}

// AddDeadheadGoal adds f to the "deadhead_goal" field.
func (m *FleetCodeMutation) AddDeadheadGoal(f float64) {
	if m.adddeadhead_goal != nil {
		*m.adddeadhead_goal += f
	} else {
		m.adddeadhead_goal = &f
	}
}

// AddedDeadheadGoal returns the value that was added to the "deadhead_goal" field in this mutation.
func (m *FleetCodeMutation) AddedDeadheadGoal() (r float64, exists bool) {
	v := m.adddeadhead_goal
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeadheadGoal clears the value of the "deadhead_goal" field.
func (m *FleetCodeMutation) ClearDeadheadGoal() {
	m.deadhead_goal = nil
	m.adddeadhead_goal = nil
	m.clearedFields[fleetcode.FieldDeadheadGoal] = struct{}{}
}

// DeadheadGoalCleared returns if the "deadhead_goal" field was cleared in this mutation.
func (m *FleetCodeMutation) DeadheadGoalCleared() bool {
	_, ok := m.clearedFields[fleetcode.FieldDeadheadGoal]
	return ok
}

// ResetDeadheadGoal resets all changes to the "deadhead_goal" field.
func (m *FleetCodeMutation) ResetDeadheadGoal() {
	m.deadhead_goal = nil
	m.adddeadhead_goal = nil
	delete(m.clearedFields, fleetcode.FieldDeadheadGoal)
}

// SetMileageGoal sets the "mileage_goal" field.
func (m *FleetCodeMutation) SetMileageGoal(f float64) {
	m.mileage_goal = &f
	m.addmileage_goal = nil
}

// MileageGoal returns the value of the "mileage_goal" field in the mutation.
func (m *FleetCodeMutation) MileageGoal() (r float64, exists bool) {
	v := m.mileage_goal
	if v == nil {
		return
	}
	return *v, true
}

// OldMileageGoal returns the old "mileage_goal" field's value of the FleetCode entity.
// If the FleetCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FleetCodeMutation) OldMileageGoal(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMileageGoal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMileageGoal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMileageGoal: %w", err)
	}
	return oldValue.MileageGoal, nil
}

// AddMileageGoal adds f to the "mileage_goal" field.
func (m *FleetCodeMutation) AddMileageGoal(f float64) {
	if m.addmileage_goal != nil {
		*m.addmileage_goal += f
	} else {
		m.addmileage_goal = &f
	}
}

// AddedMileageGoal returns the value that was added to the "mileage_goal" field in this mutation.
func (m *FleetCodeMutation) AddedMileageGoal() (r float64, exists bool) {
	v := m.addmileage_goal
	if v == nil {
		return
	}
	return *v, true
}

// ClearMileageGoal clears the value of the "mileage_goal" field.
func (m *FleetCodeMutation) ClearMileageGoal() {
	m.mileage_goal = nil
	m.addmileage_goal = nil
	m.clearedFields[fleetcode.FieldMileageGoal] = struct{}{}
}

// MileageGoalCleared returns if the "mileage_goal" field was cleared in this mutation.
func (m *FleetCodeMutation) MileageGoalCleared() bool {
	_, ok := m.clearedFields[fleetcode.FieldMileageGoal]
	return ok
}

// ResetMileageGoal resets all changes to the "mileage_goal" field.
func (m *FleetCodeMutation) ResetMileageGoal() {
	m.mileage_goal = nil
	m.addmileage_goal = nil
	delete(m.clearedFields, fleetcode.FieldMileageGoal)
}

// SetManagerID sets the "manager_id" field.
func (m *FleetCodeMutation) SetManagerID(u uuid.UUID) {
	m.manager = &u
}

// ManagerID returns the value of the "manager_id" field in the mutation.
func (m *FleetCodeMutation) ManagerID() (r uuid.UUID, exists bool) {
	v := m.manager
	if v == nil {
		return
	}
	return *v, true
}

// OldManagerID returns the old "manager_id" field's value of the FleetCode entity.
// If the FleetCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FleetCodeMutation) OldManagerID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManagerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManagerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManagerID: %w", err)
	}
	return oldValue.ManagerID, nil
}

// ClearManagerID clears the value of the "manager_id" field.
func (m *FleetCodeMutation) ClearManagerID() {
	m.manager = nil
	m.clearedFields[fleetcode.FieldManagerID] = struct{}{}
}

// ManagerIDCleared returns if the "manager_id" field was cleared in this mutation.
func (m *FleetCodeMutation) ManagerIDCleared() bool {
	_, ok := m.clearedFields[fleetcode.FieldManagerID]
	return ok
}

// ResetManagerID resets all changes to the "manager_id" field.
func (m *FleetCodeMutation) ResetManagerID() {
	m.manager = nil
	delete(m.clearedFields, fleetcode.FieldManagerID)
}

// SetColor sets the "color" field.
func (m *FleetCodeMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *FleetCodeMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the FleetCode entity.
// If the FleetCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FleetCodeMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *FleetCodeMutation) ClearColor() {
	m.color = nil
	m.clearedFields[fleetcode.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *FleetCodeMutation) ColorCleared() bool {
	_, ok := m.clearedFields[fleetcode.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *FleetCodeMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, fleetcode.FieldColor)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *FleetCodeMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[fleetcode.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *FleetCodeMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *FleetCodeMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *FleetCodeMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *FleetCodeMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[fleetcode.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *FleetCodeMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *FleetCodeMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *FleetCodeMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearManager clears the "manager" edge to the User entity.
func (m *FleetCodeMutation) ClearManager() {
	m.clearedmanager = true
	m.clearedFields[fleetcode.FieldManagerID] = struct{}{}
}

// ManagerCleared reports if the "manager" edge to the User entity was cleared.
func (m *FleetCodeMutation) ManagerCleared() bool {
	return m.ManagerIDCleared() || m.clearedmanager
}

// ManagerIDs returns the "manager" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ManagerID instead. It exists only for internal usage by the builders.
func (m *FleetCodeMutation) ManagerIDs() (ids []uuid.UUID) {
	if id := m.manager; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetManager resets all changes to the "manager" edge.
func (m *FleetCodeMutation) ResetManager() {
	m.manager = nil
	m.clearedmanager = false
}

// Where appends a list predicates to the FleetCodeMutation builder.
func (m *FleetCodeMutation) Where(ps ...predicate.FleetCode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FleetCodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FleetCodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FleetCode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FleetCodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FleetCodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FleetCode).
func (m *FleetCodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FleetCodeMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.business_unit != nil {
		fields = append(fields, fleetcode.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, fleetcode.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, fleetcode.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, fleetcode.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, fleetcode.FieldVersion)
	}
	if m.status != nil {
		fields = append(fields, fleetcode.FieldStatus)
	}
	if m.code != nil {
		fields = append(fields, fleetcode.FieldCode)
	}
	if m.description != nil {
		fields = append(fields, fleetcode.FieldDescription)
	}
	if m.revenue_goal != nil {
		fields = append(fields, fleetcode.FieldRevenueGoal)
	}
	if m.deadhead_goal != nil {
		fields = append(fields, fleetcode.FieldDeadheadGoal)
	}
	if m.mileage_goal != nil {
		fields = append(fields, fleetcode.FieldMileageGoal)
	}
	if m.manager != nil {
		fields = append(fields, fleetcode.FieldManagerID)
	}
	if m.color != nil {
		fields = append(fields, fleetcode.FieldColor)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FleetCodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fleetcode.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case fleetcode.FieldOrganizationID:
		return m.OrganizationID()
	case fleetcode.FieldCreatedAt:
		return m.CreatedAt()
	case fleetcode.FieldUpdatedAt:
		return m.UpdatedAt()
	case fleetcode.FieldVersion:
		return m.Version()
	case fleetcode.FieldStatus:
		return m.Status()
	case fleetcode.FieldCode:
		return m.Code()
	case fleetcode.FieldDescription:
		return m.Description()
	case fleetcode.FieldRevenueGoal:
		return m.RevenueGoal()
	case fleetcode.FieldDeadheadGoal:
		return m.DeadheadGoal()
	case fleetcode.FieldMileageGoal:
		return m.MileageGoal()
	case fleetcode.FieldManagerID:
		return m.ManagerID()
	case fleetcode.FieldColor:
		return m.Color()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FleetCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fleetcode.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case fleetcode.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case fleetcode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case fleetcode.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case fleetcode.FieldVersion:
		return m.OldVersion(ctx)
	case fleetcode.FieldStatus:
		return m.OldStatus(ctx)
	case fleetcode.FieldCode:
		return m.OldCode(ctx)
	case fleetcode.FieldDescription:
		return m.OldDescription(ctx)
	case fleetcode.FieldRevenueGoal:
		return m.OldRevenueGoal(ctx)
	case fleetcode.FieldDeadheadGoal:
		return m.OldDeadheadGoal(ctx)
	case fleetcode.FieldMileageGoal:
		return m.OldMileageGoal(ctx)
	case fleetcode.FieldManagerID:
		return m.OldManagerID(ctx)
	case fleetcode.FieldColor:
		return m.OldColor(ctx)
	}
	return nil, fmt.Errorf("unknown FleetCode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FleetCodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fleetcode.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case fleetcode.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case fleetcode.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case fleetcode.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case fleetcode.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case fleetcode.FieldStatus:
		v, ok := value.(fleetcode.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case fleetcode.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case fleetcode.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case fleetcode.FieldRevenueGoal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevenueGoal(v)
		return nil
	case fleetcode.FieldDeadheadGoal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeadheadGoal(v)
		return nil
	case fleetcode.FieldMileageGoal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMileageGoal(v)
		return nil
	case fleetcode.FieldManagerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManagerID(v)
		return nil
	case fleetcode.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	}
	return fmt.Errorf("unknown FleetCode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FleetCodeMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, fleetcode.FieldVersion)
	}
	if m.addrevenue_goal != nil {
		fields = append(fields, fleetcode.FieldRevenueGoal)
	}
	if m.adddeadhead_goal != nil {
		fields = append(fields, fleetcode.FieldDeadheadGoal)
	}
	if m.addmileage_goal != nil {
		fields = append(fields, fleetcode.FieldMileageGoal)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FleetCodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case fleetcode.FieldVersion:
		return m.AddedVersion()
	case fleetcode.FieldRevenueGoal:
		return m.AddedRevenueGoal()
	case fleetcode.FieldDeadheadGoal:
		return m.AddedDeadheadGoal()
	case fleetcode.FieldMileageGoal:
		return m.AddedMileageGoal()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FleetCodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case fleetcode.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case fleetcode.FieldRevenueGoal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRevenueGoal(v)
		return nil
	case fleetcode.FieldDeadheadGoal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeadheadGoal(v)
		return nil
	case fleetcode.FieldMileageGoal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMileageGoal(v)
		return nil
	}
	return fmt.Errorf("unknown FleetCode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FleetCodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(fleetcode.FieldDescription) {
		fields = append(fields, fleetcode.FieldDescription)
	}
	if m.FieldCleared(fleetcode.FieldRevenueGoal) {
		fields = append(fields, fleetcode.FieldRevenueGoal)
	}
	if m.FieldCleared(fleetcode.FieldDeadheadGoal) {
		fields = append(fields, fleetcode.FieldDeadheadGoal)
	}
	if m.FieldCleared(fleetcode.FieldMileageGoal) {
		fields = append(fields, fleetcode.FieldMileageGoal)
	}
	if m.FieldCleared(fleetcode.FieldManagerID) {
		fields = append(fields, fleetcode.FieldManagerID)
	}
	if m.FieldCleared(fleetcode.FieldColor) {
		fields = append(fields, fleetcode.FieldColor)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FleetCodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FleetCodeMutation) ClearField(name string) error {
	switch name {
	case fleetcode.FieldDescription:
		m.ClearDescription()
		return nil
	case fleetcode.FieldRevenueGoal:
		m.ClearRevenueGoal()
		return nil
	case fleetcode.FieldDeadheadGoal:
		m.ClearDeadheadGoal()
		return nil
	case fleetcode.FieldMileageGoal:
		m.ClearMileageGoal()
		return nil
	case fleetcode.FieldManagerID:
		m.ClearManagerID()
		return nil
	case fleetcode.FieldColor:
		m.ClearColor()
		return nil
	}
	return fmt.Errorf("unknown FleetCode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FleetCodeMutation) ResetField(name string) error {
	switch name {
	case fleetcode.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case fleetcode.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case fleetcode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case fleetcode.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case fleetcode.FieldVersion:
		m.ResetVersion()
		return nil
	case fleetcode.FieldStatus:
		m.ResetStatus()
		return nil
	case fleetcode.FieldCode:
		m.ResetCode()
		return nil
	case fleetcode.FieldDescription:
		m.ResetDescription()
		return nil
	case fleetcode.FieldRevenueGoal:
		m.ResetRevenueGoal()
		return nil
	case fleetcode.FieldDeadheadGoal:
		m.ResetDeadheadGoal()
		return nil
	case fleetcode.FieldMileageGoal:
		m.ResetMileageGoal()
		return nil
	case fleetcode.FieldManagerID:
		m.ResetManagerID()
		return nil
	case fleetcode.FieldColor:
		m.ResetColor()
		return nil
	}
	return fmt.Errorf("unknown FleetCode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FleetCodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.business_unit != nil {
		edges = append(edges, fleetcode.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, fleetcode.EdgeOrganization)
	}
	if m.manager != nil {
		edges = append(edges, fleetcode.EdgeManager)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FleetCodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case fleetcode.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case fleetcode.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case fleetcode.EdgeManager:
		if id := m.manager; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FleetCodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FleetCodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FleetCodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbusiness_unit {
		edges = append(edges, fleetcode.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, fleetcode.EdgeOrganization)
	}
	if m.clearedmanager {
		edges = append(edges, fleetcode.EdgeManager)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FleetCodeMutation) EdgeCleared(name string) bool {
	switch name {
	case fleetcode.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case fleetcode.EdgeOrganization:
		return m.clearedorganization
	case fleetcode.EdgeManager:
		return m.clearedmanager
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FleetCodeMutation) ClearEdge(name string) error {
	switch name {
	case fleetcode.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case fleetcode.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case fleetcode.EdgeManager:
		m.ClearManager()
		return nil
	}
	return fmt.Errorf("unknown FleetCode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FleetCodeMutation) ResetEdge(name string) error {
	switch name {
	case fleetcode.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case fleetcode.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case fleetcode.EdgeManager:
		m.ResetManager()
		return nil
	}
	return fmt.Errorf("unknown FleetCode edge %s", name)
}

// FormulaTemplateMutation represents an operation that mutates the FormulaTemplate nodes in the graph.
type FormulaTemplateMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	version              *int
	addversion           *int
	name                 *string
	formula_text         *string
	description          *string
	template_type        *formulatemplate.TemplateType
	auto_apply           *bool
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	customer             *uuid.UUID
	clearedcustomer      bool
	shipment_type        *uuid.UUID
	clearedshipment_type bool
	done                 bool
	oldValue             func(context.Context) (*FormulaTemplate, error)
	predicates           []predicate.FormulaTemplate
}

var _ ent.Mutation = (*FormulaTemplateMutation)(nil)

// formulatemplateOption allows management of the mutation configuration using functional options.
type formulatemplateOption func(*FormulaTemplateMutation)

// newFormulaTemplateMutation creates new mutation for the FormulaTemplate entity.
func newFormulaTemplateMutation(c config, op Op, opts ...formulatemplateOption) *FormulaTemplateMutation {
	m := &FormulaTemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeFormulaTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFormulaTemplateID sets the ID field of the mutation.
func withFormulaTemplateID(id uuid.UUID) formulatemplateOption {
	return func(m *FormulaTemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *FormulaTemplate
		)
		m.oldValue = func(ctx context.Context) (*FormulaTemplate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FormulaTemplate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFormulaTemplate sets the old FormulaTemplate of the mutation.
func withFormulaTemplate(node *FormulaTemplate) formulatemplateOption {
	return func(m *FormulaTemplateMutation) {
		m.oldValue = func(context.Context) (*FormulaTemplate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FormulaTemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FormulaTemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FormulaTemplate entities.
func (m *FormulaTemplateMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FormulaTemplateMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FormulaTemplateMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FormulaTemplate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *FormulaTemplateMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *FormulaTemplateMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the FormulaTemplate entity.
// If the FormulaTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FormulaTemplateMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *FormulaTemplateMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *FormulaTemplateMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *FormulaTemplateMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the FormulaTemplate entity.
// If the FormulaTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FormulaTemplateMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *FormulaTemplateMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FormulaTemplateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FormulaTemplateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FormulaTemplate entity.
// If the FormulaTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FormulaTemplateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FormulaTemplateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FormulaTemplateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FormulaTemplateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FormulaTemplate entity.
// If the FormulaTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FormulaTemplateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FormulaTemplateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *FormulaTemplateMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *FormulaTemplateMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the FormulaTemplate entity.
// If the FormulaTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FormulaTemplateMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *FormulaTemplateMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *FormulaTemplateMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *FormulaTemplateMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetName sets the "name" field.
func (m *FormulaTemplateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FormulaTemplateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the FormulaTemplate entity.
// If the FormulaTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FormulaTemplateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FormulaTemplateMutation) ResetName() {
	m.name = nil
}

// SetFormulaText sets the "formula_text" field.
func (m *FormulaTemplateMutation) SetFormulaText(s string) {
	m.formula_text = &s
}

// FormulaText returns the value of the "formula_text" field in the mutation.
func (m *FormulaTemplateMutation) FormulaText() (r string, exists bool) {
	v := m.formula_text
	if v == nil {
		return
	}
	return *v, true
}

// OldFormulaText returns the old "formula_text" field's value of the FormulaTemplate entity.
// If the FormulaTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FormulaTemplateMutation) OldFormulaText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormulaText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormulaText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormulaText: %w", err)
	}
	return oldValue.FormulaText, nil
}

// ResetFormulaText resets all changes to the "formula_text" field.
func (m *FormulaTemplateMutation) ResetFormulaText() {
	m.formula_text = nil
}

// SetDescription sets the "description" field.
func (m *FormulaTemplateMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FormulaTemplateMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the FormulaTemplate entity.
// If the FormulaTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FormulaTemplateMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *FormulaTemplateMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[formulatemplate.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *FormulaTemplateMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[formulatemplate.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *FormulaTemplateMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, formulatemplate.FieldDescription)
}

// SetTemplateType sets the "template_type" field.
func (m *FormulaTemplateMutation) SetTemplateType(ft formulatemplate.TemplateType) {
	m.template_type = &ft
}

// TemplateType returns the value of the "template_type" field in the mutation.
func (m *FormulaTemplateMutation) TemplateType() (r formulatemplate.TemplateType, exists bool) {
	v := m.template_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateType returns the old "template_type" field's value of the FormulaTemplate entity.
// If the FormulaTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FormulaTemplateMutation) OldTemplateType(ctx context.Context) (v formulatemplate.TemplateType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateType: %w", err)
	}
	return oldValue.TemplateType, nil
}

// ResetTemplateType resets all changes to the "template_type" field.
func (m *FormulaTemplateMutation) ResetTemplateType() {
	m.template_type = nil
}

// SetCustomerID sets the "customer_id" field.
func (m *FormulaTemplateMutation) SetCustomerID(u uuid.UUID) {
	m.customer = &u
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *FormulaTemplateMutation) CustomerID() (r uuid.UUID, exists bool) {
	v := m.customer
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the FormulaTemplate entity.
// If the FormulaTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FormulaTemplateMutation) OldCustomerID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ClearCustomerID clears the value of the "customer_id" field.
func (m *FormulaTemplateMutation) ClearCustomerID() {
	m.customer = nil
	m.clearedFields[formulatemplate.FieldCustomerID] = struct{}{}
}

// CustomerIDCleared returns if the "customer_id" field was cleared in this mutation.
func (m *FormulaTemplateMutation) CustomerIDCleared() bool {
	_, ok := m.clearedFields[formulatemplate.FieldCustomerID]
	return ok
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *FormulaTemplateMutation) ResetCustomerID() {
	m.customer = nil
	delete(m.clearedFields, formulatemplate.FieldCustomerID)
}

// SetShipmentTypeID sets the "shipment_type_id" field.
func (m *FormulaTemplateMutation) SetShipmentTypeID(u uuid.UUID) {
	m.shipment_type = &u
}

// ShipmentTypeID returns the value of the "shipment_type_id" field in the mutation.
func (m *FormulaTemplateMutation) ShipmentTypeID() (r uuid.UUID, exists bool) {
	v := m.shipment_type
	if v == nil {
		return
	}
	return *v, true
}

// OldShipmentTypeID returns the old "shipment_type_id" field's value of the FormulaTemplate entity.
// If the FormulaTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FormulaTemplateMutation) OldShipmentTypeID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShipmentTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShipmentTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipmentTypeID: %w", err)
	}
	return oldValue.ShipmentTypeID, nil
}

// ClearShipmentTypeID clears the value of the "shipment_type_id" field.
func (m *FormulaTemplateMutation) ClearShipmentTypeID() {
	m.shipment_type = nil
	m.clearedFields[formulatemplate.FieldShipmentTypeID] = struct{}{}
}

// ShipmentTypeIDCleared returns if the "shipment_type_id" field was cleared in this mutation.
func (m *FormulaTemplateMutation) ShipmentTypeIDCleared() bool {
	_, ok := m.clearedFields[formulatemplate.FieldShipmentTypeID]
	return ok
}

// ResetShipmentTypeID resets all changes to the "shipment_type_id" field.
func (m *FormulaTemplateMutation) ResetShipmentTypeID() {
	m.shipment_type = nil
	delete(m.clearedFields, formulatemplate.FieldShipmentTypeID)
}

// SetAutoApply sets the "auto_apply" field.
func (m *FormulaTemplateMutation) SetAutoApply(b bool) {
	m.auto_apply = &b
}

// AutoApply returns the value of the "auto_apply" field in the mutation.
func (m *FormulaTemplateMutation) AutoApply() (r bool, exists bool) {
	v := m.auto_apply
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoApply returns the old "auto_apply" field's value of the FormulaTemplate entity.
// If the FormulaTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FormulaTemplateMutation) OldAutoApply(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoApply is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoApply requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoApply: %w", err)
	}
	return oldValue.AutoApply, nil
}

// ResetAutoApply resets all changes to the "auto_apply" field.
func (m *FormulaTemplateMutation) ResetAutoApply() {
	m.auto_apply = nil
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *FormulaTemplateMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[formulatemplate.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *FormulaTemplateMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *FormulaTemplateMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *FormulaTemplateMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *FormulaTemplateMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[formulatemplate.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *FormulaTemplateMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *FormulaTemplateMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *FormulaTemplateMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *FormulaTemplateMutation) ClearCustomer() {
	m.clearedcustomer = true
	m.clearedFields[formulatemplate.FieldCustomerID] = struct{}{}
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *FormulaTemplateMutation) CustomerCleared() bool {
	return m.CustomerIDCleared() || m.clearedcustomer
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *FormulaTemplateMutation) CustomerIDs() (ids []uuid.UUID) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *FormulaTemplateMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// ClearShipmentType clears the "shipment_type" edge to the ShipmentType entity.
func (m *FormulaTemplateMutation) ClearShipmentType() {
	m.clearedshipment_type = true
	m.clearedFields[formulatemplate.FieldShipmentTypeID] = struct{}{}
}

// ShipmentTypeCleared reports if the "shipment_type" edge to the ShipmentType entity was cleared.
func (m *FormulaTemplateMutation) ShipmentTypeCleared() bool {
	return m.ShipmentTypeIDCleared() || m.clearedshipment_type
}

// ShipmentTypeIDs returns the "shipment_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentTypeID instead. It exists only for internal usage by the builders.
func (m *FormulaTemplateMutation) ShipmentTypeIDs() (ids []uuid.UUID) {
	if id := m.shipment_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipmentType resets all changes to the "shipment_type" edge.
func (m *FormulaTemplateMutation) ResetShipmentType() {
	m.shipment_type = nil
	m.clearedshipment_type = false
}

// Where appends a list predicates to the FormulaTemplateMutation builder.
func (m *FormulaTemplateMutation) Where(ps ...predicate.FormulaTemplate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FormulaTemplateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FormulaTemplateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FormulaTemplate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FormulaTemplateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FormulaTemplateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FormulaTemplate).
func (m *FormulaTemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FormulaTemplateMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.business_unit != nil {
		fields = append(fields, formulatemplate.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, formulatemplate.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, formulatemplate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, formulatemplate.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, formulatemplate.FieldVersion)
	}
	if m.name != nil {
		fields = append(fields, formulatemplate.FieldName)
	}
	if m.formula_text != nil {
		fields = append(fields, formulatemplate.FieldFormulaText)
	}
	if m.description != nil {
		fields = append(fields, formulatemplate.FieldDescription)
	}
	if m.template_type != nil {
		fields = append(fields, formulatemplate.FieldTemplateType)
	}
	if m.customer != nil {
		fields = append(fields, formulatemplate.FieldCustomerID)
	}
	if m.shipment_type != nil {
		fields = append(fields, formulatemplate.FieldShipmentTypeID)
	}
	if m.auto_apply != nil {
		fields = append(fields, formulatemplate.FieldAutoApply)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FormulaTemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case formulatemplate.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case formulatemplate.FieldOrganizationID:
		return m.OrganizationID()
	case formulatemplate.FieldCreatedAt:
		return m.CreatedAt()
	case formulatemplate.FieldUpdatedAt:
		return m.UpdatedAt()
	case formulatemplate.FieldVersion:
		return m.Version()
	case formulatemplate.FieldName:
		return m.Name()
	case formulatemplate.FieldFormulaText:
		return m.FormulaText()
	case formulatemplate.FieldDescription:
		return m.Description()
	case formulatemplate.FieldTemplateType:
		return m.TemplateType()
	case formulatemplate.FieldCustomerID:
		return m.CustomerID()
	case formulatemplate.FieldShipmentTypeID:
		return m.ShipmentTypeID()
	case formulatemplate.FieldAutoApply:
		return m.AutoApply()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FormulaTemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case formulatemplate.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case formulatemplate.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case formulatemplate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case formulatemplate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case formulatemplate.FieldVersion:
		return m.OldVersion(ctx)
	case formulatemplate.FieldName:
		return m.OldName(ctx)
	case formulatemplate.FieldFormulaText:
		return m.OldFormulaText(ctx)
	case formulatemplate.FieldDescription:
		return m.OldDescription(ctx)
	case formulatemplate.FieldTemplateType:
		return m.OldTemplateType(ctx)
	case formulatemplate.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case formulatemplate.FieldShipmentTypeID:
		return m.OldShipmentTypeID(ctx)
	case formulatemplate.FieldAutoApply:
		return m.OldAutoApply(ctx)
	}
	return nil, fmt.Errorf("unknown FormulaTemplate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FormulaTemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case formulatemplate.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case formulatemplate.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case formulatemplate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case formulatemplate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case formulatemplate.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case formulatemplate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case formulatemplate.FieldFormulaText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormulaText(v)
		return nil
	case formulatemplate.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case formulatemplate.FieldTemplateType:
		v, ok := value.(formulatemplate.TemplateType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateType(v)
		return nil
	case formulatemplate.FieldCustomerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case formulatemplate.FieldShipmentTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipmentTypeID(v)
		return nil
	case formulatemplate.FieldAutoApply:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoApply(v)
		return nil
	}
	return fmt.Errorf("unknown FormulaTemplate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FormulaTemplateMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, formulatemplate.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FormulaTemplateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case formulatemplate.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FormulaTemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case formulatemplate.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown FormulaTemplate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FormulaTemplateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(formulatemplate.FieldDescription) {
		fields = append(fields, formulatemplate.FieldDescription)
	}
	if m.FieldCleared(formulatemplate.FieldCustomerID) {
		fields = append(fields, formulatemplate.FieldCustomerID)
	}
	if m.FieldCleared(formulatemplate.FieldShipmentTypeID) {
		fields = append(fields, formulatemplate.FieldShipmentTypeID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FormulaTemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FormulaTemplateMutation) ClearField(name string) error {
	switch name {
	case formulatemplate.FieldDescription:
		m.ClearDescription()
		return nil
	case formulatemplate.FieldCustomerID:
		m.ClearCustomerID()
		return nil
	case formulatemplate.FieldShipmentTypeID:
		m.ClearShipmentTypeID()
		return nil
	}
	return fmt.Errorf("unknown FormulaTemplate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FormulaTemplateMutation) ResetField(name string) error {
	switch name {
	case formulatemplate.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case formulatemplate.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case formulatemplate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case formulatemplate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case formulatemplate.FieldVersion:
		m.ResetVersion()
		return nil
	case formulatemplate.FieldName:
		m.ResetName()
		return nil
	case formulatemplate.FieldFormulaText:
		m.ResetFormulaText()
		return nil
	case formulatemplate.FieldDescription:
		m.ResetDescription()
		return nil
	case formulatemplate.FieldTemplateType:
		m.ResetTemplateType()
		return nil
	case formulatemplate.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case formulatemplate.FieldShipmentTypeID:
		m.ResetShipmentTypeID()
		return nil
	case formulatemplate.FieldAutoApply:
		m.ResetAutoApply()
		return nil
	}
	return fmt.Errorf("unknown FormulaTemplate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FormulaTemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.business_unit != nil {
		edges = append(edges, formulatemplate.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, formulatemplate.EdgeOrganization)
	}
	if m.customer != nil {
		edges = append(edges, formulatemplate.EdgeCustomer)
	}
	if m.shipment_type != nil {
		edges = append(edges, formulatemplate.EdgeShipmentType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FormulaTemplateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case formulatemplate.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case formulatemplate.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case formulatemplate.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	case formulatemplate.EdgeShipmentType:
		if id := m.shipment_type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FormulaTemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FormulaTemplateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FormulaTemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedbusiness_unit {
		edges = append(edges, formulatemplate.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, formulatemplate.EdgeOrganization)
	}
	if m.clearedcustomer {
		edges = append(edges, formulatemplate.EdgeCustomer)
	}
	if m.clearedshipment_type {
		edges = append(edges, formulatemplate.EdgeShipmentType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FormulaTemplateMutation) EdgeCleared(name string) bool {
	switch name {
	case formulatemplate.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case formulatemplate.EdgeOrganization:
		return m.clearedorganization
	case formulatemplate.EdgeCustomer:
		return m.clearedcustomer
	case formulatemplate.EdgeShipmentType:
		return m.clearedshipment_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FormulaTemplateMutation) ClearEdge(name string) error {
	switch name {
	case formulatemplate.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case formulatemplate.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case formulatemplate.EdgeCustomer:
		m.ClearCustomer()
		return nil
	case formulatemplate.EdgeShipmentType:
		m.ClearShipmentType()
		return nil
	}
	return fmt.Errorf("unknown FormulaTemplate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FormulaTemplateMutation) ResetEdge(name string) error {
	switch name {
	case formulatemplate.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case formulatemplate.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case formulatemplate.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case formulatemplate.EdgeShipmentType:
		m.ResetShipmentType()
		return nil
	}
	return fmt.Errorf("unknown FormulaTemplate edge %s", name)
}

// GeneralLedgerAccountMutation represents an operation that mutates the GeneralLedgerAccount nodes in the graph.
type GeneralLedgerAccountMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	version              *int
	addversion           *int
	status               *generalledgeraccount.Status
	account_number       *string
	account_type         *generalledgeraccount.AccountType
	cash_flow_type       *string
	account_sub_type     *string
	account_class        *string
	balance              *float64
	addbalance           *float64
	interest_rate        *float64
	addinterest_rate     *float64
	date_closed          **pgtype.Date
	notes                *string
	is_tax_relevant      *bool
	is_reconciled        *bool
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	tags                 map[uuid.UUID]struct{}
	removedtags          map[uuid.UUID]struct{}
	clearedtags          bool
	done                 bool
	oldValue             func(context.Context) (*GeneralLedgerAccount, error)
	predicates           []predicate.GeneralLedgerAccount
}

var _ ent.Mutation = (*GeneralLedgerAccountMutation)(nil)

// generalledgeraccountOption allows management of the mutation configuration using functional options.
type generalledgeraccountOption func(*GeneralLedgerAccountMutation)

// newGeneralLedgerAccountMutation creates new mutation for the GeneralLedgerAccount entity.
func newGeneralLedgerAccountMutation(c config, op Op, opts ...generalledgeraccountOption) *GeneralLedgerAccountMutation {
	m := &GeneralLedgerAccountMutation{
		config:        c,
		op:            op,
		typ:           TypeGeneralLedgerAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGeneralLedgerAccountID sets the ID field of the mutation.
func withGeneralLedgerAccountID(id uuid.UUID) generalledgeraccountOption {
	return func(m *GeneralLedgerAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *GeneralLedgerAccount
		)
		m.oldValue = func(ctx context.Context) (*GeneralLedgerAccount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GeneralLedgerAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGeneralLedgerAccount sets the old GeneralLedgerAccount of the mutation.
func withGeneralLedgerAccount(node *GeneralLedgerAccount) generalledgeraccountOption {
	return func(m *GeneralLedgerAccountMutation) {
		m.oldValue = func(context.Context) (*GeneralLedgerAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GeneralLedgerAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GeneralLedgerAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GeneralLedgerAccount entities.
func (m *GeneralLedgerAccountMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GeneralLedgerAccountMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GeneralLedgerAccountMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GeneralLedgerAccount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *GeneralLedgerAccountMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *GeneralLedgerAccountMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *GeneralLedgerAccountMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *GeneralLedgerAccountMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *GeneralLedgerAccountMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *GeneralLedgerAccountMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GeneralLedgerAccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GeneralLedgerAccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GeneralLedgerAccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GeneralLedgerAccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GeneralLedgerAccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GeneralLedgerAccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *GeneralLedgerAccountMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *GeneralLedgerAccountMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *GeneralLedgerAccountMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *GeneralLedgerAccountMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *GeneralLedgerAccountMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetStatus sets the "status" field.
func (m *GeneralLedgerAccountMutation) SetStatus(ge generalledgeraccount.Status) {
	m.status = &ge
}

// Status returns the value of the "status" field in the mutation.
func (m *GeneralLedgerAccountMutation) Status() (r generalledgeraccount.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldStatus(ctx context.Context) (v generalledgeraccount.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *GeneralLedgerAccountMutation) ResetStatus() {
	m.status = nil
}

// SetAccountNumber sets the "account_number" field.
func (m *GeneralLedgerAccountMutation) SetAccountNumber(s string) {
	m.account_number = &s
}

// AccountNumber returns the value of the "account_number" field in the mutation.
func (m *GeneralLedgerAccountMutation) AccountNumber() (r string, exists bool) {
	v := m.account_number
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountNumber returns the old "account_number" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldAccountNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountNumber: %w", err)
	}
	return oldValue.AccountNumber, nil
}

// ResetAccountNumber resets all changes to the "account_number" field.
func (m *GeneralLedgerAccountMutation) ResetAccountNumber() {
	m.account_number = nil
}

// SetAccountType sets the "account_type" field.
func (m *GeneralLedgerAccountMutation) SetAccountType(gt generalledgeraccount.AccountType) {
	m.account_type = &gt
}

// AccountType returns the value of the "account_type" field in the mutation.
func (m *GeneralLedgerAccountMutation) AccountType() (r generalledgeraccount.AccountType, exists bool) {
	v := m.account_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountType returns the old "account_type" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldAccountType(ctx context.Context) (v generalledgeraccount.AccountType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountType: %w", err)
	}
	return oldValue.AccountType, nil
}

// ResetAccountType resets all changes to the "account_type" field.
func (m *GeneralLedgerAccountMutation) ResetAccountType() {
	m.account_type = nil
}

// SetCashFlowType sets the "cash_flow_type" field.
func (m *GeneralLedgerAccountMutation) SetCashFlowType(s string) {
	m.cash_flow_type = &s
}

// CashFlowType returns the value of the "cash_flow_type" field in the mutation.
func (m *GeneralLedgerAccountMutation) CashFlowType() (r string, exists bool) {
	v := m.cash_flow_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCashFlowType returns the old "cash_flow_type" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldCashFlowType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCashFlowType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCashFlowType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCashFlowType: %w", err)
	}
	return oldValue.CashFlowType, nil
}

// ClearCashFlowType clears the value of the "cash_flow_type" field.
func (m *GeneralLedgerAccountMutation) ClearCashFlowType() {
	m.cash_flow_type = nil
	m.clearedFields[generalledgeraccount.FieldCashFlowType] = struct{}{}
}

// CashFlowTypeCleared returns if the "cash_flow_type" field was cleared in this mutation.
func (m *GeneralLedgerAccountMutation) CashFlowTypeCleared() bool {
	_, ok := m.clearedFields[generalledgeraccount.FieldCashFlowType]
	return ok
}

// ResetCashFlowType resets all changes to the "cash_flow_type" field.
func (m *GeneralLedgerAccountMutation) ResetCashFlowType() {
	m.cash_flow_type = nil
	delete(m.clearedFields, generalledgeraccount.FieldCashFlowType)
}

// SetAccountSubType sets the "account_sub_type" field.
func (m *GeneralLedgerAccountMutation) SetAccountSubType(s string) {
	m.account_sub_type = &s
}

// AccountSubType returns the value of the "account_sub_type" field in the mutation.
func (m *GeneralLedgerAccountMutation) AccountSubType() (r string, exists bool) {
	v := m.account_sub_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountSubType returns the old "account_sub_type" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldAccountSubType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountSubType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountSubType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountSubType: %w", err)
	}
	return oldValue.AccountSubType, nil
}

// ClearAccountSubType clears the value of the "account_sub_type" field.
func (m *GeneralLedgerAccountMutation) ClearAccountSubType() {
	m.account_sub_type = nil
	m.clearedFields[generalledgeraccount.FieldAccountSubType] = struct{}{}
}

// AccountSubTypeCleared returns if the "account_sub_type" field was cleared in this mutation.
func (m *GeneralLedgerAccountMutation) AccountSubTypeCleared() bool {
	_, ok := m.clearedFields[generalledgeraccount.FieldAccountSubType]
	return ok
}

// ResetAccountSubType resets all changes to the "account_sub_type" field.
func (m *GeneralLedgerAccountMutation) ResetAccountSubType() {
	m.account_sub_type = nil
	delete(m.clearedFields, generalledgeraccount.FieldAccountSubType)
}

// SetAccountClass sets the "account_class" field.
func (m *GeneralLedgerAccountMutation) SetAccountClass(s string) {
	m.account_class = &s
}

// AccountClass returns the value of the "account_class" field in the mutation.
func (m *GeneralLedgerAccountMutation) AccountClass() (r string, exists bool) {
	v := m.account_class
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountClass returns the old "account_class" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldAccountClass(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountClass is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountClass requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountClass: %w", err)
	}
	return oldValue.AccountClass, nil
}

// ClearAccountClass clears the value of the "account_class" field.
func (m *GeneralLedgerAccountMutation) ClearAccountClass() {
	m.account_class = nil
	m.clearedFields[generalledgeraccount.FieldAccountClass] = struct{}{}
}

// AccountClassCleared returns if the "account_class" field was cleared in this mutation.
func (m *GeneralLedgerAccountMutation) AccountClassCleared() bool {
	_, ok := m.clearedFields[generalledgeraccount.FieldAccountClass]
	return ok
}

// ResetAccountClass resets all changes to the "account_class" field.
func (m *GeneralLedgerAccountMutation) ResetAccountClass() {
	m.account_class = nil
	delete(m.clearedFields, generalledgeraccount.FieldAccountClass)
}

// SetBalance sets the "balance" field.
func (m *GeneralLedgerAccountMutation) SetBalance(f float64) {
	m.balance = &f
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *GeneralLedgerAccountMutation) Balance() (r float64, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldBalance(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds f to the "balance" field.
func (m *GeneralLedgerAccountMutation) AddBalance(f float64) {
	if m.addbalance != nil {
		*m.addbalance += f
	} else {
		m.addbalance = &f
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *GeneralLedgerAccountMutation) AddedBalance() (r float64, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ClearBalance clears the value of the "balance" field.
func (m *GeneralLedgerAccountMutation) ClearBalance() {
	m.balance = nil
	m.addbalance = nil
	m.clearedFields[generalledgeraccount.FieldBalance] = struct{}{}
}

// BalanceCleared returns if the "balance" field was cleared in this mutation.
func (m *GeneralLedgerAccountMutation) BalanceCleared() bool {
	_, ok := m.clearedFields[generalledgeraccount.FieldBalance]
	return ok
}

// ResetBalance resets all changes to the "balance" field.
func (m *GeneralLedgerAccountMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
	delete(m.clearedFields, generalledgeraccount.FieldBalance)
}

// SetInterestRate sets the "interest_rate" field.
func (m *GeneralLedgerAccountMutation) SetInterestRate(f float64) {
	m.interest_rate = &f
	m.addinterest_rate = nil
}

// InterestRate returns the value of the "interest_rate" field in the mutation.
func (m *GeneralLedgerAccountMutation) InterestRate() (r float64, exists bool) {
	v := m.interest_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldInterestRate returns the old "interest_rate" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldInterestRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInterestRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInterestRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterestRate: %w", err)
	}
	return oldValue.InterestRate, nil
}

// AddInterestRate adds f to the "interest_rate" field.
func (m *GeneralLedgerAccountMutation) AddInterestRate(f float64) {
	if m.addinterest_rate != nil {
		*m.addinterest_rate += f
	} else {
		m.addinterest_rate = &f
	}
}

// AddedInterestRate returns the value that was added to the "interest_rate" field in this mutation.
func (m *GeneralLedgerAccountMutation) AddedInterestRate() (r float64, exists bool) {
	v := m.addinterest_rate
	if v == nil {
		return
	}
	return *v, true
}

// ClearInterestRate clears the value of the "interest_rate" field.
func (m *GeneralLedgerAccountMutation) ClearInterestRate() {
	m.interest_rate = nil
	m.addinterest_rate = nil
	m.clearedFields[generalledgeraccount.FieldInterestRate] = struct{}{}
}

// InterestRateCleared returns if the "interest_rate" field was cleared in this mutation.
func (m *GeneralLedgerAccountMutation) InterestRateCleared() bool {
	_, ok := m.clearedFields[generalledgeraccount.FieldInterestRate]
	return ok
}

// ResetInterestRate resets all changes to the "interest_rate" field.
func (m *GeneralLedgerAccountMutation) ResetInterestRate() {
	m.interest_rate = nil
	m.addinterest_rate = nil
	delete(m.clearedFields, generalledgeraccount.FieldInterestRate)
}

// SetDateClosed sets the "date_closed" field.
func (m *GeneralLedgerAccountMutation) SetDateClosed(pg *pgtype.Date) {
	m.date_closed = &pg
}

// DateClosed returns the value of the "date_closed" field in the mutation.
func (m *GeneralLedgerAccountMutation) DateClosed() (r *pgtype.Date, exists bool) {
	v := m.date_closed
	if v == nil {
		return
	}
	return *v, true
}

// OldDateClosed returns the old "date_closed" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldDateClosed(ctx context.Context) (v *pgtype.Date, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDateClosed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDateClosed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateClosed: %w", err)
	}
	return oldValue.DateClosed, nil
}

// ClearDateClosed clears the value of the "date_closed" field.
func (m *GeneralLedgerAccountMutation) ClearDateClosed() {
	m.date_closed = nil
	m.clearedFields[generalledgeraccount.FieldDateClosed] = struct{}{}
}

// DateClosedCleared returns if the "date_closed" field was cleared in this mutation.
func (m *GeneralLedgerAccountMutation) DateClosedCleared() bool {
	_, ok := m.clearedFields[generalledgeraccount.FieldDateClosed]
	return ok
}

// ResetDateClosed resets all changes to the "date_closed" field.
func (m *GeneralLedgerAccountMutation) ResetDateClosed() {
	m.date_closed = nil
	delete(m.clearedFields, generalledgeraccount.FieldDateClosed)
}

// SetNotes sets the "notes" field.
func (m *GeneralLedgerAccountMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *GeneralLedgerAccountMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *GeneralLedgerAccountMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[generalledgeraccount.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *GeneralLedgerAccountMutation) NotesCleared() bool {
	_, ok := m.clearedFields[generalledgeraccount.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *GeneralLedgerAccountMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, generalledgeraccount.FieldNotes)
}

// SetIsTaxRelevant sets the "is_tax_relevant" field.
func (m *GeneralLedgerAccountMutation) SetIsTaxRelevant(b bool) {
	m.is_tax_relevant = &b
}

// IsTaxRelevant returns the value of the "is_tax_relevant" field in the mutation.
func (m *GeneralLedgerAccountMutation) IsTaxRelevant() (r bool, exists bool) {
	v := m.is_tax_relevant
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTaxRelevant returns the old "is_tax_relevant" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldIsTaxRelevant(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTaxRelevant is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTaxRelevant requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTaxRelevant: %w", err)
	}
	return oldValue.IsTaxRelevant, nil
}

// ResetIsTaxRelevant resets all changes to the "is_tax_relevant" field.
func (m *GeneralLedgerAccountMutation) ResetIsTaxRelevant() {
	m.is_tax_relevant = nil
}

// SetIsReconciled sets the "is_reconciled" field.
func (m *GeneralLedgerAccountMutation) SetIsReconciled(b bool) {
	m.is_reconciled = &b
}

// IsReconciled returns the value of the "is_reconciled" field in the mutation.
func (m *GeneralLedgerAccountMutation) IsReconciled() (r bool, exists bool) {
	v := m.is_reconciled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsReconciled returns the old "is_reconciled" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldIsReconciled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsReconciled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsReconciled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsReconciled: %w", err)
	}
	return oldValue.IsReconciled, nil
}

// ResetIsReconciled resets all changes to the "is_reconciled" field.
func (m *GeneralLedgerAccountMutation) ResetIsReconciled() {
	m.is_reconciled = nil
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *GeneralLedgerAccountMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[generalledgeraccount.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *GeneralLedgerAccountMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *GeneralLedgerAccountMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *GeneralLedgerAccountMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *GeneralLedgerAccountMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[generalledgeraccount.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *GeneralLedgerAccountMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *GeneralLedgerAccountMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *GeneralLedgerAccountMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *GeneralLedgerAccountMutation) AddTagIDs(ids ...uuid.UUID) {
	if m.tags == nil {
		m.tags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *GeneralLedgerAccountMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *GeneralLedgerAccountMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *GeneralLedgerAccountMutation) RemoveTagIDs(ids ...uuid.UUID) {
	if m.removedtags == nil {
		m.removedtags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *GeneralLedgerAccountMutation) RemovedTagsIDs() (ids []uuid.UUID) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *GeneralLedgerAccountMutation) TagsIDs() (ids []uuid.UUID) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *GeneralLedgerAccountMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// Where appends a list predicates to the GeneralLedgerAccountMutation builder.
func (m *GeneralLedgerAccountMutation) Where(ps ...predicate.GeneralLedgerAccount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GeneralLedgerAccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GeneralLedgerAccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GeneralLedgerAccount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GeneralLedgerAccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GeneralLedgerAccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GeneralLedgerAccount).
func (m *GeneralLedgerAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GeneralLedgerAccountMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.business_unit != nil {
		fields = append(fields, generalledgeraccount.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, generalledgeraccount.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, generalledgeraccount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, generalledgeraccount.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, generalledgeraccount.FieldVersion)
	}
	if m.status != nil {
		fields = append(fields, generalledgeraccount.FieldStatus)
	}
	if m.account_number != nil {
		fields = append(fields, generalledgeraccount.FieldAccountNumber)
	}
	if m.account_type != nil {
		fields = append(fields, generalledgeraccount.FieldAccountType)
	}
	if m.cash_flow_type != nil {
		fields = append(fields, generalledgeraccount.FieldCashFlowType)
	}
	if m.account_sub_type != nil {
		fields = append(fields, generalledgeraccount.FieldAccountSubType)
	}
	if m.account_class != nil {
		fields = append(fields, generalledgeraccount.FieldAccountClass)
	}
	if m.balance != nil {
		fields = append(fields, generalledgeraccount.FieldBalance)
	}
	if m.interest_rate != nil {
		fields = append(fields, generalledgeraccount.FieldInterestRate)
	}
	if m.date_closed != nil {
		fields = append(fields, generalledgeraccount.FieldDateClosed)
	}
	if m.notes != nil {
		fields = append(fields, generalledgeraccount.FieldNotes)
	}
	if m.is_tax_relevant != nil {
		fields = append(fields, generalledgeraccount.FieldIsTaxRelevant)
	}
	if m.is_reconciled != nil {
		fields = append(fields, generalledgeraccount.FieldIsReconciled)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GeneralLedgerAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case generalledgeraccount.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case generalledgeraccount.FieldOrganizationID:
		return m.OrganizationID()
	case generalledgeraccount.FieldCreatedAt:
		return m.CreatedAt()
	case generalledgeraccount.FieldUpdatedAt:
		return m.UpdatedAt()
	case generalledgeraccount.FieldVersion:
		return m.Version()
	case generalledgeraccount.FieldStatus:
		return m.Status()
	case generalledgeraccount.FieldAccountNumber:
		return m.AccountNumber()
	case generalledgeraccount.FieldAccountType:
		return m.AccountType()
	case generalledgeraccount.FieldCashFlowType:
		return m.CashFlowType()
	case generalledgeraccount.FieldAccountSubType:
		return m.AccountSubType()
	case generalledgeraccount.FieldAccountClass:
		return m.AccountClass()
	case generalledgeraccount.FieldBalance:
		return m.Balance()
	case generalledgeraccount.FieldInterestRate:
		return m.InterestRate()
	case generalledgeraccount.FieldDateClosed:
		return m.DateClosed()
	case generalledgeraccount.FieldNotes:
		return m.Notes()
	case generalledgeraccount.FieldIsTaxRelevant:
		return m.IsTaxRelevant()
	case generalledgeraccount.FieldIsReconciled:
		return m.IsReconciled()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GeneralLedgerAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case generalledgeraccount.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case generalledgeraccount.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case generalledgeraccount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case generalledgeraccount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case generalledgeraccount.FieldVersion:
		return m.OldVersion(ctx)
	case generalledgeraccount.FieldStatus:
		return m.OldStatus(ctx)
	case generalledgeraccount.FieldAccountNumber:
		return m.OldAccountNumber(ctx)
	case generalledgeraccount.FieldAccountType:
		return m.OldAccountType(ctx)
	case generalledgeraccount.FieldCashFlowType:
		return m.OldCashFlowType(ctx)
	case generalledgeraccount.FieldAccountSubType:
		return m.OldAccountSubType(ctx)
	case generalledgeraccount.FieldAccountClass:
		return m.OldAccountClass(ctx)
	case generalledgeraccount.FieldBalance:
		return m.OldBalance(ctx)
	case generalledgeraccount.FieldInterestRate:
		return m.OldInterestRate(ctx)
	case generalledgeraccount.FieldDateClosed:
		return m.OldDateClosed(ctx)
	case generalledgeraccount.FieldNotes:
		return m.OldNotes(ctx)
	case generalledgeraccount.FieldIsTaxRelevant:
		return m.OldIsTaxRelevant(ctx)
	case generalledgeraccount.FieldIsReconciled:
		return m.OldIsReconciled(ctx)
	}
	return nil, fmt.Errorf("unknown GeneralLedgerAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GeneralLedgerAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case generalledgeraccount.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case generalledgeraccount.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case generalledgeraccount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case generalledgeraccount.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case generalledgeraccount.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case generalledgeraccount.FieldStatus:
		v, ok := value.(generalledgeraccount.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case generalledgeraccount.FieldAccountNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountNumber(v)
		return nil
	case generalledgeraccount.FieldAccountType:
		v, ok := value.(generalledgeraccount.AccountType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountType(v)
		return nil
	case generalledgeraccount.FieldCashFlowType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCashFlowType(v)
		return nil
	case generalledgeraccount.FieldAccountSubType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountSubType(v)
		return nil
	case generalledgeraccount.FieldAccountClass:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountClass(v)
		return nil
	case generalledgeraccount.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	case generalledgeraccount.FieldInterestRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterestRate(v)
		return nil
	case generalledgeraccount.FieldDateClosed:
		v, ok := value.(*pgtype.Date)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateClosed(v)
		return nil
	case generalledgeraccount.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case generalledgeraccount.FieldIsTaxRelevant:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTaxRelevant(v)
		return nil
	case generalledgeraccount.FieldIsReconciled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsReconciled(v)
		return nil
	}
	return fmt.Errorf("unknown GeneralLedgerAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GeneralLedgerAccountMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, generalledgeraccount.FieldVersion)
	}
	if m.addbalance != nil {
		fields = append(fields, generalledgeraccount.FieldBalance)
	}
	if m.addinterest_rate != nil {
		fields = append(fields, generalledgeraccount.FieldInterestRate)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GeneralLedgerAccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case generalledgeraccount.FieldVersion:
		return m.AddedVersion()
	case generalledgeraccount.FieldBalance:
		return m.AddedBalance()
	case generalledgeraccount.FieldInterestRate:
		return m.AddedInterestRate()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GeneralLedgerAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case generalledgeraccount.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case generalledgeraccount.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	case generalledgeraccount.FieldInterestRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInterestRate(v)
		return nil
	}
	return fmt.Errorf("unknown GeneralLedgerAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GeneralLedgerAccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(generalledgeraccount.FieldCashFlowType) {
		fields = append(fields, generalledgeraccount.FieldCashFlowType)
	}
	if m.FieldCleared(generalledgeraccount.FieldAccountSubType) {
		fields = append(fields, generalledgeraccount.FieldAccountSubType)
	}
	if m.FieldCleared(generalledgeraccount.FieldAccountClass) {
		fields = append(fields, generalledgeraccount.FieldAccountClass)
	}
	if m.FieldCleared(generalledgeraccount.FieldBalance) {
		fields = append(fields, generalledgeraccount.FieldBalance)
	}
	if m.FieldCleared(generalledgeraccount.FieldInterestRate) {
		fields = append(fields, generalledgeraccount.FieldInterestRate)
	}
	if m.FieldCleared(generalledgeraccount.FieldDateClosed) {
		fields = append(fields, generalledgeraccount.FieldDateClosed)
	}
	if m.FieldCleared(generalledgeraccount.FieldNotes) {
		fields = append(fields, generalledgeraccount.FieldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GeneralLedgerAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GeneralLedgerAccountMutation) ClearField(name string) error {
	switch name {
	case generalledgeraccount.FieldCashFlowType:
		m.ClearCashFlowType()
		return nil
	case generalledgeraccount.FieldAccountSubType:
		m.ClearAccountSubType()
		return nil
	case generalledgeraccount.FieldAccountClass:
		m.ClearAccountClass()
		return nil
	case generalledgeraccount.FieldBalance:
		m.ClearBalance()
		return nil
	case generalledgeraccount.FieldInterestRate:
		m.ClearInterestRate()
		return nil
	case generalledgeraccount.FieldDateClosed:
		m.ClearDateClosed()
		return nil
	case generalledgeraccount.FieldNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown GeneralLedgerAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GeneralLedgerAccountMutation) ResetField(name string) error {
	switch name {
	case generalledgeraccount.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case generalledgeraccount.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case generalledgeraccount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case generalledgeraccount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case generalledgeraccount.FieldVersion:
		m.ResetVersion()
		return nil
	case generalledgeraccount.FieldStatus:
		m.ResetStatus()
		return nil
	case generalledgeraccount.FieldAccountNumber:
		m.ResetAccountNumber()
		return nil
	case generalledgeraccount.FieldAccountType:
		m.ResetAccountType()
		return nil
	case generalledgeraccount.FieldCashFlowType:
		m.ResetCashFlowType()
		return nil
	case generalledgeraccount.FieldAccountSubType:
		m.ResetAccountSubType()
		return nil
	case generalledgeraccount.FieldAccountClass:
		m.ResetAccountClass()
		return nil
	case generalledgeraccount.FieldBalance:
		m.ResetBalance()
		return nil
	case generalledgeraccount.FieldInterestRate:
		m.ResetInterestRate()
		return nil
	case generalledgeraccount.FieldDateClosed:
		m.ResetDateClosed()
		return nil
	case generalledgeraccount.FieldNotes:
		m.ResetNotes()
		return nil
	case generalledgeraccount.FieldIsTaxRelevant:
		m.ResetIsTaxRelevant()
		return nil
	case generalledgeraccount.FieldIsReconciled:
		m.ResetIsReconciled()
		return nil
	}
	return fmt.Errorf("unknown GeneralLedgerAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GeneralLedgerAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.business_unit != nil {
		edges = append(edges, generalledgeraccount.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, generalledgeraccount.EdgeOrganization)
	}
	if m.tags != nil {
		edges = append(edges, generalledgeraccount.EdgeTags)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GeneralLedgerAccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case generalledgeraccount.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case generalledgeraccount.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case generalledgeraccount.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GeneralLedgerAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedtags != nil {
		edges = append(edges, generalledgeraccount.EdgeTags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GeneralLedgerAccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case generalledgeraccount.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GeneralLedgerAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbusiness_unit {
		edges = append(edges, generalledgeraccount.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, generalledgeraccount.EdgeOrganization)
	}
	if m.clearedtags {
		edges = append(edges, generalledgeraccount.EdgeTags)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GeneralLedgerAccountMutation) EdgeCleared(name string) bool {
	switch name {
	case generalledgeraccount.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case generalledgeraccount.EdgeOrganization:
		return m.clearedorganization
	case generalledgeraccount.EdgeTags:
		return m.clearedtags
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GeneralLedgerAccountMutation) ClearEdge(name string) error {
	switch name {
	case generalledgeraccount.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case generalledgeraccount.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown GeneralLedgerAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GeneralLedgerAccountMutation) ResetEdge(name string) error {
	switch name {
	case generalledgeraccount.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case generalledgeraccount.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case generalledgeraccount.EdgeTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown GeneralLedgerAccount edge %s", name)
}

// GoogleApiMutation represents an operation that mutates the GoogleApi nodes in the graph.
type GoogleApiMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	created_at            *time.Time
	updated_at            *time.Time
	api_key               *string
	mileage_unit          *googleapi.MileageUnit
	add_customer_location *bool
	auto_geocode          *bool
	add_location          *bool
	traffic_model         *googleapi.TrafficModel
	clearedFields         map[string]struct{}
	organization          *uuid.UUID
	clearedorganization   bool
	business_unit         *uuid.UUID
	clearedbusiness_unit  bool
	done                  bool
	oldValue              func(context.Context) (*GoogleApi, error)
	predicates            []predicate.GoogleApi
}

var _ ent.Mutation = (*GoogleApiMutation)(nil)

// googleapiOption allows management of the mutation configuration using functional options.
type googleapiOption func(*GoogleApiMutation)

// newGoogleApiMutation creates new mutation for the GoogleApi entity.
func newGoogleApiMutation(c config, op Op, opts ...googleapiOption) *GoogleApiMutation {
	m := &GoogleApiMutation{
		config:        c,
		op:            op,
		typ:           TypeGoogleApi,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGoogleApiID sets the ID field of the mutation.
func withGoogleApiID(id uuid.UUID) googleapiOption {
	return func(m *GoogleApiMutation) {
		var (
			err   error
			once  sync.Once
			value *GoogleApi
		)
		m.oldValue = func(ctx context.Context) (*GoogleApi, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GoogleApi.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGoogleApi sets the old GoogleApi of the mutation.
func withGoogleApi(node *GoogleApi) googleapiOption {
	return func(m *GoogleApiMutation) {
		m.oldValue = func(context.Context) (*GoogleApi, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoogleApiMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoogleApiMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GoogleApi entities.
func (m *GoogleApiMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GoogleApiMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GoogleApiMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GoogleApi.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *GoogleApiMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GoogleApiMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GoogleApi entity.
// If the GoogleApi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleApiMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GoogleApiMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GoogleApiMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GoogleApiMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GoogleApi entity.
// If the GoogleApi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleApiMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GoogleApiMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAPIKey sets the "api_key" field.
func (m *GoogleApiMutation) SetAPIKey(s string) {
	m.api_key = &s
}

// APIKey returns the value of the "api_key" field in the mutation.
func (m *GoogleApiMutation) APIKey() (r string, exists bool) {
	v := m.api_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIKey returns the old "api_key" field's value of the GoogleApi entity.
// If the GoogleApi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleApiMutation) OldAPIKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIKey: %w", err)
	}
	return oldValue.APIKey, nil
}

// ResetAPIKey resets all changes to the "api_key" field.
func (m *GoogleApiMutation) ResetAPIKey() {
	m.api_key = nil
}

// SetMileageUnit sets the "mileage_unit" field.
func (m *GoogleApiMutation) SetMileageUnit(gu googleapi.MileageUnit) {
	m.mileage_unit = &gu
}

// MileageUnit returns the value of the "mileage_unit" field in the mutation.
func (m *GoogleApiMutation) MileageUnit() (r googleapi.MileageUnit, exists bool) {
	v := m.mileage_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldMileageUnit returns the old "mileage_unit" field's value of the GoogleApi entity.
// If the GoogleApi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleApiMutation) OldMileageUnit(ctx context.Context) (v googleapi.MileageUnit, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMileageUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMileageUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMileageUnit: %w", err)
	}
	return oldValue.MileageUnit, nil
}

// ResetMileageUnit resets all changes to the "mileage_unit" field.
func (m *GoogleApiMutation) ResetMileageUnit() {
	m.mileage_unit = nil
}

// SetAddCustomerLocation sets the "add_customer_location" field.
func (m *GoogleApiMutation) SetAddCustomerLocation(b bool) {
	m.add_customer_location = &b
}

// AddCustomerLocation returns the value of the "add_customer_location" field in the mutation.
func (m *GoogleApiMutation) AddCustomerLocation() (r bool, exists bool) {
	v := m.add_customer_location
	if v == nil {
		return
	}
	return *v, true
}

// OldAddCustomerLocation returns the old "add_customer_location" field's value of the GoogleApi entity.
// If the GoogleApi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleApiMutation) OldAddCustomerLocation(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddCustomerLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddCustomerLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddCustomerLocation: %w", err)
	}
	return oldValue.AddCustomerLocation, nil
}

// ResetAddCustomerLocation resets all changes to the "add_customer_location" field.
func (m *GoogleApiMutation) ResetAddCustomerLocation() {
	m.add_customer_location = nil
}

// SetAutoGeocode sets the "auto_geocode" field.
func (m *GoogleApiMutation) SetAutoGeocode(b bool) {
	m.auto_geocode = &b
}

// AutoGeocode returns the value of the "auto_geocode" field in the mutation.
func (m *GoogleApiMutation) AutoGeocode() (r bool, exists bool) {
	v := m.auto_geocode
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoGeocode returns the old "auto_geocode" field's value of the GoogleApi entity.
// If the GoogleApi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleApiMutation) OldAutoGeocode(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoGeocode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoGeocode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoGeocode: %w", err)
	}
	return oldValue.AutoGeocode, nil
}

// ResetAutoGeocode resets all changes to the "auto_geocode" field.
func (m *GoogleApiMutation) ResetAutoGeocode() {
	m.auto_geocode = nil
}

// SetAddLocation sets the "add_location" field.
func (m *GoogleApiMutation) SetAddLocation(b bool) {
	m.add_location = &b
}

// AddLocation returns the value of the "add_location" field in the mutation.
func (m *GoogleApiMutation) AddLocation() (r bool, exists bool) {
	v := m.add_location
	if v == nil {
		return
	}
	return *v, true
}

// OldAddLocation returns the old "add_location" field's value of the GoogleApi entity.
// If the GoogleApi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleApiMutation) OldAddLocation(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddLocation: %w", err)
	}
	return oldValue.AddLocation, nil
}

// ResetAddLocation resets all changes to the "add_location" field.
func (m *GoogleApiMutation) ResetAddLocation() {
	m.add_location = nil
}

// SetTrafficModel sets the "traffic_model" field.
func (m *GoogleApiMutation) SetTrafficModel(gm googleapi.TrafficModel) {
	m.traffic_model = &gm
}

// TrafficModel returns the value of the "traffic_model" field in the mutation.
func (m *GoogleApiMutation) TrafficModel() (r googleapi.TrafficModel, exists bool) {
	v := m.traffic_model
	if v == nil {
		return
	}
	return *v, true
}

// OldTrafficModel returns the old "traffic_model" field's value of the GoogleApi entity.
// If the GoogleApi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleApiMutation) OldTrafficModel(ctx context.Context) (v googleapi.TrafficModel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrafficModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrafficModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrafficModel: %w", err)
	}
	return oldValue.TrafficModel, nil
}

// ResetTrafficModel resets all changes to the "traffic_model" field.
func (m *GoogleApiMutation) ResetTrafficModel() {
	m.traffic_model = nil
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *GoogleApiMutation) SetOrganizationID(id uuid.UUID) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *GoogleApiMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *GoogleApiMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *GoogleApiMutation) OrganizationID() (id uuid.UUID, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *GoogleApiMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *GoogleApiMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// SetBusinessUnitID sets the "business_unit" edge to the BusinessUnit entity by id.
func (m *GoogleApiMutation) SetBusinessUnitID(id uuid.UUID) {
	m.business_unit = &id
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *GoogleApiMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *GoogleApiMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitID returns the "business_unit" edge ID in the mutation.
func (m *GoogleApiMutation) BusinessUnitID() (id uuid.UUID, exists bool) {
	if m.business_unit != nil {
		return *m.business_unit, true
	}
	return
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *GoogleApiMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *GoogleApiMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// Where appends a list predicates to the GoogleApiMutation builder.
func (m *GoogleApiMutation) Where(ps ...predicate.GoogleApi) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GoogleApiMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GoogleApiMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GoogleApi, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GoogleApiMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GoogleApiMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GoogleApi).
func (m *GoogleApiMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoogleApiMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, googleapi.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, googleapi.FieldUpdatedAt)
	}
	if m.api_key != nil {
		fields = append(fields, googleapi.FieldAPIKey)
	}
	if m.mileage_unit != nil {
		fields = append(fields, googleapi.FieldMileageUnit)
	}
	if m.add_customer_location != nil {
		fields = append(fields, googleapi.FieldAddCustomerLocation)
	}
	if m.auto_geocode != nil {
		fields = append(fields, googleapi.FieldAutoGeocode)
	}
	if m.add_location != nil {
		fields = append(fields, googleapi.FieldAddLocation)
	}
	if m.traffic_model != nil {
		fields = append(fields, googleapi.FieldTrafficModel)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoogleApiMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case googleapi.FieldCreatedAt:
		return m.CreatedAt()
	case googleapi.FieldUpdatedAt:
		return m.UpdatedAt()
	case googleapi.FieldAPIKey:
		return m.APIKey()
	case googleapi.FieldMileageUnit:
		return m.MileageUnit()
	case googleapi.FieldAddCustomerLocation:
		return m.AddCustomerLocation()
	case googleapi.FieldAutoGeocode:
		return m.AutoGeocode()
	case googleapi.FieldAddLocation:
		return m.AddLocation()
	case googleapi.FieldTrafficModel:
		return m.TrafficModel()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoogleApiMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case googleapi.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case googleapi.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case googleapi.FieldAPIKey:
		return m.OldAPIKey(ctx)
	case googleapi.FieldMileageUnit:
		return m.OldMileageUnit(ctx)
	case googleapi.FieldAddCustomerLocation:
		return m.OldAddCustomerLocation(ctx)
	case googleapi.FieldAutoGeocode:
		return m.OldAutoGeocode(ctx)
	case googleapi.FieldAddLocation:
		return m.OldAddLocation(ctx)
	case googleapi.FieldTrafficModel:
		return m.OldTrafficModel(ctx)
	}
	return nil, fmt.Errorf("unknown GoogleApi field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoogleApiMutation) SetField(name string, value ent.Value) error {
	switch name {
	case googleapi.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case googleapi.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case googleapi.FieldAPIKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIKey(v)
		return nil
	case googleapi.FieldMileageUnit:
		v, ok := value.(googleapi.MileageUnit)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMileageUnit(v)
		return nil
	case googleapi.FieldAddCustomerLocation:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddCustomerLocation(v)
		return nil
	case googleapi.FieldAutoGeocode:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoGeocode(v)
		return nil
	case googleapi.FieldAddLocation:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddLocation(v)
		return nil
	case googleapi.FieldTrafficModel:
		v, ok := value.(googleapi.TrafficModel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrafficModel(v)
		return nil
	}
	return fmt.Errorf("unknown GoogleApi field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoogleApiMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoogleApiMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoogleApiMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GoogleApi numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoogleApiMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoogleApiMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoogleApiMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GoogleApi nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoogleApiMutation) ResetField(name string) error {
	switch name {
	case googleapi.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case googleapi.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case googleapi.FieldAPIKey:
		m.ResetAPIKey()
		return nil
	case googleapi.FieldMileageUnit:
		m.ResetMileageUnit()
		return nil
	case googleapi.FieldAddCustomerLocation:
		m.ResetAddCustomerLocation()
		return nil
	case googleapi.FieldAutoGeocode:
		m.ResetAutoGeocode()
		return nil
	case googleapi.FieldAddLocation:
		m.ResetAddLocation()
		return nil
	case googleapi.FieldTrafficModel:
		m.ResetTrafficModel()
		return nil
	}
	return fmt.Errorf("unknown GoogleApi field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoogleApiMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.organization != nil {
		edges = append(edges, googleapi.EdgeOrganization)
	}
	if m.business_unit != nil {
		edges = append(edges, googleapi.EdgeBusinessUnit)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoogleApiMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case googleapi.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case googleapi.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoogleApiMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoogleApiMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoogleApiMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorganization {
		edges = append(edges, googleapi.EdgeOrganization)
	}
	if m.clearedbusiness_unit {
		edges = append(edges, googleapi.EdgeBusinessUnit)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoogleApiMutation) EdgeCleared(name string) bool {
	switch name {
	case googleapi.EdgeOrganization:
		return m.clearedorganization
	case googleapi.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoogleApiMutation) ClearEdge(name string) error {
	switch name {
	case googleapi.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case googleapi.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	}
	return fmt.Errorf("unknown GoogleApi unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoogleApiMutation) ResetEdge(name string) error {
	switch name {
	case googleapi.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case googleapi.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	}
	return fmt.Errorf("unknown GoogleApi edge %s", name)
}

// HazardousMaterialMutation represents an operation that mutates the HazardousMaterial nodes in the graph.
type HazardousMaterialMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	version              *int
	addversion           *int
	status               *hazardousmaterial.Status
	name                 *string
	hazard_class         *hazardousmaterial.HazardClass
	erg_number           *string
	description          *string
	packing_group        *string
	proper_shipping_name *string
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	done                 bool
	oldValue             func(context.Context) (*HazardousMaterial, error)
	predicates           []predicate.HazardousMaterial
}

var _ ent.Mutation = (*HazardousMaterialMutation)(nil)

// hazardousmaterialOption allows management of the mutation configuration using functional options.
type hazardousmaterialOption func(*HazardousMaterialMutation)

// newHazardousMaterialMutation creates new mutation for the HazardousMaterial entity.
func newHazardousMaterialMutation(c config, op Op, opts ...hazardousmaterialOption) *HazardousMaterialMutation {
	m := &HazardousMaterialMutation{
		config:        c,
		op:            op,
		typ:           TypeHazardousMaterial,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHazardousMaterialID sets the ID field of the mutation.
func withHazardousMaterialID(id uuid.UUID) hazardousmaterialOption {
	return func(m *HazardousMaterialMutation) {
		var (
			err   error
			once  sync.Once
			value *HazardousMaterial
		)
		m.oldValue = func(ctx context.Context) (*HazardousMaterial, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HazardousMaterial.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHazardousMaterial sets the old HazardousMaterial of the mutation.
func withHazardousMaterial(node *HazardousMaterial) hazardousmaterialOption {
	return func(m *HazardousMaterialMutation) {
		m.oldValue = func(context.Context) (*HazardousMaterial, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HazardousMaterialMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HazardousMaterialMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of HazardousMaterial entities.
func (m *HazardousMaterialMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HazardousMaterialMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HazardousMaterialMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HazardousMaterial.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *HazardousMaterialMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *HazardousMaterialMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the HazardousMaterial entity.
// If the HazardousMaterial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HazardousMaterialMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *HazardousMaterialMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *HazardousMaterialMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *HazardousMaterialMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the HazardousMaterial entity.
// If the HazardousMaterial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HazardousMaterialMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *HazardousMaterialMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *HazardousMaterialMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HazardousMaterialMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the HazardousMaterial entity.
// If the HazardousMaterial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HazardousMaterialMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HazardousMaterialMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HazardousMaterialMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HazardousMaterialMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the HazardousMaterial entity.
// If the HazardousMaterial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HazardousMaterialMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HazardousMaterialMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *HazardousMaterialMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *HazardousMaterialMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the HazardousMaterial entity.
// If the HazardousMaterial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HazardousMaterialMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *HazardousMaterialMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *HazardousMaterialMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *HazardousMaterialMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetStatus sets the "status" field.
func (m *HazardousMaterialMutation) SetStatus(h hazardousmaterial.Status) {
	m.status = &h
}

// Status returns the value of the "status" field in the mutation.
func (m *HazardousMaterialMutation) Status() (r hazardousmaterial.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the HazardousMaterial entity.
// If the HazardousMaterial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HazardousMaterialMutation) OldStatus(ctx context.Context) (v hazardousmaterial.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *HazardousMaterialMutation) ResetStatus() {
	m.status = nil
}

// SetName sets the "name" field.
func (m *HazardousMaterialMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *HazardousMaterialMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the HazardousMaterial entity.
// If the HazardousMaterial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HazardousMaterialMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *HazardousMaterialMutation) ResetName() {
	m.name = nil
}

// SetHazardClass sets the "hazard_class" field.
func (m *HazardousMaterialMutation) SetHazardClass(hc hazardousmaterial.HazardClass) {
	m.hazard_class = &hc
}

// HazardClass returns the value of the "hazard_class" field in the mutation.
func (m *HazardousMaterialMutation) HazardClass() (r hazardousmaterial.HazardClass, exists bool) {
	v := m.hazard_class
	if v == nil {
		return
	}
	return *v, true
}

// OldHazardClass returns the old "hazard_class" field's value of the HazardousMaterial entity.
// If the HazardousMaterial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HazardousMaterialMutation) OldHazardClass(ctx context.Context) (v hazardousmaterial.HazardClass, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHazardClass is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHazardClass requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHazardClass: %w", err)
	}
	return oldValue.HazardClass, nil
}

// ResetHazardClass resets all changes to the "hazard_class" field.
func (m *HazardousMaterialMutation) ResetHazardClass() {
	m.hazard_class = nil
}

// SetErgNumber sets the "erg_number" field.
func (m *HazardousMaterialMutation) SetErgNumber(s string) {
	m.erg_number = &s
}

// ErgNumber returns the value of the "erg_number" field in the mutation.
func (m *HazardousMaterialMutation) ErgNumber() (r string, exists bool) {
	v := m.erg_number
	if v == nil {
		return
	}
	return *v, true
}

// OldErgNumber returns the old "erg_number" field's value of the HazardousMaterial entity.
// If the HazardousMaterial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HazardousMaterialMutation) OldErgNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErgNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErgNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErgNumber: %w", err)
	}
	return oldValue.ErgNumber, nil
}

// ClearErgNumber clears the value of the "erg_number" field.
func (m *HazardousMaterialMutation) ClearErgNumber() {
	m.erg_number = nil
	m.clearedFields[hazardousmaterial.FieldErgNumber] = struct{}{}
}

// ErgNumberCleared returns if the "erg_number" field was cleared in this mutation.
func (m *HazardousMaterialMutation) ErgNumberCleared() bool {
	_, ok := m.clearedFields[hazardousmaterial.FieldErgNumber]
	return ok
}

// ResetErgNumber resets all changes to the "erg_number" field.
func (m *HazardousMaterialMutation) ResetErgNumber() {
	m.erg_number = nil
	delete(m.clearedFields, hazardousmaterial.FieldErgNumber)
}

// SetDescription sets the "description" field.
func (m *HazardousMaterialMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *HazardousMaterialMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the HazardousMaterial entity.
// If the HazardousMaterial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HazardousMaterialMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *HazardousMaterialMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[hazardousmaterial.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *HazardousMaterialMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[hazardousmaterial.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *HazardousMaterialMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, hazardousmaterial.FieldDescription)
}

// SetPackingGroup sets the "packing_group" field.
func (m *HazardousMaterialMutation) SetPackingGroup(s string) {
	m.packing_group = &s
}

// PackingGroup returns the value of the "packing_group" field in the mutation.
func (m *HazardousMaterialMutation) PackingGroup() (r string, exists bool) {
	v := m.packing_group
	if v == nil {
		return
	}
	return *v, true
}

// OldPackingGroup returns the old "packing_group" field's value of the HazardousMaterial entity.
// If the HazardousMaterial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HazardousMaterialMutation) OldPackingGroup(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackingGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackingGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackingGroup: %w", err)
	}
	return oldValue.PackingGroup, nil
}

// ClearPackingGroup clears the value of the "packing_group" field.
func (m *HazardousMaterialMutation) ClearPackingGroup() {
	m.packing_group = nil
	m.clearedFields[hazardousmaterial.FieldPackingGroup] = struct{}{}
}

// PackingGroupCleared returns if the "packing_group" field was cleared in this mutation.
func (m *HazardousMaterialMutation) PackingGroupCleared() bool {
	_, ok := m.clearedFields[hazardousmaterial.FieldPackingGroup]
	return ok
}

// ResetPackingGroup resets all changes to the "packing_group" field.
func (m *HazardousMaterialMutation) ResetPackingGroup() {
	m.packing_group = nil
	delete(m.clearedFields, hazardousmaterial.FieldPackingGroup)
}

// SetProperShippingName sets the "proper_shipping_name" field.
func (m *HazardousMaterialMutation) SetProperShippingName(s string) {
	m.proper_shipping_name = &s
}

// ProperShippingName returns the value of the "proper_shipping_name" field in the mutation.
func (m *HazardousMaterialMutation) ProperShippingName() (r string, exists bool) {
	v := m.proper_shipping_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProperShippingName returns the old "proper_shipping_name" field's value of the HazardousMaterial entity.
// If the HazardousMaterial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HazardousMaterialMutation) OldProperShippingName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProperShippingName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProperShippingName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProperShippingName: %w", err)
	}
	return oldValue.ProperShippingName, nil
}

// ClearProperShippingName clears the value of the "proper_shipping_name" field.
func (m *HazardousMaterialMutation) ClearProperShippingName() {
	m.proper_shipping_name = nil
	m.clearedFields[hazardousmaterial.FieldProperShippingName] = struct{}{}
}

// ProperShippingNameCleared returns if the "proper_shipping_name" field was cleared in this mutation.
func (m *HazardousMaterialMutation) ProperShippingNameCleared() bool {
	_, ok := m.clearedFields[hazardousmaterial.FieldProperShippingName]
	return ok
}

// ResetProperShippingName resets all changes to the "proper_shipping_name" field.
func (m *HazardousMaterialMutation) ResetProperShippingName() {
	m.proper_shipping_name = nil
	delete(m.clearedFields, hazardousmaterial.FieldProperShippingName)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *HazardousMaterialMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[hazardousmaterial.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *HazardousMaterialMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *HazardousMaterialMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *HazardousMaterialMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *HazardousMaterialMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[hazardousmaterial.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *HazardousMaterialMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *HazardousMaterialMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *HazardousMaterialMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the HazardousMaterialMutation builder.
func (m *HazardousMaterialMutation) Where(ps ...predicate.HazardousMaterial) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HazardousMaterialMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HazardousMaterialMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HazardousMaterial, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HazardousMaterialMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HazardousMaterialMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HazardousMaterial).
func (m *HazardousMaterialMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HazardousMaterialMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.business_unit != nil {
		fields = append(fields, hazardousmaterial.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, hazardousmaterial.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, hazardousmaterial.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, hazardousmaterial.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, hazardousmaterial.FieldVersion)
	}
	if m.status != nil {
		fields = append(fields, hazardousmaterial.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, hazardousmaterial.FieldName)
	}
	if m.hazard_class != nil {
		fields = append(fields, hazardousmaterial.FieldHazardClass)
	}
	if m.erg_number != nil {
		fields = append(fields, hazardousmaterial.FieldErgNumber)
	}
	if m.description != nil {
		fields = append(fields, hazardousmaterial.FieldDescription)
	}
	if m.packing_group != nil {
		fields = append(fields, hazardousmaterial.FieldPackingGroup)
	}
	if m.proper_shipping_name != nil {
		fields = append(fields, hazardousmaterial.FieldProperShippingName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HazardousMaterialMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hazardousmaterial.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case hazardousmaterial.FieldOrganizationID:
		return m.OrganizationID()
	case hazardousmaterial.FieldCreatedAt:
		return m.CreatedAt()
	case hazardousmaterial.FieldUpdatedAt:
		return m.UpdatedAt()
	case hazardousmaterial.FieldVersion:
		return m.Version()
	case hazardousmaterial.FieldStatus:
		return m.Status()
	case hazardousmaterial.FieldName:
		return m.Name()
	case hazardousmaterial.FieldHazardClass:
		return m.HazardClass()
	case hazardousmaterial.FieldErgNumber:
		return m.ErgNumber()
	case hazardousmaterial.FieldDescription:
		return m.Description()
	case hazardousmaterial.FieldPackingGroup:
		return m.PackingGroup()
	case hazardousmaterial.FieldProperShippingName:
		return m.ProperShippingName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HazardousMaterialMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hazardousmaterial.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case hazardousmaterial.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case hazardousmaterial.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case hazardousmaterial.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case hazardousmaterial.FieldVersion:
		return m.OldVersion(ctx)
	case hazardousmaterial.FieldStatus:
		return m.OldStatus(ctx)
	case hazardousmaterial.FieldName:
		return m.OldName(ctx)
	case hazardousmaterial.FieldHazardClass:
		return m.OldHazardClass(ctx)
	case hazardousmaterial.FieldErgNumber:
		return m.OldErgNumber(ctx)
	case hazardousmaterial.FieldDescription:
		return m.OldDescription(ctx)
	case hazardousmaterial.FieldPackingGroup:
		return m.OldPackingGroup(ctx)
	case hazardousmaterial.FieldProperShippingName:
		return m.OldProperShippingName(ctx)
	}
	return nil, fmt.Errorf("unknown HazardousMaterial field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HazardousMaterialMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hazardousmaterial.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case hazardousmaterial.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case hazardousmaterial.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case hazardousmaterial.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case hazardousmaterial.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case hazardousmaterial.FieldStatus:
		v, ok := value.(hazardousmaterial.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case hazardousmaterial.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case hazardousmaterial.FieldHazardClass:
		v, ok := value.(hazardousmaterial.HazardClass)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHazardClass(v)
		return nil
	case hazardousmaterial.FieldErgNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErgNumber(v)
		return nil
	case hazardousmaterial.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case hazardousmaterial.FieldPackingGroup:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackingGroup(v)
		return nil
	case hazardousmaterial.FieldProperShippingName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProperShippingName(v)
		return nil
	}
	return fmt.Errorf("unknown HazardousMaterial field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HazardousMaterialMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, hazardousmaterial.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HazardousMaterialMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case hazardousmaterial.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HazardousMaterialMutation) AddField(name string, value ent.Value) error {
	switch name {
	case hazardousmaterial.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown HazardousMaterial numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HazardousMaterialMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hazardousmaterial.FieldErgNumber) {
		fields = append(fields, hazardousmaterial.FieldErgNumber)
	}
	if m.FieldCleared(hazardousmaterial.FieldDescription) {
		fields = append(fields, hazardousmaterial.FieldDescription)
	}
	if m.FieldCleared(hazardousmaterial.FieldPackingGroup) {
		fields = append(fields, hazardousmaterial.FieldPackingGroup)
	}
	if m.FieldCleared(hazardousmaterial.FieldProperShippingName) {
		fields = append(fields, hazardousmaterial.FieldProperShippingName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HazardousMaterialMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HazardousMaterialMutation) ClearField(name string) error {
	switch name {
	case hazardousmaterial.FieldErgNumber:
		m.ClearErgNumber()
		return nil
	case hazardousmaterial.FieldDescription:
		m.ClearDescription()
		return nil
	case hazardousmaterial.FieldPackingGroup:
		m.ClearPackingGroup()
		return nil
	case hazardousmaterial.FieldProperShippingName:
		m.ClearProperShippingName()
		return nil
	}
	return fmt.Errorf("unknown HazardousMaterial nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HazardousMaterialMutation) ResetField(name string) error {
	switch name {
	case hazardousmaterial.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case hazardousmaterial.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case hazardousmaterial.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case hazardousmaterial.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case hazardousmaterial.FieldVersion:
		m.ResetVersion()
		return nil
	case hazardousmaterial.FieldStatus:
		m.ResetStatus()
		return nil
	case hazardousmaterial.FieldName:
		m.ResetName()
		return nil
	case hazardousmaterial.FieldHazardClass:
		m.ResetHazardClass()
		return nil
	case hazardousmaterial.FieldErgNumber:
		m.ResetErgNumber()
		return nil
	case hazardousmaterial.FieldDescription:
		m.ResetDescription()
		return nil
	case hazardousmaterial.FieldPackingGroup:
		m.ResetPackingGroup()
		return nil
	case hazardousmaterial.FieldProperShippingName:
		m.ResetProperShippingName()
		return nil
	}
	return fmt.Errorf("unknown HazardousMaterial field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HazardousMaterialMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.business_unit != nil {
		edges = append(edges, hazardousmaterial.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, hazardousmaterial.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HazardousMaterialMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hazardousmaterial.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case hazardousmaterial.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HazardousMaterialMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HazardousMaterialMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HazardousMaterialMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbusiness_unit {
		edges = append(edges, hazardousmaterial.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, hazardousmaterial.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HazardousMaterialMutation) EdgeCleared(name string) bool {
	switch name {
	case hazardousmaterial.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case hazardousmaterial.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HazardousMaterialMutation) ClearEdge(name string) error {
	switch name {
	case hazardousmaterial.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case hazardousmaterial.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown HazardousMaterial unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HazardousMaterialMutation) ResetEdge(name string) error {
	switch name {
	case hazardousmaterial.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case hazardousmaterial.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown HazardousMaterial edge %s", name)
}

// HazardousMaterialSegregationMutation represents an operation that mutates the HazardousMaterialSegregation nodes in the graph.
type HazardousMaterialSegregationMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	version              *int
	addversion           *int
	class_a              *hazardousmaterialsegregation.ClassA
	class_b              *hazardousmaterialsegregation.ClassB
	segregation_type     *hazardousmaterialsegregation.SegregationType
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	done                 bool
	oldValue             func(context.Context) (*HazardousMaterialSegregation, error)
	predicates           []predicate.HazardousMaterialSegregation
}

var _ ent.Mutation = (*HazardousMaterialSegregationMutation)(nil)

// hazardousmaterialsegregationOption allows management of the mutation configuration using functional options.
type hazardousmaterialsegregationOption func(*HazardousMaterialSegregationMutation)

// newHazardousMaterialSegregationMutation creates new mutation for the HazardousMaterialSegregation entity.
func newHazardousMaterialSegregationMutation(c config, op Op, opts ...hazardousmaterialsegregationOption) *HazardousMaterialSegregationMutation {
	m := &HazardousMaterialSegregationMutation{
		config:        c,
		op:            op,
		typ:           TypeHazardousMaterialSegregation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHazardousMaterialSegregationID sets the ID field of the mutation.
func withHazardousMaterialSegregationID(id uuid.UUID) hazardousmaterialsegregationOption {
	return func(m *HazardousMaterialSegregationMutation) {
		var (
			err   error
			once  sync.Once
			value *HazardousMaterialSegregation
		)
		m.oldValue = func(ctx context.Context) (*HazardousMaterialSegregation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HazardousMaterialSegregation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHazardousMaterialSegregation sets the old HazardousMaterialSegregation of the mutation.
func withHazardousMaterialSegregation(node *HazardousMaterialSegregation) hazardousmaterialsegregationOption {
	return func(m *HazardousMaterialSegregationMutation) {
		m.oldValue = func(context.Context) (*HazardousMaterialSegregation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HazardousMaterialSegregationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HazardousMaterialSegregationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of HazardousMaterialSegregation entities.
func (m *HazardousMaterialSegregationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HazardousMaterialSegregationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HazardousMaterialSegregationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HazardousMaterialSegregation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *HazardousMaterialSegregationMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *HazardousMaterialSegregationMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the HazardousMaterialSegregation entity.
// If the HazardousMaterialSegregation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HazardousMaterialSegregationMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *HazardousMaterialSegregationMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *HazardousMaterialSegregationMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *HazardousMaterialSegregationMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the HazardousMaterialSegregation entity.
// If the HazardousMaterialSegregation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HazardousMaterialSegregationMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *HazardousMaterialSegregationMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *HazardousMaterialSegregationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HazardousMaterialSegregationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the HazardousMaterialSegregation entity.
// If the HazardousMaterialSegregation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HazardousMaterialSegregationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HazardousMaterialSegregationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HazardousMaterialSegregationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HazardousMaterialSegregationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the HazardousMaterialSegregation entity.
// If the HazardousMaterialSegregation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HazardousMaterialSegregationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HazardousMaterialSegregationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *HazardousMaterialSegregationMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *HazardousMaterialSegregationMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the HazardousMaterialSegregation entity.
// If the HazardousMaterialSegregation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HazardousMaterialSegregationMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *HazardousMaterialSegregationMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *HazardousMaterialSegregationMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *HazardousMaterialSegregationMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetClassA sets the "class_a" field.
func (m *HazardousMaterialSegregationMutation) SetClassA(h hazardousmaterialsegregation.ClassA) {
	m.class_a = &h
}

// ClassA returns the value of the "class_a" field in the mutation.
func (m *HazardousMaterialSegregationMutation) ClassA() (r hazardousmaterialsegregation.ClassA, exists bool) {
	v := m.class_a
	if v == nil {
		return
	}
	return *v, true
}

// OldClassA returns the old "class_a" field's value of the HazardousMaterialSegregation entity.
// If the HazardousMaterialSegregation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HazardousMaterialSegregationMutation) OldClassA(ctx context.Context) (v hazardousmaterialsegregation.ClassA, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClassA is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClassA requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassA: %w", err)
	}
	return oldValue.ClassA, nil
}

// ResetClassA resets all changes to the "class_a" field.
func (m *HazardousMaterialSegregationMutation) ResetClassA() {
	m.class_a = nil
}

// SetClassB sets the "class_b" field.
func (m *HazardousMaterialSegregationMutation) SetClassB(h hazardousmaterialsegregation.ClassB) {
	m.class_b = &h
}

// ClassB returns the value of the "class_b" field in the mutation.
func (m *HazardousMaterialSegregationMutation) ClassB() (r hazardousmaterialsegregation.ClassB, exists bool) {
	v := m.class_b
	if v == nil {
		return
	}
	return *v, true
}

// OldClassB returns the old "class_b" field's value of the HazardousMaterialSegregation entity.
// If the HazardousMaterialSegregation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HazardousMaterialSegregationMutation) OldClassB(ctx context.Context) (v hazardousmaterialsegregation.ClassB, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClassB is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClassB requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassB: %w", err)
	}
	return oldValue.ClassB, nil
}

// ResetClassB resets all changes to the "class_b" field.
func (m *HazardousMaterialSegregationMutation) ResetClassB() {
	m.class_b = nil
}

// SetSegregationType sets the "segregation_type" field.
func (m *HazardousMaterialSegregationMutation) SetSegregationType(ht hazardousmaterialsegregation.SegregationType) {
	m.segregation_type = &ht
}

// SegregationType returns the value of the "segregation_type" field in the mutation.
func (m *HazardousMaterialSegregationMutation) SegregationType() (r hazardousmaterialsegregation.SegregationType, exists bool) {
	v := m.segregation_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSegregationType returns the old "segregation_type" field's value of the HazardousMaterialSegregation entity.
// If the HazardousMaterialSegregation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HazardousMaterialSegregationMutation) OldSegregationType(ctx context.Context) (v hazardousmaterialsegregation.SegregationType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSegregationType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSegregationType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSegregationType: %w", err)
	}
	return oldValue.SegregationType, nil
}

// ResetSegregationType resets all changes to the "segregation_type" field.
func (m *HazardousMaterialSegregationMutation) ResetSegregationType() {
	m.segregation_type = nil
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *HazardousMaterialSegregationMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[hazardousmaterialsegregation.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *HazardousMaterialSegregationMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *HazardousMaterialSegregationMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *HazardousMaterialSegregationMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *HazardousMaterialSegregationMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[hazardousmaterialsegregation.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *HazardousMaterialSegregationMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *HazardousMaterialSegregationMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *HazardousMaterialSegregationMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the HazardousMaterialSegregationMutation builder.
func (m *HazardousMaterialSegregationMutation) Where(ps ...predicate.HazardousMaterialSegregation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HazardousMaterialSegregationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HazardousMaterialSegregationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HazardousMaterialSegregation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HazardousMaterialSegregationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HazardousMaterialSegregationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HazardousMaterialSegregation).
func (m *HazardousMaterialSegregationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HazardousMaterialSegregationMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.business_unit != nil {
		fields = append(fields, hazardousmaterialsegregation.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, hazardousmaterialsegregation.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, hazardousmaterialsegregation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, hazardousmaterialsegregation.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, hazardousmaterialsegregation.FieldVersion)
	}
	if m.class_a != nil {
		fields = append(fields, hazardousmaterialsegregation.FieldClassA)
	}
	if m.class_b != nil {
		fields = append(fields, hazardousmaterialsegregation.FieldClassB)
	}
	if m.segregation_type != nil {
		fields = append(fields, hazardousmaterialsegregation.FieldSegregationType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HazardousMaterialSegregationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hazardousmaterialsegregation.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case hazardousmaterialsegregation.FieldOrganizationID:
		return m.OrganizationID()
	case hazardousmaterialsegregation.FieldCreatedAt:
		return m.CreatedAt()
	case hazardousmaterialsegregation.FieldUpdatedAt:
		return m.UpdatedAt()
	case hazardousmaterialsegregation.FieldVersion:
		return m.Version()
	case hazardousmaterialsegregation.FieldClassA:
		return m.ClassA()
	case hazardousmaterialsegregation.FieldClassB:
		return m.ClassB()
	case hazardousmaterialsegregation.FieldSegregationType:
		return m.SegregationType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HazardousMaterialSegregationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hazardousmaterialsegregation.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case hazardousmaterialsegregation.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case hazardousmaterialsegregation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case hazardousmaterialsegregation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case hazardousmaterialsegregation.FieldVersion:
		return m.OldVersion(ctx)
	case hazardousmaterialsegregation.FieldClassA:
		return m.OldClassA(ctx)
	case hazardousmaterialsegregation.FieldClassB:
		return m.OldClassB(ctx)
	case hazardousmaterialsegregation.FieldSegregationType:
		return m.OldSegregationType(ctx)
	}
	return nil, fmt.Errorf("unknown HazardousMaterialSegregation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HazardousMaterialSegregationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hazardousmaterialsegregation.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case hazardousmaterialsegregation.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case hazardousmaterialsegregation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case hazardousmaterialsegregation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case hazardousmaterialsegregation.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case hazardousmaterialsegregation.FieldClassA:
		v, ok := value.(hazardousmaterialsegregation.ClassA)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassA(v)
		return nil
	case hazardousmaterialsegregation.FieldClassB:
		v, ok := value.(hazardousmaterialsegregation.ClassB)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassB(v)
		return nil
	case hazardousmaterialsegregation.FieldSegregationType:
		v, ok := value.(hazardousmaterialsegregation.SegregationType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSegregationType(v)
		return nil
	}
	return fmt.Errorf("unknown HazardousMaterialSegregation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HazardousMaterialSegregationMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, hazardousmaterialsegregation.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HazardousMaterialSegregationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case hazardousmaterialsegregation.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HazardousMaterialSegregationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case hazardousmaterialsegregation.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown HazardousMaterialSegregation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HazardousMaterialSegregationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HazardousMaterialSegregationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HazardousMaterialSegregationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown HazardousMaterialSegregation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HazardousMaterialSegregationMutation) ResetField(name string) error {
	switch name {
	case hazardousmaterialsegregation.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case hazardousmaterialsegregation.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case hazardousmaterialsegregation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case hazardousmaterialsegregation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case hazardousmaterialsegregation.FieldVersion:
		m.ResetVersion()
		return nil
	case hazardousmaterialsegregation.FieldClassA:
		m.ResetClassA()
		return nil
	case hazardousmaterialsegregation.FieldClassB:
		m.ResetClassB()
		return nil
	case hazardousmaterialsegregation.FieldSegregationType:
		m.ResetSegregationType()
		return nil
	}
	return fmt.Errorf("unknown HazardousMaterialSegregation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HazardousMaterialSegregationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.business_unit != nil {
		edges = append(edges, hazardousmaterialsegregation.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, hazardousmaterialsegregation.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HazardousMaterialSegregationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hazardousmaterialsegregation.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case hazardousmaterialsegregation.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HazardousMaterialSegregationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HazardousMaterialSegregationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HazardousMaterialSegregationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbusiness_unit {
		edges = append(edges, hazardousmaterialsegregation.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, hazardousmaterialsegregation.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HazardousMaterialSegregationMutation) EdgeCleared(name string) bool {
	switch name {
	case hazardousmaterialsegregation.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case hazardousmaterialsegregation.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HazardousMaterialSegregationMutation) ClearEdge(name string) error {
	switch name {
	case hazardousmaterialsegregation.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case hazardousmaterialsegregation.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown HazardousMaterialSegregation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HazardousMaterialSegregationMutation) ResetEdge(name string) error {
	switch name {
	case hazardousmaterialsegregation.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case hazardousmaterialsegregation.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown HazardousMaterialSegregation edge %s", name)
}

// InvoiceControlMutation represents an operation that mutates the InvoiceControl nodes in the graph.
type InvoiceControlMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	created_at                *time.Time
	updated_at                *time.Time
	invoice_number_prefix     *string
	credit_memo_number_prefix *string
	invoice_terms             *string
	invoice_footer            *string
	invoice_logo_url          *string
	invoice_date_format       *invoicecontrol.InvoiceDateFormat
	invoice_due_after_days    *uint8
	addinvoice_due_after_days *int8
	invoice_logo_width        *uint16
	addinvoice_logo_width     *int16
	show_amount_due           *bool
	attach_pdf                *bool
	show_invoice_due_date     *bool
	clearedFields             map[string]struct{}
	organization              *uuid.UUID
	clearedorganization       bool
	business_unit             *uuid.UUID
	clearedbusiness_unit      bool
	done                      bool
	oldValue                  func(context.Context) (*InvoiceControl, error)
	predicates                []predicate.InvoiceControl
}

var _ ent.Mutation = (*InvoiceControlMutation)(nil)

// invoicecontrolOption allows management of the mutation configuration using functional options.
type invoicecontrolOption func(*InvoiceControlMutation)

// newInvoiceControlMutation creates new mutation for the InvoiceControl entity.
func newInvoiceControlMutation(c config, op Op, opts ...invoicecontrolOption) *InvoiceControlMutation {
	m := &InvoiceControlMutation{
		config:        c,
		op:            op,
		typ:           TypeInvoiceControl,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvoiceControlID sets the ID field of the mutation.
func withInvoiceControlID(id uuid.UUID) invoicecontrolOption {
	return func(m *InvoiceControlMutation) {
		var (
			err   error
			once  sync.Once
			value *InvoiceControl
		)
		m.oldValue = func(ctx context.Context) (*InvoiceControl, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InvoiceControl.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvoiceControl sets the old InvoiceControl of the mutation.
func withInvoiceControl(node *InvoiceControl) invoicecontrolOption {
	return func(m *InvoiceControlMutation) {
		m.oldValue = func(context.Context) (*InvoiceControl, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InvoiceControlMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InvoiceControlMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InvoiceControl entities.
func (m *InvoiceControlMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InvoiceControlMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InvoiceControlMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InvoiceControl.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InvoiceControlMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InvoiceControlMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InvoiceControl entity.
// If the InvoiceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceControlMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InvoiceControlMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InvoiceControlMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InvoiceControlMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the InvoiceControl entity.
// If the InvoiceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceControlMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InvoiceControlMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetInvoiceNumberPrefix sets the "invoice_number_prefix" field.
func (m *InvoiceControlMutation) SetInvoiceNumberPrefix(s string) {
	m.invoice_number_prefix = &s
}

// InvoiceNumberPrefix returns the value of the "invoice_number_prefix" field in the mutation.
func (m *InvoiceControlMutation) InvoiceNumberPrefix() (r string, exists bool) {
	v := m.invoice_number_prefix
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceNumberPrefix returns the old "invoice_number_prefix" field's value of the InvoiceControl entity.
// If the InvoiceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceControlMutation) OldInvoiceNumberPrefix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceNumberPrefix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceNumberPrefix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceNumberPrefix: %w", err)
	}
	return oldValue.InvoiceNumberPrefix, nil
}

// ResetInvoiceNumberPrefix resets all changes to the "invoice_number_prefix" field.
func (m *InvoiceControlMutation) ResetInvoiceNumberPrefix() {
	m.invoice_number_prefix = nil
}

// SetCreditMemoNumberPrefix sets the "credit_memo_number_prefix" field.
func (m *InvoiceControlMutation) SetCreditMemoNumberPrefix(s string) {
	m.credit_memo_number_prefix = &s
}

// CreditMemoNumberPrefix returns the value of the "credit_memo_number_prefix" field in the mutation.
func (m *InvoiceControlMutation) CreditMemoNumberPrefix() (r string, exists bool) {
	v := m.credit_memo_number_prefix
	if v == nil {
		return
	}
	return *v, true
}

// OldCreditMemoNumberPrefix returns the old "credit_memo_number_prefix" field's value of the InvoiceControl entity.
// If the InvoiceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceControlMutation) OldCreditMemoNumberPrefix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreditMemoNumberPrefix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreditMemoNumberPrefix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreditMemoNumberPrefix: %w", err)
	}
	return oldValue.CreditMemoNumberPrefix, nil
}

// ResetCreditMemoNumberPrefix resets all changes to the "credit_memo_number_prefix" field.
func (m *InvoiceControlMutation) ResetCreditMemoNumberPrefix() {
	m.credit_memo_number_prefix = nil
}

// SetInvoiceTerms sets the "invoice_terms" field.
func (m *InvoiceControlMutation) SetInvoiceTerms(s string) {
	m.invoice_terms = &s
}

// InvoiceTerms returns the value of the "invoice_terms" field in the mutation.
func (m *InvoiceControlMutation) InvoiceTerms() (r string, exists bool) {
	v := m.invoice_terms
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceTerms returns the old "invoice_terms" field's value of the InvoiceControl entity.
// If the InvoiceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceControlMutation) OldInvoiceTerms(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceTerms is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceTerms requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceTerms: %w", err)
	}
	return oldValue.InvoiceTerms, nil
}

// ClearInvoiceTerms clears the value of the "invoice_terms" field.
func (m *InvoiceControlMutation) ClearInvoiceTerms() {
	m.invoice_terms = nil
	m.clearedFields[invoicecontrol.FieldInvoiceTerms] = struct{}{}
}

// InvoiceTermsCleared returns if the "invoice_terms" field was cleared in this mutation.
func (m *InvoiceControlMutation) InvoiceTermsCleared() bool {
	_, ok := m.clearedFields[invoicecontrol.FieldInvoiceTerms]
	return ok
}

// ResetInvoiceTerms resets all changes to the "invoice_terms" field.
func (m *InvoiceControlMutation) ResetInvoiceTerms() {
	m.invoice_terms = nil
	delete(m.clearedFields, invoicecontrol.FieldInvoiceTerms)
}

// SetInvoiceFooter sets the "invoice_footer" field.
func (m *InvoiceControlMutation) SetInvoiceFooter(s string) {
	m.invoice_footer = &s
}

// InvoiceFooter returns the value of the "invoice_footer" field in the mutation.
func (m *InvoiceControlMutation) InvoiceFooter() (r string, exists bool) {
	v := m.invoice_footer
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceFooter returns the old "invoice_footer" field's value of the InvoiceControl entity.
// If the InvoiceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceControlMutation) OldInvoiceFooter(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceFooter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceFooter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceFooter: %w", err)
	}
	return oldValue.InvoiceFooter, nil
}

// ClearInvoiceFooter clears the value of the "invoice_footer" field.
func (m *InvoiceControlMutation) ClearInvoiceFooter() {
	m.invoice_footer = nil
	m.clearedFields[invoicecontrol.FieldInvoiceFooter] = struct{}{}
}

// InvoiceFooterCleared returns if the "invoice_footer" field was cleared in this mutation.
func (m *InvoiceControlMutation) InvoiceFooterCleared() bool {
	_, ok := m.clearedFields[invoicecontrol.FieldInvoiceFooter]
	return ok
}

// ResetInvoiceFooter resets all changes to the "invoice_footer" field.
func (m *InvoiceControlMutation) ResetInvoiceFooter() {
	m.invoice_footer = nil
	delete(m.clearedFields, invoicecontrol.FieldInvoiceFooter)
}

// SetInvoiceLogoURL sets the "invoice_logo_url" field.
func (m *InvoiceControlMutation) SetInvoiceLogoURL(s string) {
	m.invoice_logo_url = &s
}

// InvoiceLogoURL returns the value of the "invoice_logo_url" field in the mutation.
func (m *InvoiceControlMutation) InvoiceLogoURL() (r string, exists bool) {
	v := m.invoice_logo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceLogoURL returns the old "invoice_logo_url" field's value of the InvoiceControl entity.
// If the InvoiceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceControlMutation) OldInvoiceLogoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceLogoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceLogoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceLogoURL: %w", err)
	}
	return oldValue.InvoiceLogoURL, nil
}

// ClearInvoiceLogoURL clears the value of the "invoice_logo_url" field.
func (m *InvoiceControlMutation) ClearInvoiceLogoURL() {
	m.invoice_logo_url = nil
	m.clearedFields[invoicecontrol.FieldInvoiceLogoURL] = struct{}{}
}

// InvoiceLogoURLCleared returns if the "invoice_logo_url" field was cleared in this mutation.
func (m *InvoiceControlMutation) InvoiceLogoURLCleared() bool {
	_, ok := m.clearedFields[invoicecontrol.FieldInvoiceLogoURL]
	return ok
}

// ResetInvoiceLogoURL resets all changes to the "invoice_logo_url" field.
func (m *InvoiceControlMutation) ResetInvoiceLogoURL() {
	m.invoice_logo_url = nil
	delete(m.clearedFields, invoicecontrol.FieldInvoiceLogoURL)
}

// SetInvoiceDateFormat sets the "invoice_date_format" field.
func (m *InvoiceControlMutation) SetInvoiceDateFormat(idf invoicecontrol.InvoiceDateFormat) {
	m.invoice_date_format = &idf
}

// InvoiceDateFormat returns the value of the "invoice_date_format" field in the mutation.
func (m *InvoiceControlMutation) InvoiceDateFormat() (r invoicecontrol.InvoiceDateFormat, exists bool) {
	v := m.invoice_date_format
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceDateFormat returns the old "invoice_date_format" field's value of the InvoiceControl entity.
// If the InvoiceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceControlMutation) OldInvoiceDateFormat(ctx context.Context) (v invoicecontrol.InvoiceDateFormat, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceDateFormat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceDateFormat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceDateFormat: %w", err)
	}
	return oldValue.InvoiceDateFormat, nil
}

// ResetInvoiceDateFormat resets all changes to the "invoice_date_format" field.
func (m *InvoiceControlMutation) ResetInvoiceDateFormat() {
	m.invoice_date_format = nil
}

// SetInvoiceDueAfterDays sets the "invoice_due_after_days" field.
func (m *InvoiceControlMutation) SetInvoiceDueAfterDays(u uint8) {
	m.invoice_due_after_days = &u
	m.addinvoice_due_after_days = nil
}

// InvoiceDueAfterDays returns the value of the "invoice_due_after_days" field in the mutation.
func (m *InvoiceControlMutation) InvoiceDueAfterDays() (r uint8, exists bool) {
	v := m.invoice_due_after_days
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceDueAfterDays returns the old "invoice_due_after_days" field's value of the InvoiceControl entity.
// If the InvoiceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceControlMutation) OldInvoiceDueAfterDays(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceDueAfterDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceDueAfterDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceDueAfterDays: %w", err)
	}
	return oldValue.InvoiceDueAfterDays, nil
}

// AddInvoiceDueAfterDays adds u to the "invoice_due_after_days" field.
func (m *InvoiceControlMutation) AddInvoiceDueAfterDays(u int8) {
	if m.addinvoice_due_after_days != nil {
		*m.addinvoice_due_after_days += u
	} else {
		m.addinvoice_due_after_days = &u
	}
}

// AddedInvoiceDueAfterDays returns the value that was added to the "invoice_due_after_days" field in this mutation.
func (m *InvoiceControlMutation) AddedInvoiceDueAfterDays() (r int8, exists bool) {
	v := m.addinvoice_due_after_days
	if v == nil {
		return
	}
	return *v, true
}

// ResetInvoiceDueAfterDays resets all changes to the "invoice_due_after_days" field.
func (m *InvoiceControlMutation) ResetInvoiceDueAfterDays() {
	m.invoice_due_after_days = nil
	m.addinvoice_due_after_days = nil
}

// SetInvoiceLogoWidth sets the "invoice_logo_width" field.
func (m *InvoiceControlMutation) SetInvoiceLogoWidth(u uint16) {
	m.invoice_logo_width = &u
	m.addinvoice_logo_width = nil
}

// InvoiceLogoWidth returns the value of the "invoice_logo_width" field in the mutation.
func (m *InvoiceControlMutation) InvoiceLogoWidth() (r uint16, exists bool) {
	v := m.invoice_logo_width
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceLogoWidth returns the old "invoice_logo_width" field's value of the InvoiceControl entity.
// If the InvoiceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceControlMutation) OldInvoiceLogoWidth(ctx context.Context) (v uint16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceLogoWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceLogoWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceLogoWidth: %w", err)
	}
	return oldValue.InvoiceLogoWidth, nil
}

// AddInvoiceLogoWidth adds u to the "invoice_logo_width" field.
func (m *InvoiceControlMutation) AddInvoiceLogoWidth(u int16) {
	if m.addinvoice_logo_width != nil {
		*m.addinvoice_logo_width += u
	} else {
		m.addinvoice_logo_width = &u
	}
}

// AddedInvoiceLogoWidth returns the value that was added to the "invoice_logo_width" field in this mutation.
func (m *InvoiceControlMutation) AddedInvoiceLogoWidth() (r int16, exists bool) {
	v := m.addinvoice_logo_width
	if v == nil {
		return
	}
	return *v, true
}

// ResetInvoiceLogoWidth resets all changes to the "invoice_logo_width" field.
func (m *InvoiceControlMutation) ResetInvoiceLogoWidth() {
	m.invoice_logo_width = nil
	m.addinvoice_logo_width = nil
}

// SetShowAmountDue sets the "show_amount_due" field.
func (m *InvoiceControlMutation) SetShowAmountDue(b bool) {
	m.show_amount_due = &b
}

// ShowAmountDue returns the value of the "show_amount_due" field in the mutation.
func (m *InvoiceControlMutation) ShowAmountDue() (r bool, exists bool) {
	v := m.show_amount_due
	if v == nil {
		return
	}
	return *v, true
}

// OldShowAmountDue returns the old "show_amount_due" field's value of the InvoiceControl entity.
// If the InvoiceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceControlMutation) OldShowAmountDue(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShowAmountDue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShowAmountDue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShowAmountDue: %w", err)
	}
	return oldValue.ShowAmountDue, nil
}

// ResetShowAmountDue resets all changes to the "show_amount_due" field.
func (m *InvoiceControlMutation) ResetShowAmountDue() {
	m.show_amount_due = nil
}

// SetAttachPdf sets the "attach_pdf" field.
func (m *InvoiceControlMutation) SetAttachPdf(b bool) {
	m.attach_pdf = &b
}

// AttachPdf returns the value of the "attach_pdf" field in the mutation.
func (m *InvoiceControlMutation) AttachPdf() (r bool, exists bool) {
	v := m.attach_pdf
	if v == nil {
		return
	}
	return *v, true
}

// OldAttachPdf returns the old "attach_pdf" field's value of the InvoiceControl entity.
// If the InvoiceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceControlMutation) OldAttachPdf(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttachPdf is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttachPdf requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttachPdf: %w", err)
	}
	return oldValue.AttachPdf, nil
}

// ResetAttachPdf resets all changes to the "attach_pdf" field.
func (m *InvoiceControlMutation) ResetAttachPdf() {
	m.attach_pdf = nil
}

// SetShowInvoiceDueDate sets the "show_invoice_due_date" field.
func (m *InvoiceControlMutation) SetShowInvoiceDueDate(b bool) {
	m.show_invoice_due_date = &b
}

// ShowInvoiceDueDate returns the value of the "show_invoice_due_date" field in the mutation.
func (m *InvoiceControlMutation) ShowInvoiceDueDate() (r bool, exists bool) {
	v := m.show_invoice_due_date
	if v == nil {
		return
	}
	return *v, true
}

// OldShowInvoiceDueDate returns the old "show_invoice_due_date" field's value of the InvoiceControl entity.
// If the InvoiceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceControlMutation) OldShowInvoiceDueDate(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShowInvoiceDueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShowInvoiceDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShowInvoiceDueDate: %w", err)
	}
	return oldValue.ShowInvoiceDueDate, nil
}

// ResetShowInvoiceDueDate resets all changes to the "show_invoice_due_date" field.
func (m *InvoiceControlMutation) ResetShowInvoiceDueDate() {
	m.show_invoice_due_date = nil
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *InvoiceControlMutation) SetOrganizationID(id uuid.UUID) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *InvoiceControlMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *InvoiceControlMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *InvoiceControlMutation) OrganizationID() (id uuid.UUID, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *InvoiceControlMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *InvoiceControlMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// SetBusinessUnitID sets the "business_unit" edge to the BusinessUnit entity by id.
func (m *InvoiceControlMutation) SetBusinessUnitID(id uuid.UUID) {
	m.business_unit = &id
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *InvoiceControlMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *InvoiceControlMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitID returns the "business_unit" edge ID in the mutation.
func (m *InvoiceControlMutation) BusinessUnitID() (id uuid.UUID, exists bool) {
	if m.business_unit != nil {
		return *m.business_unit, true
	}
	return
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *InvoiceControlMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *InvoiceControlMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// Where appends a list predicates to the InvoiceControlMutation builder.
func (m *InvoiceControlMutation) Where(ps ...predicate.InvoiceControl) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InvoiceControlMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InvoiceControlMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InvoiceControl, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InvoiceControlMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InvoiceControlMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InvoiceControl).
func (m *InvoiceControlMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InvoiceControlMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, invoicecontrol.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, invoicecontrol.FieldUpdatedAt)
	}
	if m.invoice_number_prefix != nil {
		fields = append(fields, invoicecontrol.FieldInvoiceNumberPrefix)
	}
	if m.credit_memo_number_prefix != nil {
		fields = append(fields, invoicecontrol.FieldCreditMemoNumberPrefix)
	}
	if m.invoice_terms != nil {
		fields = append(fields, invoicecontrol.FieldInvoiceTerms)
	}
	if m.invoice_footer != nil {
		fields = append(fields, invoicecontrol.FieldInvoiceFooter)
	}
	if m.invoice_logo_url != nil {
		fields = append(fields, invoicecontrol.FieldInvoiceLogoURL)
	}
	if m.invoice_date_format != nil {
		fields = append(fields, invoicecontrol.FieldInvoiceDateFormat)
	}
	if m.invoice_due_after_days != nil {
		fields = append(fields, invoicecontrol.FieldInvoiceDueAfterDays)
	}
	if m.invoice_logo_width != nil {
		fields = append(fields, invoicecontrol.FieldInvoiceLogoWidth)
	}
	if m.show_amount_due != nil {
		fields = append(fields, invoicecontrol.FieldShowAmountDue)
	}
	if m.attach_pdf != nil {
		fields = append(fields, invoicecontrol.FieldAttachPdf)
	}
	if m.show_invoice_due_date != nil {
		fields = append(fields, invoicecontrol.FieldShowInvoiceDueDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InvoiceControlMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case invoicecontrol.FieldCreatedAt:
		return m.CreatedAt()
	case invoicecontrol.FieldUpdatedAt:
		return m.UpdatedAt()
	case invoicecontrol.FieldInvoiceNumberPrefix:
		return m.InvoiceNumberPrefix()
	case invoicecontrol.FieldCreditMemoNumberPrefix:
		return m.CreditMemoNumberPrefix()
	case invoicecontrol.FieldInvoiceTerms:
		return m.InvoiceTerms()
	case invoicecontrol.FieldInvoiceFooter:
		return m.InvoiceFooter()
	case invoicecontrol.FieldInvoiceLogoURL:
		return m.InvoiceLogoURL()
	case invoicecontrol.FieldInvoiceDateFormat:
		return m.InvoiceDateFormat()
	case invoicecontrol.FieldInvoiceDueAfterDays:
		return m.InvoiceDueAfterDays()
	case invoicecontrol.FieldInvoiceLogoWidth:
		return m.InvoiceLogoWidth()
	case invoicecontrol.FieldShowAmountDue:
		return m.ShowAmountDue()
	case invoicecontrol.FieldAttachPdf:
		return m.AttachPdf()
	case invoicecontrol.FieldShowInvoiceDueDate:
		return m.ShowInvoiceDueDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InvoiceControlMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case invoicecontrol.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case invoicecontrol.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case invoicecontrol.FieldInvoiceNumberPrefix:
		return m.OldInvoiceNumberPrefix(ctx)
	case invoicecontrol.FieldCreditMemoNumberPrefix:
		return m.OldCreditMemoNumberPrefix(ctx)
	case invoicecontrol.FieldInvoiceTerms:
		return m.OldInvoiceTerms(ctx)
	case invoicecontrol.FieldInvoiceFooter:
		return m.OldInvoiceFooter(ctx)
	case invoicecontrol.FieldInvoiceLogoURL:
		return m.OldInvoiceLogoURL(ctx)
	case invoicecontrol.FieldInvoiceDateFormat:
		return m.OldInvoiceDateFormat(ctx)
	case invoicecontrol.FieldInvoiceDueAfterDays:
		return m.OldInvoiceDueAfterDays(ctx)
	case invoicecontrol.FieldInvoiceLogoWidth:
		return m.OldInvoiceLogoWidth(ctx)
	case invoicecontrol.FieldShowAmountDue:
		return m.OldShowAmountDue(ctx)
	case invoicecontrol.FieldAttachPdf:
		return m.OldAttachPdf(ctx)
	case invoicecontrol.FieldShowInvoiceDueDate:
		return m.OldShowInvoiceDueDate(ctx)
	}
	return nil, fmt.Errorf("unknown InvoiceControl field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvoiceControlMutation) SetField(name string, value ent.Value) error {
	switch name {
	case invoicecontrol.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case invoicecontrol.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case invoicecontrol.FieldInvoiceNumberPrefix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceNumberPrefix(v)
		return nil
	case invoicecontrol.FieldCreditMemoNumberPrefix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreditMemoNumberPrefix(v)
		return nil
	case invoicecontrol.FieldInvoiceTerms:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceTerms(v)
		return nil
	case invoicecontrol.FieldInvoiceFooter:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceFooter(v)
		return nil
	case invoicecontrol.FieldInvoiceLogoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceLogoURL(v)
		return nil
	case invoicecontrol.FieldInvoiceDateFormat:
		v, ok := value.(invoicecontrol.InvoiceDateFormat)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceDateFormat(v)
		return nil
	case invoicecontrol.FieldInvoiceDueAfterDays:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceDueAfterDays(v)
		return nil
	case invoicecontrol.FieldInvoiceLogoWidth:
		v, ok := value.(uint16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceLogoWidth(v)
		return nil
	case invoicecontrol.FieldShowAmountDue:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShowAmountDue(v)
		return nil
	case invoicecontrol.FieldAttachPdf:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttachPdf(v)
		return nil
	case invoicecontrol.FieldShowInvoiceDueDate:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShowInvoiceDueDate(v)
		return nil
	}
	return fmt.Errorf("unknown InvoiceControl field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InvoiceControlMutation) AddedFields() []string {
	var fields []string
	if m.addinvoice_due_after_days != nil {
		fields = append(fields, invoicecontrol.FieldInvoiceDueAfterDays)
	}
	if m.addinvoice_logo_width != nil {
		fields = append(fields, invoicecontrol.FieldInvoiceLogoWidth)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InvoiceControlMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case invoicecontrol.FieldInvoiceDueAfterDays:
		return m.AddedInvoiceDueAfterDays()
	case invoicecontrol.FieldInvoiceLogoWidth:
		return m.AddedInvoiceLogoWidth()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvoiceControlMutation) AddField(name string, value ent.Value) error {
	switch name {
	case invoicecontrol.FieldInvoiceDueAfterDays:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInvoiceDueAfterDays(v)
		return nil
	case invoicecontrol.FieldInvoiceLogoWidth:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInvoiceLogoWidth(v)
		return nil
	}
	return fmt.Errorf("unknown InvoiceControl numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InvoiceControlMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(invoicecontrol.FieldInvoiceTerms) {
		fields = append(fields, invoicecontrol.FieldInvoiceTerms)
	}
	if m.FieldCleared(invoicecontrol.FieldInvoiceFooter) {
		fields = append(fields, invoicecontrol.FieldInvoiceFooter)
	}
	if m.FieldCleared(invoicecontrol.FieldInvoiceLogoURL) {
		fields = append(fields, invoicecontrol.FieldInvoiceLogoURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InvoiceControlMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InvoiceControlMutation) ClearField(name string) error {
	switch name {
	case invoicecontrol.FieldInvoiceTerms:
		m.ClearInvoiceTerms()
		return nil
	case invoicecontrol.FieldInvoiceFooter:
		m.ClearInvoiceFooter()
		return nil
	case invoicecontrol.FieldInvoiceLogoURL:
		m.ClearInvoiceLogoURL()
		return nil
	}
	return fmt.Errorf("unknown InvoiceControl nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InvoiceControlMutation) ResetField(name string) error {
	switch name {
	case invoicecontrol.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case invoicecontrol.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case invoicecontrol.FieldInvoiceNumberPrefix:
		m.ResetInvoiceNumberPrefix()
		return nil
	case invoicecontrol.FieldCreditMemoNumberPrefix:
		m.ResetCreditMemoNumberPrefix()
		return nil
	case invoicecontrol.FieldInvoiceTerms:
		m.ResetInvoiceTerms()
		return nil
	case invoicecontrol.FieldInvoiceFooter:
		m.ResetInvoiceFooter()
		return nil
	case invoicecontrol.FieldInvoiceLogoURL:
		m.ResetInvoiceLogoURL()
		return nil
	case invoicecontrol.FieldInvoiceDateFormat:
		m.ResetInvoiceDateFormat()
		return nil
	case invoicecontrol.FieldInvoiceDueAfterDays:
		m.ResetInvoiceDueAfterDays()
		return nil
	case invoicecontrol.FieldInvoiceLogoWidth:
		m.ResetInvoiceLogoWidth()
		return nil
	case invoicecontrol.FieldShowAmountDue:
		m.ResetShowAmountDue()
		return nil
	case invoicecontrol.FieldAttachPdf:
		m.ResetAttachPdf()
		return nil
	case invoicecontrol.FieldShowInvoiceDueDate:
		m.ResetShowInvoiceDueDate()
		return nil
	}
	return fmt.Errorf("unknown InvoiceControl field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InvoiceControlMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.organization != nil {
		edges = append(edges, invoicecontrol.EdgeOrganization)
	}
	if m.business_unit != nil {
		edges = append(edges, invoicecontrol.EdgeBusinessUnit)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InvoiceControlMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case invoicecontrol.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case invoicecontrol.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InvoiceControlMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InvoiceControlMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InvoiceControlMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorganization {
		edges = append(edges, invoicecontrol.EdgeOrganization)
	}
	if m.clearedbusiness_unit {
		edges = append(edges, invoicecontrol.EdgeBusinessUnit)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InvoiceControlMutation) EdgeCleared(name string) bool {
	switch name {
	case invoicecontrol.EdgeOrganization:
		return m.clearedorganization
	case invoicecontrol.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InvoiceControlMutation) ClearEdge(name string) error {
	switch name {
	case invoicecontrol.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case invoicecontrol.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	}
	return fmt.Errorf("unknown InvoiceControl unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InvoiceControlMutation) ResetEdge(name string) error {
	switch name {
	case invoicecontrol.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case invoicecontrol.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	}
	return fmt.Errorf("unknown InvoiceControl edge %s", name)
}

// LocationMutation represents an operation that mutates the Location nodes in the graph.
type LocationMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *uuid.UUID
	created_at                         *time.Time
	updated_at                         *time.Time
	version                            *int
	addversion                         *int
	status                             *location.Status
	code                               *string
	name                               *string
	description                        *string
	address_line_1                     *string
	address_line_2                     *string
	city                               *string
	postal_code                        *string
	longitude                          *float64
	addlongitude                       *float64
	latitude                           *float64
	addlatitude                        *float64
	place_id                           *string
	is_geocoded                        *bool
	clearedFields                      map[string]struct{}
	business_unit                      *uuid.UUID
	clearedbusiness_unit               bool
	organization                       *uuid.UUID
	clearedorganization                bool
	location_category                  *uuid.UUID
	clearedlocation_category           bool
	state                              *uuid.UUID
	clearedstate                       bool
	comments                           map[uuid.UUID]struct{}
	removedcomments                    map[uuid.UUID]struct{}
	clearedcomments                    bool
	contacts                           map[uuid.UUID]struct{}
	removedcontacts                    map[uuid.UUID]struct{}
	clearedcontacts                    bool
	origin_route_locations             map[uuid.UUID]struct{}
	removedorigin_route_locations      map[uuid.UUID]struct{}
	clearedorigin_route_locations      bool
	destination_route_locations        map[uuid.UUID]struct{}
	removeddestination_route_locations map[uuid.UUID]struct{}
	cleareddestination_route_locations bool
	done                               bool
	oldValue                           func(context.Context) (*Location, error)
	predicates                         []predicate.Location
}

var _ ent.Mutation = (*LocationMutation)(nil)

// locationOption allows management of the mutation configuration using functional options.
type locationOption func(*LocationMutation)

// newLocationMutation creates new mutation for the Location entity.
func newLocationMutation(c config, op Op, opts ...locationOption) *LocationMutation {
	m := &LocationMutation{
		config:        c,
		op:            op,
		typ:           TypeLocation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLocationID sets the ID field of the mutation.
func withLocationID(id uuid.UUID) locationOption {
	return func(m *LocationMutation) {
		var (
			err   error
			once  sync.Once
			value *Location
		)
		m.oldValue = func(ctx context.Context) (*Location, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Location.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLocation sets the old Location of the mutation.
func withLocation(node *Location) locationOption {
	return func(m *LocationMutation) {
		m.oldValue = func(context.Context) (*Location, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LocationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LocationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Location entities.
func (m *LocationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LocationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LocationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Location.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *LocationMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *LocationMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *LocationMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *LocationMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *LocationMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *LocationMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *LocationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LocationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LocationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LocationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LocationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LocationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *LocationMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *LocationMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *LocationMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *LocationMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *LocationMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetStatus sets the "status" field.
func (m *LocationMutation) SetStatus(l location.Status) {
	m.status = &l
}

// Status returns the value of the "status" field in the mutation.
func (m *LocationMutation) Status() (r location.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldStatus(ctx context.Context) (v location.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *LocationMutation) ResetStatus() {
	m.status = nil
}

// SetCode sets the "code" field.
func (m *LocationMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *LocationMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *LocationMutation) ResetCode() {
	m.code = nil
}

// SetLocationCategoryID sets the "location_category_id" field.
func (m *LocationMutation) SetLocationCategoryID(u uuid.UUID) {
	m.location_category = &u
}

// LocationCategoryID returns the value of the "location_category_id" field in the mutation.
func (m *LocationMutation) LocationCategoryID() (r uuid.UUID, exists bool) {
	v := m.location_category
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationCategoryID returns the old "location_category_id" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldLocationCategoryID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationCategoryID: %w", err)
	}
	return oldValue.LocationCategoryID, nil
}

// ClearLocationCategoryID clears the value of the "location_category_id" field.
func (m *LocationMutation) ClearLocationCategoryID() {
	m.location_category = nil
	m.clearedFields[location.FieldLocationCategoryID] = struct{}{}
}

// LocationCategoryIDCleared returns if the "location_category_id" field was cleared in this mutation.
func (m *LocationMutation) LocationCategoryIDCleared() bool {
	_, ok := m.clearedFields[location.FieldLocationCategoryID]
	return ok
}

// ResetLocationCategoryID resets all changes to the "location_category_id" field.
func (m *LocationMutation) ResetLocationCategoryID() {
	m.location_category = nil
	delete(m.clearedFields, location.FieldLocationCategoryID)
}

// SetName sets the "name" field.
func (m *LocationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LocationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LocationMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *LocationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *LocationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *LocationMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[location.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *LocationMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[location.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *LocationMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, location.FieldDescription)
}

// SetAddressLine1 sets the "address_line_1" field.
func (m *LocationMutation) SetAddressLine1(s string) {
	m.address_line_1 = &s
}

// AddressLine1 returns the value of the "address_line_1" field in the mutation.
func (m *LocationMutation) AddressLine1() (r string, exists bool) {
	v := m.address_line_1
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressLine1 returns the old "address_line_1" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldAddressLine1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddressLine1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddressLine1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressLine1: %w", err)
	}
	return oldValue.AddressLine1, nil
}

// ResetAddressLine1 resets all changes to the "address_line_1" field.
func (m *LocationMutation) ResetAddressLine1() {
	m.address_line_1 = nil
}

// SetAddressLine2 sets the "address_line_2" field.
func (m *LocationMutation) SetAddressLine2(s string) {
	m.address_line_2 = &s
}

// AddressLine2 returns the value of the "address_line_2" field in the mutation.
func (m *LocationMutation) AddressLine2() (r string, exists bool) {
	v := m.address_line_2
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressLine2 returns the old "address_line_2" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldAddressLine2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddressLine2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddressLine2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressLine2: %w", err)
	}
	return oldValue.AddressLine2, nil
}

// ClearAddressLine2 clears the value of the "address_line_2" field.
func (m *LocationMutation) ClearAddressLine2() {
	m.address_line_2 = nil
	m.clearedFields[location.FieldAddressLine2] = struct{}{}
}

// AddressLine2Cleared returns if the "address_line_2" field was cleared in this mutation.
func (m *LocationMutation) AddressLine2Cleared() bool {
	_, ok := m.clearedFields[location.FieldAddressLine2]
	return ok
}

// ResetAddressLine2 resets all changes to the "address_line_2" field.
func (m *LocationMutation) ResetAddressLine2() {
	m.address_line_2 = nil
	delete(m.clearedFields, location.FieldAddressLine2)
}

// SetCity sets the "city" field.
func (m *LocationMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *LocationMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *LocationMutation) ResetCity() {
	m.city = nil
}

// SetStateID sets the "state_id" field.
func (m *LocationMutation) SetStateID(u uuid.UUID) {
	m.state = &u
}

// StateID returns the value of the "state_id" field in the mutation.
func (m *LocationMutation) StateID() (r uuid.UUID, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldStateID returns the old "state_id" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldStateID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStateID: %w", err)
	}
	return oldValue.StateID, nil
}

// ResetStateID resets all changes to the "state_id" field.
func (m *LocationMutation) ResetStateID() {
	m.state = nil
}

// SetPostalCode sets the "postal_code" field.
func (m *LocationMutation) SetPostalCode(s string) {
	m.postal_code = &s
}

// PostalCode returns the value of the "postal_code" field in the mutation.
func (m *LocationMutation) PostalCode() (r string, exists bool) {
	v := m.postal_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPostalCode returns the old "postal_code" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldPostalCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostalCode: %w", err)
	}
	return oldValue.PostalCode, nil
}

// ResetPostalCode resets all changes to the "postal_code" field.
func (m *LocationMutation) ResetPostalCode() {
	m.postal_code = nil
}

// SetLongitude sets the "longitude" field.
func (m *LocationMutation) SetLongitude(f float64) {
	m.longitude = &f
	m.addlongitude = nil
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *LocationMutation) Longitude() (r float64, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldLongitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// AddLongitude adds f to the "longitude" field.
func (m *LocationMutation) AddLongitude(f float64) {
	if m.addlongitude != nil {
		*m.addlongitude += f
	} else {
		m.addlongitude = &f
	}
}

// AddedLongitude returns the value that was added to the "longitude" field in this mutation.
func (m *LocationMutation) AddedLongitude() (r float64, exists bool) {
	v := m.addlongitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLongitude clears the value of the "longitude" field.
func (m *LocationMutation) ClearLongitude() {
	m.longitude = nil
	m.addlongitude = nil
	m.clearedFields[location.FieldLongitude] = struct{}{}
}

// LongitudeCleared returns if the "longitude" field was cleared in this mutation.
func (m *LocationMutation) LongitudeCleared() bool {
	_, ok := m.clearedFields[location.FieldLongitude]
	return ok
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *LocationMutation) ResetLongitude() {
	m.longitude = nil
	m.addlongitude = nil
	delete(m.clearedFields, location.FieldLongitude)
}

// SetLatitude sets the "latitude" field.
func (m *LocationMutation) SetLatitude(f float64) {
	m.latitude = &f
	m.addlatitude = nil
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *LocationMutation) Latitude() (r float64, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldLatitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// AddLatitude adds f to the "latitude" field.
func (m *LocationMutation) AddLatitude(f float64) {
	if m.addlatitude != nil {
		*m.addlatitude += f
	} else {
		m.addlatitude = &f
	}
}

// AddedLatitude returns the value that was added to the "latitude" field in this mutation.
func (m *LocationMutation) AddedLatitude() (r float64, exists bool) {
	v := m.addlatitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLatitude clears the value of the "latitude" field.
func (m *LocationMutation) ClearLatitude() {
	m.latitude = nil
	m.addlatitude = nil
	m.clearedFields[location.FieldLatitude] = struct{}{}
}

// LatitudeCleared returns if the "latitude" field was cleared in this mutation.
func (m *LocationMutation) LatitudeCleared() bool {
	_, ok := m.clearedFields[location.FieldLatitude]
	return ok
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *LocationMutation) ResetLatitude() {
	m.latitude = nil
	m.addlatitude = nil
	delete(m.clearedFields, location.FieldLatitude)
}

// SetPlaceID sets the "place_id" field.
func (m *LocationMutation) SetPlaceID(s string) {
	m.place_id = &s
}

// PlaceID returns the value of the "place_id" field in the mutation.
func (m *LocationMutation) PlaceID() (r string, exists bool) {
	v := m.place_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPlaceID returns the old "place_id" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldPlaceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlaceID: %w", err)
	}
	return oldValue.PlaceID, nil
}

// ClearPlaceID clears the value of the "place_id" field.
func (m *LocationMutation) ClearPlaceID() {
	m.place_id = nil
	m.clearedFields[location.FieldPlaceID] = struct{}{}
}

// PlaceIDCleared returns if the "place_id" field was cleared in this mutation.
func (m *LocationMutation) PlaceIDCleared() bool {
	_, ok := m.clearedFields[location.FieldPlaceID]
	return ok
}

// ResetPlaceID resets all changes to the "place_id" field.
func (m *LocationMutation) ResetPlaceID() {
	m.place_id = nil
	delete(m.clearedFields, location.FieldPlaceID)
}

// SetIsGeocoded sets the "is_geocoded" field.
func (m *LocationMutation) SetIsGeocoded(b bool) {
	m.is_geocoded = &b
}

// IsGeocoded returns the value of the "is_geocoded" field in the mutation.
func (m *LocationMutation) IsGeocoded() (r bool, exists bool) {
	v := m.is_geocoded
	if v == nil {
		return
	}
	return *v, true
}

// OldIsGeocoded returns the old "is_geocoded" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldIsGeocoded(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsGeocoded is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsGeocoded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsGeocoded: %w", err)
	}
	return oldValue.IsGeocoded, nil
}

// ResetIsGeocoded resets all changes to the "is_geocoded" field.
func (m *LocationMutation) ResetIsGeocoded() {
	m.is_geocoded = nil
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *LocationMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[location.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *LocationMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *LocationMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *LocationMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *LocationMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[location.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *LocationMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *LocationMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *LocationMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearLocationCategory clears the "location_category" edge to the LocationCategory entity.
func (m *LocationMutation) ClearLocationCategory() {
	m.clearedlocation_category = true
	m.clearedFields[location.FieldLocationCategoryID] = struct{}{}
}

// LocationCategoryCleared reports if the "location_category" edge to the LocationCategory entity was cleared.
func (m *LocationMutation) LocationCategoryCleared() bool {
	return m.LocationCategoryIDCleared() || m.clearedlocation_category
}

// LocationCategoryIDs returns the "location_category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LocationCategoryID instead. It exists only for internal usage by the builders.
func (m *LocationMutation) LocationCategoryIDs() (ids []uuid.UUID) {
	if id := m.location_category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocationCategory resets all changes to the "location_category" edge.
func (m *LocationMutation) ResetLocationCategory() {
	m.location_category = nil
	m.clearedlocation_category = false
}

// ClearState clears the "state" edge to the UsState entity.
func (m *LocationMutation) ClearState() {
	m.clearedstate = true
	m.clearedFields[location.FieldStateID] = struct{}{}
}

// StateCleared reports if the "state" edge to the UsState entity was cleared.
func (m *LocationMutation) StateCleared() bool {
	return m.clearedstate
}

// StateIDs returns the "state" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StateID instead. It exists only for internal usage by the builders.
func (m *LocationMutation) StateIDs() (ids []uuid.UUID) {
	if id := m.state; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetState resets all changes to the "state" edge.
func (m *LocationMutation) ResetState() {
	m.state = nil
	m.clearedstate = false
}

// AddCommentIDs adds the "comments" edge to the LocationComment entity by ids.
func (m *LocationMutation) AddCommentIDs(ids ...uuid.UUID) {
	if m.comments == nil {
		m.comments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the "comments" edge to the LocationComment entity.
func (m *LocationMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared reports if the "comments" edge to the LocationComment entity was cleared.
func (m *LocationMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the "comments" edge to the LocationComment entity by IDs.
func (m *LocationMutation) RemoveCommentIDs(ids ...uuid.UUID) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.comments, ids[i])
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed IDs of the "comments" edge to the LocationComment entity.
func (m *LocationMutation) RemovedCommentsIDs() (ids []uuid.UUID) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the "comments" edge IDs in the mutation.
func (m *LocationMutation) CommentsIDs() (ids []uuid.UUID) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments resets all changes to the "comments" edge.
func (m *LocationMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// AddContactIDs adds the "contacts" edge to the LocationContact entity by ids.
func (m *LocationMutation) AddContactIDs(ids ...uuid.UUID) {
	if m.contacts == nil {
		m.contacts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.contacts[ids[i]] = struct{}{}
	}
}

// ClearContacts clears the "contacts" edge to the LocationContact entity.
func (m *LocationMutation) ClearContacts() {
	m.clearedcontacts = true
}

// ContactsCleared reports if the "contacts" edge to the LocationContact entity was cleared.
func (m *LocationMutation) ContactsCleared() bool {
	return m.clearedcontacts
}

// RemoveContactIDs removes the "contacts" edge to the LocationContact entity by IDs.
func (m *LocationMutation) RemoveContactIDs(ids ...uuid.UUID) {
	if m.removedcontacts == nil {
		m.removedcontacts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.contacts, ids[i])
		m.removedcontacts[ids[i]] = struct{}{}
	}
}

// RemovedContacts returns the removed IDs of the "contacts" edge to the LocationContact entity.
func (m *LocationMutation) RemovedContactsIDs() (ids []uuid.UUID) {
	for id := range m.removedcontacts {
		ids = append(ids, id)
	}
	return
}

// ContactsIDs returns the "contacts" edge IDs in the mutation.
func (m *LocationMutation) ContactsIDs() (ids []uuid.UUID) {
	for id := range m.contacts {
		ids = append(ids, id)
	}
	return
}

// ResetContacts resets all changes to the "contacts" edge.
func (m *LocationMutation) ResetContacts() {
	m.contacts = nil
	m.clearedcontacts = false
	m.removedcontacts = nil
}

// AddOriginRouteLocationIDs adds the "origin_route_locations" edge to the ShipmentRoute entity by ids.
func (m *LocationMutation) AddOriginRouteLocationIDs(ids ...uuid.UUID) {
	if m.origin_route_locations == nil {
		m.origin_route_locations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.origin_route_locations[ids[i]] = struct{}{}
	}
}

// ClearOriginRouteLocations clears the "origin_route_locations" edge to the ShipmentRoute entity.
func (m *LocationMutation) ClearOriginRouteLocations() {
	m.clearedorigin_route_locations = true
}

// OriginRouteLocationsCleared reports if the "origin_route_locations" edge to the ShipmentRoute entity was cleared.
func (m *LocationMutation) OriginRouteLocationsCleared() bool {
	return m.clearedorigin_route_locations
}

// RemoveOriginRouteLocationIDs removes the "origin_route_locations" edge to the ShipmentRoute entity by IDs.
func (m *LocationMutation) RemoveOriginRouteLocationIDs(ids ...uuid.UUID) {
	if m.removedorigin_route_locations == nil {
		m.removedorigin_route_locations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.origin_route_locations, ids[i])
		m.removedorigin_route_locations[ids[i]] = struct{}{}
	}
}

// RemovedOriginRouteLocations returns the removed IDs of the "origin_route_locations" edge to the ShipmentRoute entity.
func (m *LocationMutation) RemovedOriginRouteLocationsIDs() (ids []uuid.UUID) {
	for id := range m.removedorigin_route_locations {
		ids = append(ids, id)
	}
	return
}

// OriginRouteLocationsIDs returns the "origin_route_locations" edge IDs in the mutation.
func (m *LocationMutation) OriginRouteLocationsIDs() (ids []uuid.UUID) {
	for id := range m.origin_route_locations {
		ids = append(ids, id)
	}
	return
}

// ResetOriginRouteLocations resets all changes to the "origin_route_locations" edge.
func (m *LocationMutation) ResetOriginRouteLocations() {
	m.origin_route_locations = nil
	m.clearedorigin_route_locations = false
	m.removedorigin_route_locations = nil
}

// AddDestinationRouteLocationIDs adds the "destination_route_locations" edge to the ShipmentRoute entity by ids.
func (m *LocationMutation) AddDestinationRouteLocationIDs(ids ...uuid.UUID) {
	if m.destination_route_locations == nil {
		m.destination_route_locations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.destination_route_locations[ids[i]] = struct{}{}
	}
}

// ClearDestinationRouteLocations clears the "destination_route_locations" edge to the ShipmentRoute entity.
func (m *LocationMutation) ClearDestinationRouteLocations() {
	m.cleareddestination_route_locations = true
}

// DestinationRouteLocationsCleared reports if the "destination_route_locations" edge to the ShipmentRoute entity was cleared.
func (m *LocationMutation) DestinationRouteLocationsCleared() bool {
	return m.cleareddestination_route_locations
}

// RemoveDestinationRouteLocationIDs removes the "destination_route_locations" edge to the ShipmentRoute entity by IDs.
func (m *LocationMutation) RemoveDestinationRouteLocationIDs(ids ...uuid.UUID) {
	if m.removeddestination_route_locations == nil {
		m.removeddestination_route_locations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.destination_route_locations, ids[i])
		m.removeddestination_route_locations[ids[i]] = struct{}{}
	}
}

// RemovedDestinationRouteLocations returns the removed IDs of the "destination_route_locations" edge to the ShipmentRoute entity.
func (m *LocationMutation) RemovedDestinationRouteLocationsIDs() (ids []uuid.UUID) {
	for id := range m.removeddestination_route_locations {
		ids = append(ids, id)
	}
	return
}

// DestinationRouteLocationsIDs returns the "destination_route_locations" edge IDs in the mutation.
func (m *LocationMutation) DestinationRouteLocationsIDs() (ids []uuid.UUID) {
	for id := range m.destination_route_locations {
		ids = append(ids, id)
	}
	return
}

// ResetDestinationRouteLocations resets all changes to the "destination_route_locations" edge.
func (m *LocationMutation) ResetDestinationRouteLocations() {
	m.destination_route_locations = nil
	m.cleareddestination_route_locations = false
	m.removeddestination_route_locations = nil
}

// Where appends a list predicates to the LocationMutation builder.
func (m *LocationMutation) Where(ps ...predicate.Location) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LocationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LocationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Location, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LocationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LocationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Location).
func (m *LocationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LocationMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.business_unit != nil {
		fields = append(fields, location.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, location.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, location.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, location.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, location.FieldVersion)
	}
	if m.status != nil {
		fields = append(fields, location.FieldStatus)
	}
	if m.code != nil {
		fields = append(fields, location.FieldCode)
	}
	if m.location_category != nil {
		fields = append(fields, location.FieldLocationCategoryID)
	}
	if m.name != nil {
		fields = append(fields, location.FieldName)
	}
	if m.description != nil {
		fields = append(fields, location.FieldDescription)
	}
	if m.address_line_1 != nil {
		fields = append(fields, location.FieldAddressLine1)
	}
	if m.address_line_2 != nil {
		fields = append(fields, location.FieldAddressLine2)
	}
	if m.city != nil {
		fields = append(fields, location.FieldCity)
	}
	if m.state != nil {
		fields = append(fields, location.FieldStateID)
	}
	if m.postal_code != nil {
		fields = append(fields, location.FieldPostalCode)
	}
	if m.longitude != nil {
		fields = append(fields, location.FieldLongitude)
	}
	if m.latitude != nil {
		fields = append(fields, location.FieldLatitude)
	}
	if m.place_id != nil {
		fields = append(fields, location.FieldPlaceID)
	}
	if m.is_geocoded != nil {
		fields = append(fields, location.FieldIsGeocoded)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LocationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case location.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case location.FieldOrganizationID:
		return m.OrganizationID()
	case location.FieldCreatedAt:
		return m.CreatedAt()
	case location.FieldUpdatedAt:
		return m.UpdatedAt()
	case location.FieldVersion:
		return m.Version()
	case location.FieldStatus:
		return m.Status()
	case location.FieldCode:
		return m.Code()
	case location.FieldLocationCategoryID:
		return m.LocationCategoryID()
	case location.FieldName:
		return m.Name()
	case location.FieldDescription:
		return m.Description()
	case location.FieldAddressLine1:
		return m.AddressLine1()
	case location.FieldAddressLine2:
		return m.AddressLine2()
	case location.FieldCity:
		return m.City()
	case location.FieldStateID:
		return m.StateID()
	case location.FieldPostalCode:
		return m.PostalCode()
	case location.FieldLongitude:
		return m.Longitude()
	case location.FieldLatitude:
		return m.Latitude()
	case location.FieldPlaceID:
		return m.PlaceID()
	case location.FieldIsGeocoded:
		return m.IsGeocoded()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LocationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case location.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case location.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case location.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case location.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case location.FieldVersion:
		return m.OldVersion(ctx)
	case location.FieldStatus:
		return m.OldStatus(ctx)
	case location.FieldCode:
		return m.OldCode(ctx)
	case location.FieldLocationCategoryID:
		return m.OldLocationCategoryID(ctx)
	case location.FieldName:
		return m.OldName(ctx)
	case location.FieldDescription:
		return m.OldDescription(ctx)
	case location.FieldAddressLine1:
		return m.OldAddressLine1(ctx)
	case location.FieldAddressLine2:
		return m.OldAddressLine2(ctx)
	case location.FieldCity:
		return m.OldCity(ctx)
	case location.FieldStateID:
		return m.OldStateID(ctx)
	case location.FieldPostalCode:
		return m.OldPostalCode(ctx)
	case location.FieldLongitude:
		return m.OldLongitude(ctx)
	case location.FieldLatitude:
		return m.OldLatitude(ctx)
	case location.FieldPlaceID:
		return m.OldPlaceID(ctx)
	case location.FieldIsGeocoded:
		return m.OldIsGeocoded(ctx)
	}
	return nil, fmt.Errorf("unknown Location field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case location.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case location.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case location.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case location.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case location.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case location.FieldStatus:
		v, ok := value.(location.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case location.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case location.FieldLocationCategoryID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationCategoryID(v)
		return nil
	case location.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case location.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case location.FieldAddressLine1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressLine1(v)
		return nil
	case location.FieldAddressLine2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressLine2(v)
		return nil
	case location.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case location.FieldStateID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStateID(v)
		return nil
	case location.FieldPostalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostalCode(v)
		return nil
	case location.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case location.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case location.FieldPlaceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlaceID(v)
		return nil
	case location.FieldIsGeocoded:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsGeocoded(v)
		return nil
	}
	return fmt.Errorf("unknown Location field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LocationMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, location.FieldVersion)
	}
	if m.addlongitude != nil {
		fields = append(fields, location.FieldLongitude)
	}
	if m.addlatitude != nil {
		fields = append(fields, location.FieldLatitude)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LocationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case location.FieldVersion:
		return m.AddedVersion()
	case location.FieldLongitude:
		return m.AddedLongitude()
	case location.FieldLatitude:
		return m.AddedLatitude()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case location.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case location.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLongitude(v)
		return nil
	case location.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatitude(v)
		return nil
	}
	return fmt.Errorf("unknown Location numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LocationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(location.FieldLocationCategoryID) {
		fields = append(fields, location.FieldLocationCategoryID)
	}
	if m.FieldCleared(location.FieldDescription) {
		fields = append(fields, location.FieldDescription)
	}
	if m.FieldCleared(location.FieldAddressLine2) {
		fields = append(fields, location.FieldAddressLine2)
	}
	if m.FieldCleared(location.FieldLongitude) {
		fields = append(fields, location.FieldLongitude)
	}
	if m.FieldCleared(location.FieldLatitude) {
		fields = append(fields, location.FieldLatitude)
	}
	if m.FieldCleared(location.FieldPlaceID) {
		fields = append(fields, location.FieldPlaceID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LocationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LocationMutation) ClearField(name string) error {
	switch name {
	case location.FieldLocationCategoryID:
		m.ClearLocationCategoryID()
		return nil
	case location.FieldDescription:
		m.ClearDescription()
		return nil
	case location.FieldAddressLine2:
		m.ClearAddressLine2()
		return nil
	case location.FieldLongitude:
		m.ClearLongitude()
		return nil
	case location.FieldLatitude:
		m.ClearLatitude()
		return nil
	case location.FieldPlaceID:
		m.ClearPlaceID()
		return nil
	}
	return fmt.Errorf("unknown Location nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LocationMutation) ResetField(name string) error {
	switch name {
	case location.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case location.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case location.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case location.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case location.FieldVersion:
		m.ResetVersion()
		return nil
	case location.FieldStatus:
		m.ResetStatus()
		return nil
	case location.FieldCode:
		m.ResetCode()
		return nil
	case location.FieldLocationCategoryID:
		m.ResetLocationCategoryID()
		return nil
	case location.FieldName:
		m.ResetName()
		return nil
	case location.FieldDescription:
		m.ResetDescription()
		return nil
	case location.FieldAddressLine1:
		m.ResetAddressLine1()
		return nil
	case location.FieldAddressLine2:
		m.ResetAddressLine2()
		return nil
	case location.FieldCity:
		m.ResetCity()
		return nil
	case location.FieldStateID:
		m.ResetStateID()
		return nil
	case location.FieldPostalCode:
		m.ResetPostalCode()
		return nil
	case location.FieldLongitude:
		m.ResetLongitude()
		return nil
	case location.FieldLatitude:
		m.ResetLatitude()
		return nil
	case location.FieldPlaceID:
		m.ResetPlaceID()
		return nil
	case location.FieldIsGeocoded:
		m.ResetIsGeocoded()
		return nil
	}
	return fmt.Errorf("unknown Location field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LocationMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.business_unit != nil {
		edges = append(edges, location.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, location.EdgeOrganization)
	}
	if m.location_category != nil {
		edges = append(edges, location.EdgeLocationCategory)
	}
	if m.state != nil {
		edges = append(edges, location.EdgeState)
	}
	if m.comments != nil {
		edges = append(edges, location.EdgeComments)
	}
	if m.contacts != nil {
		edges = append(edges, location.EdgeContacts)
	}
	if m.origin_route_locations != nil {
		edges = append(edges, location.EdgeOriginRouteLocations)
	}
	if m.destination_route_locations != nil {
		edges = append(edges, location.EdgeDestinationRouteLocations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LocationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case location.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case location.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case location.EdgeLocationCategory:
		if id := m.location_category; id != nil {
			return []ent.Value{*id}
		}
	case location.EdgeState:
		if id := m.state; id != nil {
			return []ent.Value{*id}
		}
	case location.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeContacts:
		ids := make([]ent.Value, 0, len(m.contacts))
		for id := range m.contacts {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeOriginRouteLocations:
		ids := make([]ent.Value, 0, len(m.origin_route_locations))
		for id := range m.origin_route_locations {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeDestinationRouteLocations:
		ids := make([]ent.Value, 0, len(m.destination_route_locations))
		for id := range m.destination_route_locations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LocationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedcomments != nil {
		edges = append(edges, location.EdgeComments)
	}
	if m.removedcontacts != nil {
		edges = append(edges, location.EdgeContacts)
	}
	if m.removedorigin_route_locations != nil {
		edges = append(edges, location.EdgeOriginRouteLocations)
	}
	if m.removeddestination_route_locations != nil {
		edges = append(edges, location.EdgeDestinationRouteLocations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LocationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case location.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeContacts:
		ids := make([]ent.Value, 0, len(m.removedcontacts))
		for id := range m.removedcontacts {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeOriginRouteLocations:
		ids := make([]ent.Value, 0, len(m.removedorigin_route_locations))
		for id := range m.removedorigin_route_locations {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeDestinationRouteLocations:
		ids := make([]ent.Value, 0, len(m.removeddestination_route_locations))
		for id := range m.removeddestination_route_locations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LocationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedbusiness_unit {
		edges = append(edges, location.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, location.EdgeOrganization)
	}
	if m.clearedlocation_category {
		edges = append(edges, location.EdgeLocationCategory)
	}
	if m.clearedstate {
		edges = append(edges, location.EdgeState)
	}
	if m.clearedcomments {
		edges = append(edges, location.EdgeComments)
	}
	if m.clearedcontacts {
		edges = append(edges, location.EdgeContacts)
	}
	if m.clearedorigin_route_locations {
		edges = append(edges, location.EdgeOriginRouteLocations)
	}
	if m.cleareddestination_route_locations {
		edges = append(edges, location.EdgeDestinationRouteLocations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LocationMutation) EdgeCleared(name string) bool {
	switch name {
	case location.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case location.EdgeOrganization:
		return m.clearedorganization
	case location.EdgeLocationCategory:
		return m.clearedlocation_category
	case location.EdgeState:
		return m.clearedstate
	case location.EdgeComments:
		return m.clearedcomments
	case location.EdgeContacts:
		return m.clearedcontacts
	case location.EdgeOriginRouteLocations:
		return m.clearedorigin_route_locations
	case location.EdgeDestinationRouteLocations:
		return m.cleareddestination_route_locations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LocationMutation) ClearEdge(name string) error {
	switch name {
	case location.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case location.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case location.EdgeLocationCategory:
		m.ClearLocationCategory()
		return nil
	case location.EdgeState:
		m.ClearState()
		return nil
	}
	return fmt.Errorf("unknown Location unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LocationMutation) ResetEdge(name string) error {
	switch name {
	case location.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case location.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case location.EdgeLocationCategory:
		m.ResetLocationCategory()
		return nil
	case location.EdgeState:
		m.ResetState()
		return nil
	case location.EdgeComments:
		m.ResetComments()
		return nil
	case location.EdgeContacts:
		m.ResetContacts()
		return nil
	case location.EdgeOriginRouteLocations:
		m.ResetOriginRouteLocations()
		return nil
	case location.EdgeDestinationRouteLocations:
		m.ResetDestinationRouteLocations()
		return nil
	}
	return fmt.Errorf("unknown Location edge %s", name)
}

// LocationCategoryMutation represents an operation that mutates the LocationCategory nodes in the graph.
type LocationCategoryMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	version              *int
	addversion           *int
	name                 *string
	description          *string
	color                *string
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	done                 bool
	oldValue             func(context.Context) (*LocationCategory, error)
	predicates           []predicate.LocationCategory
}

var _ ent.Mutation = (*LocationCategoryMutation)(nil)

// locationcategoryOption allows management of the mutation configuration using functional options.
type locationcategoryOption func(*LocationCategoryMutation)

// newLocationCategoryMutation creates new mutation for the LocationCategory entity.
func newLocationCategoryMutation(c config, op Op, opts ...locationcategoryOption) *LocationCategoryMutation {
	m := &LocationCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeLocationCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLocationCategoryID sets the ID field of the mutation.
func withLocationCategoryID(id uuid.UUID) locationcategoryOption {
	return func(m *LocationCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *LocationCategory
		)
		m.oldValue = func(ctx context.Context) (*LocationCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LocationCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLocationCategory sets the old LocationCategory of the mutation.
func withLocationCategory(node *LocationCategory) locationcategoryOption {
	return func(m *LocationCategoryMutation) {
		m.oldValue = func(context.Context) (*LocationCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LocationCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LocationCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LocationCategory entities.
func (m *LocationCategoryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LocationCategoryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LocationCategoryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LocationCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *LocationCategoryMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *LocationCategoryMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the LocationCategory entity.
// If the LocationCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationCategoryMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *LocationCategoryMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *LocationCategoryMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *LocationCategoryMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the LocationCategory entity.
// If the LocationCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationCategoryMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *LocationCategoryMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *LocationCategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LocationCategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LocationCategory entity.
// If the LocationCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationCategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LocationCategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LocationCategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LocationCategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the LocationCategory entity.
// If the LocationCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationCategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LocationCategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *LocationCategoryMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *LocationCategoryMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the LocationCategory entity.
// If the LocationCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationCategoryMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *LocationCategoryMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *LocationCategoryMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *LocationCategoryMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetName sets the "name" field.
func (m *LocationCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LocationCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the LocationCategory entity.
// If the LocationCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LocationCategoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *LocationCategoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *LocationCategoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the LocationCategory entity.
// If the LocationCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationCategoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *LocationCategoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[locationcategory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *LocationCategoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[locationcategory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *LocationCategoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, locationcategory.FieldDescription)
}

// SetColor sets the "color" field.
func (m *LocationCategoryMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *LocationCategoryMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the LocationCategory entity.
// If the LocationCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationCategoryMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *LocationCategoryMutation) ClearColor() {
	m.color = nil
	m.clearedFields[locationcategory.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *LocationCategoryMutation) ColorCleared() bool {
	_, ok := m.clearedFields[locationcategory.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *LocationCategoryMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, locationcategory.FieldColor)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *LocationCategoryMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[locationcategory.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *LocationCategoryMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *LocationCategoryMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *LocationCategoryMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *LocationCategoryMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[locationcategory.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *LocationCategoryMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *LocationCategoryMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *LocationCategoryMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the LocationCategoryMutation builder.
func (m *LocationCategoryMutation) Where(ps ...predicate.LocationCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LocationCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LocationCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LocationCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LocationCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LocationCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LocationCategory).
func (m *LocationCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LocationCategoryMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.business_unit != nil {
		fields = append(fields, locationcategory.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, locationcategory.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, locationcategory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, locationcategory.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, locationcategory.FieldVersion)
	}
	if m.name != nil {
		fields = append(fields, locationcategory.FieldName)
	}
	if m.description != nil {
		fields = append(fields, locationcategory.FieldDescription)
	}
	if m.color != nil {
		fields = append(fields, locationcategory.FieldColor)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LocationCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case locationcategory.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case locationcategory.FieldOrganizationID:
		return m.OrganizationID()
	case locationcategory.FieldCreatedAt:
		return m.CreatedAt()
	case locationcategory.FieldUpdatedAt:
		return m.UpdatedAt()
	case locationcategory.FieldVersion:
		return m.Version()
	case locationcategory.FieldName:
		return m.Name()
	case locationcategory.FieldDescription:
		return m.Description()
	case locationcategory.FieldColor:
		return m.Color()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LocationCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case locationcategory.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case locationcategory.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case locationcategory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case locationcategory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case locationcategory.FieldVersion:
		return m.OldVersion(ctx)
	case locationcategory.FieldName:
		return m.OldName(ctx)
	case locationcategory.FieldDescription:
		return m.OldDescription(ctx)
	case locationcategory.FieldColor:
		return m.OldColor(ctx)
	}
	return nil, fmt.Errorf("unknown LocationCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case locationcategory.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case locationcategory.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case locationcategory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case locationcategory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case locationcategory.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case locationcategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case locationcategory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case locationcategory.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	}
	return fmt.Errorf("unknown LocationCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LocationCategoryMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, locationcategory.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LocationCategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case locationcategory.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case locationcategory.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown LocationCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LocationCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(locationcategory.FieldDescription) {
		fields = append(fields, locationcategory.FieldDescription)
	}
	if m.FieldCleared(locationcategory.FieldColor) {
		fields = append(fields, locationcategory.FieldColor)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LocationCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LocationCategoryMutation) ClearField(name string) error {
	switch name {
	case locationcategory.FieldDescription:
		m.ClearDescription()
		return nil
	case locationcategory.FieldColor:
		m.ClearColor()
		return nil
	}
	return fmt.Errorf("unknown LocationCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LocationCategoryMutation) ResetField(name string) error {
	switch name {
	case locationcategory.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case locationcategory.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case locationcategory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case locationcategory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case locationcategory.FieldVersion:
		m.ResetVersion()
		return nil
	case locationcategory.FieldName:
		m.ResetName()
		return nil
	case locationcategory.FieldDescription:
		m.ResetDescription()
		return nil
	case locationcategory.FieldColor:
		m.ResetColor()
		return nil
	}
	return fmt.Errorf("unknown LocationCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LocationCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.business_unit != nil {
		edges = append(edges, locationcategory.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, locationcategory.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LocationCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case locationcategory.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case locationcategory.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LocationCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LocationCategoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LocationCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbusiness_unit {
		edges = append(edges, locationcategory.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, locationcategory.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LocationCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case locationcategory.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case locationcategory.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LocationCategoryMutation) ClearEdge(name string) error {
	switch name {
	case locationcategory.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case locationcategory.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown LocationCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LocationCategoryMutation) ResetEdge(name string) error {
	switch name {
	case locationcategory.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case locationcategory.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown LocationCategory edge %s", name)
}

// LocationCommentMutation represents an operation that mutates the LocationComment nodes in the graph.
type LocationCommentMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	version              *int
	addversion           *int
	comment              *string
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	location             *uuid.UUID
	clearedlocation      bool
	user                 *uuid.UUID
	cleareduser          bool
	comment_type         *uuid.UUID
	clearedcomment_type  bool
	done                 bool
	oldValue             func(context.Context) (*LocationComment, error)
	predicates           []predicate.LocationComment
}

var _ ent.Mutation = (*LocationCommentMutation)(nil)

// locationcommentOption allows management of the mutation configuration using functional options.
type locationcommentOption func(*LocationCommentMutation)

// newLocationCommentMutation creates new mutation for the LocationComment entity.
func newLocationCommentMutation(c config, op Op, opts ...locationcommentOption) *LocationCommentMutation {
	m := &LocationCommentMutation{
		config:        c,
		op:            op,
		typ:           TypeLocationComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLocationCommentID sets the ID field of the mutation.
func withLocationCommentID(id uuid.UUID) locationcommentOption {
	return func(m *LocationCommentMutation) {
		var (
			err   error
			once  sync.Once
			value *LocationComment
		)
		m.oldValue = func(ctx context.Context) (*LocationComment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LocationComment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLocationComment sets the old LocationComment of the mutation.
func withLocationComment(node *LocationComment) locationcommentOption {
	return func(m *LocationCommentMutation) {
		m.oldValue = func(context.Context) (*LocationComment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LocationCommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LocationCommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LocationComment entities.
func (m *LocationCommentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LocationCommentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LocationCommentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LocationComment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *LocationCommentMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *LocationCommentMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the LocationComment entity.
// If the LocationComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationCommentMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *LocationCommentMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *LocationCommentMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *LocationCommentMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the LocationComment entity.
// If the LocationComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationCommentMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *LocationCommentMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *LocationCommentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LocationCommentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LocationComment entity.
// If the LocationComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationCommentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LocationCommentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LocationCommentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LocationCommentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the LocationComment entity.
// If the LocationComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationCommentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LocationCommentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *LocationCommentMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *LocationCommentMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the LocationComment entity.
// If the LocationComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationCommentMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *LocationCommentMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *LocationCommentMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *LocationCommentMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetLocationID sets the "location_id" field.
func (m *LocationCommentMutation) SetLocationID(u uuid.UUID) {
	m.location = &u
}

// LocationID returns the value of the "location_id" field in the mutation.
func (m *LocationCommentMutation) LocationID() (r uuid.UUID, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationID returns the old "location_id" field's value of the LocationComment entity.
// If the LocationComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationCommentMutation) OldLocationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationID: %w", err)
	}
	return oldValue.LocationID, nil
}

// ResetLocationID resets all changes to the "location_id" field.
func (m *LocationCommentMutation) ResetLocationID() {
	m.location = nil
}

// SetUserID sets the "user_id" field.
func (m *LocationCommentMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *LocationCommentMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the LocationComment entity.
// If the LocationComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationCommentMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *LocationCommentMutation) ResetUserID() {
	m.user = nil
}

// SetCommentTypeID sets the "comment_type_id" field.
func (m *LocationCommentMutation) SetCommentTypeID(u uuid.UUID) {
	m.comment_type = &u
}

// CommentTypeID returns the value of the "comment_type_id" field in the mutation.
func (m *LocationCommentMutation) CommentTypeID() (r uuid.UUID, exists bool) {
	v := m.comment_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCommentTypeID returns the old "comment_type_id" field's value of the LocationComment entity.
// If the LocationComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationCommentMutation) OldCommentTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommentTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommentTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommentTypeID: %w", err)
	}
	return oldValue.CommentTypeID, nil
}

// ResetCommentTypeID resets all changes to the "comment_type_id" field.
func (m *LocationCommentMutation) ResetCommentTypeID() {
	m.comment_type = nil
}

// SetComment sets the "comment" field.
func (m *LocationCommentMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *LocationCommentMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the LocationComment entity.
// If the LocationComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationCommentMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ResetComment resets all changes to the "comment" field.
func (m *LocationCommentMutation) ResetComment() {
	m.comment = nil
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *LocationCommentMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[locationcomment.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *LocationCommentMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *LocationCommentMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *LocationCommentMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *LocationCommentMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[locationcomment.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *LocationCommentMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *LocationCommentMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *LocationCommentMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearLocation clears the "location" edge to the Location entity.
func (m *LocationCommentMutation) ClearLocation() {
	m.clearedlocation = true
	m.clearedFields[locationcomment.FieldLocationID] = struct{}{}
}

// LocationCleared reports if the "location" edge to the Location entity was cleared.
func (m *LocationCommentMutation) LocationCleared() bool {
	return m.clearedlocation
}

// LocationIDs returns the "location" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LocationID instead. It exists only for internal usage by the builders.
func (m *LocationCommentMutation) LocationIDs() (ids []uuid.UUID) {
	if id := m.location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocation resets all changes to the "location" edge.
func (m *LocationCommentMutation) ResetLocation() {
	m.location = nil
	m.clearedlocation = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *LocationCommentMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[locationcomment.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *LocationCommentMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *LocationCommentMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *LocationCommentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearCommentType clears the "comment_type" edge to the CommentType entity.
func (m *LocationCommentMutation) ClearCommentType() {
	m.clearedcomment_type = true
	m.clearedFields[locationcomment.FieldCommentTypeID] = struct{}{}
}

// CommentTypeCleared reports if the "comment_type" edge to the CommentType entity was cleared.
func (m *LocationCommentMutation) CommentTypeCleared() bool {
	return m.clearedcomment_type
}

// CommentTypeIDs returns the "comment_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CommentTypeID instead. It exists only for internal usage by the builders.
func (m *LocationCommentMutation) CommentTypeIDs() (ids []uuid.UUID) {
	if id := m.comment_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCommentType resets all changes to the "comment_type" edge.
func (m *LocationCommentMutation) ResetCommentType() {
	m.comment_type = nil
	m.clearedcomment_type = false
}

// Where appends a list predicates to the LocationCommentMutation builder.
func (m *LocationCommentMutation) Where(ps ...predicate.LocationComment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LocationCommentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LocationCommentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LocationComment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LocationCommentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LocationCommentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LocationComment).
func (m *LocationCommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LocationCommentMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.business_unit != nil {
		fields = append(fields, locationcomment.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, locationcomment.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, locationcomment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, locationcomment.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, locationcomment.FieldVersion)
	}
	if m.location != nil {
		fields = append(fields, locationcomment.FieldLocationID)
	}
	if m.user != nil {
		fields = append(fields, locationcomment.FieldUserID)
	}
	if m.comment_type != nil {
		fields = append(fields, locationcomment.FieldCommentTypeID)
	}
	if m.comment != nil {
		fields = append(fields, locationcomment.FieldComment)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LocationCommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case locationcomment.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case locationcomment.FieldOrganizationID:
		return m.OrganizationID()
	case locationcomment.FieldCreatedAt:
		return m.CreatedAt()
	case locationcomment.FieldUpdatedAt:
		return m.UpdatedAt()
	case locationcomment.FieldVersion:
		return m.Version()
	case locationcomment.FieldLocationID:
		return m.LocationID()
	case locationcomment.FieldUserID:
		return m.UserID()
	case locationcomment.FieldCommentTypeID:
		return m.CommentTypeID()
	case locationcomment.FieldComment:
		return m.Comment()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LocationCommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case locationcomment.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case locationcomment.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case locationcomment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case locationcomment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case locationcomment.FieldVersion:
		return m.OldVersion(ctx)
	case locationcomment.FieldLocationID:
		return m.OldLocationID(ctx)
	case locationcomment.FieldUserID:
		return m.OldUserID(ctx)
	case locationcomment.FieldCommentTypeID:
		return m.OldCommentTypeID(ctx)
	case locationcomment.FieldComment:
		return m.OldComment(ctx)
	}
	return nil, fmt.Errorf("unknown LocationComment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationCommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case locationcomment.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case locationcomment.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case locationcomment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case locationcomment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case locationcomment.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case locationcomment.FieldLocationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationID(v)
		return nil
	case locationcomment.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case locationcomment.FieldCommentTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentTypeID(v)
		return nil
	case locationcomment.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	}
	return fmt.Errorf("unknown LocationComment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LocationCommentMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, locationcomment.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LocationCommentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case locationcomment.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationCommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case locationcomment.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown LocationComment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LocationCommentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LocationCommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LocationCommentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LocationComment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LocationCommentMutation) ResetField(name string) error {
	switch name {
	case locationcomment.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case locationcomment.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case locationcomment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case locationcomment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case locationcomment.FieldVersion:
		m.ResetVersion()
		return nil
	case locationcomment.FieldLocationID:
		m.ResetLocationID()
		return nil
	case locationcomment.FieldUserID:
		m.ResetUserID()
		return nil
	case locationcomment.FieldCommentTypeID:
		m.ResetCommentTypeID()
		return nil
	case locationcomment.FieldComment:
		m.ResetComment()
		return nil
	}
	return fmt.Errorf("unknown LocationComment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LocationCommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.business_unit != nil {
		edges = append(edges, locationcomment.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, locationcomment.EdgeOrganization)
	}
	if m.location != nil {
		edges = append(edges, locationcomment.EdgeLocation)
	}
	if m.user != nil {
		edges = append(edges, locationcomment.EdgeUser)
	}
	if m.comment_type != nil {
		edges = append(edges, locationcomment.EdgeCommentType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LocationCommentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case locationcomment.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case locationcomment.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case locationcomment.EdgeLocation:
		if id := m.location; id != nil {
			return []ent.Value{*id}
		}
	case locationcomment.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case locationcomment.EdgeCommentType:
		if id := m.comment_type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LocationCommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LocationCommentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LocationCommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedbusiness_unit {
		edges = append(edges, locationcomment.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, locationcomment.EdgeOrganization)
	}
	if m.clearedlocation {
		edges = append(edges, locationcomment.EdgeLocation)
	}
	if m.cleareduser {
		edges = append(edges, locationcomment.EdgeUser)
	}
	if m.clearedcomment_type {
		edges = append(edges, locationcomment.EdgeCommentType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LocationCommentMutation) EdgeCleared(name string) bool {
	switch name {
	case locationcomment.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case locationcomment.EdgeOrganization:
		return m.clearedorganization
	case locationcomment.EdgeLocation:
		return m.clearedlocation
	case locationcomment.EdgeUser:
		return m.cleareduser
	case locationcomment.EdgeCommentType:
		return m.clearedcomment_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LocationCommentMutation) ClearEdge(name string) error {
	switch name {
	case locationcomment.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case locationcomment.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case locationcomment.EdgeLocation:
		m.ClearLocation()
		return nil
	case locationcomment.EdgeUser:
		m.ClearUser()
		return nil
	case locationcomment.EdgeCommentType:
		m.ClearCommentType()
		return nil
	}
	return fmt.Errorf("unknown LocationComment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LocationCommentMutation) ResetEdge(name string) error {
	switch name {
	case locationcomment.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case locationcomment.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case locationcomment.EdgeLocation:
		m.ResetLocation()
		return nil
	case locationcomment.EdgeUser:
		m.ResetUser()
		return nil
	case locationcomment.EdgeCommentType:
		m.ResetCommentType()
		return nil
	}
	return fmt.Errorf("unknown LocationComment edge %s", name)
}

// LocationContactMutation represents an operation that mutates the LocationContact nodes in the graph.
type LocationContactMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	version              *int
	addversion           *int
	name                 *string
	email_address        *string
	phone_number         *string
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	location             *uuid.UUID
	clearedlocation      bool
	done                 bool
	oldValue             func(context.Context) (*LocationContact, error)
	predicates           []predicate.LocationContact
}

var _ ent.Mutation = (*LocationContactMutation)(nil)

// locationcontactOption allows management of the mutation configuration using functional options.
type locationcontactOption func(*LocationContactMutation)

// newLocationContactMutation creates new mutation for the LocationContact entity.
func newLocationContactMutation(c config, op Op, opts ...locationcontactOption) *LocationContactMutation {
	m := &LocationContactMutation{
		config:        c,
		op:            op,
		typ:           TypeLocationContact,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLocationContactID sets the ID field of the mutation.
func withLocationContactID(id uuid.UUID) locationcontactOption {
	return func(m *LocationContactMutation) {
		var (
			err   error
			once  sync.Once
			value *LocationContact
		)
		m.oldValue = func(ctx context.Context) (*LocationContact, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LocationContact.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLocationContact sets the old LocationContact of the mutation.
func withLocationContact(node *LocationContact) locationcontactOption {
	return func(m *LocationContactMutation) {
		m.oldValue = func(context.Context) (*LocationContact, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LocationContactMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LocationContactMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LocationContact entities.
func (m *LocationContactMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LocationContactMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LocationContactMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LocationContact.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *LocationContactMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *LocationContactMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the LocationContact entity.
// If the LocationContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationContactMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *LocationContactMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *LocationContactMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *LocationContactMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the LocationContact entity.
// If the LocationContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationContactMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *LocationContactMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *LocationContactMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LocationContactMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LocationContact entity.
// If the LocationContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationContactMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LocationContactMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LocationContactMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LocationContactMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the LocationContact entity.
// If the LocationContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationContactMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LocationContactMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *LocationContactMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *LocationContactMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the LocationContact entity.
// If the LocationContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationContactMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *LocationContactMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *LocationContactMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *LocationContactMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetLocationID sets the "location_id" field.
func (m *LocationContactMutation) SetLocationID(u uuid.UUID) {
	m.location = &u
}

// LocationID returns the value of the "location_id" field in the mutation.
func (m *LocationContactMutation) LocationID() (r uuid.UUID, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationID returns the old "location_id" field's value of the LocationContact entity.
// If the LocationContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationContactMutation) OldLocationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationID: %w", err)
	}
	return oldValue.LocationID, nil
}

// ResetLocationID resets all changes to the "location_id" field.
func (m *LocationContactMutation) ResetLocationID() {
	m.location = nil
}

// SetName sets the "name" field.
func (m *LocationContactMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LocationContactMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the LocationContact entity.
// If the LocationContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationContactMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LocationContactMutation) ResetName() {
	m.name = nil
}

// SetEmailAddress sets the "email_address" field.
func (m *LocationContactMutation) SetEmailAddress(s string) {
	m.email_address = &s
}

// EmailAddress returns the value of the "email_address" field in the mutation.
func (m *LocationContactMutation) EmailAddress() (r string, exists bool) {
	v := m.email_address
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailAddress returns the old "email_address" field's value of the LocationContact entity.
// If the LocationContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationContactMutation) OldEmailAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailAddress: %w", err)
	}
	return oldValue.EmailAddress, nil
}

// ClearEmailAddress clears the value of the "email_address" field.
func (m *LocationContactMutation) ClearEmailAddress() {
	m.email_address = nil
	m.clearedFields[locationcontact.FieldEmailAddress] = struct{}{}
}

// EmailAddressCleared returns if the "email_address" field was cleared in this mutation.
func (m *LocationContactMutation) EmailAddressCleared() bool {
	_, ok := m.clearedFields[locationcontact.FieldEmailAddress]
	return ok
}

// ResetEmailAddress resets all changes to the "email_address" field.
func (m *LocationContactMutation) ResetEmailAddress() {
	m.email_address = nil
	delete(m.clearedFields, locationcontact.FieldEmailAddress)
}

// SetPhoneNumber sets the "phone_number" field.
func (m *LocationContactMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *LocationContactMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the LocationContact entity.
// If the LocationContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationContactMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ClearPhoneNumber clears the value of the "phone_number" field.
func (m *LocationContactMutation) ClearPhoneNumber() {
	m.phone_number = nil
	m.clearedFields[locationcontact.FieldPhoneNumber] = struct{}{}
}

// PhoneNumberCleared returns if the "phone_number" field was cleared in this mutation.
func (m *LocationContactMutation) PhoneNumberCleared() bool {
	_, ok := m.clearedFields[locationcontact.FieldPhoneNumber]
	return ok
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *LocationContactMutation) ResetPhoneNumber() {
	m.phone_number = nil
	delete(m.clearedFields, locationcontact.FieldPhoneNumber)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *LocationContactMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[locationcontact.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *LocationContactMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *LocationContactMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *LocationContactMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *LocationContactMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[locationcontact.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *LocationContactMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *LocationContactMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *LocationContactMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearLocation clears the "location" edge to the Location entity.
func (m *LocationContactMutation) ClearLocation() {
	m.clearedlocation = true
	m.clearedFields[locationcontact.FieldLocationID] = struct{}{}
}

// LocationCleared reports if the "location" edge to the Location entity was cleared.
func (m *LocationContactMutation) LocationCleared() bool {
	return m.clearedlocation
}

// LocationIDs returns the "location" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LocationID instead. It exists only for internal usage by the builders.
func (m *LocationContactMutation) LocationIDs() (ids []uuid.UUID) {
	if id := m.location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocation resets all changes to the "location" edge.
func (m *LocationContactMutation) ResetLocation() {
	m.location = nil
	m.clearedlocation = false
}

// Where appends a list predicates to the LocationContactMutation builder.
func (m *LocationContactMutation) Where(ps ...predicate.LocationContact) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LocationContactMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LocationContactMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LocationContact, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LocationContactMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LocationContactMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LocationContact).
func (m *LocationContactMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LocationContactMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.business_unit != nil {
		fields = append(fields, locationcontact.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, locationcontact.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, locationcontact.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, locationcontact.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, locationcontact.FieldVersion)
	}
	if m.location != nil {
		fields = append(fields, locationcontact.FieldLocationID)
	}
	if m.name != nil {
		fields = append(fields, locationcontact.FieldName)
	}
	if m.email_address != nil {
		fields = append(fields, locationcontact.FieldEmailAddress)
	}
	if m.phone_number != nil {
		fields = append(fields, locationcontact.FieldPhoneNumber)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LocationContactMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case locationcontact.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case locationcontact.FieldOrganizationID:
		return m.OrganizationID()
	case locationcontact.FieldCreatedAt:
		return m.CreatedAt()
	case locationcontact.FieldUpdatedAt:
		return m.UpdatedAt()
	case locationcontact.FieldVersion:
		return m.Version()
	case locationcontact.FieldLocationID:
		return m.LocationID()
	case locationcontact.FieldName:
		return m.Name()
	case locationcontact.FieldEmailAddress:
		return m.EmailAddress()
	case locationcontact.FieldPhoneNumber:
		return m.PhoneNumber()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LocationContactMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case locationcontact.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case locationcontact.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case locationcontact.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case locationcontact.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case locationcontact.FieldVersion:
		return m.OldVersion(ctx)
	case locationcontact.FieldLocationID:
		return m.OldLocationID(ctx)
	case locationcontact.FieldName:
		return m.OldName(ctx)
	case locationcontact.FieldEmailAddress:
		return m.OldEmailAddress(ctx)
	case locationcontact.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	}
	return nil, fmt.Errorf("unknown LocationContact field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationContactMutation) SetField(name string, value ent.Value) error {
	switch name {
	case locationcontact.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case locationcontact.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case locationcontact.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case locationcontact.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case locationcontact.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case locationcontact.FieldLocationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationID(v)
		return nil
	case locationcontact.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case locationcontact.FieldEmailAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailAddress(v)
		return nil
	case locationcontact.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	}
	return fmt.Errorf("unknown LocationContact field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LocationContactMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, locationcontact.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LocationContactMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case locationcontact.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationContactMutation) AddField(name string, value ent.Value) error {
	switch name {
	case locationcontact.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown LocationContact numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LocationContactMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(locationcontact.FieldEmailAddress) {
		fields = append(fields, locationcontact.FieldEmailAddress)
	}
	if m.FieldCleared(locationcontact.FieldPhoneNumber) {
		fields = append(fields, locationcontact.FieldPhoneNumber)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LocationContactMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LocationContactMutation) ClearField(name string) error {
	switch name {
	case locationcontact.FieldEmailAddress:
		m.ClearEmailAddress()
		return nil
	case locationcontact.FieldPhoneNumber:
		m.ClearPhoneNumber()
		return nil
	}
	return fmt.Errorf("unknown LocationContact nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LocationContactMutation) ResetField(name string) error {
	switch name {
	case locationcontact.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case locationcontact.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case locationcontact.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case locationcontact.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case locationcontact.FieldVersion:
		m.ResetVersion()
		return nil
	case locationcontact.FieldLocationID:
		m.ResetLocationID()
		return nil
	case locationcontact.FieldName:
		m.ResetName()
		return nil
	case locationcontact.FieldEmailAddress:
		m.ResetEmailAddress()
		return nil
	case locationcontact.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	}
	return fmt.Errorf("unknown LocationContact field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LocationContactMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.business_unit != nil {
		edges = append(edges, locationcontact.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, locationcontact.EdgeOrganization)
	}
	if m.location != nil {
		edges = append(edges, locationcontact.EdgeLocation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LocationContactMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case locationcontact.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case locationcontact.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case locationcontact.EdgeLocation:
		if id := m.location; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LocationContactMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LocationContactMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LocationContactMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbusiness_unit {
		edges = append(edges, locationcontact.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, locationcontact.EdgeOrganization)
	}
	if m.clearedlocation {
		edges = append(edges, locationcontact.EdgeLocation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LocationContactMutation) EdgeCleared(name string) bool {
	switch name {
	case locationcontact.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case locationcontact.EdgeOrganization:
		return m.clearedorganization
	case locationcontact.EdgeLocation:
		return m.clearedlocation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LocationContactMutation) ClearEdge(name string) error {
	switch name {
	case locationcontact.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case locationcontact.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case locationcontact.EdgeLocation:
		m.ClearLocation()
		return nil
	}
	return fmt.Errorf("unknown LocationContact unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LocationContactMutation) ResetEdge(name string) error {
	switch name {
	case locationcontact.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case locationcontact.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case locationcontact.EdgeLocation:
		m.ResetLocation()
		return nil
	}
	return fmt.Errorf("unknown LocationContact edge %s", name)
}

// OrganizationMutation represents an operation that mutates the Organization nodes in the graph.
type OrganizationMutation struct {
	config
	op                               Op
	typ                              string
	id                               *uuid.UUID
	created_at                       *time.Time
	updated_at                       *time.Time
	name                             *string
	scac_code                        *string
	dot_number                       *string
	logo_url                         *string
	org_type                         *organization.OrgType
	timezone                         *string
	clearedFields                    map[string]struct{}
	business_unit                    *uuid.UUID
	clearedbusiness_unit             bool
	organization_feature_flag        map[uuid.UUID]struct{}
	removedorganization_feature_flag map[uuid.UUID]struct{}
	clearedorganization_feature_flag bool
	shipments                        map[uuid.UUID]struct{}
	removedshipments                 map[uuid.UUID]struct{}
	clearedshipments                 bool
	accounting_control               *uuid.UUID
	clearedaccounting_control        bool
	billing_control                  *uuid.UUID
	clearedbilling_control           bool
	dispatch_control                 *uuid.UUID
	cleareddispatch_control          bool
	feasibility_tool_control         *uuid.UUID
	clearedfeasibility_tool_control  bool
	invoice_control                  *uuid.UUID
	clearedinvoice_control           bool
	route_control                    *uuid.UUID
	clearedroute_control             bool
	shipment_control                 *uuid.UUID
	clearedshipment_control          bool
	email_control                    *uuid.UUID
	clearedemail_control             bool
	google_api                       *uuid.UUID
	clearedgoogle_api                bool
	done                             bool
	oldValue                         func(context.Context) (*Organization, error)
	predicates                       []predicate.Organization
}

var _ ent.Mutation = (*OrganizationMutation)(nil)

// organizationOption allows management of the mutation configuration using functional options.
type organizationOption func(*OrganizationMutation)

// newOrganizationMutation creates new mutation for the Organization entity.
func newOrganizationMutation(c config, op Op, opts ...organizationOption) *OrganizationMutation {
	m := &OrganizationMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganization,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationID sets the ID field of the mutation.
func withOrganizationID(id uuid.UUID) organizationOption {
	return func(m *OrganizationMutation) {
		var (
			err   error
			once  sync.Once
			value *Organization
		)
		m.oldValue = func(ctx context.Context) (*Organization, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Organization.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganization sets the old Organization of the mutation.
func withOrganization(node *Organization) organizationOption {
	return func(m *OrganizationMutation) {
		m.oldValue = func(context.Context) (*Organization, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Organization entities.
func (m *OrganizationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Organization.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrganizationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrganizationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrganizationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *OrganizationMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *OrganizationMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *OrganizationMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetName sets the "name" field.
func (m *OrganizationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrganizationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrganizationMutation) ResetName() {
	m.name = nil
}

// SetScacCode sets the "scac_code" field.
func (m *OrganizationMutation) SetScacCode(s string) {
	m.scac_code = &s
}

// ScacCode returns the value of the "scac_code" field in the mutation.
func (m *OrganizationMutation) ScacCode() (r string, exists bool) {
	v := m.scac_code
	if v == nil {
		return
	}
	return *v, true
}

// OldScacCode returns the old "scac_code" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldScacCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScacCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScacCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScacCode: %w", err)
	}
	return oldValue.ScacCode, nil
}

// ResetScacCode resets all changes to the "scac_code" field.
func (m *OrganizationMutation) ResetScacCode() {
	m.scac_code = nil
}

// SetDotNumber sets the "dot_number" field.
func (m *OrganizationMutation) SetDotNumber(s string) {
	m.dot_number = &s
}

// DotNumber returns the value of the "dot_number" field in the mutation.
func (m *OrganizationMutation) DotNumber() (r string, exists bool) {
	v := m.dot_number
	if v == nil {
		return
	}
	return *v, true
}

// OldDotNumber returns the old "dot_number" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldDotNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDotNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDotNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDotNumber: %w", err)
	}
	return oldValue.DotNumber, nil
}

// ResetDotNumber resets all changes to the "dot_number" field.
func (m *OrganizationMutation) ResetDotNumber() {
	m.dot_number = nil
}

// SetLogoURL sets the "logo_url" field.
func (m *OrganizationMutation) SetLogoURL(s string) {
	m.logo_url = &s
}

// LogoURL returns the value of the "logo_url" field in the mutation.
func (m *OrganizationMutation) LogoURL() (r string, exists bool) {
	v := m.logo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldLogoURL returns the old "logo_url" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldLogoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogoURL: %w", err)
	}
	return oldValue.LogoURL, nil
}

// ClearLogoURL clears the value of the "logo_url" field.
func (m *OrganizationMutation) ClearLogoURL() {
	m.logo_url = nil
	m.clearedFields[organization.FieldLogoURL] = struct{}{}
}

// LogoURLCleared returns if the "logo_url" field was cleared in this mutation.
func (m *OrganizationMutation) LogoURLCleared() bool {
	_, ok := m.clearedFields[organization.FieldLogoURL]
	return ok
}

// ResetLogoURL resets all changes to the "logo_url" field.
func (m *OrganizationMutation) ResetLogoURL() {
	m.logo_url = nil
	delete(m.clearedFields, organization.FieldLogoURL)
}

// SetOrgType sets the "org_type" field.
func (m *OrganizationMutation) SetOrgType(ot organization.OrgType) {
	m.org_type = &ot
}

// OrgType returns the value of the "org_type" field in the mutation.
func (m *OrganizationMutation) OrgType() (r organization.OrgType, exists bool) {
	v := m.org_type
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgType returns the old "org_type" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldOrgType(ctx context.Context) (v organization.OrgType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrgType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrgType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgType: %w", err)
	}
	return oldValue.OrgType, nil
}

// ResetOrgType resets all changes to the "org_type" field.
func (m *OrganizationMutation) ResetOrgType() {
	m.org_type = nil
}

// SetTimezone sets the "timezone" field.
func (m *OrganizationMutation) SetTimezone(s string) {
	m.timezone = &s
}

// Timezone returns the value of the "timezone" field in the mutation.
func (m *OrganizationMutation) Timezone() (r string, exists bool) {
	v := m.timezone
	if v == nil {
		return
	}
	return *v, true
}

// OldTimezone returns the old "timezone" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldTimezone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimezone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimezone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimezone: %w", err)
	}
	return oldValue.Timezone, nil
}

// ResetTimezone resets all changes to the "timezone" field.
func (m *OrganizationMutation) ResetTimezone() {
	m.timezone = nil
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *OrganizationMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[organization.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *OrganizationMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *OrganizationMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// AddOrganizationFeatureFlagIDs adds the "organization_feature_flag" edge to the OrganizationFeatureFlag entity by ids.
func (m *OrganizationMutation) AddOrganizationFeatureFlagIDs(ids ...uuid.UUID) {
	if m.organization_feature_flag == nil {
		m.organization_feature_flag = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.organization_feature_flag[ids[i]] = struct{}{}
	}
}

// ClearOrganizationFeatureFlag clears the "organization_feature_flag" edge to the OrganizationFeatureFlag entity.
func (m *OrganizationMutation) ClearOrganizationFeatureFlag() {
	m.clearedorganization_feature_flag = true
}

// OrganizationFeatureFlagCleared reports if the "organization_feature_flag" edge to the OrganizationFeatureFlag entity was cleared.
func (m *OrganizationMutation) OrganizationFeatureFlagCleared() bool {
	return m.clearedorganization_feature_flag
}

// RemoveOrganizationFeatureFlagIDs removes the "organization_feature_flag" edge to the OrganizationFeatureFlag entity by IDs.
func (m *OrganizationMutation) RemoveOrganizationFeatureFlagIDs(ids ...uuid.UUID) {
	if m.removedorganization_feature_flag == nil {
		m.removedorganization_feature_flag = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.organization_feature_flag, ids[i])
		m.removedorganization_feature_flag[ids[i]] = struct{}{}
	}
}

// RemovedOrganizationFeatureFlag returns the removed IDs of the "organization_feature_flag" edge to the OrganizationFeatureFlag entity.
func (m *OrganizationMutation) RemovedOrganizationFeatureFlagIDs() (ids []uuid.UUID) {
	for id := range m.removedorganization_feature_flag {
		ids = append(ids, id)
	}
	return
}

// OrganizationFeatureFlagIDs returns the "organization_feature_flag" edge IDs in the mutation.
func (m *OrganizationMutation) OrganizationFeatureFlagIDs() (ids []uuid.UUID) {
	for id := range m.organization_feature_flag {
		ids = append(ids, id)
	}
	return
}

// ResetOrganizationFeatureFlag resets all changes to the "organization_feature_flag" edge.
func (m *OrganizationMutation) ResetOrganizationFeatureFlag() {
	m.organization_feature_flag = nil
	m.clearedorganization_feature_flag = false
	m.removedorganization_feature_flag = nil
}

// AddShipmentIDs adds the "shipments" edge to the Shipment entity by ids.
func (m *OrganizationMutation) AddShipmentIDs(ids ...uuid.UUID) {
	if m.shipments == nil {
		m.shipments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.shipments[ids[i]] = struct{}{}
	}
}

// ClearShipments clears the "shipments" edge to the Shipment entity.
func (m *OrganizationMutation) ClearShipments() {
	m.clearedshipments = true
}

// ShipmentsCleared reports if the "shipments" edge to the Shipment entity was cleared.
func (m *OrganizationMutation) ShipmentsCleared() bool {
	return m.clearedshipments
}

// RemoveShipmentIDs removes the "shipments" edge to the Shipment entity by IDs.
func (m *OrganizationMutation) RemoveShipmentIDs(ids ...uuid.UUID) {
	if m.removedshipments == nil {
		m.removedshipments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.shipments, ids[i])
		m.removedshipments[ids[i]] = struct{}{}
	}
}

// RemovedShipments returns the removed IDs of the "shipments" edge to the Shipment entity.
func (m *OrganizationMutation) RemovedShipmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedshipments {
		ids = append(ids, id)
	}
	return
}

// ShipmentsIDs returns the "shipments" edge IDs in the mutation.
func (m *OrganizationMutation) ShipmentsIDs() (ids []uuid.UUID) {
	for id := range m.shipments {
		ids = append(ids, id)
	}
	return
}

// ResetShipments resets all changes to the "shipments" edge.
func (m *OrganizationMutation) ResetShipments() {
	m.shipments = nil
	m.clearedshipments = false
	m.removedshipments = nil
}

// SetAccountingControlID sets the "accounting_control" edge to the AccountingControl entity by id.
func (m *OrganizationMutation) SetAccountingControlID(id uuid.UUID) {
	m.accounting_control = &id
}

// ClearAccountingControl clears the "accounting_control" edge to the AccountingControl entity.
func (m *OrganizationMutation) ClearAccountingControl() {
	m.clearedaccounting_control = true
}

// AccountingControlCleared reports if the "accounting_control" edge to the AccountingControl entity was cleared.
func (m *OrganizationMutation) AccountingControlCleared() bool {
	return m.clearedaccounting_control
}

// AccountingControlID returns the "accounting_control" edge ID in the mutation.
func (m *OrganizationMutation) AccountingControlID() (id uuid.UUID, exists bool) {
	if m.accounting_control != nil {
		return *m.accounting_control, true
	}
	return
}

// AccountingControlIDs returns the "accounting_control" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountingControlID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) AccountingControlIDs() (ids []uuid.UUID) {
	if id := m.accounting_control; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccountingControl resets all changes to the "accounting_control" edge.
func (m *OrganizationMutation) ResetAccountingControl() {
	m.accounting_control = nil
	m.clearedaccounting_control = false
}

// SetBillingControlID sets the "billing_control" edge to the BillingControl entity by id.
func (m *OrganizationMutation) SetBillingControlID(id uuid.UUID) {
	m.billing_control = &id
}

// ClearBillingControl clears the "billing_control" edge to the BillingControl entity.
func (m *OrganizationMutation) ClearBillingControl() {
	m.clearedbilling_control = true
}

// BillingControlCleared reports if the "billing_control" edge to the BillingControl entity was cleared.
func (m *OrganizationMutation) BillingControlCleared() bool {
	return m.clearedbilling_control
}

// BillingControlID returns the "billing_control" edge ID in the mutation.
func (m *OrganizationMutation) BillingControlID() (id uuid.UUID, exists bool) {
	if m.billing_control != nil {
		return *m.billing_control, true
	}
	return
}

// BillingControlIDs returns the "billing_control" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BillingControlID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) BillingControlIDs() (ids []uuid.UUID) {
	if id := m.billing_control; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBillingControl resets all changes to the "billing_control" edge.
func (m *OrganizationMutation) ResetBillingControl() {
	m.billing_control = nil
	m.clearedbilling_control = false
}

// SetDispatchControlID sets the "dispatch_control" edge to the DispatchControl entity by id.
func (m *OrganizationMutation) SetDispatchControlID(id uuid.UUID) {
	m.dispatch_control = &id
}

// ClearDispatchControl clears the "dispatch_control" edge to the DispatchControl entity.
func (m *OrganizationMutation) ClearDispatchControl() {
	m.cleareddispatch_control = true
}

// DispatchControlCleared reports if the "dispatch_control" edge to the DispatchControl entity was cleared.
func (m *OrganizationMutation) DispatchControlCleared() bool {
	return m.cleareddispatch_control
}

// DispatchControlID returns the "dispatch_control" edge ID in the mutation.
func (m *OrganizationMutation) DispatchControlID() (id uuid.UUID, exists bool) {
	if m.dispatch_control != nil {
		return *m.dispatch_control, true
	}
	return
}

// DispatchControlIDs returns the "dispatch_control" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DispatchControlID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) DispatchControlIDs() (ids []uuid.UUID) {
	if id := m.dispatch_control; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDispatchControl resets all changes to the "dispatch_control" edge.
func (m *OrganizationMutation) ResetDispatchControl() {
	m.dispatch_control = nil
	m.cleareddispatch_control = false
}

// SetFeasibilityToolControlID sets the "feasibility_tool_control" edge to the FeasibilityToolControl entity by id.
func (m *OrganizationMutation) SetFeasibilityToolControlID(id uuid.UUID) {
	m.feasibility_tool_control = &id
}

// ClearFeasibilityToolControl clears the "feasibility_tool_control" edge to the FeasibilityToolControl entity.
func (m *OrganizationMutation) ClearFeasibilityToolControl() {
	m.clearedfeasibility_tool_control = true
}

// FeasibilityToolControlCleared reports if the "feasibility_tool_control" edge to the FeasibilityToolControl entity was cleared.
func (m *OrganizationMutation) FeasibilityToolControlCleared() bool {
	return m.clearedfeasibility_tool_control
}

// FeasibilityToolControlID returns the "feasibility_tool_control" edge ID in the mutation.
func (m *OrganizationMutation) FeasibilityToolControlID() (id uuid.UUID, exists bool) {
	if m.feasibility_tool_control != nil {
		return *m.feasibility_tool_control, true
	}
	return
}

// FeasibilityToolControlIDs returns the "feasibility_tool_control" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FeasibilityToolControlID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) FeasibilityToolControlIDs() (ids []uuid.UUID) {
	if id := m.feasibility_tool_control; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFeasibilityToolControl resets all changes to the "feasibility_tool_control" edge.
func (m *OrganizationMutation) ResetFeasibilityToolControl() {
	m.feasibility_tool_control = nil
	m.clearedfeasibility_tool_control = false
}

// SetInvoiceControlID sets the "invoice_control" edge to the InvoiceControl entity by id.
func (m *OrganizationMutation) SetInvoiceControlID(id uuid.UUID) {
	m.invoice_control = &id
}

// ClearInvoiceControl clears the "invoice_control" edge to the InvoiceControl entity.
func (m *OrganizationMutation) ClearInvoiceControl() {
	m.clearedinvoice_control = true
}

// InvoiceControlCleared reports if the "invoice_control" edge to the InvoiceControl entity was cleared.
func (m *OrganizationMutation) InvoiceControlCleared() bool {
	return m.clearedinvoice_control
}

// InvoiceControlID returns the "invoice_control" edge ID in the mutation.
func (m *OrganizationMutation) InvoiceControlID() (id uuid.UUID, exists bool) {
	if m.invoice_control != nil {
		return *m.invoice_control, true
	}
	return
}

// InvoiceControlIDs returns the "invoice_control" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InvoiceControlID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) InvoiceControlIDs() (ids []uuid.UUID) {
	if id := m.invoice_control; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInvoiceControl resets all changes to the "invoice_control" edge.
func (m *OrganizationMutation) ResetInvoiceControl() {
	m.invoice_control = nil
	m.clearedinvoice_control = false
}

// SetRouteControlID sets the "route_control" edge to the RouteControl entity by id.
func (m *OrganizationMutation) SetRouteControlID(id uuid.UUID) {
	m.route_control = &id
}

// ClearRouteControl clears the "route_control" edge to the RouteControl entity.
func (m *OrganizationMutation) ClearRouteControl() {
	m.clearedroute_control = true
}

// RouteControlCleared reports if the "route_control" edge to the RouteControl entity was cleared.
func (m *OrganizationMutation) RouteControlCleared() bool {
	return m.clearedroute_control
}

// RouteControlID returns the "route_control" edge ID in the mutation.
func (m *OrganizationMutation) RouteControlID() (id uuid.UUID, exists bool) {
	if m.route_control != nil {
		return *m.route_control, true
	}
	return
}

// RouteControlIDs returns the "route_control" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RouteControlID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) RouteControlIDs() (ids []uuid.UUID) {
	if id := m.route_control; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRouteControl resets all changes to the "route_control" edge.
func (m *OrganizationMutation) ResetRouteControl() {
	m.route_control = nil
	m.clearedroute_control = false
}

// SetShipmentControlID sets the "shipment_control" edge to the ShipmentControl entity by id.
func (m *OrganizationMutation) SetShipmentControlID(id uuid.UUID) {
	m.shipment_control = &id
}

// ClearShipmentControl clears the "shipment_control" edge to the ShipmentControl entity.
func (m *OrganizationMutation) ClearShipmentControl() {
	m.clearedshipment_control = true
}

// ShipmentControlCleared reports if the "shipment_control" edge to the ShipmentControl entity was cleared.
func (m *OrganizationMutation) ShipmentControlCleared() bool {
	return m.clearedshipment_control
}

// ShipmentControlID returns the "shipment_control" edge ID in the mutation.
func (m *OrganizationMutation) ShipmentControlID() (id uuid.UUID, exists bool) {
	if m.shipment_control != nil {
		return *m.shipment_control, true
	}
	return
}

// ShipmentControlIDs returns the "shipment_control" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentControlID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) ShipmentControlIDs() (ids []uuid.UUID) {
	if id := m.shipment_control; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipmentControl resets all changes to the "shipment_control" edge.
func (m *OrganizationMutation) ResetShipmentControl() {
	m.shipment_control = nil
	m.clearedshipment_control = false
}

// SetEmailControlID sets the "email_control" edge to the EmailControl entity by id.
func (m *OrganizationMutation) SetEmailControlID(id uuid.UUID) {
	m.email_control = &id
}

// ClearEmailControl clears the "email_control" edge to the EmailControl entity.
func (m *OrganizationMutation) ClearEmailControl() {
	m.clearedemail_control = true
}

// EmailControlCleared reports if the "email_control" edge to the EmailControl entity was cleared.
func (m *OrganizationMutation) EmailControlCleared() bool {
	return m.clearedemail_control
}

// EmailControlID returns the "email_control" edge ID in the mutation.
func (m *OrganizationMutation) EmailControlID() (id uuid.UUID, exists bool) {
	if m.email_control != nil {
		return *m.email_control, true
	}
	return
}

// EmailControlIDs returns the "email_control" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmailControlID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) EmailControlIDs() (ids []uuid.UUID) {
	if id := m.email_control; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmailControl resets all changes to the "email_control" edge.
func (m *OrganizationMutation) ResetEmailControl() {
	m.email_control = nil
	m.clearedemail_control = false
}

// SetGoogleAPIID sets the "google_api" edge to the GoogleApi entity by id.
func (m *OrganizationMutation) SetGoogleAPIID(id uuid.UUID) {
	m.google_api = &id
}

// ClearGoogleAPI clears the "google_api" edge to the GoogleApi entity.
func (m *OrganizationMutation) ClearGoogleAPI() {
	m.clearedgoogle_api = true
}

// GoogleAPICleared reports if the "google_api" edge to the GoogleApi entity was cleared.
func (m *OrganizationMutation) GoogleAPICleared() bool {
	return m.clearedgoogle_api
}

// GoogleAPIID returns the "google_api" edge ID in the mutation.
func (m *OrganizationMutation) GoogleAPIID() (id uuid.UUID, exists bool) {
	if m.google_api != nil {
		return *m.google_api, true
	}
	return
}

// GoogleAPIIDs returns the "google_api" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GoogleAPIID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) GoogleAPIIDs() (ids []uuid.UUID) {
	if id := m.google_api; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGoogleAPI resets all changes to the "google_api" edge.
func (m *OrganizationMutation) ResetGoogleAPI() {
	m.google_api = nil
	m.clearedgoogle_api = false
}

// Where appends a list predicates to the OrganizationMutation builder.
func (m *OrganizationMutation) Where(ps ...predicate.Organization) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Organization, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Organization).
func (m *OrganizationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, organization.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, organization.FieldUpdatedAt)
	}
	if m.business_unit != nil {
		fields = append(fields, organization.FieldBusinessUnitID)
	}
	if m.name != nil {
		fields = append(fields, organization.FieldName)
	}
	if m.scac_code != nil {
		fields = append(fields, organization.FieldScacCode)
	}
	if m.dot_number != nil {
		fields = append(fields, organization.FieldDotNumber)
	}
	if m.logo_url != nil {
		fields = append(fields, organization.FieldLogoURL)
	}
	if m.org_type != nil {
		fields = append(fields, organization.FieldOrgType)
	}
	if m.timezone != nil {
		fields = append(fields, organization.FieldTimezone)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organization.FieldCreatedAt:
		return m.CreatedAt()
	case organization.FieldUpdatedAt:
		return m.UpdatedAt()
	case organization.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case organization.FieldName:
		return m.Name()
	case organization.FieldScacCode:
		return m.ScacCode()
	case organization.FieldDotNumber:
		return m.DotNumber()
	case organization.FieldLogoURL:
		return m.LogoURL()
	case organization.FieldOrgType:
		return m.OrgType()
	case organization.FieldTimezone:
		return m.Timezone()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organization.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case organization.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case organization.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case organization.FieldName:
		return m.OldName(ctx)
	case organization.FieldScacCode:
		return m.OldScacCode(ctx)
	case organization.FieldDotNumber:
		return m.OldDotNumber(ctx)
	case organization.FieldLogoURL:
		return m.OldLogoURL(ctx)
	case organization.FieldOrgType:
		return m.OldOrgType(ctx)
	case organization.FieldTimezone:
		return m.OldTimezone(ctx)
	}
	return nil, fmt.Errorf("unknown Organization field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organization.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organization.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case organization.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case organization.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case organization.FieldScacCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScacCode(v)
		return nil
	case organization.FieldDotNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDotNumber(v)
		return nil
	case organization.FieldLogoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogoURL(v)
		return nil
	case organization.FieldOrgType:
		v, ok := value.(organization.OrgType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgType(v)
		return nil
	case organization.FieldTimezone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimezone(v)
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Organization numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organization.FieldLogoURL) {
		fields = append(fields, organization.FieldLogoURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationMutation) ClearField(name string) error {
	switch name {
	case organization.FieldLogoURL:
		m.ClearLogoURL()
		return nil
	}
	return fmt.Errorf("unknown Organization nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationMutation) ResetField(name string) error {
	switch name {
	case organization.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organization.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case organization.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case organization.FieldName:
		m.ResetName()
		return nil
	case organization.FieldScacCode:
		m.ResetScacCode()
		return nil
	case organization.FieldDotNumber:
		m.ResetDotNumber()
		return nil
	case organization.FieldLogoURL:
		m.ResetLogoURL()
		return nil
	case organization.FieldOrgType:
		m.ResetOrgType()
		return nil
	case organization.FieldTimezone:
		m.ResetTimezone()
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationMutation) AddedEdges() []string {
	edges := make([]string, 0, 12)
	if m.business_unit != nil {
		edges = append(edges, organization.EdgeBusinessUnit)
	}
	if m.organization_feature_flag != nil {
		edges = append(edges, organization.EdgeOrganizationFeatureFlag)
	}
	if m.shipments != nil {
		edges = append(edges, organization.EdgeShipments)
	}
	if m.accounting_control != nil {
		edges = append(edges, organization.EdgeAccountingControl)
	}
	if m.billing_control != nil {
		edges = append(edges, organization.EdgeBillingControl)
	}
	if m.dispatch_control != nil {
		edges = append(edges, organization.EdgeDispatchControl)
	}
	if m.feasibility_tool_control != nil {
		edges = append(edges, organization.EdgeFeasibilityToolControl)
	}
	if m.invoice_control != nil {
		edges = append(edges, organization.EdgeInvoiceControl)
	}
	if m.route_control != nil {
		edges = append(edges, organization.EdgeRouteControl)
	}
	if m.shipment_control != nil {
		edges = append(edges, organization.EdgeShipmentControl)
	}
	if m.email_control != nil {
		edges = append(edges, organization.EdgeEmailControl)
	}
	if m.google_api != nil {
		edges = append(edges, organization.EdgeGoogleAPI)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case organization.EdgeOrganizationFeatureFlag:
		ids := make([]ent.Value, 0, len(m.organization_feature_flag))
		for id := range m.organization_feature_flag {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeShipments:
		ids := make([]ent.Value, 0, len(m.shipments))
		for id := range m.shipments {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeAccountingControl:
		if id := m.accounting_control; id != nil {
			return []ent.Value{*id}
		}
	case organization.EdgeBillingControl:
		if id := m.billing_control; id != nil {
			return []ent.Value{*id}
		}
	case organization.EdgeDispatchControl:
		if id := m.dispatch_control; id != nil {
			return []ent.Value{*id}
		}
	case organization.EdgeFeasibilityToolControl:
		if id := m.feasibility_tool_control; id != nil {
			return []ent.Value{*id}
		}
	case organization.EdgeInvoiceControl:
		if id := m.invoice_control; id != nil {
			return []ent.Value{*id}
		}
	case organization.EdgeRouteControl:
		if id := m.route_control; id != nil {
			return []ent.Value{*id}
		}
	case organization.EdgeShipmentControl:
		if id := m.shipment_control; id != nil {
			return []ent.Value{*id}
		}
	case organization.EdgeEmailControl:
		if id := m.email_control; id != nil {
			return []ent.Value{*id}
		}
	case organization.EdgeGoogleAPI:
		if id := m.google_api; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 12)
	if m.removedorganization_feature_flag != nil {
		edges = append(edges, organization.EdgeOrganizationFeatureFlag)
	}
	if m.removedshipments != nil {
		edges = append(edges, organization.EdgeShipments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeOrganizationFeatureFlag:
		ids := make([]ent.Value, 0, len(m.removedorganization_feature_flag))
		for id := range m.removedorganization_feature_flag {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeShipments:
		ids := make([]ent.Value, 0, len(m.removedshipments))
		for id := range m.removedshipments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 12)
	if m.clearedbusiness_unit {
		edges = append(edges, organization.EdgeBusinessUnit)
	}
	if m.clearedorganization_feature_flag {
		edges = append(edges, organization.EdgeOrganizationFeatureFlag)
	}
	if m.clearedshipments {
		edges = append(edges, organization.EdgeShipments)
	}
	if m.clearedaccounting_control {
		edges = append(edges, organization.EdgeAccountingControl)
	}
	if m.clearedbilling_control {
		edges = append(edges, organization.EdgeBillingControl)
	}
	if m.cleareddispatch_control {
		edges = append(edges, organization.EdgeDispatchControl)
	}
	if m.clearedfeasibility_tool_control {
		edges = append(edges, organization.EdgeFeasibilityToolControl)
	}
	if m.clearedinvoice_control {
		edges = append(edges, organization.EdgeInvoiceControl)
	}
	if m.clearedroute_control {
		edges = append(edges, organization.EdgeRouteControl)
	}
	if m.clearedshipment_control {
		edges = append(edges, organization.EdgeShipmentControl)
	}
	if m.clearedemail_control {
		edges = append(edges, organization.EdgeEmailControl)
	}
	if m.clearedgoogle_api {
		edges = append(edges, organization.EdgeGoogleAPI)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationMutation) EdgeCleared(name string) bool {
	switch name {
	case organization.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case organization.EdgeOrganizationFeatureFlag:
		return m.clearedorganization_feature_flag
	case organization.EdgeShipments:
		return m.clearedshipments
	case organization.EdgeAccountingControl:
		return m.clearedaccounting_control
	case organization.EdgeBillingControl:
		return m.clearedbilling_control
	case organization.EdgeDispatchControl:
		return m.cleareddispatch_control
	case organization.EdgeFeasibilityToolControl:
		return m.clearedfeasibility_tool_control
	case organization.EdgeInvoiceControl:
		return m.clearedinvoice_control
	case organization.EdgeRouteControl:
		return m.clearedroute_control
	case organization.EdgeShipmentControl:
		return m.clearedshipment_control
	case organization.EdgeEmailControl:
		return m.clearedemail_control
	case organization.EdgeGoogleAPI:
		return m.clearedgoogle_api
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationMutation) ClearEdge(name string) error {
	switch name {
	case organization.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case organization.EdgeAccountingControl:
		m.ClearAccountingControl()
		return nil
	case organization.EdgeBillingControl:
		m.ClearBillingControl()
		return nil
	case organization.EdgeDispatchControl:
		m.ClearDispatchControl()
		return nil
	case organization.EdgeFeasibilityToolControl:
		m.ClearFeasibilityToolControl()
		return nil
	case organization.EdgeInvoiceControl:
		m.ClearInvoiceControl()
		return nil
	case organization.EdgeRouteControl:
		m.ClearRouteControl()
		return nil
	case organization.EdgeShipmentControl:
		m.ClearShipmentControl()
		return nil
	case organization.EdgeEmailControl:
		m.ClearEmailControl()
		return nil
	case organization.EdgeGoogleAPI:
		m.ClearGoogleAPI()
		return nil
	}
	return fmt.Errorf("unknown Organization unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationMutation) ResetEdge(name string) error {
	switch name {
	case organization.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case organization.EdgeOrganizationFeatureFlag:
		m.ResetOrganizationFeatureFlag()
		return nil
	case organization.EdgeShipments:
		m.ResetShipments()
		return nil
	case organization.EdgeAccountingControl:
		m.ResetAccountingControl()
		return nil
	case organization.EdgeBillingControl:
		m.ResetBillingControl()
		return nil
	case organization.EdgeDispatchControl:
		m.ResetDispatchControl()
		return nil
	case organization.EdgeFeasibilityToolControl:
		m.ResetFeasibilityToolControl()
		return nil
	case organization.EdgeInvoiceControl:
		m.ResetInvoiceControl()
		return nil
	case organization.EdgeRouteControl:
		m.ResetRouteControl()
		return nil
	case organization.EdgeShipmentControl:
		m.ResetShipmentControl()
		return nil
	case organization.EdgeEmailControl:
		m.ResetEmailControl()
		return nil
	case organization.EdgeGoogleAPI:
		m.ResetGoogleAPI()
		return nil
	}
	return fmt.Errorf("unknown Organization edge %s", name)
}

// OrganizationFeatureFlagMutation represents an operation that mutates the OrganizationFeatureFlag nodes in the graph.
type OrganizationFeatureFlagMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	created_at          *time.Time
	updated_at          *time.Time
	is_enabled          *bool
	clearedFields       map[string]struct{}
	feature_flag        *uuid.UUID
	clearedfeature_flag bool
	organization        *uuid.UUID
	clearedorganization bool
	done                bool
	oldValue            func(context.Context) (*OrganizationFeatureFlag, error)
	predicates          []predicate.OrganizationFeatureFlag
}

var _ ent.Mutation = (*OrganizationFeatureFlagMutation)(nil)

// organizationfeatureflagOption allows management of the mutation configuration using functional options.
type organizationfeatureflagOption func(*OrganizationFeatureFlagMutation)

// newOrganizationFeatureFlagMutation creates new mutation for the OrganizationFeatureFlag entity.
func newOrganizationFeatureFlagMutation(c config, op Op, opts ...organizationfeatureflagOption) *OrganizationFeatureFlagMutation {
	m := &OrganizationFeatureFlagMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganizationFeatureFlag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationFeatureFlagID sets the ID field of the mutation.
func withOrganizationFeatureFlagID(id uuid.UUID) organizationfeatureflagOption {
	return func(m *OrganizationFeatureFlagMutation) {
		var (
			err   error
			once  sync.Once
			value *OrganizationFeatureFlag
		)
		m.oldValue = func(ctx context.Context) (*OrganizationFeatureFlag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrganizationFeatureFlag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganizationFeatureFlag sets the old OrganizationFeatureFlag of the mutation.
func withOrganizationFeatureFlag(node *OrganizationFeatureFlag) organizationfeatureflagOption {
	return func(m *OrganizationFeatureFlagMutation) {
		m.oldValue = func(context.Context) (*OrganizationFeatureFlag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationFeatureFlagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationFeatureFlagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrganizationFeatureFlag entities.
func (m *OrganizationFeatureFlagMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationFeatureFlagMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationFeatureFlagMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrganizationFeatureFlag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationFeatureFlagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationFeatureFlagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrganizationFeatureFlag entity.
// If the OrganizationFeatureFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationFeatureFlagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationFeatureFlagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrganizationFeatureFlagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrganizationFeatureFlagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrganizationFeatureFlag entity.
// If the OrganizationFeatureFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationFeatureFlagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrganizationFeatureFlagMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *OrganizationFeatureFlagMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *OrganizationFeatureFlagMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the OrganizationFeatureFlag entity.
// If the OrganizationFeatureFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationFeatureFlagMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *OrganizationFeatureFlagMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetFeatureFlagID sets the "feature_flag_id" field.
func (m *OrganizationFeatureFlagMutation) SetFeatureFlagID(u uuid.UUID) {
	m.feature_flag = &u
}

// FeatureFlagID returns the value of the "feature_flag_id" field in the mutation.
func (m *OrganizationFeatureFlagMutation) FeatureFlagID() (r uuid.UUID, exists bool) {
	v := m.feature_flag
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatureFlagID returns the old "feature_flag_id" field's value of the OrganizationFeatureFlag entity.
// If the OrganizationFeatureFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationFeatureFlagMutation) OldFeatureFlagID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatureFlagID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatureFlagID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatureFlagID: %w", err)
	}
	return oldValue.FeatureFlagID, nil
}

// ResetFeatureFlagID resets all changes to the "feature_flag_id" field.
func (m *OrganizationFeatureFlagMutation) ResetFeatureFlagID() {
	m.feature_flag = nil
}

// SetIsEnabled sets the "is_enabled" field.
func (m *OrganizationFeatureFlagMutation) SetIsEnabled(b bool) {
	m.is_enabled = &b
}

// IsEnabled returns the value of the "is_enabled" field in the mutation.
func (m *OrganizationFeatureFlagMutation) IsEnabled() (r bool, exists bool) {
	v := m.is_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsEnabled returns the old "is_enabled" field's value of the OrganizationFeatureFlag entity.
// If the OrganizationFeatureFlag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationFeatureFlagMutation) OldIsEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsEnabled: %w", err)
	}
	return oldValue.IsEnabled, nil
}

// ResetIsEnabled resets all changes to the "is_enabled" field.
func (m *OrganizationFeatureFlagMutation) ResetIsEnabled() {
	m.is_enabled = nil
}

// ClearFeatureFlag clears the "feature_flag" edge to the FeatureFlag entity.
func (m *OrganizationFeatureFlagMutation) ClearFeatureFlag() {
	m.clearedfeature_flag = true
	m.clearedFields[organizationfeatureflag.FieldFeatureFlagID] = struct{}{}
}

// FeatureFlagCleared reports if the "feature_flag" edge to the FeatureFlag entity was cleared.
func (m *OrganizationFeatureFlagMutation) FeatureFlagCleared() bool {
	return m.clearedfeature_flag
}

// FeatureFlagIDs returns the "feature_flag" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FeatureFlagID instead. It exists only for internal usage by the builders.
func (m *OrganizationFeatureFlagMutation) FeatureFlagIDs() (ids []uuid.UUID) {
	if id := m.feature_flag; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFeatureFlag resets all changes to the "feature_flag" edge.
func (m *OrganizationFeatureFlagMutation) ResetFeatureFlag() {
	m.feature_flag = nil
	m.clearedfeature_flag = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *OrganizationFeatureFlagMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[organizationfeatureflag.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *OrganizationFeatureFlagMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *OrganizationFeatureFlagMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *OrganizationFeatureFlagMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the OrganizationFeatureFlagMutation builder.
func (m *OrganizationFeatureFlagMutation) Where(ps ...predicate.OrganizationFeatureFlag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationFeatureFlagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationFeatureFlagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrganizationFeatureFlag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationFeatureFlagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationFeatureFlagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrganizationFeatureFlag).
func (m *OrganizationFeatureFlagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationFeatureFlagMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, organizationfeatureflag.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, organizationfeatureflag.FieldUpdatedAt)
	}
	if m.organization != nil {
		fields = append(fields, organizationfeatureflag.FieldOrganizationID)
	}
	if m.feature_flag != nil {
		fields = append(fields, organizationfeatureflag.FieldFeatureFlagID)
	}
	if m.is_enabled != nil {
		fields = append(fields, organizationfeatureflag.FieldIsEnabled)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationFeatureFlagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organizationfeatureflag.FieldCreatedAt:
		return m.CreatedAt()
	case organizationfeatureflag.FieldUpdatedAt:
		return m.UpdatedAt()
	case organizationfeatureflag.FieldOrganizationID:
		return m.OrganizationID()
	case organizationfeatureflag.FieldFeatureFlagID:
		return m.FeatureFlagID()
	case organizationfeatureflag.FieldIsEnabled:
		return m.IsEnabled()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationFeatureFlagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organizationfeatureflag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case organizationfeatureflag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case organizationfeatureflag.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case organizationfeatureflag.FieldFeatureFlagID:
		return m.OldFeatureFlagID(ctx)
	case organizationfeatureflag.FieldIsEnabled:
		return m.OldIsEnabled(ctx)
	}
	return nil, fmt.Errorf("unknown OrganizationFeatureFlag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationFeatureFlagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organizationfeatureflag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organizationfeatureflag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case organizationfeatureflag.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case organizationfeatureflag.FieldFeatureFlagID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatureFlagID(v)
		return nil
	case organizationfeatureflag.FieldIsEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsEnabled(v)
		return nil
	}
	return fmt.Errorf("unknown OrganizationFeatureFlag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationFeatureFlagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationFeatureFlagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationFeatureFlagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OrganizationFeatureFlag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationFeatureFlagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationFeatureFlagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationFeatureFlagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OrganizationFeatureFlag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationFeatureFlagMutation) ResetField(name string) error {
	switch name {
	case organizationfeatureflag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organizationfeatureflag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case organizationfeatureflag.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case organizationfeatureflag.FieldFeatureFlagID:
		m.ResetFeatureFlagID()
		return nil
	case organizationfeatureflag.FieldIsEnabled:
		m.ResetIsEnabled()
		return nil
	}
	return fmt.Errorf("unknown OrganizationFeatureFlag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationFeatureFlagMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.feature_flag != nil {
		edges = append(edges, organizationfeatureflag.EdgeFeatureFlag)
	}
	if m.organization != nil {
		edges = append(edges, organizationfeatureflag.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationFeatureFlagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organizationfeatureflag.EdgeFeatureFlag:
		if id := m.feature_flag; id != nil {
			return []ent.Value{*id}
		}
	case organizationfeatureflag.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationFeatureFlagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationFeatureFlagMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationFeatureFlagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfeature_flag {
		edges = append(edges, organizationfeatureflag.EdgeFeatureFlag)
	}
	if m.clearedorganization {
		edges = append(edges, organizationfeatureflag.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationFeatureFlagMutation) EdgeCleared(name string) bool {
	switch name {
	case organizationfeatureflag.EdgeFeatureFlag:
		return m.clearedfeature_flag
	case organizationfeatureflag.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationFeatureFlagMutation) ClearEdge(name string) error {
	switch name {
	case organizationfeatureflag.EdgeFeatureFlag:
		m.ClearFeatureFlag()
		return nil
	case organizationfeatureflag.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown OrganizationFeatureFlag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationFeatureFlagMutation) ResetEdge(name string) error {
	switch name {
	case organizationfeatureflag.EdgeFeatureFlag:
		m.ResetFeatureFlag()
		return nil
	case organizationfeatureflag.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown OrganizationFeatureFlag edge %s", name)
}

// PermissionMutation represents an operation that mutates the Permission nodes in the graph.
type PermissionMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	version              *int
	addversion           *int
	codename             *string
	action               *string
	label                *string
	read_description     *string
	write_description    *string
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	resource             *uuid.UUID
	clearedresource      bool
	roles                map[uuid.UUID]struct{}
	removedroles         map[uuid.UUID]struct{}
	clearedroles         bool
	done                 bool
	oldValue             func(context.Context) (*Permission, error)
	predicates           []predicate.Permission
}

var _ ent.Mutation = (*PermissionMutation)(nil)

// permissionOption allows management of the mutation configuration using functional options.
type permissionOption func(*PermissionMutation)

// newPermissionMutation creates new mutation for the Permission entity.
func newPermissionMutation(c config, op Op, opts ...permissionOption) *PermissionMutation {
	m := &PermissionMutation{
		config:        c,
		op:            op,
		typ:           TypePermission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPermissionID sets the ID field of the mutation.
func withPermissionID(id uuid.UUID) permissionOption {
	return func(m *PermissionMutation) {
		var (
			err   error
			once  sync.Once
			value *Permission
		)
		m.oldValue = func(ctx context.Context) (*Permission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Permission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPermission sets the old Permission of the mutation.
func withPermission(node *Permission) permissionOption {
	return func(m *PermissionMutation) {
		m.oldValue = func(context.Context) (*Permission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PermissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PermissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Permission entities.
func (m *PermissionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PermissionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PermissionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Permission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *PermissionMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *PermissionMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *PermissionMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *PermissionMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *PermissionMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *PermissionMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PermissionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PermissionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PermissionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PermissionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PermissionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PermissionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *PermissionMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *PermissionMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *PermissionMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *PermissionMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *PermissionMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetCodename sets the "codename" field.
func (m *PermissionMutation) SetCodename(s string) {
	m.codename = &s
}

// Codename returns the value of the "codename" field in the mutation.
func (m *PermissionMutation) Codename() (r string, exists bool) {
	v := m.codename
	if v == nil {
		return
	}
	return *v, true
}

// OldCodename returns the old "codename" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldCodename(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodename is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodename requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodename: %w", err)
	}
	return oldValue.Codename, nil
}

// ResetCodename resets all changes to the "codename" field.
func (m *PermissionMutation) ResetCodename() {
	m.codename = nil
}

// SetAction sets the "action" field.
func (m *PermissionMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *PermissionMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldAction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ClearAction clears the value of the "action" field.
func (m *PermissionMutation) ClearAction() {
	m.action = nil
	m.clearedFields[permission.FieldAction] = struct{}{}
}

// ActionCleared returns if the "action" field was cleared in this mutation.
func (m *PermissionMutation) ActionCleared() bool {
	_, ok := m.clearedFields[permission.FieldAction]
	return ok
}

// ResetAction resets all changes to the "action" field.
func (m *PermissionMutation) ResetAction() {
	m.action = nil
	delete(m.clearedFields, permission.FieldAction)
}

// SetLabel sets the "label" field.
func (m *PermissionMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *PermissionMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ClearLabel clears the value of the "label" field.
func (m *PermissionMutation) ClearLabel() {
	m.label = nil
	m.clearedFields[permission.FieldLabel] = struct{}{}
}

// LabelCleared returns if the "label" field was cleared in this mutation.
func (m *PermissionMutation) LabelCleared() bool {
	_, ok := m.clearedFields[permission.FieldLabel]
	return ok
}

// ResetLabel resets all changes to the "label" field.
func (m *PermissionMutation) ResetLabel() {
	m.label = nil
	delete(m.clearedFields, permission.FieldLabel)
}

// SetReadDescription sets the "read_description" field.
func (m *PermissionMutation) SetReadDescription(s string) {
	m.read_description = &s
}

// ReadDescription returns the value of the "read_description" field in the mutation.
func (m *PermissionMutation) ReadDescription() (r string, exists bool) {
	v := m.read_description
	if v == nil {
		return
	}
	return *v, true
}

// OldReadDescription returns the old "read_description" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldReadDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReadDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReadDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReadDescription: %w", err)
	}
	return oldValue.ReadDescription, nil
}

// ClearReadDescription clears the value of the "read_description" field.
func (m *PermissionMutation) ClearReadDescription() {
	m.read_description = nil
	m.clearedFields[permission.FieldReadDescription] = struct{}{}
}

// ReadDescriptionCleared returns if the "read_description" field was cleared in this mutation.
func (m *PermissionMutation) ReadDescriptionCleared() bool {
	_, ok := m.clearedFields[permission.FieldReadDescription]
	return ok
}

// ResetReadDescription resets all changes to the "read_description" field.
func (m *PermissionMutation) ResetReadDescription() {
	m.read_description = nil
	delete(m.clearedFields, permission.FieldReadDescription)
}

// SetWriteDescription sets the "write_description" field.
func (m *PermissionMutation) SetWriteDescription(s string) {
	m.write_description = &s
}

// WriteDescription returns the value of the "write_description" field in the mutation.
func (m *PermissionMutation) WriteDescription() (r string, exists bool) {
	v := m.write_description
	if v == nil {
		return
	}
	return *v, true
}

// OldWriteDescription returns the old "write_description" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldWriteDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWriteDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWriteDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWriteDescription: %w", err)
	}
	return oldValue.WriteDescription, nil
}

// ClearWriteDescription clears the value of the "write_description" field.
func (m *PermissionMutation) ClearWriteDescription() {
	m.write_description = nil
	m.clearedFields[permission.FieldWriteDescription] = struct{}{}
}

// WriteDescriptionCleared returns if the "write_description" field was cleared in this mutation.
func (m *PermissionMutation) WriteDescriptionCleared() bool {
	_, ok := m.clearedFields[permission.FieldWriteDescription]
	return ok
}

// ResetWriteDescription resets all changes to the "write_description" field.
func (m *PermissionMutation) ResetWriteDescription() {
	m.write_description = nil
	delete(m.clearedFields, permission.FieldWriteDescription)
}

// SetResourceID sets the "resource_id" field.
func (m *PermissionMutation) SetResourceID(u uuid.UUID) {
	m.resource = &u
}

// ResourceID returns the value of the "resource_id" field in the mutation.
func (m *PermissionMutation) ResourceID() (r uuid.UUID, exists bool) {
	v := m.resource
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceID returns the old "resource_id" field's value of the Permission entity.
// If the Permission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PermissionMutation) OldResourceID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceID: %w", err)
	}
	return oldValue.ResourceID, nil
}

// ResetResourceID resets all changes to the "resource_id" field.
func (m *PermissionMutation) ResetResourceID() {
	m.resource = nil
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *PermissionMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[permission.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *PermissionMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *PermissionMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *PermissionMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *PermissionMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[permission.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *PermissionMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *PermissionMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *PermissionMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearResource clears the "resource" edge to the Resource entity.
func (m *PermissionMutation) ClearResource() {
	m.clearedresource = true
	m.clearedFields[permission.FieldResourceID] = struct{}{}
}

// ResourceCleared reports if the "resource" edge to the Resource entity was cleared.
func (m *PermissionMutation) ResourceCleared() bool {
	return m.clearedresource
}

// ResourceIDs returns the "resource" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ResourceID instead. It exists only for internal usage by the builders.
func (m *PermissionMutation) ResourceIDs() (ids []uuid.UUID) {
	if id := m.resource; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResource resets all changes to the "resource" edge.
func (m *PermissionMutation) ResetResource() {
	m.resource = nil
	m.clearedresource = false
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *PermissionMutation) AddRoleIDs(ids ...uuid.UUID) {
	if m.roles == nil {
		m.roles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *PermissionMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *PermissionMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *PermissionMutation) RemoveRoleIDs(ids ...uuid.UUID) {
	if m.removedroles == nil {
		m.removedroles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *PermissionMutation) RemovedRolesIDs() (ids []uuid.UUID) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *PermissionMutation) RolesIDs() (ids []uuid.UUID) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *PermissionMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// Where appends a list predicates to the PermissionMutation builder.
func (m *PermissionMutation) Where(ps ...predicate.Permission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PermissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PermissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Permission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PermissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PermissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Permission).
func (m *PermissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PermissionMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.business_unit != nil {
		fields = append(fields, permission.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, permission.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, permission.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, permission.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, permission.FieldVersion)
	}
	if m.codename != nil {
		fields = append(fields, permission.FieldCodename)
	}
	if m.action != nil {
		fields = append(fields, permission.FieldAction)
	}
	if m.label != nil {
		fields = append(fields, permission.FieldLabel)
	}
	if m.read_description != nil {
		fields = append(fields, permission.FieldReadDescription)
	}
	if m.write_description != nil {
		fields = append(fields, permission.FieldWriteDescription)
	}
	if m.resource != nil {
		fields = append(fields, permission.FieldResourceID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PermissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case permission.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case permission.FieldOrganizationID:
		return m.OrganizationID()
	case permission.FieldCreatedAt:
		return m.CreatedAt()
	case permission.FieldUpdatedAt:
		return m.UpdatedAt()
	case permission.FieldVersion:
		return m.Version()
	case permission.FieldCodename:
		return m.Codename()
	case permission.FieldAction:
		return m.Action()
	case permission.FieldLabel:
		return m.Label()
	case permission.FieldReadDescription:
		return m.ReadDescription()
	case permission.FieldWriteDescription:
		return m.WriteDescription()
	case permission.FieldResourceID:
		return m.ResourceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PermissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case permission.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case permission.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case permission.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case permission.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case permission.FieldVersion:
		return m.OldVersion(ctx)
	case permission.FieldCodename:
		return m.OldCodename(ctx)
	case permission.FieldAction:
		return m.OldAction(ctx)
	case permission.FieldLabel:
		return m.OldLabel(ctx)
	case permission.FieldReadDescription:
		return m.OldReadDescription(ctx)
	case permission.FieldWriteDescription:
		return m.OldWriteDescription(ctx)
	case permission.FieldResourceID:
		return m.OldResourceID(ctx)
	}
	return nil, fmt.Errorf("unknown Permission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case permission.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case permission.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case permission.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case permission.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case permission.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case permission.FieldCodename:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodename(v)
		return nil
	case permission.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case permission.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case permission.FieldReadDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReadDescription(v)
		return nil
	case permission.FieldWriteDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWriteDescription(v)
		return nil
	case permission.FieldResourceID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceID(v)
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PermissionMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, permission.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PermissionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case permission.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PermissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case permission.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Permission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PermissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(permission.FieldAction) {
		fields = append(fields, permission.FieldAction)
	}
	if m.FieldCleared(permission.FieldLabel) {
		fields = append(fields, permission.FieldLabel)
	}
	if m.FieldCleared(permission.FieldReadDescription) {
		fields = append(fields, permission.FieldReadDescription)
	}
	if m.FieldCleared(permission.FieldWriteDescription) {
		fields = append(fields, permission.FieldWriteDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PermissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PermissionMutation) ClearField(name string) error {
	switch name {
	case permission.FieldAction:
		m.ClearAction()
		return nil
	case permission.FieldLabel:
		m.ClearLabel()
		return nil
	case permission.FieldReadDescription:
		m.ClearReadDescription()
		return nil
	case permission.FieldWriteDescription:
		m.ClearWriteDescription()
		return nil
	}
	return fmt.Errorf("unknown Permission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PermissionMutation) ResetField(name string) error {
	switch name {
	case permission.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case permission.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case permission.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case permission.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case permission.FieldVersion:
		m.ResetVersion()
		return nil
	case permission.FieldCodename:
		m.ResetCodename()
		return nil
	case permission.FieldAction:
		m.ResetAction()
		return nil
	case permission.FieldLabel:
		m.ResetLabel()
		return nil
	case permission.FieldReadDescription:
		m.ResetReadDescription()
		return nil
	case permission.FieldWriteDescription:
		m.ResetWriteDescription()
		return nil
	case permission.FieldResourceID:
		m.ResetResourceID()
		return nil
	}
	return fmt.Errorf("unknown Permission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PermissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.business_unit != nil {
		edges = append(edges, permission.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, permission.EdgeOrganization)
	}
	if m.resource != nil {
		edges = append(edges, permission.EdgeResource)
	}
	if m.roles != nil {
		edges = append(edges, permission.EdgeRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PermissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case permission.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case permission.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case permission.EdgeResource:
		if id := m.resource; id != nil {
			return []ent.Value{*id}
		}
	case permission.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PermissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedroles != nil {
		edges = append(edges, permission.EdgeRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PermissionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case permission.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PermissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedbusiness_unit {
		edges = append(edges, permission.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, permission.EdgeOrganization)
	}
	if m.clearedresource {
		edges = append(edges, permission.EdgeResource)
	}
	if m.clearedroles {
		edges = append(edges, permission.EdgeRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PermissionMutation) EdgeCleared(name string) bool {
	switch name {
	case permission.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case permission.EdgeOrganization:
		return m.clearedorganization
	case permission.EdgeResource:
		return m.clearedresource
	case permission.EdgeRoles:
		return m.clearedroles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PermissionMutation) ClearEdge(name string) error {
	switch name {
	case permission.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case permission.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case permission.EdgeResource:
		m.ClearResource()
		return nil
	}
	return fmt.Errorf("unknown Permission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PermissionMutation) ResetEdge(name string) error {
	switch name {
	case permission.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case permission.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case permission.EdgeResource:
		m.ResetResource()
		return nil
	case permission.EdgeRoles:
		m.ResetRoles()
		return nil
	}
	return fmt.Errorf("unknown Permission edge %s", name)
}

// QualifierCodeMutation represents an operation that mutates the QualifierCode nodes in the graph.
type QualifierCodeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	version              *int
	addversion           *int
	status               *qualifiercode.Status
	code                 *string
	description          *string
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	done                 bool
	oldValue             func(context.Context) (*QualifierCode, error)
	predicates           []predicate.QualifierCode
}

var _ ent.Mutation = (*QualifierCodeMutation)(nil)

// qualifiercodeOption allows management of the mutation configuration using functional options.
type qualifiercodeOption func(*QualifierCodeMutation)

// newQualifierCodeMutation creates new mutation for the QualifierCode entity.
func newQualifierCodeMutation(c config, op Op, opts ...qualifiercodeOption) *QualifierCodeMutation {
	m := &QualifierCodeMutation{
		config:        c,
		op:            op,
		typ:           TypeQualifierCode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withQualifierCodeID sets the ID field of the mutation.
func withQualifierCodeID(id uuid.UUID) qualifiercodeOption {
	return func(m *QualifierCodeMutation) {
		var (
			err   error
			once  sync.Once
			value *QualifierCode
		)
		m.oldValue = func(ctx context.Context) (*QualifierCode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().QualifierCode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withQualifierCode sets the old QualifierCode of the mutation.
func withQualifierCode(node *QualifierCode) qualifiercodeOption {
	return func(m *QualifierCodeMutation) {
		m.oldValue = func(context.Context) (*QualifierCode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m QualifierCodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m QualifierCodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of QualifierCode entities.
func (m *QualifierCodeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *QualifierCodeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *QualifierCodeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().QualifierCode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *QualifierCodeMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *QualifierCodeMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the QualifierCode entity.
// If the QualifierCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QualifierCodeMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *QualifierCodeMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *QualifierCodeMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *QualifierCodeMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the QualifierCode entity.
// If the QualifierCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QualifierCodeMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *QualifierCodeMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *QualifierCodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *QualifierCodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the QualifierCode entity.
// If the QualifierCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QualifierCodeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *QualifierCodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *QualifierCodeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *QualifierCodeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the QualifierCode entity.
// If the QualifierCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QualifierCodeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *QualifierCodeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *QualifierCodeMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *QualifierCodeMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the QualifierCode entity.
// If the QualifierCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QualifierCodeMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *QualifierCodeMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *QualifierCodeMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *QualifierCodeMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetStatus sets the "status" field.
func (m *QualifierCodeMutation) SetStatus(q qualifiercode.Status) {
	m.status = &q
}

// Status returns the value of the "status" field in the mutation.
func (m *QualifierCodeMutation) Status() (r qualifiercode.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the QualifierCode entity.
// If the QualifierCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QualifierCodeMutation) OldStatus(ctx context.Context) (v qualifiercode.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *QualifierCodeMutation) ResetStatus() {
	m.status = nil
}

// SetCode sets the "code" field.
func (m *QualifierCodeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *QualifierCodeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the QualifierCode entity.
// If the QualifierCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QualifierCodeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *QualifierCodeMutation) ResetCode() {
	m.code = nil
}

// SetDescription sets the "description" field.
func (m *QualifierCodeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *QualifierCodeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the QualifierCode entity.
// If the QualifierCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QualifierCodeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *QualifierCodeMutation) ResetDescription() {
	m.description = nil
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *QualifierCodeMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[qualifiercode.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *QualifierCodeMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *QualifierCodeMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *QualifierCodeMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *QualifierCodeMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[qualifiercode.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *QualifierCodeMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *QualifierCodeMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *QualifierCodeMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the QualifierCodeMutation builder.
func (m *QualifierCodeMutation) Where(ps ...predicate.QualifierCode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the QualifierCodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *QualifierCodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.QualifierCode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *QualifierCodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *QualifierCodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (QualifierCode).
func (m *QualifierCodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *QualifierCodeMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.business_unit != nil {
		fields = append(fields, qualifiercode.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, qualifiercode.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, qualifiercode.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, qualifiercode.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, qualifiercode.FieldVersion)
	}
	if m.status != nil {
		fields = append(fields, qualifiercode.FieldStatus)
	}
	if m.code != nil {
		fields = append(fields, qualifiercode.FieldCode)
	}
	if m.description != nil {
		fields = append(fields, qualifiercode.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *QualifierCodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case qualifiercode.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case qualifiercode.FieldOrganizationID:
		return m.OrganizationID()
	case qualifiercode.FieldCreatedAt:
		return m.CreatedAt()
	case qualifiercode.FieldUpdatedAt:
		return m.UpdatedAt()
	case qualifiercode.FieldVersion:
		return m.Version()
	case qualifiercode.FieldStatus:
		return m.Status()
	case qualifiercode.FieldCode:
		return m.Code()
	case qualifiercode.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *QualifierCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case qualifiercode.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case qualifiercode.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case qualifiercode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case qualifiercode.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case qualifiercode.FieldVersion:
		return m.OldVersion(ctx)
	case qualifiercode.FieldStatus:
		return m.OldStatus(ctx)
	case qualifiercode.FieldCode:
		return m.OldCode(ctx)
	case qualifiercode.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown QualifierCode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *QualifierCodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case qualifiercode.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case qualifiercode.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case qualifiercode.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case qualifiercode.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case qualifiercode.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case qualifiercode.FieldStatus:
		v, ok := value.(qualifiercode.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case qualifiercode.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case qualifiercode.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown QualifierCode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *QualifierCodeMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, qualifiercode.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *QualifierCodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case qualifiercode.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *QualifierCodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case qualifiercode.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown QualifierCode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *QualifierCodeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *QualifierCodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *QualifierCodeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown QualifierCode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *QualifierCodeMutation) ResetField(name string) error {
	switch name {
	case qualifiercode.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case qualifiercode.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case qualifiercode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case qualifiercode.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case qualifiercode.FieldVersion:
		m.ResetVersion()
		return nil
	case qualifiercode.FieldStatus:
		m.ResetStatus()
		return nil
	case qualifiercode.FieldCode:
		m.ResetCode()
		return nil
	case qualifiercode.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown QualifierCode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *QualifierCodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.business_unit != nil {
		edges = append(edges, qualifiercode.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, qualifiercode.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *QualifierCodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case qualifiercode.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case qualifiercode.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *QualifierCodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *QualifierCodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *QualifierCodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbusiness_unit {
		edges = append(edges, qualifiercode.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, qualifiercode.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *QualifierCodeMutation) EdgeCleared(name string) bool {
	switch name {
	case qualifiercode.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case qualifiercode.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *QualifierCodeMutation) ClearEdge(name string) error {
	switch name {
	case qualifiercode.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case qualifiercode.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown QualifierCode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *QualifierCodeMutation) ResetEdge(name string) error {
	switch name {
	case qualifiercode.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case qualifiercode.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown QualifierCode edge %s", name)
}

// ReasonCodeMutation represents an operation that mutates the ReasonCode nodes in the graph.
type ReasonCodeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	version              *int
	addversion           *int
	status               *reasoncode.Status
	code                 *string
	code_type            *reasoncode.CodeType
	description          *string
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	done                 bool
	oldValue             func(context.Context) (*ReasonCode, error)
	predicates           []predicate.ReasonCode
}

var _ ent.Mutation = (*ReasonCodeMutation)(nil)

// reasoncodeOption allows management of the mutation configuration using functional options.
type reasoncodeOption func(*ReasonCodeMutation)

// newReasonCodeMutation creates new mutation for the ReasonCode entity.
func newReasonCodeMutation(c config, op Op, opts ...reasoncodeOption) *ReasonCodeMutation {
	m := &ReasonCodeMutation{
		config:        c,
		op:            op,
		typ:           TypeReasonCode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReasonCodeID sets the ID field of the mutation.
func withReasonCodeID(id uuid.UUID) reasoncodeOption {
	return func(m *ReasonCodeMutation) {
		var (
			err   error
			once  sync.Once
			value *ReasonCode
		)
		m.oldValue = func(ctx context.Context) (*ReasonCode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ReasonCode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReasonCode sets the old ReasonCode of the mutation.
func withReasonCode(node *ReasonCode) reasoncodeOption {
	return func(m *ReasonCodeMutation) {
		m.oldValue = func(context.Context) (*ReasonCode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReasonCodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReasonCodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ReasonCode entities.
func (m *ReasonCodeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReasonCodeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReasonCodeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ReasonCode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *ReasonCodeMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *ReasonCodeMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the ReasonCode entity.
// If the ReasonCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReasonCodeMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *ReasonCodeMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *ReasonCodeMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *ReasonCodeMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the ReasonCode entity.
// If the ReasonCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReasonCodeMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *ReasonCodeMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ReasonCodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ReasonCodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ReasonCode entity.
// If the ReasonCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReasonCodeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ReasonCodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ReasonCodeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ReasonCodeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ReasonCode entity.
// If the ReasonCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReasonCodeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ReasonCodeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *ReasonCodeMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *ReasonCodeMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the ReasonCode entity.
// If the ReasonCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReasonCodeMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *ReasonCodeMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *ReasonCodeMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *ReasonCodeMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetStatus sets the "status" field.
func (m *ReasonCodeMutation) SetStatus(r reasoncode.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *ReasonCodeMutation) Status() (r reasoncode.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ReasonCode entity.
// If the ReasonCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReasonCodeMutation) OldStatus(ctx context.Context) (v reasoncode.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ReasonCodeMutation) ResetStatus() {
	m.status = nil
}

// SetCode sets the "code" field.
func (m *ReasonCodeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *ReasonCodeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the ReasonCode entity.
// If the ReasonCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReasonCodeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *ReasonCodeMutation) ResetCode() {
	m.code = nil
}

// SetCodeType sets the "code_type" field.
func (m *ReasonCodeMutation) SetCodeType(rt reasoncode.CodeType) {
	m.code_type = &rt
}

// CodeType returns the value of the "code_type" field in the mutation.
func (m *ReasonCodeMutation) CodeType() (r reasoncode.CodeType, exists bool) {
	v := m.code_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCodeType returns the old "code_type" field's value of the ReasonCode entity.
// If the ReasonCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReasonCodeMutation) OldCodeType(ctx context.Context) (v reasoncode.CodeType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodeType: %w", err)
	}
	return oldValue.CodeType, nil
}

// ResetCodeType resets all changes to the "code_type" field.
func (m *ReasonCodeMutation) ResetCodeType() {
	m.code_type = nil
}

// SetDescription sets the "description" field.
func (m *ReasonCodeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ReasonCodeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ReasonCode entity.
// If the ReasonCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReasonCodeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ReasonCodeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[reasoncode.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ReasonCodeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[reasoncode.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ReasonCodeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, reasoncode.FieldDescription)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *ReasonCodeMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[reasoncode.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *ReasonCodeMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *ReasonCodeMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *ReasonCodeMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *ReasonCodeMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[reasoncode.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *ReasonCodeMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *ReasonCodeMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *ReasonCodeMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the ReasonCodeMutation builder.
func (m *ReasonCodeMutation) Where(ps ...predicate.ReasonCode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReasonCodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReasonCodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ReasonCode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReasonCodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReasonCodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ReasonCode).
func (m *ReasonCodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReasonCodeMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.business_unit != nil {
		fields = append(fields, reasoncode.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, reasoncode.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, reasoncode.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, reasoncode.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, reasoncode.FieldVersion)
	}
	if m.status != nil {
		fields = append(fields, reasoncode.FieldStatus)
	}
	if m.code != nil {
		fields = append(fields, reasoncode.FieldCode)
	}
	if m.code_type != nil {
		fields = append(fields, reasoncode.FieldCodeType)
	}
	if m.description != nil {
		fields = append(fields, reasoncode.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReasonCodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case reasoncode.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case reasoncode.FieldOrganizationID:
		return m.OrganizationID()
	case reasoncode.FieldCreatedAt:
		return m.CreatedAt()
	case reasoncode.FieldUpdatedAt:
		return m.UpdatedAt()
	case reasoncode.FieldVersion:
		return m.Version()
	case reasoncode.FieldStatus:
		return m.Status()
	case reasoncode.FieldCode:
		return m.Code()
	case reasoncode.FieldCodeType:
		return m.CodeType()
	case reasoncode.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReasonCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case reasoncode.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case reasoncode.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case reasoncode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case reasoncode.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case reasoncode.FieldVersion:
		return m.OldVersion(ctx)
	case reasoncode.FieldStatus:
		return m.OldStatus(ctx)
	case reasoncode.FieldCode:
		return m.OldCode(ctx)
	case reasoncode.FieldCodeType:
		return m.OldCodeType(ctx)
	case reasoncode.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown ReasonCode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReasonCodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case reasoncode.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case reasoncode.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case reasoncode.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case reasoncode.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case reasoncode.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case reasoncode.FieldStatus:
		v, ok := value.(reasoncode.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case reasoncode.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case reasoncode.FieldCodeType:
		v, ok := value.(reasoncode.CodeType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodeType(v)
		return nil
	case reasoncode.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown ReasonCode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReasonCodeMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, reasoncode.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReasonCodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case reasoncode.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReasonCodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case reasoncode.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown ReasonCode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReasonCodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(reasoncode.FieldDescription) {
		fields = append(fields, reasoncode.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReasonCodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReasonCodeMutation) ClearField(name string) error {
	switch name {
	case reasoncode.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ReasonCode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReasonCodeMutation) ResetField(name string) error {
	switch name {
	case reasoncode.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case reasoncode.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case reasoncode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case reasoncode.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case reasoncode.FieldVersion:
		m.ResetVersion()
		return nil
	case reasoncode.FieldStatus:
		m.ResetStatus()
		return nil
	case reasoncode.FieldCode:
		m.ResetCode()
		return nil
	case reasoncode.FieldCodeType:
		m.ResetCodeType()
		return nil
	case reasoncode.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown ReasonCode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReasonCodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.business_unit != nil {
		edges = append(edges, reasoncode.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, reasoncode.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReasonCodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case reasoncode.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case reasoncode.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReasonCodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReasonCodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReasonCodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbusiness_unit {
		edges = append(edges, reasoncode.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, reasoncode.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReasonCodeMutation) EdgeCleared(name string) bool {
	switch name {
	case reasoncode.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case reasoncode.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReasonCodeMutation) ClearEdge(name string) error {
	switch name {
	case reasoncode.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case reasoncode.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown ReasonCode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReasonCodeMutation) ResetEdge(name string) error {
	switch name {
	case reasoncode.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case reasoncode.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown ReasonCode edge %s", name)
}

// ResourceMutation represents an operation that mutates the Resource nodes in the graph.
type ResourceMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	created_at         *time.Time
	updated_at         *time.Time
	_type              *string
	description        *string
	clearedFields      map[string]struct{}
	permissions        map[uuid.UUID]struct{}
	removedpermissions map[uuid.UUID]struct{}
	clearedpermissions bool
	done               bool
	oldValue           func(context.Context) (*Resource, error)
	predicates         []predicate.Resource
}

var _ ent.Mutation = (*ResourceMutation)(nil)

// resourceOption allows management of the mutation configuration using functional options.
type resourceOption func(*ResourceMutation)

// newResourceMutation creates new mutation for the Resource entity.
func newResourceMutation(c config, op Op, opts ...resourceOption) *ResourceMutation {
	m := &ResourceMutation{
		config:        c,
		op:            op,
		typ:           TypeResource,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResourceID sets the ID field of the mutation.
func withResourceID(id uuid.UUID) resourceOption {
	return func(m *ResourceMutation) {
		var (
			err   error
			once  sync.Once
			value *Resource
		)
		m.oldValue = func(ctx context.Context) (*Resource, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Resource.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResource sets the old Resource of the mutation.
func withResource(node *Resource) resourceOption {
	return func(m *ResourceMutation) {
		m.oldValue = func(context.Context) (*Resource, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResourceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResourceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Resource entities.
func (m *ResourceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResourceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResourceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Resource.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ResourceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ResourceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ResourceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ResourceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ResourceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ResourceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the "type" field.
func (m *ResourceMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ResourceMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ResourceMutation) ResetType() {
	m._type = nil
}

// SetDescription sets the "description" field.
func (m *ResourceMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ResourceMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Resource entity.
// If the Resource object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResourceMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ResourceMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[resource.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ResourceMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[resource.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ResourceMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, resource.FieldDescription)
}

// AddPermissionIDs adds the "permissions" edge to the Permission entity by ids.
func (m *ResourceMutation) AddPermissionIDs(ids ...uuid.UUID) {
	if m.permissions == nil {
		m.permissions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.permissions[ids[i]] = struct{}{}
	}
}

// ClearPermissions clears the "permissions" edge to the Permission entity.
func (m *ResourceMutation) ClearPermissions() {
	m.clearedpermissions = true
}

// PermissionsCleared reports if the "permissions" edge to the Permission entity was cleared.
func (m *ResourceMutation) PermissionsCleared() bool {
	return m.clearedpermissions
}

// RemovePermissionIDs removes the "permissions" edge to the Permission entity by IDs.
func (m *ResourceMutation) RemovePermissionIDs(ids ...uuid.UUID) {
	if m.removedpermissions == nil {
		m.removedpermissions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.permissions, ids[i])
		m.removedpermissions[ids[i]] = struct{}{}
	}
}

// RemovedPermissions returns the removed IDs of the "permissions" edge to the Permission entity.
func (m *ResourceMutation) RemovedPermissionsIDs() (ids []uuid.UUID) {
	for id := range m.removedpermissions {
		ids = append(ids, id)
	}
	return
}

// PermissionsIDs returns the "permissions" edge IDs in the mutation.
func (m *ResourceMutation) PermissionsIDs() (ids []uuid.UUID) {
	for id := range m.permissions {
		ids = append(ids, id)
	}
	return
}

// ResetPermissions resets all changes to the "permissions" edge.
func (m *ResourceMutation) ResetPermissions() {
	m.permissions = nil
	m.clearedpermissions = false
	m.removedpermissions = nil
}

// Where appends a list predicates to the ResourceMutation builder.
func (m *ResourceMutation) Where(ps ...predicate.Resource) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResourceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResourceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Resource, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResourceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResourceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Resource).
func (m *ResourceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResourceMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, resource.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, resource.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, resource.FieldType)
	}
	if m.description != nil {
		fields = append(fields, resource.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResourceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resource.FieldCreatedAt:
		return m.CreatedAt()
	case resource.FieldUpdatedAt:
		return m.UpdatedAt()
	case resource.FieldType:
		return m.GetType()
	case resource.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResourceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resource.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case resource.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case resource.FieldType:
		return m.OldType(ctx)
	case resource.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Resource field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resource.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case resource.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case resource.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case resource.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Resource field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResourceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResourceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResourceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Resource numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResourceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(resource.FieldDescription) {
		fields = append(fields, resource.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResourceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResourceMutation) ClearField(name string) error {
	switch name {
	case resource.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Resource nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResourceMutation) ResetField(name string) error {
	switch name {
	case resource.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case resource.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case resource.FieldType:
		m.ResetType()
		return nil
	case resource.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Resource field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResourceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.permissions != nil {
		edges = append(edges, resource.EdgePermissions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResourceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resource.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.permissions))
		for id := range m.permissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResourceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpermissions != nil {
		edges = append(edges, resource.EdgePermissions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResourceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case resource.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.removedpermissions))
		for id := range m.removedpermissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResourceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpermissions {
		edges = append(edges, resource.EdgePermissions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResourceMutation) EdgeCleared(name string) bool {
	switch name {
	case resource.EdgePermissions:
		return m.clearedpermissions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResourceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Resource unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResourceMutation) ResetEdge(name string) error {
	switch name {
	case resource.EdgePermissions:
		m.ResetPermissions()
		return nil
	}
	return fmt.Errorf("unknown Resource edge %s", name)
}

// RevenueCodeMutation represents an operation that mutates the RevenueCode nodes in the graph.
type RevenueCodeMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	created_at             *time.Time
	updated_at             *time.Time
	version                *int
	addversion             *int
	status                 *revenuecode.Status
	code                   *string
	description            *string
	clearedFields          map[string]struct{}
	business_unit          *uuid.UUID
	clearedbusiness_unit   bool
	organization           *uuid.UUID
	clearedorganization    bool
	expense_account        *uuid.UUID
	clearedexpense_account bool
	revenue_account        *uuid.UUID
	clearedrevenue_account bool
	done                   bool
	oldValue               func(context.Context) (*RevenueCode, error)
	predicates             []predicate.RevenueCode
}

var _ ent.Mutation = (*RevenueCodeMutation)(nil)

// revenuecodeOption allows management of the mutation configuration using functional options.
type revenuecodeOption func(*RevenueCodeMutation)

// newRevenueCodeMutation creates new mutation for the RevenueCode entity.
func newRevenueCodeMutation(c config, op Op, opts ...revenuecodeOption) *RevenueCodeMutation {
	m := &RevenueCodeMutation{
		config:        c,
		op:            op,
		typ:           TypeRevenueCode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRevenueCodeID sets the ID field of the mutation.
func withRevenueCodeID(id uuid.UUID) revenuecodeOption {
	return func(m *RevenueCodeMutation) {
		var (
			err   error
			once  sync.Once
			value *RevenueCode
		)
		m.oldValue = func(ctx context.Context) (*RevenueCode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RevenueCode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRevenueCode sets the old RevenueCode of the mutation.
func withRevenueCode(node *RevenueCode) revenuecodeOption {
	return func(m *RevenueCodeMutation) {
		m.oldValue = func(context.Context) (*RevenueCode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RevenueCodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RevenueCodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RevenueCode entities.
func (m *RevenueCodeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RevenueCodeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RevenueCodeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RevenueCode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *RevenueCodeMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *RevenueCodeMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the RevenueCode entity.
// If the RevenueCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevenueCodeMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *RevenueCodeMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *RevenueCodeMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *RevenueCodeMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the RevenueCode entity.
// If the RevenueCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevenueCodeMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *RevenueCodeMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RevenueCodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RevenueCodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RevenueCode entity.
// If the RevenueCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevenueCodeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RevenueCodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RevenueCodeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RevenueCodeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RevenueCode entity.
// If the RevenueCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevenueCodeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RevenueCodeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *RevenueCodeMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *RevenueCodeMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the RevenueCode entity.
// If the RevenueCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevenueCodeMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *RevenueCodeMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *RevenueCodeMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *RevenueCodeMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetStatus sets the "status" field.
func (m *RevenueCodeMutation) SetStatus(r revenuecode.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *RevenueCodeMutation) Status() (r revenuecode.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the RevenueCode entity.
// If the RevenueCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevenueCodeMutation) OldStatus(ctx context.Context) (v revenuecode.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *RevenueCodeMutation) ResetStatus() {
	m.status = nil
}

// SetCode sets the "code" field.
func (m *RevenueCodeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *RevenueCodeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the RevenueCode entity.
// If the RevenueCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevenueCodeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *RevenueCodeMutation) ResetCode() {
	m.code = nil
}

// SetDescription sets the "description" field.
func (m *RevenueCodeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RevenueCodeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the RevenueCode entity.
// If the RevenueCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevenueCodeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *RevenueCodeMutation) ResetDescription() {
	m.description = nil
}

// SetExpenseAccountID sets the "expense_account_id" field.
func (m *RevenueCodeMutation) SetExpenseAccountID(u uuid.UUID) {
	m.expense_account = &u
}

// ExpenseAccountID returns the value of the "expense_account_id" field in the mutation.
func (m *RevenueCodeMutation) ExpenseAccountID() (r uuid.UUID, exists bool) {
	v := m.expense_account
	if v == nil {
		return
	}
	return *v, true
}

// OldExpenseAccountID returns the old "expense_account_id" field's value of the RevenueCode entity.
// If the RevenueCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevenueCodeMutation) OldExpenseAccountID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpenseAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpenseAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpenseAccountID: %w", err)
	}
	return oldValue.ExpenseAccountID, nil
}

// ClearExpenseAccountID clears the value of the "expense_account_id" field.
func (m *RevenueCodeMutation) ClearExpenseAccountID() {
	m.expense_account = nil
	m.clearedFields[revenuecode.FieldExpenseAccountID] = struct{}{}
}

// ExpenseAccountIDCleared returns if the "expense_account_id" field was cleared in this mutation.
func (m *RevenueCodeMutation) ExpenseAccountIDCleared() bool {
	_, ok := m.clearedFields[revenuecode.FieldExpenseAccountID]
	return ok
}

// ResetExpenseAccountID resets all changes to the "expense_account_id" field.
func (m *RevenueCodeMutation) ResetExpenseAccountID() {
	m.expense_account = nil
	delete(m.clearedFields, revenuecode.FieldExpenseAccountID)
}

// SetRevenueAccountID sets the "revenue_account_id" field.
func (m *RevenueCodeMutation) SetRevenueAccountID(u uuid.UUID) {
	m.revenue_account = &u
}

// RevenueAccountID returns the value of the "revenue_account_id" field in the mutation.
func (m *RevenueCodeMutation) RevenueAccountID() (r uuid.UUID, exists bool) {
	v := m.revenue_account
	if v == nil {
		return
	}
	return *v, true
}

// OldRevenueAccountID returns the old "revenue_account_id" field's value of the RevenueCode entity.
// If the RevenueCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevenueCodeMutation) OldRevenueAccountID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevenueAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevenueAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevenueAccountID: %w", err)
	}
	return oldValue.RevenueAccountID, nil
}

// ClearRevenueAccountID clears the value of the "revenue_account_id" field.
func (m *RevenueCodeMutation) ClearRevenueAccountID() {
	m.revenue_account = nil
	m.clearedFields[revenuecode.FieldRevenueAccountID] = struct{}{}
}

// RevenueAccountIDCleared returns if the "revenue_account_id" field was cleared in this mutation.
func (m *RevenueCodeMutation) RevenueAccountIDCleared() bool {
	_, ok := m.clearedFields[revenuecode.FieldRevenueAccountID]
	return ok
}

// ResetRevenueAccountID resets all changes to the "revenue_account_id" field.
func (m *RevenueCodeMutation) ResetRevenueAccountID() {
	m.revenue_account = nil
	delete(m.clearedFields, revenuecode.FieldRevenueAccountID)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *RevenueCodeMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[revenuecode.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *RevenueCodeMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *RevenueCodeMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *RevenueCodeMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *RevenueCodeMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[revenuecode.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *RevenueCodeMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *RevenueCodeMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *RevenueCodeMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearExpenseAccount clears the "expense_account" edge to the GeneralLedgerAccount entity.
func (m *RevenueCodeMutation) ClearExpenseAccount() {
	m.clearedexpense_account = true
	m.clearedFields[revenuecode.FieldExpenseAccountID] = struct{}{}
}

// ExpenseAccountCleared reports if the "expense_account" edge to the GeneralLedgerAccount entity was cleared.
func (m *RevenueCodeMutation) ExpenseAccountCleared() bool {
	return m.ExpenseAccountIDCleared() || m.clearedexpense_account
}

// ExpenseAccountIDs returns the "expense_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExpenseAccountID instead. It exists only for internal usage by the builders.
func (m *RevenueCodeMutation) ExpenseAccountIDs() (ids []uuid.UUID) {
	if id := m.expense_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExpenseAccount resets all changes to the "expense_account" edge.
func (m *RevenueCodeMutation) ResetExpenseAccount() {
	m.expense_account = nil
	m.clearedexpense_account = false
}

// ClearRevenueAccount clears the "revenue_account" edge to the GeneralLedgerAccount entity.
func (m *RevenueCodeMutation) ClearRevenueAccount() {
	m.clearedrevenue_account = true
	m.clearedFields[revenuecode.FieldRevenueAccountID] = struct{}{}
}

// RevenueAccountCleared reports if the "revenue_account" edge to the GeneralLedgerAccount entity was cleared.
func (m *RevenueCodeMutation) RevenueAccountCleared() bool {
	return m.RevenueAccountIDCleared() || m.clearedrevenue_account
}

// RevenueAccountIDs returns the "revenue_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RevenueAccountID instead. It exists only for internal usage by the builders.
func (m *RevenueCodeMutation) RevenueAccountIDs() (ids []uuid.UUID) {
	if id := m.revenue_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRevenueAccount resets all changes to the "revenue_account" edge.
func (m *RevenueCodeMutation) ResetRevenueAccount() {
	m.revenue_account = nil
	m.clearedrevenue_account = false
}

// Where appends a list predicates to the RevenueCodeMutation builder.
func (m *RevenueCodeMutation) Where(ps ...predicate.RevenueCode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RevenueCodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RevenueCodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RevenueCode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RevenueCodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RevenueCodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RevenueCode).
func (m *RevenueCodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RevenueCodeMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.business_unit != nil {
		fields = append(fields, revenuecode.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, revenuecode.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, revenuecode.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, revenuecode.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, revenuecode.FieldVersion)
	}
	if m.status != nil {
		fields = append(fields, revenuecode.FieldStatus)
	}
	if m.code != nil {
		fields = append(fields, revenuecode.FieldCode)
	}
	if m.description != nil {
		fields = append(fields, revenuecode.FieldDescription)
	}
	if m.expense_account != nil {
		fields = append(fields, revenuecode.FieldExpenseAccountID)
	}
	if m.revenue_account != nil {
		fields = append(fields, revenuecode.FieldRevenueAccountID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RevenueCodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case revenuecode.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case revenuecode.FieldOrganizationID:
		return m.OrganizationID()
	case revenuecode.FieldCreatedAt:
		return m.CreatedAt()
	case revenuecode.FieldUpdatedAt:
		return m.UpdatedAt()
	case revenuecode.FieldVersion:
		return m.Version()
	case revenuecode.FieldStatus:
		return m.Status()
	case revenuecode.FieldCode:
		return m.Code()
	case revenuecode.FieldDescription:
		return m.Description()
	case revenuecode.FieldExpenseAccountID:
		return m.ExpenseAccountID()
	case revenuecode.FieldRevenueAccountID:
		return m.RevenueAccountID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RevenueCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case revenuecode.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case revenuecode.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case revenuecode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case revenuecode.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case revenuecode.FieldVersion:
		return m.OldVersion(ctx)
	case revenuecode.FieldStatus:
		return m.OldStatus(ctx)
	case revenuecode.FieldCode:
		return m.OldCode(ctx)
	case revenuecode.FieldDescription:
		return m.OldDescription(ctx)
	case revenuecode.FieldExpenseAccountID:
		return m.OldExpenseAccountID(ctx)
	case revenuecode.FieldRevenueAccountID:
		return m.OldRevenueAccountID(ctx)
	}
	return nil, fmt.Errorf("unknown RevenueCode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RevenueCodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case revenuecode.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case revenuecode.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case revenuecode.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case revenuecode.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case revenuecode.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case revenuecode.FieldStatus:
		v, ok := value.(revenuecode.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case revenuecode.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case revenuecode.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case revenuecode.FieldExpenseAccountID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpenseAccountID(v)
		return nil
	case revenuecode.FieldRevenueAccountID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevenueAccountID(v)
		return nil
	}
	return fmt.Errorf("unknown RevenueCode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RevenueCodeMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, revenuecode.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RevenueCodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case revenuecode.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RevenueCodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case revenuecode.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown RevenueCode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RevenueCodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(revenuecode.FieldExpenseAccountID) {
		fields = append(fields, revenuecode.FieldExpenseAccountID)
	}
	if m.FieldCleared(revenuecode.FieldRevenueAccountID) {
		fields = append(fields, revenuecode.FieldRevenueAccountID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RevenueCodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RevenueCodeMutation) ClearField(name string) error {
	switch name {
	case revenuecode.FieldExpenseAccountID:
		m.ClearExpenseAccountID()
		return nil
	case revenuecode.FieldRevenueAccountID:
		m.ClearRevenueAccountID()
		return nil
	}
	return fmt.Errorf("unknown RevenueCode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RevenueCodeMutation) ResetField(name string) error {
	switch name {
	case revenuecode.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case revenuecode.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case revenuecode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case revenuecode.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case revenuecode.FieldVersion:
		m.ResetVersion()
		return nil
	case revenuecode.FieldStatus:
		m.ResetStatus()
		return nil
	case revenuecode.FieldCode:
		m.ResetCode()
		return nil
	case revenuecode.FieldDescription:
		m.ResetDescription()
		return nil
	case revenuecode.FieldExpenseAccountID:
		m.ResetExpenseAccountID()
		return nil
	case revenuecode.FieldRevenueAccountID:
		m.ResetRevenueAccountID()
		return nil
	}
	return fmt.Errorf("unknown RevenueCode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RevenueCodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.business_unit != nil {
		edges = append(edges, revenuecode.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, revenuecode.EdgeOrganization)
	}
	if m.expense_account != nil {
		edges = append(edges, revenuecode.EdgeExpenseAccount)
	}
	if m.revenue_account != nil {
		edges = append(edges, revenuecode.EdgeRevenueAccount)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RevenueCodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case revenuecode.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case revenuecode.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case revenuecode.EdgeExpenseAccount:
		if id := m.expense_account; id != nil {
			return []ent.Value{*id}
		}
	case revenuecode.EdgeRevenueAccount:
		if id := m.revenue_account; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RevenueCodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RevenueCodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RevenueCodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedbusiness_unit {
		edges = append(edges, revenuecode.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, revenuecode.EdgeOrganization)
	}
	if m.clearedexpense_account {
		edges = append(edges, revenuecode.EdgeExpenseAccount)
	}
	if m.clearedrevenue_account {
		edges = append(edges, revenuecode.EdgeRevenueAccount)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RevenueCodeMutation) EdgeCleared(name string) bool {
	switch name {
	case revenuecode.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case revenuecode.EdgeOrganization:
		return m.clearedorganization
	case revenuecode.EdgeExpenseAccount:
		return m.clearedexpense_account
	case revenuecode.EdgeRevenueAccount:
		return m.clearedrevenue_account
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RevenueCodeMutation) ClearEdge(name string) error {
	switch name {
	case revenuecode.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case revenuecode.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case revenuecode.EdgeExpenseAccount:
		m.ClearExpenseAccount()
		return nil
	case revenuecode.EdgeRevenueAccount:
		m.ClearRevenueAccount()
		return nil
	}
	return fmt.Errorf("unknown RevenueCode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RevenueCodeMutation) ResetEdge(name string) error {
	switch name {
	case revenuecode.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case revenuecode.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case revenuecode.EdgeExpenseAccount:
		m.ResetExpenseAccount()
		return nil
	case revenuecode.EdgeRevenueAccount:
		m.ResetRevenueAccount()
		return nil
	}
	return fmt.Errorf("unknown RevenueCode edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	version              *int
	addversion           *int
	name                 *string
	description          *string
	color                *string
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	permissions          map[uuid.UUID]struct{}
	removedpermissions   map[uuid.UUID]struct{}
	clearedpermissions   bool
	users                map[uuid.UUID]struct{}
	removedusers         map[uuid.UUID]struct{}
	clearedusers         bool
	done                 bool
	oldValue             func(context.Context) (*Role, error)
	predicates           []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id uuid.UUID) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role entities.
func (m *RoleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *RoleMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *RoleMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *RoleMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *RoleMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *RoleMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *RoleMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *RoleMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *RoleMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *RoleMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *RoleMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *RoleMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *RoleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RoleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *RoleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[role.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *RoleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[role.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *RoleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, role.FieldDescription)
}

// SetColor sets the "color" field.
func (m *RoleMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *RoleMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *RoleMutation) ClearColor() {
	m.color = nil
	m.clearedFields[role.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *RoleMutation) ColorCleared() bool {
	_, ok := m.clearedFields[role.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *RoleMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, role.FieldColor)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *RoleMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[role.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *RoleMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *RoleMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *RoleMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *RoleMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[role.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *RoleMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *RoleMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *RoleMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// AddPermissionIDs adds the "permissions" edge to the Permission entity by ids.
func (m *RoleMutation) AddPermissionIDs(ids ...uuid.UUID) {
	if m.permissions == nil {
		m.permissions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.permissions[ids[i]] = struct{}{}
	}
}

// ClearPermissions clears the "permissions" edge to the Permission entity.
func (m *RoleMutation) ClearPermissions() {
	m.clearedpermissions = true
}

// PermissionsCleared reports if the "permissions" edge to the Permission entity was cleared.
func (m *RoleMutation) PermissionsCleared() bool {
	return m.clearedpermissions
}

// RemovePermissionIDs removes the "permissions" edge to the Permission entity by IDs.
func (m *RoleMutation) RemovePermissionIDs(ids ...uuid.UUID) {
	if m.removedpermissions == nil {
		m.removedpermissions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.permissions, ids[i])
		m.removedpermissions[ids[i]] = struct{}{}
	}
}

// RemovedPermissions returns the removed IDs of the "permissions" edge to the Permission entity.
func (m *RoleMutation) RemovedPermissionsIDs() (ids []uuid.UUID) {
	for id := range m.removedpermissions {
		ids = append(ids, id)
	}
	return
}

// PermissionsIDs returns the "permissions" edge IDs in the mutation.
func (m *RoleMutation) PermissionsIDs() (ids []uuid.UUID) {
	for id := range m.permissions {
		ids = append(ids, id)
	}
	return
}

// ResetPermissions resets all changes to the "permissions" edge.
func (m *RoleMutation) ResetPermissions() {
	m.permissions = nil
	m.clearedpermissions = false
	m.removedpermissions = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *RoleMutation) AddUserIDs(ids ...uuid.UUID) {
	if m.users == nil {
		m.users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *RoleMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *RoleMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *RoleMutation) RemoveUserIDs(ids ...uuid.UUID) {
	if m.removedusers == nil {
		m.removedusers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *RoleMutation) RemovedUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *RoleMutation) UsersIDs() (ids []uuid.UUID) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *RoleMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.business_unit != nil {
		fields = append(fields, role.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, role.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, role.FieldVersion)
	}
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	if m.description != nil {
		fields = append(fields, role.FieldDescription)
	}
	if m.color != nil {
		fields = append(fields, role.FieldColor)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case role.FieldOrganizationID:
		return m.OrganizationID()
	case role.FieldCreatedAt:
		return m.CreatedAt()
	case role.FieldUpdatedAt:
		return m.UpdatedAt()
	case role.FieldVersion:
		return m.Version()
	case role.FieldName:
		return m.Name()
	case role.FieldDescription:
		return m.Description()
	case role.FieldColor:
		return m.Color()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case role.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case role.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case role.FieldVersion:
		return m.OldVersion(ctx)
	case role.FieldName:
		return m.OldName(ctx)
	case role.FieldDescription:
		return m.OldDescription(ctx)
	case role.FieldColor:
		return m.OldColor(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case role.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case role.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case role.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case role.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case role.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case role.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, role.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case role.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case role.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(role.FieldDescription) {
		fields = append(fields, role.FieldDescription)
	}
	if m.FieldCleared(role.FieldColor) {
		fields = append(fields, role.FieldColor)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	switch name {
	case role.FieldDescription:
		m.ClearDescription()
		return nil
	case role.FieldColor:
		m.ClearColor()
		return nil
	}
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case role.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case role.FieldVersion:
		m.ResetVersion()
		return nil
	case role.FieldName:
		m.ResetName()
		return nil
	case role.FieldDescription:
		m.ResetDescription()
		return nil
	case role.FieldColor:
		m.ResetColor()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.business_unit != nil {
		edges = append(edges, role.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, role.EdgeOrganization)
	}
	if m.permissions != nil {
		edges = append(edges, role.EdgePermissions)
	}
	if m.users != nil {
		edges = append(edges, role.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case role.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case role.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.permissions))
		for id := range m.permissions {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedpermissions != nil {
		edges = append(edges, role.EdgePermissions)
	}
	if m.removedusers != nil {
		edges = append(edges, role.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgePermissions:
		ids := make([]ent.Value, 0, len(m.removedpermissions))
		for id := range m.removedpermissions {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedbusiness_unit {
		edges = append(edges, role.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, role.EdgeOrganization)
	}
	if m.clearedpermissions {
		edges = append(edges, role.EdgePermissions)
	}
	if m.clearedusers {
		edges = append(edges, role.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case role.EdgeOrganization:
		return m.clearedorganization
	case role.EdgePermissions:
		return m.clearedpermissions
	case role.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	case role.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case role.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case role.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case role.EdgePermissions:
		m.ResetPermissions()
		return nil
	case role.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// RouteControlMutation represents an operation that mutates the RouteControl nodes in the graph.
type RouteControlMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	distance_method      *routecontrol.DistanceMethod
	mileage_unit         *routecontrol.MileageUnit
	generate_routes      *bool
	clearedFields        map[string]struct{}
	organization         *uuid.UUID
	clearedorganization  bool
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	done                 bool
	oldValue             func(context.Context) (*RouteControl, error)
	predicates           []predicate.RouteControl
}

var _ ent.Mutation = (*RouteControlMutation)(nil)

// routecontrolOption allows management of the mutation configuration using functional options.
type routecontrolOption func(*RouteControlMutation)

// newRouteControlMutation creates new mutation for the RouteControl entity.
func newRouteControlMutation(c config, op Op, opts ...routecontrolOption) *RouteControlMutation {
	m := &RouteControlMutation{
		config:        c,
		op:            op,
		typ:           TypeRouteControl,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRouteControlID sets the ID field of the mutation.
func withRouteControlID(id uuid.UUID) routecontrolOption {
	return func(m *RouteControlMutation) {
		var (
			err   error
			once  sync.Once
			value *RouteControl
		)
		m.oldValue = func(ctx context.Context) (*RouteControl, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RouteControl.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRouteControl sets the old RouteControl of the mutation.
func withRouteControl(node *RouteControl) routecontrolOption {
	return func(m *RouteControlMutation) {
		m.oldValue = func(context.Context) (*RouteControl, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RouteControlMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RouteControlMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RouteControl entities.
func (m *RouteControlMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RouteControlMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RouteControlMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RouteControl.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RouteControlMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RouteControlMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RouteControl entity.
// If the RouteControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteControlMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RouteControlMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RouteControlMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RouteControlMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RouteControl entity.
// If the RouteControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteControlMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RouteControlMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDistanceMethod sets the "distance_method" field.
func (m *RouteControlMutation) SetDistanceMethod(rm routecontrol.DistanceMethod) {
	m.distance_method = &rm
}

// DistanceMethod returns the value of the "distance_method" field in the mutation.
func (m *RouteControlMutation) DistanceMethod() (r routecontrol.DistanceMethod, exists bool) {
	v := m.distance_method
	if v == nil {
		return
	}
	return *v, true
}

// OldDistanceMethod returns the old "distance_method" field's value of the RouteControl entity.
// If the RouteControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteControlMutation) OldDistanceMethod(ctx context.Context) (v routecontrol.DistanceMethod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDistanceMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDistanceMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistanceMethod: %w", err)
	}
	return oldValue.DistanceMethod, nil
}

// ResetDistanceMethod resets all changes to the "distance_method" field.
func (m *RouteControlMutation) ResetDistanceMethod() {
	m.distance_method = nil
}

// SetMileageUnit sets the "mileage_unit" field.
func (m *RouteControlMutation) SetMileageUnit(ru routecontrol.MileageUnit) {
	m.mileage_unit = &ru
}

// MileageUnit returns the value of the "mileage_unit" field in the mutation.
func (m *RouteControlMutation) MileageUnit() (r routecontrol.MileageUnit, exists bool) {
	v := m.mileage_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldMileageUnit returns the old "mileage_unit" field's value of the RouteControl entity.
// If the RouteControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteControlMutation) OldMileageUnit(ctx context.Context) (v routecontrol.MileageUnit, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMileageUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMileageUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMileageUnit: %w", err)
	}
	return oldValue.MileageUnit, nil
}

// ResetMileageUnit resets all changes to the "mileage_unit" field.
func (m *RouteControlMutation) ResetMileageUnit() {
	m.mileage_unit = nil
}

// SetGenerateRoutes sets the "generate_routes" field.
func (m *RouteControlMutation) SetGenerateRoutes(b bool) {
	m.generate_routes = &b
}

// GenerateRoutes returns the value of the "generate_routes" field in the mutation.
func (m *RouteControlMutation) GenerateRoutes() (r bool, exists bool) {
	v := m.generate_routes
	if v == nil {
		return
	}
	return *v, true
}

// OldGenerateRoutes returns the old "generate_routes" field's value of the RouteControl entity.
// If the RouteControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteControlMutation) OldGenerateRoutes(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGenerateRoutes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGenerateRoutes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenerateRoutes: %w", err)
	}
	return oldValue.GenerateRoutes, nil
}

// ResetGenerateRoutes resets all changes to the "generate_routes" field.
func (m *RouteControlMutation) ResetGenerateRoutes() {
	m.generate_routes = nil
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *RouteControlMutation) SetOrganizationID(id uuid.UUID) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *RouteControlMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *RouteControlMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *RouteControlMutation) OrganizationID() (id uuid.UUID, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *RouteControlMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *RouteControlMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// SetBusinessUnitID sets the "business_unit" edge to the BusinessUnit entity by id.
func (m *RouteControlMutation) SetBusinessUnitID(id uuid.UUID) {
	m.business_unit = &id
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *RouteControlMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *RouteControlMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitID returns the "business_unit" edge ID in the mutation.
func (m *RouteControlMutation) BusinessUnitID() (id uuid.UUID, exists bool) {
	if m.business_unit != nil {
		return *m.business_unit, true
	}
	return
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *RouteControlMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *RouteControlMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// Where appends a list predicates to the RouteControlMutation builder.
func (m *RouteControlMutation) Where(ps ...predicate.RouteControl) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RouteControlMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RouteControlMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RouteControl, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RouteControlMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RouteControlMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RouteControl).
func (m *RouteControlMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RouteControlMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, routecontrol.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, routecontrol.FieldUpdatedAt)
	}
	if m.distance_method != nil {
		fields = append(fields, routecontrol.FieldDistanceMethod)
	}
	if m.mileage_unit != nil {
		fields = append(fields, routecontrol.FieldMileageUnit)
	}
	if m.generate_routes != nil {
		fields = append(fields, routecontrol.FieldGenerateRoutes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RouteControlMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case routecontrol.FieldCreatedAt:
		return m.CreatedAt()
	case routecontrol.FieldUpdatedAt:
		return m.UpdatedAt()
	case routecontrol.FieldDistanceMethod:
		return m.DistanceMethod()
	case routecontrol.FieldMileageUnit:
		return m.MileageUnit()
	case routecontrol.FieldGenerateRoutes:
		return m.GenerateRoutes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RouteControlMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case routecontrol.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case routecontrol.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case routecontrol.FieldDistanceMethod:
		return m.OldDistanceMethod(ctx)
	case routecontrol.FieldMileageUnit:
		return m.OldMileageUnit(ctx)
	case routecontrol.FieldGenerateRoutes:
		return m.OldGenerateRoutes(ctx)
	}
	return nil, fmt.Errorf("unknown RouteControl field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RouteControlMutation) SetField(name string, value ent.Value) error {
	switch name {
	case routecontrol.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case routecontrol.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case routecontrol.FieldDistanceMethod:
		v, ok := value.(routecontrol.DistanceMethod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistanceMethod(v)
		return nil
	case routecontrol.FieldMileageUnit:
		v, ok := value.(routecontrol.MileageUnit)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMileageUnit(v)
		return nil
	case routecontrol.FieldGenerateRoutes:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenerateRoutes(v)
		return nil
	}
	return fmt.Errorf("unknown RouteControl field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RouteControlMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RouteControlMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RouteControlMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RouteControl numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RouteControlMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RouteControlMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RouteControlMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RouteControl nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RouteControlMutation) ResetField(name string) error {
	switch name {
	case routecontrol.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case routecontrol.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case routecontrol.FieldDistanceMethod:
		m.ResetDistanceMethod()
		return nil
	case routecontrol.FieldMileageUnit:
		m.ResetMileageUnit()
		return nil
	case routecontrol.FieldGenerateRoutes:
		m.ResetGenerateRoutes()
		return nil
	}
	return fmt.Errorf("unknown RouteControl field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RouteControlMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.organization != nil {
		edges = append(edges, routecontrol.EdgeOrganization)
	}
	if m.business_unit != nil {
		edges = append(edges, routecontrol.EdgeBusinessUnit)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RouteControlMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case routecontrol.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case routecontrol.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RouteControlMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RouteControlMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RouteControlMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorganization {
		edges = append(edges, routecontrol.EdgeOrganization)
	}
	if m.clearedbusiness_unit {
		edges = append(edges, routecontrol.EdgeBusinessUnit)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RouteControlMutation) EdgeCleared(name string) bool {
	switch name {
	case routecontrol.EdgeOrganization:
		return m.clearedorganization
	case routecontrol.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RouteControlMutation) ClearEdge(name string) error {
	switch name {
	case routecontrol.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case routecontrol.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	}
	return fmt.Errorf("unknown RouteControl unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RouteControlMutation) ResetEdge(name string) error {
	switch name {
	case routecontrol.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case routecontrol.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	}
	return fmt.Errorf("unknown RouteControl edge %s", name)
}

// ServiceTypeMutation represents an operation that mutates the ServiceType nodes in the graph.
type ServiceTypeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	version              *int
	addversion           *int
	status               *servicetype.Status
	code                 *string
	description          *string
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	done                 bool
	oldValue             func(context.Context) (*ServiceType, error)
	predicates           []predicate.ServiceType
}

var _ ent.Mutation = (*ServiceTypeMutation)(nil)

// servicetypeOption allows management of the mutation configuration using functional options.
type servicetypeOption func(*ServiceTypeMutation)

// newServiceTypeMutation creates new mutation for the ServiceType entity.
func newServiceTypeMutation(c config, op Op, opts ...servicetypeOption) *ServiceTypeMutation {
	m := &ServiceTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeServiceType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceTypeID sets the ID field of the mutation.
func withServiceTypeID(id uuid.UUID) servicetypeOption {
	return func(m *ServiceTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ServiceType
		)
		m.oldValue = func(ctx context.Context) (*ServiceType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServiceType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServiceType sets the old ServiceType of the mutation.
func withServiceType(node *ServiceType) servicetypeOption {
	return func(m *ServiceTypeMutation) {
		m.oldValue = func(context.Context) (*ServiceType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServiceType entities.
func (m *ServiceTypeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceTypeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceTypeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServiceType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *ServiceTypeMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *ServiceTypeMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the ServiceType entity.
// If the ServiceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceTypeMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *ServiceTypeMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *ServiceTypeMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *ServiceTypeMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the ServiceType entity.
// If the ServiceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceTypeMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *ServiceTypeMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ServiceTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServiceTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ServiceType entity.
// If the ServiceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServiceTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServiceTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServiceTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ServiceType entity.
// If the ServiceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServiceTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *ServiceTypeMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *ServiceTypeMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the ServiceType entity.
// If the ServiceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceTypeMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *ServiceTypeMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *ServiceTypeMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *ServiceTypeMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetStatus sets the "status" field.
func (m *ServiceTypeMutation) SetStatus(s servicetype.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ServiceTypeMutation) Status() (r servicetype.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ServiceType entity.
// If the ServiceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceTypeMutation) OldStatus(ctx context.Context) (v servicetype.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ServiceTypeMutation) ResetStatus() {
	m.status = nil
}

// SetCode sets the "code" field.
func (m *ServiceTypeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *ServiceTypeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the ServiceType entity.
// If the ServiceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceTypeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *ServiceTypeMutation) ResetCode() {
	m.code = nil
}

// SetDescription sets the "description" field.
func (m *ServiceTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ServiceTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ServiceType entity.
// If the ServiceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ServiceTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[servicetype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ServiceTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[servicetype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ServiceTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, servicetype.FieldDescription)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *ServiceTypeMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[servicetype.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *ServiceTypeMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *ServiceTypeMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *ServiceTypeMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *ServiceTypeMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[servicetype.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *ServiceTypeMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *ServiceTypeMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *ServiceTypeMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the ServiceTypeMutation builder.
func (m *ServiceTypeMutation) Where(ps ...predicate.ServiceType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServiceType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServiceType).
func (m *ServiceTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceTypeMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.business_unit != nil {
		fields = append(fields, servicetype.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, servicetype.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, servicetype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, servicetype.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, servicetype.FieldVersion)
	}
	if m.status != nil {
		fields = append(fields, servicetype.FieldStatus)
	}
	if m.code != nil {
		fields = append(fields, servicetype.FieldCode)
	}
	if m.description != nil {
		fields = append(fields, servicetype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servicetype.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case servicetype.FieldOrganizationID:
		return m.OrganizationID()
	case servicetype.FieldCreatedAt:
		return m.CreatedAt()
	case servicetype.FieldUpdatedAt:
		return m.UpdatedAt()
	case servicetype.FieldVersion:
		return m.Version()
	case servicetype.FieldStatus:
		return m.Status()
	case servicetype.FieldCode:
		return m.Code()
	case servicetype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servicetype.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case servicetype.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case servicetype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case servicetype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case servicetype.FieldVersion:
		return m.OldVersion(ctx)
	case servicetype.FieldStatus:
		return m.OldStatus(ctx)
	case servicetype.FieldCode:
		return m.OldCode(ctx)
	case servicetype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown ServiceType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servicetype.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case servicetype.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case servicetype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case servicetype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case servicetype.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case servicetype.FieldStatus:
		v, ok := value.(servicetype.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case servicetype.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case servicetype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceTypeMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, servicetype.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceTypeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case servicetype.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case servicetype.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(servicetype.FieldDescription) {
		fields = append(fields, servicetype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceTypeMutation) ClearField(name string) error {
	switch name {
	case servicetype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ServiceType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceTypeMutation) ResetField(name string) error {
	switch name {
	case servicetype.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case servicetype.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case servicetype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case servicetype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case servicetype.FieldVersion:
		m.ResetVersion()
		return nil
	case servicetype.FieldStatus:
		m.ResetStatus()
		return nil
	case servicetype.FieldCode:
		m.ResetCode()
		return nil
	case servicetype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown ServiceType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.business_unit != nil {
		edges = append(edges, servicetype.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, servicetype.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case servicetype.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case servicetype.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbusiness_unit {
		edges = append(edges, servicetype.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, servicetype.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case servicetype.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case servicetype.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceTypeMutation) ClearEdge(name string) error {
	switch name {
	case servicetype.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case servicetype.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown ServiceType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceTypeMutation) ResetEdge(name string) error {
	switch name {
	case servicetype.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case servicetype.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown ServiceType edge %s", name)
}

// SessionMutation represents an operation that mutates the Session nodes in the graph.
type SessionMutation struct {
	config
	op            Op
	typ           string
	id            *string
	data          *string
	created_at    *time.Time
	updated_at    *time.Time
	expires_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Session, error)
	predicates    []predicate.Session
}

var _ ent.Mutation = (*SessionMutation)(nil)

// sessionOption allows management of the mutation configuration using functional options.
type sessionOption func(*SessionMutation)

// newSessionMutation creates new mutation for the Session entity.
func newSessionMutation(c config, op Op, opts ...sessionOption) *SessionMutation {
	m := &SessionMutation{
		config:        c,
		op:            op,
		typ:           TypeSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionID sets the ID field of the mutation.
func withSessionID(id string) sessionOption {
	return func(m *SessionMutation) {
		var (
			err   error
			once  sync.Once
			value *Session
		)
		m.oldValue = func(ctx context.Context) (*Session, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Session.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSession sets the old Session of the mutation.
func withSession(node *Session) sessionOption {
	return func(m *SessionMutation) {
		m.oldValue = func(context.Context) (*Session, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Session entities.
func (m *SessionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SessionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SessionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Session.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetData sets the "data" field.
func (m *SessionMutation) SetData(s string) {
	m.data = &s
}

// Data returns the value of the "data" field in the mutation.
func (m *SessionMutation) Data() (r string, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData resets all changes to the "data" field.
func (m *SessionMutation) ResetData() {
	m.data = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SessionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SessionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SessionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *SessionMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *SessionMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *SessionMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// Where appends a list predicates to the SessionMutation builder.
func (m *SessionMutation) Where(ps ...predicate.Session) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Session, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Session).
func (m *SessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SessionMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.data != nil {
		fields = append(fields, session.FieldData)
	}
	if m.created_at != nil {
		fields = append(fields, session.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, session.FieldUpdatedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, session.FieldExpiresAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case session.FieldData:
		return m.Data()
	case session.FieldCreatedAt:
		return m.CreatedAt()
	case session.FieldUpdatedAt:
		return m.UpdatedAt()
	case session.FieldExpiresAt:
		return m.ExpiresAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case session.FieldData:
		return m.OldData(ctx)
	case session.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case session.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case session.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	}
	return nil, fmt.Errorf("unknown Session field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case session.FieldData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	case session.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case session.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case session.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Session numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SessionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Session nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SessionMutation) ResetField(name string) error {
	switch name {
	case session.FieldData:
		m.ResetData()
		return nil
	case session.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case session.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case session.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SessionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SessionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SessionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Session unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SessionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Session edge %s", name)
}

// ShipmentMutation represents an operation that mutates the Shipment nodes in the graph.
type ShipmentMutation struct {
	config
	op                            Op
	typ                           string
	id                            *uuid.UUID
	created_at                    *time.Time
	updated_at                    *time.Time
	version                       *int
	addversion                    *int
	pro_number                    *string
	status                        *shipment.Status
	origin_address_line           *string
	origin_appointment_start      *time.Time
	origin_appointment_end        *time.Time
	destination_address_line      *string
	destination_appointment_start *time.Time
	destination_appointment_end   *time.Time
	rating_unit                   *int
	addrating_unit                *int
	mileage                       *float64
	addmileage                    *float64
	other_charge_amount           *float64
	addother_charge_amount        *float64
	freight_charge_amount         *float64
	addfreight_charge_amount      *float64
	rating_method                 *shipment.RatingMethod
	pieces                        *float64
	addpieces                     *float64
	weight                        *float64
	addweight                     *float64
	ready_to_bill                 *bool
	bill_date                     **pgtype.Date
	ship_date                     **pgtype.Date
	billed                        *bool
	transferred_to_billing        *bool
	transferred_to_billing_date   **pgtype.Date
	total_charge_amount           *float64
	addtotal_charge_amount        *float64
	temperature_min               *int
	addtemperature_min            *int
	temperature_max               *int
	addtemperature_max            *int
	bill_of_lading_number         *string
	consignee_reference_number    *string
	comment                       *string
	voided_comment                *string
	auto_rated                    *bool
	current_suffix                *string
	entry_method                  *shipment.EntryMethod
	is_hazardous                  *bool
	clearedFields                 map[string]struct{}
	business_unit                 *uuid.UUID
	clearedbusiness_unit          bool
	organization                  *uuid.UUID
	clearedorganization           bool
	shipment_type                 *uuid.UUID
	clearedshipment_type          bool
	service_type                  *uuid.UUID
	clearedservice_type           bool
	revenue_code                  *uuid.UUID
	clearedrevenue_code           bool
	origin_location               *uuid.UUID
	clearedorigin_location        bool
	destination_location          *uuid.UUID
	cleareddestination_location   bool
	trailer_type                  *uuid.UUID
	clearedtrailer_type           bool
	tractor_type                  *uuid.UUID
	clearedtractor_type           bool
	shipment_documentation        map[uuid.UUID]struct{}
	removedshipment_documentation map[uuid.UUID]struct{}
	clearedshipment_documentation bool
	shipment_comments             map[uuid.UUID]struct{}
	removedshipment_comments      map[uuid.UUID]struct{}
	clearedshipment_comments      bool
	shipment_charges              map[uuid.UUID]struct{}
	removedshipment_charges       map[uuid.UUID]struct{}
	clearedshipment_charges       bool
	shipment_commodities          map[uuid.UUID]struct{}
	removedshipment_commodities   map[uuid.UUID]struct{}
	clearedshipment_commodities   bool
	created_by_user               *uuid.UUID
	clearedcreated_by_user        bool
	customer                      *uuid.UUID
	clearedcustomer               bool
	shipment_moves                map[uuid.UUID]struct{}
	removedshipment_moves         map[uuid.UUID]struct{}
	clearedshipment_moves         bool
	done                          bool
	oldValue                      func(context.Context) (*Shipment, error)
	predicates                    []predicate.Shipment
}

var _ ent.Mutation = (*ShipmentMutation)(nil)

// shipmentOption allows management of the mutation configuration using functional options.
type shipmentOption func(*ShipmentMutation)

// newShipmentMutation creates new mutation for the Shipment entity.
func newShipmentMutation(c config, op Op, opts ...shipmentOption) *ShipmentMutation {
	m := &ShipmentMutation{
		config:        c,
		op:            op,
		typ:           TypeShipment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShipmentID sets the ID field of the mutation.
func withShipmentID(id uuid.UUID) shipmentOption {
	return func(m *ShipmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Shipment
		)
		m.oldValue = func(ctx context.Context) (*Shipment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Shipment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShipment sets the old Shipment of the mutation.
func withShipment(node *Shipment) shipmentOption {
	return func(m *ShipmentMutation) {
		m.oldValue = func(context.Context) (*Shipment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShipmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShipmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Shipment entities.
func (m *ShipmentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShipmentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ShipmentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Shipment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *ShipmentMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *ShipmentMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *ShipmentMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *ShipmentMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *ShipmentMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *ShipmentMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ShipmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ShipmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ShipmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ShipmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ShipmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ShipmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *ShipmentMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *ShipmentMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *ShipmentMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *ShipmentMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *ShipmentMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetProNumber sets the "pro_number" field.
func (m *ShipmentMutation) SetProNumber(s string) {
	m.pro_number = &s
}

// ProNumber returns the value of the "pro_number" field in the mutation.
func (m *ShipmentMutation) ProNumber() (r string, exists bool) {
	v := m.pro_number
	if v == nil {
		return
	}
	return *v, true
}

// OldProNumber returns the old "pro_number" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldProNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProNumber: %w", err)
	}
	return oldValue.ProNumber, nil
}

// ResetProNumber resets all changes to the "pro_number" field.
func (m *ShipmentMutation) ResetProNumber() {
	m.pro_number = nil
}

// SetStatus sets the "status" field.
func (m *ShipmentMutation) SetStatus(s shipment.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ShipmentMutation) Status() (r shipment.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldStatus(ctx context.Context) (v shipment.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ShipmentMutation) ResetStatus() {
	m.status = nil
}

// SetOriginLocationID sets the "origin_location_id" field.
func (m *ShipmentMutation) SetOriginLocationID(u uuid.UUID) {
	m.origin_location = &u
}

// OriginLocationID returns the value of the "origin_location_id" field in the mutation.
func (m *ShipmentMutation) OriginLocationID() (r uuid.UUID, exists bool) {
	v := m.origin_location
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginLocationID returns the old "origin_location_id" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldOriginLocationID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginLocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginLocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginLocationID: %w", err)
	}
	return oldValue.OriginLocationID, nil
}

// ClearOriginLocationID clears the value of the "origin_location_id" field.
func (m *ShipmentMutation) ClearOriginLocationID() {
	m.origin_location = nil
	m.clearedFields[shipment.FieldOriginLocationID] = struct{}{}
}

// OriginLocationIDCleared returns if the "origin_location_id" field was cleared in this mutation.
func (m *ShipmentMutation) OriginLocationIDCleared() bool {
	_, ok := m.clearedFields[shipment.FieldOriginLocationID]
	return ok
}

// ResetOriginLocationID resets all changes to the "origin_location_id" field.
func (m *ShipmentMutation) ResetOriginLocationID() {
	m.origin_location = nil
	delete(m.clearedFields, shipment.FieldOriginLocationID)
}

// SetOriginAddressLine sets the "origin_address_line" field.
func (m *ShipmentMutation) SetOriginAddressLine(s string) {
	m.origin_address_line = &s
}

// OriginAddressLine returns the value of the "origin_address_line" field in the mutation.
func (m *ShipmentMutation) OriginAddressLine() (r string, exists bool) {
	v := m.origin_address_line
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginAddressLine returns the old "origin_address_line" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldOriginAddressLine(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginAddressLine is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginAddressLine requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginAddressLine: %w", err)
	}
	return oldValue.OriginAddressLine, nil
}

// ClearOriginAddressLine clears the value of the "origin_address_line" field.
func (m *ShipmentMutation) ClearOriginAddressLine() {
	m.origin_address_line = nil
	m.clearedFields[shipment.FieldOriginAddressLine] = struct{}{}
}

// OriginAddressLineCleared returns if the "origin_address_line" field was cleared in this mutation.
func (m *ShipmentMutation) OriginAddressLineCleared() bool {
	_, ok := m.clearedFields[shipment.FieldOriginAddressLine]
	return ok
}

// ResetOriginAddressLine resets all changes to the "origin_address_line" field.
func (m *ShipmentMutation) ResetOriginAddressLine() {
	m.origin_address_line = nil
	delete(m.clearedFields, shipment.FieldOriginAddressLine)
}

// SetOriginAppointmentStart sets the "origin_appointment_start" field.
func (m *ShipmentMutation) SetOriginAppointmentStart(t time.Time) {
	m.origin_appointment_start = &t
}

// OriginAppointmentStart returns the value of the "origin_appointment_start" field in the mutation.
func (m *ShipmentMutation) OriginAppointmentStart() (r time.Time, exists bool) {
	v := m.origin_appointment_start
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginAppointmentStart returns the old "origin_appointment_start" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldOriginAppointmentStart(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginAppointmentStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginAppointmentStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginAppointmentStart: %w", err)
	}
	return oldValue.OriginAppointmentStart, nil
}

// ClearOriginAppointmentStart clears the value of the "origin_appointment_start" field.
func (m *ShipmentMutation) ClearOriginAppointmentStart() {
	m.origin_appointment_start = nil
	m.clearedFields[shipment.FieldOriginAppointmentStart] = struct{}{}
}

// OriginAppointmentStartCleared returns if the "origin_appointment_start" field was cleared in this mutation.
func (m *ShipmentMutation) OriginAppointmentStartCleared() bool {
	_, ok := m.clearedFields[shipment.FieldOriginAppointmentStart]
	return ok
}

// ResetOriginAppointmentStart resets all changes to the "origin_appointment_start" field.
func (m *ShipmentMutation) ResetOriginAppointmentStart() {
	m.origin_appointment_start = nil
	delete(m.clearedFields, shipment.FieldOriginAppointmentStart)
}

// SetOriginAppointmentEnd sets the "origin_appointment_end" field.
func (m *ShipmentMutation) SetOriginAppointmentEnd(t time.Time) {
	m.origin_appointment_end = &t
}

// OriginAppointmentEnd returns the value of the "origin_appointment_end" field in the mutation.
func (m *ShipmentMutation) OriginAppointmentEnd() (r time.Time, exists bool) {
	v := m.origin_appointment_end
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginAppointmentEnd returns the old "origin_appointment_end" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldOriginAppointmentEnd(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginAppointmentEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginAppointmentEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginAppointmentEnd: %w", err)
	}
	return oldValue.OriginAppointmentEnd, nil
}

// ClearOriginAppointmentEnd clears the value of the "origin_appointment_end" field.
func (m *ShipmentMutation) ClearOriginAppointmentEnd() {
	m.origin_appointment_end = nil
	m.clearedFields[shipment.FieldOriginAppointmentEnd] = struct{}{}
}

// OriginAppointmentEndCleared returns if the "origin_appointment_end" field was cleared in this mutation.
func (m *ShipmentMutation) OriginAppointmentEndCleared() bool {
	_, ok := m.clearedFields[shipment.FieldOriginAppointmentEnd]
	return ok
}

// ResetOriginAppointmentEnd resets all changes to the "origin_appointment_end" field.
func (m *ShipmentMutation) ResetOriginAppointmentEnd() {
	m.origin_appointment_end = nil
	delete(m.clearedFields, shipment.FieldOriginAppointmentEnd)
}

// SetDestinationLocationID sets the "destination_location_id" field.
func (m *ShipmentMutation) SetDestinationLocationID(u uuid.UUID) {
	m.destination_location = &u
}

// DestinationLocationID returns the value of the "destination_location_id" field in the mutation.
func (m *ShipmentMutation) DestinationLocationID() (r uuid.UUID, exists bool) {
	v := m.destination_location
	if v == nil {
		return
	}
	return *v, true
}

// OldDestinationLocationID returns the old "destination_location_id" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldDestinationLocationID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDestinationLocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDestinationLocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDestinationLocationID: %w", err)
	}
	return oldValue.DestinationLocationID, nil
}

// ClearDestinationLocationID clears the value of the "destination_location_id" field.
func (m *ShipmentMutation) ClearDestinationLocationID() {
	m.destination_location = nil
	m.clearedFields[shipment.FieldDestinationLocationID] = struct{}{}
}

// DestinationLocationIDCleared returns if the "destination_location_id" field was cleared in this mutation.
func (m *ShipmentMutation) DestinationLocationIDCleared() bool {
	_, ok := m.clearedFields[shipment.FieldDestinationLocationID]
	return ok
}

// ResetDestinationLocationID resets all changes to the "destination_location_id" field.
func (m *ShipmentMutation) ResetDestinationLocationID() {
	m.destination_location = nil
	delete(m.clearedFields, shipment.FieldDestinationLocationID)
}

// SetDestinationAddressLine sets the "destination_address_line" field.
func (m *ShipmentMutation) SetDestinationAddressLine(s string) {
	m.destination_address_line = &s
}

// DestinationAddressLine returns the value of the "destination_address_line" field in the mutation.
func (m *ShipmentMutation) DestinationAddressLine() (r string, exists bool) {
	v := m.destination_address_line
	if v == nil {
		return
	}
	return *v, true
}

// OldDestinationAddressLine returns the old "destination_address_line" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldDestinationAddressLine(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDestinationAddressLine is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDestinationAddressLine requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDestinationAddressLine: %w", err)
	}
	return oldValue.DestinationAddressLine, nil
}

// ClearDestinationAddressLine clears the value of the "destination_address_line" field.
func (m *ShipmentMutation) ClearDestinationAddressLine() {
	m.destination_address_line = nil
	m.clearedFields[shipment.FieldDestinationAddressLine] = struct{}{}
}

// DestinationAddressLineCleared returns if the "destination_address_line" field was cleared in this mutation.
func (m *ShipmentMutation) DestinationAddressLineCleared() bool {
	_, ok := m.clearedFields[shipment.FieldDestinationAddressLine]
	return ok
}

// ResetDestinationAddressLine resets all changes to the "destination_address_line" field.
func (m *ShipmentMutation) ResetDestinationAddressLine() {
	m.destination_address_line = nil
	delete(m.clearedFields, shipment.FieldDestinationAddressLine)
}

// SetDestinationAppointmentStart sets the "destination_appointment_start" field.
func (m *ShipmentMutation) SetDestinationAppointmentStart(t time.Time) {
	m.destination_appointment_start = &t
}

// DestinationAppointmentStart returns the value of the "destination_appointment_start" field in the mutation.
func (m *ShipmentMutation) DestinationAppointmentStart() (r time.Time, exists bool) {
	v := m.destination_appointment_start
	if v == nil {
		return
	}
	return *v, true
}

// OldDestinationAppointmentStart returns the old "destination_appointment_start" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldDestinationAppointmentStart(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDestinationAppointmentStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDestinationAppointmentStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDestinationAppointmentStart: %w", err)
	}
	return oldValue.DestinationAppointmentStart, nil
}

// ClearDestinationAppointmentStart clears the value of the "destination_appointment_start" field.
func (m *ShipmentMutation) ClearDestinationAppointmentStart() {
	m.destination_appointment_start = nil
	m.clearedFields[shipment.FieldDestinationAppointmentStart] = struct{}{}
}

// DestinationAppointmentStartCleared returns if the "destination_appointment_start" field was cleared in this mutation.
func (m *ShipmentMutation) DestinationAppointmentStartCleared() bool {
	_, ok := m.clearedFields[shipment.FieldDestinationAppointmentStart]
	return ok
}

// ResetDestinationAppointmentStart resets all changes to the "destination_appointment_start" field.
func (m *ShipmentMutation) ResetDestinationAppointmentStart() {
	m.destination_appointment_start = nil
	delete(m.clearedFields, shipment.FieldDestinationAppointmentStart)
}

// SetDestinationAppointmentEnd sets the "destination_appointment_end" field.
func (m *ShipmentMutation) SetDestinationAppointmentEnd(t time.Time) {
	m.destination_appointment_end = &t
}

// DestinationAppointmentEnd returns the value of the "destination_appointment_end" field in the mutation.
func (m *ShipmentMutation) DestinationAppointmentEnd() (r time.Time, exists bool) {
	v := m.destination_appointment_end
	if v == nil {
		return
	}
	return *v, true
}

// OldDestinationAppointmentEnd returns the old "destination_appointment_end" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldDestinationAppointmentEnd(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDestinationAppointmentEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDestinationAppointmentEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDestinationAppointmentEnd: %w", err)
	}
	return oldValue.DestinationAppointmentEnd, nil
}

// ClearDestinationAppointmentEnd clears the value of the "destination_appointment_end" field.
func (m *ShipmentMutation) ClearDestinationAppointmentEnd() {
	m.destination_appointment_end = nil
	m.clearedFields[shipment.FieldDestinationAppointmentEnd] = struct{}{}
}

// DestinationAppointmentEndCleared returns if the "destination_appointment_end" field was cleared in this mutation.
func (m *ShipmentMutation) DestinationAppointmentEndCleared() bool {
	_, ok := m.clearedFields[shipment.FieldDestinationAppointmentEnd]
	return ok
}

// ResetDestinationAppointmentEnd resets all changes to the "destination_appointment_end" field.
func (m *ShipmentMutation) ResetDestinationAppointmentEnd() {
	m.destination_appointment_end = nil
	delete(m.clearedFields, shipment.FieldDestinationAppointmentEnd)
}

// SetShipmentTypeID sets the "shipment_type_id" field.
func (m *ShipmentMutation) SetShipmentTypeID(u uuid.UUID) {
	m.shipment_type = &u
}

// ShipmentTypeID returns the value of the "shipment_type_id" field in the mutation.
func (m *ShipmentMutation) ShipmentTypeID() (r uuid.UUID, exists bool) {
	v := m.shipment_type
	if v == nil {
		return
	}
	return *v, true
}

// OldShipmentTypeID returns the old "shipment_type_id" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldShipmentTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShipmentTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShipmentTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipmentTypeID: %w", err)
	}
	return oldValue.ShipmentTypeID, nil
}

// ResetShipmentTypeID resets all changes to the "shipment_type_id" field.
func (m *ShipmentMutation) ResetShipmentTypeID() {
	m.shipment_type = nil
}

// SetRevenueCodeID sets the "revenue_code_id" field.
func (m *ShipmentMutation) SetRevenueCodeID(u uuid.UUID) {
	m.revenue_code = &u
}

// RevenueCodeID returns the value of the "revenue_code_id" field in the mutation.
func (m *ShipmentMutation) RevenueCodeID() (r uuid.UUID, exists bool) {
	v := m.revenue_code
	if v == nil {
		return
	}
	return *v, true
}

// OldRevenueCodeID returns the old "revenue_code_id" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldRevenueCodeID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevenueCodeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevenueCodeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevenueCodeID: %w", err)
	}
	return oldValue.RevenueCodeID, nil
}

// ClearRevenueCodeID clears the value of the "revenue_code_id" field.
func (m *ShipmentMutation) ClearRevenueCodeID() {
	m.revenue_code = nil
	m.clearedFields[shipment.FieldRevenueCodeID] = struct{}{}
}

// RevenueCodeIDCleared returns if the "revenue_code_id" field was cleared in this mutation.
func (m *ShipmentMutation) RevenueCodeIDCleared() bool {
	_, ok := m.clearedFields[shipment.FieldRevenueCodeID]
	return ok
}

// ResetRevenueCodeID resets all changes to the "revenue_code_id" field.
func (m *ShipmentMutation) ResetRevenueCodeID() {
	m.revenue_code = nil
	delete(m.clearedFields, shipment.FieldRevenueCodeID)
}

// SetServiceTypeID sets the "service_type_id" field.
func (m *ShipmentMutation) SetServiceTypeID(u uuid.UUID) {
	m.service_type = &u
}

// ServiceTypeID returns the value of the "service_type_id" field in the mutation.
func (m *ShipmentMutation) ServiceTypeID() (r uuid.UUID, exists bool) {
	v := m.service_type
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceTypeID returns the old "service_type_id" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldServiceTypeID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceTypeID: %w", err)
	}
	return oldValue.ServiceTypeID, nil
}

// ClearServiceTypeID clears the value of the "service_type_id" field.
func (m *ShipmentMutation) ClearServiceTypeID() {
	m.service_type = nil
	m.clearedFields[shipment.FieldServiceTypeID] = struct{}{}
}

// ServiceTypeIDCleared returns if the "service_type_id" field was cleared in this mutation.
func (m *ShipmentMutation) ServiceTypeIDCleared() bool {
	_, ok := m.clearedFields[shipment.FieldServiceTypeID]
	return ok
}

// ResetServiceTypeID resets all changes to the "service_type_id" field.
func (m *ShipmentMutation) ResetServiceTypeID() {
	m.service_type = nil
	delete(m.clearedFields, shipment.FieldServiceTypeID)
}

// SetRatingUnit sets the "rating_unit" field.
func (m *ShipmentMutation) SetRatingUnit(i int) {
	m.rating_unit = &i
	m.addrating_unit = nil
}

// RatingUnit returns the value of the "rating_unit" field in the mutation.
func (m *ShipmentMutation) RatingUnit() (r int, exists bool) {
	v := m.rating_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldRatingUnit returns the old "rating_unit" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldRatingUnit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRatingUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRatingUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRatingUnit: %w", err)
	}
	return oldValue.RatingUnit, nil
}

// AddRatingUnit adds i to the "rating_unit" field.
func (m *ShipmentMutation) AddRatingUnit(i int) {
	if m.addrating_unit != nil {
		*m.addrating_unit += i
	} else {
		m.addrating_unit = &i
	}
}

// AddedRatingUnit returns the value that was added to the "rating_unit" field in this mutation.
func (m *ShipmentMutation) AddedRatingUnit() (r int, exists bool) {
	v := m.addrating_unit
	if v == nil {
		return
	}
	return *v, true
}

// ResetRatingUnit resets all changes to the "rating_unit" field.
func (m *ShipmentMutation) ResetRatingUnit() {
	m.rating_unit = nil
	m.addrating_unit = nil
}

// SetMileage sets the "mileage" field.
func (m *ShipmentMutation) SetMileage(f float64) {
	m.mileage = &f
	m.addmileage = nil
}

// Mileage returns the value of the "mileage" field in the mutation.
func (m *ShipmentMutation) Mileage() (r float64, exists bool) {
	v := m.mileage
	if v == nil {
		return
	}
	return *v, true
}

// OldMileage returns the old "mileage" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldMileage(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMileage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMileage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMileage: %w", err)
	}
	return oldValue.Mileage, nil
}

// AddMileage adds f to the "mileage" field.
func (m *ShipmentMutation) AddMileage(f float64) {
	if m.addmileage != nil {
		*m.addmileage += f
	} else {
		m.addmileage = &f
	}
}

// AddedMileage returns the value that was added to the "mileage" field in this mutation.
func (m *ShipmentMutation) AddedMileage() (r float64, exists bool) {
	v := m.addmileage
	if v == nil {
		return
	}
	return *v, true
}

// ClearMileage clears the value of the "mileage" field.
func (m *ShipmentMutation) ClearMileage() {
	m.mileage = nil
	m.addmileage = nil
	m.clearedFields[shipment.FieldMileage] = struct{}{}
}

// MileageCleared returns if the "mileage" field was cleared in this mutation.
func (m *ShipmentMutation) MileageCleared() bool {
	_, ok := m.clearedFields[shipment.FieldMileage]
	return ok
}

// ResetMileage resets all changes to the "mileage" field.
func (m *ShipmentMutation) ResetMileage() {
	m.mileage = nil
	m.addmileage = nil
	delete(m.clearedFields, shipment.FieldMileage)
}

// SetOtherChargeAmount sets the "other_charge_amount" field.
func (m *ShipmentMutation) SetOtherChargeAmount(f float64) {
	m.other_charge_amount = &f
	m.addother_charge_amount = nil
}

// OtherChargeAmount returns the value of the "other_charge_amount" field in the mutation.
func (m *ShipmentMutation) OtherChargeAmount() (r float64, exists bool) {
	v := m.other_charge_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherChargeAmount returns the old "other_charge_amount" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldOtherChargeAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherChargeAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherChargeAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherChargeAmount: %w", err)
	}
	return oldValue.OtherChargeAmount, nil
}

// AddOtherChargeAmount adds f to the "other_charge_amount" field.
func (m *ShipmentMutation) AddOtherChargeAmount(f float64) {
	if m.addother_charge_amount != nil {
		*m.addother_charge_amount += f
	} else {
		m.addother_charge_amount = &f
	}
}

// AddedOtherChargeAmount returns the value that was added to the "other_charge_amount" field in this mutation.
func (m *ShipmentMutation) AddedOtherChargeAmount() (r float64, exists bool) {
	v := m.addother_charge_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearOtherChargeAmount clears the value of the "other_charge_amount" field.
func (m *ShipmentMutation) ClearOtherChargeAmount() {
	m.other_charge_amount = nil
	m.addother_charge_amount = nil
	m.clearedFields[shipment.FieldOtherChargeAmount] = struct{}{}
}

// OtherChargeAmountCleared returns if the "other_charge_amount" field was cleared in this mutation.
func (m *ShipmentMutation) OtherChargeAmountCleared() bool {
	_, ok := m.clearedFields[shipment.FieldOtherChargeAmount]
	return ok
}

// ResetOtherChargeAmount resets all changes to the "other_charge_amount" field.
func (m *ShipmentMutation) ResetOtherChargeAmount() {
	m.other_charge_amount = nil
	m.addother_charge_amount = nil
	delete(m.clearedFields, shipment.FieldOtherChargeAmount)
}

// SetFreightChargeAmount sets the "freight_charge_amount" field.
func (m *ShipmentMutation) SetFreightChargeAmount(f float64) {
	m.freight_charge_amount = &f
	m.addfreight_charge_amount = nil
}

// FreightChargeAmount returns the value of the "freight_charge_amount" field in the mutation.
func (m *ShipmentMutation) FreightChargeAmount() (r float64, exists bool) {
	v := m.freight_charge_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldFreightChargeAmount returns the old "freight_charge_amount" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldFreightChargeAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFreightChargeAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFreightChargeAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFreightChargeAmount: %w", err)
	}
	return oldValue.FreightChargeAmount, nil
}

// AddFreightChargeAmount adds f to the "freight_charge_amount" field.
func (m *ShipmentMutation) AddFreightChargeAmount(f float64) {
	if m.addfreight_charge_amount != nil {
		*m.addfreight_charge_amount += f
	} else {
		m.addfreight_charge_amount = &f
	}
}

// AddedFreightChargeAmount returns the value that was added to the "freight_charge_amount" field in this mutation.
func (m *ShipmentMutation) AddedFreightChargeAmount() (r float64, exists bool) {
	v := m.addfreight_charge_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearFreightChargeAmount clears the value of the "freight_charge_amount" field.
func (m *ShipmentMutation) ClearFreightChargeAmount() {
	m.freight_charge_amount = nil
	m.addfreight_charge_amount = nil
	m.clearedFields[shipment.FieldFreightChargeAmount] = struct{}{}
}

// FreightChargeAmountCleared returns if the "freight_charge_amount" field was cleared in this mutation.
func (m *ShipmentMutation) FreightChargeAmountCleared() bool {
	_, ok := m.clearedFields[shipment.FieldFreightChargeAmount]
	return ok
}

// ResetFreightChargeAmount resets all changes to the "freight_charge_amount" field.
func (m *ShipmentMutation) ResetFreightChargeAmount() {
	m.freight_charge_amount = nil
	m.addfreight_charge_amount = nil
	delete(m.clearedFields, shipment.FieldFreightChargeAmount)
}

// SetRatingMethod sets the "rating_method" field.
func (m *ShipmentMutation) SetRatingMethod(sm shipment.RatingMethod) {
	m.rating_method = &sm
}

// RatingMethod returns the value of the "rating_method" field in the mutation.
func (m *ShipmentMutation) RatingMethod() (r shipment.RatingMethod, exists bool) {
	v := m.rating_method
	if v == nil {
		return
	}
	return *v, true
}

// OldRatingMethod returns the old "rating_method" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldRatingMethod(ctx context.Context) (v shipment.RatingMethod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRatingMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRatingMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRatingMethod: %w", err)
	}
	return oldValue.RatingMethod, nil
}

// ResetRatingMethod resets all changes to the "rating_method" field.
func (m *ShipmentMutation) ResetRatingMethod() {
	m.rating_method = nil
}

// SetCustomerID sets the "customer_id" field.
func (m *ShipmentMutation) SetCustomerID(u uuid.UUID) {
	m.customer = &u
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *ShipmentMutation) CustomerID() (r uuid.UUID, exists bool) {
	v := m.customer
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldCustomerID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *ShipmentMutation) ResetCustomerID() {
	m.customer = nil
}

// SetPieces sets the "pieces" field.
func (m *ShipmentMutation) SetPieces(f float64) {
	m.pieces = &f
	m.addpieces = nil
}

// Pieces returns the value of the "pieces" field in the mutation.
func (m *ShipmentMutation) Pieces() (r float64, exists bool) {
	v := m.pieces
	if v == nil {
		return
	}
	return *v, true
}

// OldPieces returns the old "pieces" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldPieces(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPieces is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPieces requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPieces: %w", err)
	}
	return oldValue.Pieces, nil
}

// AddPieces adds f to the "pieces" field.
func (m *ShipmentMutation) AddPieces(f float64) {
	if m.addpieces != nil {
		*m.addpieces += f
	} else {
		m.addpieces = &f
	}
}

// AddedPieces returns the value that was added to the "pieces" field in this mutation.
func (m *ShipmentMutation) AddedPieces() (r float64, exists bool) {
	v := m.addpieces
	if v == nil {
		return
	}
	return *v, true
}

// ClearPieces clears the value of the "pieces" field.
func (m *ShipmentMutation) ClearPieces() {
	m.pieces = nil
	m.addpieces = nil
	m.clearedFields[shipment.FieldPieces] = struct{}{}
}

// PiecesCleared returns if the "pieces" field was cleared in this mutation.
func (m *ShipmentMutation) PiecesCleared() bool {
	_, ok := m.clearedFields[shipment.FieldPieces]
	return ok
}

// ResetPieces resets all changes to the "pieces" field.
func (m *ShipmentMutation) ResetPieces() {
	m.pieces = nil
	m.addpieces = nil
	delete(m.clearedFields, shipment.FieldPieces)
}

// SetWeight sets the "weight" field.
func (m *ShipmentMutation) SetWeight(f float64) {
	m.weight = &f
	m.addweight = nil
}

// Weight returns the value of the "weight" field in the mutation.
func (m *ShipmentMutation) Weight() (r float64, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old "weight" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldWeight(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds f to the "weight" field.
func (m *ShipmentMutation) AddWeight(f float64) {
	if m.addweight != nil {
		*m.addweight += f
	} else {
		m.addweight = &f
	}
}

// AddedWeight returns the value that was added to the "weight" field in this mutation.
func (m *ShipmentMutation) AddedWeight() (r float64, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ClearWeight clears the value of the "weight" field.
func (m *ShipmentMutation) ClearWeight() {
	m.weight = nil
	m.addweight = nil
	m.clearedFields[shipment.FieldWeight] = struct{}{}
}

// WeightCleared returns if the "weight" field was cleared in this mutation.
func (m *ShipmentMutation) WeightCleared() bool {
	_, ok := m.clearedFields[shipment.FieldWeight]
	return ok
}

// ResetWeight resets all changes to the "weight" field.
func (m *ShipmentMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
	delete(m.clearedFields, shipment.FieldWeight)
}

// SetReadyToBill sets the "ready_to_bill" field.
func (m *ShipmentMutation) SetReadyToBill(b bool) {
	m.ready_to_bill = &b
}

// ReadyToBill returns the value of the "ready_to_bill" field in the mutation.
func (m *ShipmentMutation) ReadyToBill() (r bool, exists bool) {
	v := m.ready_to_bill
	if v == nil {
		return
	}
	return *v, true
}

// OldReadyToBill returns the old "ready_to_bill" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldReadyToBill(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReadyToBill is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReadyToBill requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReadyToBill: %w", err)
	}
	return oldValue.ReadyToBill, nil
}

// ResetReadyToBill resets all changes to the "ready_to_bill" field.
func (m *ShipmentMutation) ResetReadyToBill() {
	m.ready_to_bill = nil
}

// SetBillDate sets the "bill_date" field.
func (m *ShipmentMutation) SetBillDate(pg *pgtype.Date) {
	m.bill_date = &pg
}

// BillDate returns the value of the "bill_date" field in the mutation.
func (m *ShipmentMutation) BillDate() (r *pgtype.Date, exists bool) {
	v := m.bill_date
	if v == nil {
		return
	}
	return *v, true
}

// OldBillDate returns the old "bill_date" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldBillDate(ctx context.Context) (v *pgtype.Date, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillDate: %w", err)
	}
	return oldValue.BillDate, nil
}

// ClearBillDate clears the value of the "bill_date" field.
func (m *ShipmentMutation) ClearBillDate() {
	m.bill_date = nil
	m.clearedFields[shipment.FieldBillDate] = struct{}{}
}

// BillDateCleared returns if the "bill_date" field was cleared in this mutation.
func (m *ShipmentMutation) BillDateCleared() bool {
	_, ok := m.clearedFields[shipment.FieldBillDate]
	return ok
}

// ResetBillDate resets all changes to the "bill_date" field.
func (m *ShipmentMutation) ResetBillDate() {
	m.bill_date = nil
	delete(m.clearedFields, shipment.FieldBillDate)
}

// SetShipDate sets the "ship_date" field.
func (m *ShipmentMutation) SetShipDate(pg *pgtype.Date) {
	m.ship_date = &pg
}

// ShipDate returns the value of the "ship_date" field in the mutation.
func (m *ShipmentMutation) ShipDate() (r *pgtype.Date, exists bool) {
	v := m.ship_date
	if v == nil {
		return
	}
	return *v, true
}

// OldShipDate returns the old "ship_date" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldShipDate(ctx context.Context) (v *pgtype.Date, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShipDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShipDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipDate: %w", err)
	}
	return oldValue.ShipDate, nil
}

// ClearShipDate clears the value of the "ship_date" field.
func (m *ShipmentMutation) ClearShipDate() {
	m.ship_date = nil
	m.clearedFields[shipment.FieldShipDate] = struct{}{}
}

// ShipDateCleared returns if the "ship_date" field was cleared in this mutation.
func (m *ShipmentMutation) ShipDateCleared() bool {
	_, ok := m.clearedFields[shipment.FieldShipDate]
	return ok
}

// ResetShipDate resets all changes to the "ship_date" field.
func (m *ShipmentMutation) ResetShipDate() {
	m.ship_date = nil
	delete(m.clearedFields, shipment.FieldShipDate)
}

// SetBilled sets the "billed" field.
func (m *ShipmentMutation) SetBilled(b bool) {
	m.billed = &b
}

// Billed returns the value of the "billed" field in the mutation.
func (m *ShipmentMutation) Billed() (r bool, exists bool) {
	v := m.billed
	if v == nil {
		return
	}
	return *v, true
}

// OldBilled returns the old "billed" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldBilled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBilled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBilled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBilled: %w", err)
	}
	return oldValue.Billed, nil
}

// ResetBilled resets all changes to the "billed" field.
func (m *ShipmentMutation) ResetBilled() {
	m.billed = nil
}

// SetTransferredToBilling sets the "transferred_to_billing" field.
func (m *ShipmentMutation) SetTransferredToBilling(b bool) {
	m.transferred_to_billing = &b
}

// TransferredToBilling returns the value of the "transferred_to_billing" field in the mutation.
func (m *ShipmentMutation) TransferredToBilling() (r bool, exists bool) {
	v := m.transferred_to_billing
	if v == nil {
		return
	}
	return *v, true
}

// OldTransferredToBilling returns the old "transferred_to_billing" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldTransferredToBilling(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransferredToBilling is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransferredToBilling requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransferredToBilling: %w", err)
	}
	return oldValue.TransferredToBilling, nil
}

// ResetTransferredToBilling resets all changes to the "transferred_to_billing" field.
func (m *ShipmentMutation) ResetTransferredToBilling() {
	m.transferred_to_billing = nil
}

// SetTransferredToBillingDate sets the "transferred_to_billing_date" field.
func (m *ShipmentMutation) SetTransferredToBillingDate(pg *pgtype.Date) {
	m.transferred_to_billing_date = &pg
}

// TransferredToBillingDate returns the value of the "transferred_to_billing_date" field in the mutation.
func (m *ShipmentMutation) TransferredToBillingDate() (r *pgtype.Date, exists bool) {
	v := m.transferred_to_billing_date
	if v == nil {
		return
	}
	return *v, true
}

// OldTransferredToBillingDate returns the old "transferred_to_billing_date" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldTransferredToBillingDate(ctx context.Context) (v *pgtype.Date, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransferredToBillingDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransferredToBillingDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransferredToBillingDate: %w", err)
	}
	return oldValue.TransferredToBillingDate, nil
}

// ClearTransferredToBillingDate clears the value of the "transferred_to_billing_date" field.
func (m *ShipmentMutation) ClearTransferredToBillingDate() {
	m.transferred_to_billing_date = nil
	m.clearedFields[shipment.FieldTransferredToBillingDate] = struct{}{}
}

// TransferredToBillingDateCleared returns if the "transferred_to_billing_date" field was cleared in this mutation.
func (m *ShipmentMutation) TransferredToBillingDateCleared() bool {
	_, ok := m.clearedFields[shipment.FieldTransferredToBillingDate]
	return ok
}

// ResetTransferredToBillingDate resets all changes to the "transferred_to_billing_date" field.
func (m *ShipmentMutation) ResetTransferredToBillingDate() {
	m.transferred_to_billing_date = nil
	delete(m.clearedFields, shipment.FieldTransferredToBillingDate)
}

// SetTotalChargeAmount sets the "total_charge_amount" field.
func (m *ShipmentMutation) SetTotalChargeAmount(f float64) {
	m.total_charge_amount = &f
	m.addtotal_charge_amount = nil
}

// TotalChargeAmount returns the value of the "total_charge_amount" field in the mutation.
func (m *ShipmentMutation) TotalChargeAmount() (r float64, exists bool) {
	v := m.total_charge_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalChargeAmount returns the old "total_charge_amount" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldTotalChargeAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalChargeAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalChargeAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalChargeAmount: %w", err)
	}
	return oldValue.TotalChargeAmount, nil
}

// AddTotalChargeAmount adds f to the "total_charge_amount" field.
func (m *ShipmentMutation) AddTotalChargeAmount(f float64) {
	if m.addtotal_charge_amount != nil {
		*m.addtotal_charge_amount += f
	} else {
		m.addtotal_charge_amount = &f
	}
}

// AddedTotalChargeAmount returns the value that was added to the "total_charge_amount" field in this mutation.
func (m *ShipmentMutation) AddedTotalChargeAmount() (r float64, exists bool) {
	v := m.addtotal_charge_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotalChargeAmount clears the value of the "total_charge_amount" field.
func (m *ShipmentMutation) ClearTotalChargeAmount() {
	m.total_charge_amount = nil
	m.addtotal_charge_amount = nil
	m.clearedFields[shipment.FieldTotalChargeAmount] = struct{}{}
}

// TotalChargeAmountCleared returns if the "total_charge_amount" field was cleared in this mutation.
func (m *ShipmentMutation) TotalChargeAmountCleared() bool {
	_, ok := m.clearedFields[shipment.FieldTotalChargeAmount]
	return ok
}

// ResetTotalChargeAmount resets all changes to the "total_charge_amount" field.
func (m *ShipmentMutation) ResetTotalChargeAmount() {
	m.total_charge_amount = nil
	m.addtotal_charge_amount = nil
	delete(m.clearedFields, shipment.FieldTotalChargeAmount)
}

// SetTrailerTypeID sets the "trailer_type_id" field.
func (m *ShipmentMutation) SetTrailerTypeID(u uuid.UUID) {
	m.trailer_type = &u
}

// TrailerTypeID returns the value of the "trailer_type_id" field in the mutation.
func (m *ShipmentMutation) TrailerTypeID() (r uuid.UUID, exists bool) {
	v := m.trailer_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTrailerTypeID returns the old "trailer_type_id" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldTrailerTypeID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrailerTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrailerTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrailerTypeID: %w", err)
	}
	return oldValue.TrailerTypeID, nil
}

// ClearTrailerTypeID clears the value of the "trailer_type_id" field.
func (m *ShipmentMutation) ClearTrailerTypeID() {
	m.trailer_type = nil
	m.clearedFields[shipment.FieldTrailerTypeID] = struct{}{}
}

// TrailerTypeIDCleared returns if the "trailer_type_id" field was cleared in this mutation.
func (m *ShipmentMutation) TrailerTypeIDCleared() bool {
	_, ok := m.clearedFields[shipment.FieldTrailerTypeID]
	return ok
}

// ResetTrailerTypeID resets all changes to the "trailer_type_id" field.
func (m *ShipmentMutation) ResetTrailerTypeID() {
	m.trailer_type = nil
	delete(m.clearedFields, shipment.FieldTrailerTypeID)
}

// SetTractorTypeID sets the "tractor_type_id" field.
func (m *ShipmentMutation) SetTractorTypeID(u uuid.UUID) {
	m.tractor_type = &u
}

// TractorTypeID returns the value of the "tractor_type_id" field in the mutation.
func (m *ShipmentMutation) TractorTypeID() (r uuid.UUID, exists bool) {
	v := m.tractor_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTractorTypeID returns the old "tractor_type_id" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldTractorTypeID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTractorTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTractorTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTractorTypeID: %w", err)
	}
	return oldValue.TractorTypeID, nil
}

// ClearTractorTypeID clears the value of the "tractor_type_id" field.
func (m *ShipmentMutation) ClearTractorTypeID() {
	m.tractor_type = nil
	m.clearedFields[shipment.FieldTractorTypeID] = struct{}{}
}

// TractorTypeIDCleared returns if the "tractor_type_id" field was cleared in this mutation.
func (m *ShipmentMutation) TractorTypeIDCleared() bool {
	_, ok := m.clearedFields[shipment.FieldTractorTypeID]
	return ok
}

// ResetTractorTypeID resets all changes to the "tractor_type_id" field.
func (m *ShipmentMutation) ResetTractorTypeID() {
	m.tractor_type = nil
	delete(m.clearedFields, shipment.FieldTractorTypeID)
}

// SetTemperatureMin sets the "temperature_min" field.
func (m *ShipmentMutation) SetTemperatureMin(i int) {
	m.temperature_min = &i
	m.addtemperature_min = nil
}

// TemperatureMin returns the value of the "temperature_min" field in the mutation.
func (m *ShipmentMutation) TemperatureMin() (r int, exists bool) {
	v := m.temperature_min
	if v == nil {
		return
	}
	return *v, true
}

// OldTemperatureMin returns the old "temperature_min" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldTemperatureMin(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemperatureMin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemperatureMin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemperatureMin: %w", err)
	}
	return oldValue.TemperatureMin, nil
}

// AddTemperatureMin adds i to the "temperature_min" field.
func (m *ShipmentMutation) AddTemperatureMin(i int) {
	if m.addtemperature_min != nil {
		*m.addtemperature_min += i
	} else {
		m.addtemperature_min = &i
	}
}

// AddedTemperatureMin returns the value that was added to the "temperature_min" field in this mutation.
func (m *ShipmentMutation) AddedTemperatureMin() (r int, exists bool) {
	v := m.addtemperature_min
	if v == nil {
		return
	}
	return *v, true
}

// ClearTemperatureMin clears the value of the "temperature_min" field.
func (m *ShipmentMutation) ClearTemperatureMin() {
	m.temperature_min = nil
	m.addtemperature_min = nil
	m.clearedFields[shipment.FieldTemperatureMin] = struct{}{}
}

// TemperatureMinCleared returns if the "temperature_min" field was cleared in this mutation.
func (m *ShipmentMutation) TemperatureMinCleared() bool {
	_, ok := m.clearedFields[shipment.FieldTemperatureMin]
	return ok
}

// ResetTemperatureMin resets all changes to the "temperature_min" field.
func (m *ShipmentMutation) ResetTemperatureMin() {
	m.temperature_min = nil
	m.addtemperature_min = nil
	delete(m.clearedFields, shipment.FieldTemperatureMin)
}

// SetTemperatureMax sets the "temperature_max" field.
func (m *ShipmentMutation) SetTemperatureMax(i int) {
	m.temperature_max = &i
	m.addtemperature_max = nil
}

// TemperatureMax returns the value of the "temperature_max" field in the mutation.
func (m *ShipmentMutation) TemperatureMax() (r int, exists bool) {
	v := m.temperature_max
	if v == nil {
		return
	}
	return *v, true
}

// OldTemperatureMax returns the old "temperature_max" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldTemperatureMax(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemperatureMax is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemperatureMax requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemperatureMax: %w", err)
	}
	return oldValue.TemperatureMax, nil
}

// AddTemperatureMax adds i to the "temperature_max" field.
func (m *ShipmentMutation) AddTemperatureMax(i int) {
	if m.addtemperature_max != nil {
		*m.addtemperature_max += i
	} else {
		m.addtemperature_max = &i
	}
}

// AddedTemperatureMax returns the value that was added to the "temperature_max" field in this mutation.
func (m *ShipmentMutation) AddedTemperatureMax() (r int, exists bool) {
	v := m.addtemperature_max
	if v == nil {
		return
	}
	return *v, true
}

// ClearTemperatureMax clears the value of the "temperature_max" field.
func (m *ShipmentMutation) ClearTemperatureMax() {
	m.temperature_max = nil
	m.addtemperature_max = nil
	m.clearedFields[shipment.FieldTemperatureMax] = struct{}{}
}

// TemperatureMaxCleared returns if the "temperature_max" field was cleared in this mutation.
func (m *ShipmentMutation) TemperatureMaxCleared() bool {
	_, ok := m.clearedFields[shipment.FieldTemperatureMax]
	return ok
}

// ResetTemperatureMax resets all changes to the "temperature_max" field.
func (m *ShipmentMutation) ResetTemperatureMax() {
	m.temperature_max = nil
	m.addtemperature_max = nil
	delete(m.clearedFields, shipment.FieldTemperatureMax)
}

// SetBillOfLadingNumber sets the "bill_of_lading_number" field.
func (m *ShipmentMutation) SetBillOfLadingNumber(s string) {
	m.bill_of_lading_number = &s
}

// BillOfLadingNumber returns the value of the "bill_of_lading_number" field in the mutation.
func (m *ShipmentMutation) BillOfLadingNumber() (r string, exists bool) {
	v := m.bill_of_lading_number
	if v == nil {
		return
	}
	return *v, true
}

// OldBillOfLadingNumber returns the old "bill_of_lading_number" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldBillOfLadingNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillOfLadingNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillOfLadingNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillOfLadingNumber: %w", err)
	}
	return oldValue.BillOfLadingNumber, nil
}

// ClearBillOfLadingNumber clears the value of the "bill_of_lading_number" field.
func (m *ShipmentMutation) ClearBillOfLadingNumber() {
	m.bill_of_lading_number = nil
	m.clearedFields[shipment.FieldBillOfLadingNumber] = struct{}{}
}

// BillOfLadingNumberCleared returns if the "bill_of_lading_number" field was cleared in this mutation.
func (m *ShipmentMutation) BillOfLadingNumberCleared() bool {
	_, ok := m.clearedFields[shipment.FieldBillOfLadingNumber]
	return ok
}

// ResetBillOfLadingNumber resets all changes to the "bill_of_lading_number" field.
func (m *ShipmentMutation) ResetBillOfLadingNumber() {
	m.bill_of_lading_number = nil
	delete(m.clearedFields, shipment.FieldBillOfLadingNumber)
}

// SetConsigneeReferenceNumber sets the "consignee_reference_number" field.
func (m *ShipmentMutation) SetConsigneeReferenceNumber(s string) {
	m.consignee_reference_number = &s
}

// ConsigneeReferenceNumber returns the value of the "consignee_reference_number" field in the mutation.
func (m *ShipmentMutation) ConsigneeReferenceNumber() (r string, exists bool) {
	v := m.consignee_reference_number
	if v == nil {
		return
	}
	return *v, true
}

// OldConsigneeReferenceNumber returns the old "consignee_reference_number" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldConsigneeReferenceNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConsigneeReferenceNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConsigneeReferenceNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConsigneeReferenceNumber: %w", err)
	}
	return oldValue.ConsigneeReferenceNumber, nil
}

// ClearConsigneeReferenceNumber clears the value of the "consignee_reference_number" field.
func (m *ShipmentMutation) ClearConsigneeReferenceNumber() {
	m.consignee_reference_number = nil
	m.clearedFields[shipment.FieldConsigneeReferenceNumber] = struct{}{}
}

// ConsigneeReferenceNumberCleared returns if the "consignee_reference_number" field was cleared in this mutation.
func (m *ShipmentMutation) ConsigneeReferenceNumberCleared() bool {
	_, ok := m.clearedFields[shipment.FieldConsigneeReferenceNumber]
	return ok
}

// ResetConsigneeReferenceNumber resets all changes to the "consignee_reference_number" field.
func (m *ShipmentMutation) ResetConsigneeReferenceNumber() {
	m.consignee_reference_number = nil
	delete(m.clearedFields, shipment.FieldConsigneeReferenceNumber)
}

// SetComment sets the "comment" field.
func (m *ShipmentMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *ShipmentMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ClearComment clears the value of the "comment" field.
func (m *ShipmentMutation) ClearComment() {
	m.comment = nil
	m.clearedFields[shipment.FieldComment] = struct{}{}
}

// CommentCleared returns if the "comment" field was cleared in this mutation.
func (m *ShipmentMutation) CommentCleared() bool {
	_, ok := m.clearedFields[shipment.FieldComment]
	return ok
}

// ResetComment resets all changes to the "comment" field.
func (m *ShipmentMutation) ResetComment() {
	m.comment = nil
	delete(m.clearedFields, shipment.FieldComment)
}

// SetVoidedComment sets the "voided_comment" field.
func (m *ShipmentMutation) SetVoidedComment(s string) {
	m.voided_comment = &s
}

// VoidedComment returns the value of the "voided_comment" field in the mutation.
func (m *ShipmentMutation) VoidedComment() (r string, exists bool) {
	v := m.voided_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldVoidedComment returns the old "voided_comment" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldVoidedComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVoidedComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVoidedComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVoidedComment: %w", err)
	}
	return oldValue.VoidedComment, nil
}

// ClearVoidedComment clears the value of the "voided_comment" field.
func (m *ShipmentMutation) ClearVoidedComment() {
	m.voided_comment = nil
	m.clearedFields[shipment.FieldVoidedComment] = struct{}{}
}

// VoidedCommentCleared returns if the "voided_comment" field was cleared in this mutation.
func (m *ShipmentMutation) VoidedCommentCleared() bool {
	_, ok := m.clearedFields[shipment.FieldVoidedComment]
	return ok
}

// ResetVoidedComment resets all changes to the "voided_comment" field.
func (m *ShipmentMutation) ResetVoidedComment() {
	m.voided_comment = nil
	delete(m.clearedFields, shipment.FieldVoidedComment)
}

// SetAutoRated sets the "auto_rated" field.
func (m *ShipmentMutation) SetAutoRated(b bool) {
	m.auto_rated = &b
}

// AutoRated returns the value of the "auto_rated" field in the mutation.
func (m *ShipmentMutation) AutoRated() (r bool, exists bool) {
	v := m.auto_rated
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoRated returns the old "auto_rated" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldAutoRated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoRated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoRated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoRated: %w", err)
	}
	return oldValue.AutoRated, nil
}

// ResetAutoRated resets all changes to the "auto_rated" field.
func (m *ShipmentMutation) ResetAutoRated() {
	m.auto_rated = nil
}

// SetCurrentSuffix sets the "current_suffix" field.
func (m *ShipmentMutation) SetCurrentSuffix(s string) {
	m.current_suffix = &s
}

// CurrentSuffix returns the value of the "current_suffix" field in the mutation.
func (m *ShipmentMutation) CurrentSuffix() (r string, exists bool) {
	v := m.current_suffix
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentSuffix returns the old "current_suffix" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldCurrentSuffix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentSuffix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentSuffix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentSuffix: %w", err)
	}
	return oldValue.CurrentSuffix, nil
}

// ClearCurrentSuffix clears the value of the "current_suffix" field.
func (m *ShipmentMutation) ClearCurrentSuffix() {
	m.current_suffix = nil
	m.clearedFields[shipment.FieldCurrentSuffix] = struct{}{}
}

// CurrentSuffixCleared returns if the "current_suffix" field was cleared in this mutation.
func (m *ShipmentMutation) CurrentSuffixCleared() bool {
	_, ok := m.clearedFields[shipment.FieldCurrentSuffix]
	return ok
}

// ResetCurrentSuffix resets all changes to the "current_suffix" field.
func (m *ShipmentMutation) ResetCurrentSuffix() {
	m.current_suffix = nil
	delete(m.clearedFields, shipment.FieldCurrentSuffix)
}

// SetEntryMethod sets the "entry_method" field.
func (m *ShipmentMutation) SetEntryMethod(sm shipment.EntryMethod) {
	m.entry_method = &sm
}

// EntryMethod returns the value of the "entry_method" field in the mutation.
func (m *ShipmentMutation) EntryMethod() (r shipment.EntryMethod, exists bool) {
	v := m.entry_method
	if v == nil {
		return
	}
	return *v, true
}

// OldEntryMethod returns the old "entry_method" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldEntryMethod(ctx context.Context) (v shipment.EntryMethod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntryMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntryMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntryMethod: %w", err)
	}
	return oldValue.EntryMethod, nil
}

// ResetEntryMethod resets all changes to the "entry_method" field.
func (m *ShipmentMutation) ResetEntryMethod() {
	m.entry_method = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ShipmentMutation) SetCreatedBy(u uuid.UUID) {
	m.created_by_user = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ShipmentMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.created_by_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldCreatedBy(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *ShipmentMutation) ClearCreatedBy() {
	m.created_by_user = nil
	m.clearedFields[shipment.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *ShipmentMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[shipment.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ShipmentMutation) ResetCreatedBy() {
	m.created_by_user = nil
	delete(m.clearedFields, shipment.FieldCreatedBy)
}

// SetIsHazardous sets the "is_hazardous" field.
func (m *ShipmentMutation) SetIsHazardous(b bool) {
	m.is_hazardous = &b
}

// IsHazardous returns the value of the "is_hazardous" field in the mutation.
func (m *ShipmentMutation) IsHazardous() (r bool, exists bool) {
	v := m.is_hazardous
	if v == nil {
		return
	}
	return *v, true
}

// OldIsHazardous returns the old "is_hazardous" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldIsHazardous(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsHazardous is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsHazardous requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsHazardous: %w", err)
	}
	return oldValue.IsHazardous, nil
}

// ResetIsHazardous resets all changes to the "is_hazardous" field.
func (m *ShipmentMutation) ResetIsHazardous() {
	m.is_hazardous = nil
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *ShipmentMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[shipment.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *ShipmentMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *ShipmentMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *ShipmentMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *ShipmentMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[shipment.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *ShipmentMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *ShipmentMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *ShipmentMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearShipmentType clears the "shipment_type" edge to the ShipmentType entity.
func (m *ShipmentMutation) ClearShipmentType() {
	m.clearedshipment_type = true
	m.clearedFields[shipment.FieldShipmentTypeID] = struct{}{}
}

// ShipmentTypeCleared reports if the "shipment_type" edge to the ShipmentType entity was cleared.
func (m *ShipmentMutation) ShipmentTypeCleared() bool {
	return m.clearedshipment_type
}

// ShipmentTypeIDs returns the "shipment_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentTypeID instead. It exists only for internal usage by the builders.
func (m *ShipmentMutation) ShipmentTypeIDs() (ids []uuid.UUID) {
	if id := m.shipment_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipmentType resets all changes to the "shipment_type" edge.
func (m *ShipmentMutation) ResetShipmentType() {
	m.shipment_type = nil
	m.clearedshipment_type = false
}

// ClearServiceType clears the "service_type" edge to the ServiceType entity.
func (m *ShipmentMutation) ClearServiceType() {
	m.clearedservice_type = true
	m.clearedFields[shipment.FieldServiceTypeID] = struct{}{}
}

// ServiceTypeCleared reports if the "service_type" edge to the ServiceType entity was cleared.
func (m *ShipmentMutation) ServiceTypeCleared() bool {
	return m.ServiceTypeIDCleared() || m.clearedservice_type
}

// ServiceTypeIDs returns the "service_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ServiceTypeID instead. It exists only for internal usage by the builders.
func (m *ShipmentMutation) ServiceTypeIDs() (ids []uuid.UUID) {
	if id := m.service_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetServiceType resets all changes to the "service_type" edge.
func (m *ShipmentMutation) ResetServiceType() {
	m.service_type = nil
	m.clearedservice_type = false
}

// ClearRevenueCode clears the "revenue_code" edge to the ServiceType entity.
func (m *ShipmentMutation) ClearRevenueCode() {
	m.clearedrevenue_code = true
	m.clearedFields[shipment.FieldRevenueCodeID] = struct{}{}
}

// RevenueCodeCleared reports if the "revenue_code" edge to the ServiceType entity was cleared.
func (m *ShipmentMutation) RevenueCodeCleared() bool {
	return m.RevenueCodeIDCleared() || m.clearedrevenue_code
}

// RevenueCodeIDs returns the "revenue_code" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RevenueCodeID instead. It exists only for internal usage by the builders.
func (m *ShipmentMutation) RevenueCodeIDs() (ids []uuid.UUID) {
	if id := m.revenue_code; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRevenueCode resets all changes to the "revenue_code" edge.
func (m *ShipmentMutation) ResetRevenueCode() {
	m.revenue_code = nil
	m.clearedrevenue_code = false
}

// ClearOriginLocation clears the "origin_location" edge to the Location entity.
func (m *ShipmentMutation) ClearOriginLocation() {
	m.clearedorigin_location = true
	m.clearedFields[shipment.FieldOriginLocationID] = struct{}{}
}

// OriginLocationCleared reports if the "origin_location" edge to the Location entity was cleared.
func (m *ShipmentMutation) OriginLocationCleared() bool {
	return m.OriginLocationIDCleared() || m.clearedorigin_location
}

// OriginLocationIDs returns the "origin_location" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OriginLocationID instead. It exists only for internal usage by the builders.
func (m *ShipmentMutation) OriginLocationIDs() (ids []uuid.UUID) {
	if id := m.origin_location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOriginLocation resets all changes to the "origin_location" edge.
func (m *ShipmentMutation) ResetOriginLocation() {
	m.origin_location = nil
	m.clearedorigin_location = false
}

// ClearDestinationLocation clears the "destination_location" edge to the Location entity.
func (m *ShipmentMutation) ClearDestinationLocation() {
	m.cleareddestination_location = true
	m.clearedFields[shipment.FieldDestinationLocationID] = struct{}{}
}

// DestinationLocationCleared reports if the "destination_location" edge to the Location entity was cleared.
func (m *ShipmentMutation) DestinationLocationCleared() bool {
	return m.DestinationLocationIDCleared() || m.cleareddestination_location
}

// DestinationLocationIDs returns the "destination_location" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DestinationLocationID instead. It exists only for internal usage by the builders.
func (m *ShipmentMutation) DestinationLocationIDs() (ids []uuid.UUID) {
	if id := m.destination_location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDestinationLocation resets all changes to the "destination_location" edge.
func (m *ShipmentMutation) ResetDestinationLocation() {
	m.destination_location = nil
	m.cleareddestination_location = false
}

// ClearTrailerType clears the "trailer_type" edge to the EquipmentType entity.
func (m *ShipmentMutation) ClearTrailerType() {
	m.clearedtrailer_type = true
	m.clearedFields[shipment.FieldTrailerTypeID] = struct{}{}
}

// TrailerTypeCleared reports if the "trailer_type" edge to the EquipmentType entity was cleared.
func (m *ShipmentMutation) TrailerTypeCleared() bool {
	return m.TrailerTypeIDCleared() || m.clearedtrailer_type
}

// TrailerTypeIDs returns the "trailer_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TrailerTypeID instead. It exists only for internal usage by the builders.
func (m *ShipmentMutation) TrailerTypeIDs() (ids []uuid.UUID) {
	if id := m.trailer_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTrailerType resets all changes to the "trailer_type" edge.
func (m *ShipmentMutation) ResetTrailerType() {
	m.trailer_type = nil
	m.clearedtrailer_type = false
}

// ClearTractorType clears the "tractor_type" edge to the EquipmentType entity.
func (m *ShipmentMutation) ClearTractorType() {
	m.clearedtractor_type = true
	m.clearedFields[shipment.FieldTractorTypeID] = struct{}{}
}

// TractorTypeCleared reports if the "tractor_type" edge to the EquipmentType entity was cleared.
func (m *ShipmentMutation) TractorTypeCleared() bool {
	return m.TractorTypeIDCleared() || m.clearedtractor_type
}

// TractorTypeIDs returns the "tractor_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TractorTypeID instead. It exists only for internal usage by the builders.
func (m *ShipmentMutation) TractorTypeIDs() (ids []uuid.UUID) {
	if id := m.tractor_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTractorType resets all changes to the "tractor_type" edge.
func (m *ShipmentMutation) ResetTractorType() {
	m.tractor_type = nil
	m.clearedtractor_type = false
}

// AddShipmentDocumentationIDs adds the "shipment_documentation" edge to the ShipmentDocumentation entity by ids.
func (m *ShipmentMutation) AddShipmentDocumentationIDs(ids ...uuid.UUID) {
	if m.shipment_documentation == nil {
		m.shipment_documentation = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.shipment_documentation[ids[i]] = struct{}{}
	}
}

// ClearShipmentDocumentation clears the "shipment_documentation" edge to the ShipmentDocumentation entity.
func (m *ShipmentMutation) ClearShipmentDocumentation() {
	m.clearedshipment_documentation = true
}

// ShipmentDocumentationCleared reports if the "shipment_documentation" edge to the ShipmentDocumentation entity was cleared.
func (m *ShipmentMutation) ShipmentDocumentationCleared() bool {
	return m.clearedshipment_documentation
}

// RemoveShipmentDocumentationIDs removes the "shipment_documentation" edge to the ShipmentDocumentation entity by IDs.
func (m *ShipmentMutation) RemoveShipmentDocumentationIDs(ids ...uuid.UUID) {
	if m.removedshipment_documentation == nil {
		m.removedshipment_documentation = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.shipment_documentation, ids[i])
		m.removedshipment_documentation[ids[i]] = struct{}{}
	}
}

// RemovedShipmentDocumentation returns the removed IDs of the "shipment_documentation" edge to the ShipmentDocumentation entity.
func (m *ShipmentMutation) RemovedShipmentDocumentationIDs() (ids []uuid.UUID) {
	for id := range m.removedshipment_documentation {
		ids = append(ids, id)
	}
	return
}

// ShipmentDocumentationIDs returns the "shipment_documentation" edge IDs in the mutation.
func (m *ShipmentMutation) ShipmentDocumentationIDs() (ids []uuid.UUID) {
	for id := range m.shipment_documentation {
		ids = append(ids, id)
	}
	return
}

// ResetShipmentDocumentation resets all changes to the "shipment_documentation" edge.
func (m *ShipmentMutation) ResetShipmentDocumentation() {
	m.shipment_documentation = nil
	m.clearedshipment_documentation = false
	m.removedshipment_documentation = nil
}

// AddShipmentCommentIDs adds the "shipment_comments" edge to the ShipmentComment entity by ids.
func (m *ShipmentMutation) AddShipmentCommentIDs(ids ...uuid.UUID) {
	if m.shipment_comments == nil {
		m.shipment_comments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.shipment_comments[ids[i]] = struct{}{}
	}
}

// ClearShipmentComments clears the "shipment_comments" edge to the ShipmentComment entity.
func (m *ShipmentMutation) ClearShipmentComments() {
	m.clearedshipment_comments = true
}

// ShipmentCommentsCleared reports if the "shipment_comments" edge to the ShipmentComment entity was cleared.
func (m *ShipmentMutation) ShipmentCommentsCleared() bool {
	return m.clearedshipment_comments
}

// RemoveShipmentCommentIDs removes the "shipment_comments" edge to the ShipmentComment entity by IDs.
func (m *ShipmentMutation) RemoveShipmentCommentIDs(ids ...uuid.UUID) {
	if m.removedshipment_comments == nil {
		m.removedshipment_comments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.shipment_comments, ids[i])
		m.removedshipment_comments[ids[i]] = struct{}{}
	}
}

// RemovedShipmentComments returns the removed IDs of the "shipment_comments" edge to the ShipmentComment entity.
func (m *ShipmentMutation) RemovedShipmentCommentsIDs() (ids []uuid.UUID) {
	for id := range m.removedshipment_comments {
		ids = append(ids, id)
	}
	return
}

// ShipmentCommentsIDs returns the "shipment_comments" edge IDs in the mutation.
func (m *ShipmentMutation) ShipmentCommentsIDs() (ids []uuid.UUID) {
	for id := range m.shipment_comments {
		ids = append(ids, id)
	}
	return
}

// ResetShipmentComments resets all changes to the "shipment_comments" edge.
func (m *ShipmentMutation) ResetShipmentComments() {
	m.shipment_comments = nil
	m.clearedshipment_comments = false
	m.removedshipment_comments = nil
}

// AddShipmentChargeIDs adds the "shipment_charges" edge to the ShipmentCharges entity by ids.
func (m *ShipmentMutation) AddShipmentChargeIDs(ids ...uuid.UUID) {
	if m.shipment_charges == nil {
		m.shipment_charges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.shipment_charges[ids[i]] = struct{}{}
	}
}

// ClearShipmentCharges clears the "shipment_charges" edge to the ShipmentCharges entity.
func (m *ShipmentMutation) ClearShipmentCharges() {
	m.clearedshipment_charges = true
}

// ShipmentChargesCleared reports if the "shipment_charges" edge to the ShipmentCharges entity was cleared.
func (m *ShipmentMutation) ShipmentChargesCleared() bool {
	return m.clearedshipment_charges
}

// RemoveShipmentChargeIDs removes the "shipment_charges" edge to the ShipmentCharges entity by IDs.
func (m *ShipmentMutation) RemoveShipmentChargeIDs(ids ...uuid.UUID) {
	if m.removedshipment_charges == nil {
		m.removedshipment_charges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.shipment_charges, ids[i])
		m.removedshipment_charges[ids[i]] = struct{}{}
	}
}

// RemovedShipmentCharges returns the removed IDs of the "shipment_charges" edge to the ShipmentCharges entity.
func (m *ShipmentMutation) RemovedShipmentChargesIDs() (ids []uuid.UUID) {
	for id := range m.removedshipment_charges {
		ids = append(ids, id)
	}
	return
}

// ShipmentChargesIDs returns the "shipment_charges" edge IDs in the mutation.
func (m *ShipmentMutation) ShipmentChargesIDs() (ids []uuid.UUID) {
	for id := range m.shipment_charges {
		ids = append(ids, id)
	}
	return
}

// ResetShipmentCharges resets all changes to the "shipment_charges" edge.
func (m *ShipmentMutation) ResetShipmentCharges() {
	m.shipment_charges = nil
	m.clearedshipment_charges = false
	m.removedshipment_charges = nil
}

// AddShipmentCommodityIDs adds the "shipment_commodities" edge to the ShipmentCommodity entity by ids.
func (m *ShipmentMutation) AddShipmentCommodityIDs(ids ...uuid.UUID) {
	if m.shipment_commodities == nil {
		m.shipment_commodities = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.shipment_commodities[ids[i]] = struct{}{}
	}
}

// ClearShipmentCommodities clears the "shipment_commodities" edge to the ShipmentCommodity entity.
func (m *ShipmentMutation) ClearShipmentCommodities() {
	m.clearedshipment_commodities = true
}

// ShipmentCommoditiesCleared reports if the "shipment_commodities" edge to the ShipmentCommodity entity was cleared.
func (m *ShipmentMutation) ShipmentCommoditiesCleared() bool {
	return m.clearedshipment_commodities
}

// RemoveShipmentCommodityIDs removes the "shipment_commodities" edge to the ShipmentCommodity entity by IDs.
func (m *ShipmentMutation) RemoveShipmentCommodityIDs(ids ...uuid.UUID) {
	if m.removedshipment_commodities == nil {
		m.removedshipment_commodities = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.shipment_commodities, ids[i])
		m.removedshipment_commodities[ids[i]] = struct{}{}
	}
}

// RemovedShipmentCommodities returns the removed IDs of the "shipment_commodities" edge to the ShipmentCommodity entity.
func (m *ShipmentMutation) RemovedShipmentCommoditiesIDs() (ids []uuid.UUID) {
	for id := range m.removedshipment_commodities {
		ids = append(ids, id)
	}
	return
}

// ShipmentCommoditiesIDs returns the "shipment_commodities" edge IDs in the mutation.
func (m *ShipmentMutation) ShipmentCommoditiesIDs() (ids []uuid.UUID) {
	for id := range m.shipment_commodities {
		ids = append(ids, id)
	}
	return
}

// ResetShipmentCommodities resets all changes to the "shipment_commodities" edge.
func (m *ShipmentMutation) ResetShipmentCommodities() {
	m.shipment_commodities = nil
	m.clearedshipment_commodities = false
	m.removedshipment_commodities = nil
}

// SetCreatedByUserID sets the "created_by_user" edge to the User entity by id.
func (m *ShipmentMutation) SetCreatedByUserID(id uuid.UUID) {
	m.created_by_user = &id
}

// ClearCreatedByUser clears the "created_by_user" edge to the User entity.
func (m *ShipmentMutation) ClearCreatedByUser() {
	m.clearedcreated_by_user = true
	m.clearedFields[shipment.FieldCreatedBy] = struct{}{}
}

// CreatedByUserCleared reports if the "created_by_user" edge to the User entity was cleared.
func (m *ShipmentMutation) CreatedByUserCleared() bool {
	return m.CreatedByCleared() || m.clearedcreated_by_user
}

// CreatedByUserID returns the "created_by_user" edge ID in the mutation.
func (m *ShipmentMutation) CreatedByUserID() (id uuid.UUID, exists bool) {
	if m.created_by_user != nil {
		return *m.created_by_user, true
	}
	return
}

// CreatedByUserIDs returns the "created_by_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByUserID instead. It exists only for internal usage by the builders.
func (m *ShipmentMutation) CreatedByUserIDs() (ids []uuid.UUID) {
	if id := m.created_by_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedByUser resets all changes to the "created_by_user" edge.
func (m *ShipmentMutation) ResetCreatedByUser() {
	m.created_by_user = nil
	m.clearedcreated_by_user = false
}

// ClearCustomer clears the "customer" edge to the Customer entity.
func (m *ShipmentMutation) ClearCustomer() {
	m.clearedcustomer = true
	m.clearedFields[shipment.FieldCustomerID] = struct{}{}
}

// CustomerCleared reports if the "customer" edge to the Customer entity was cleared.
func (m *ShipmentMutation) CustomerCleared() bool {
	return m.clearedcustomer
}

// CustomerIDs returns the "customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CustomerID instead. It exists only for internal usage by the builders.
func (m *ShipmentMutation) CustomerIDs() (ids []uuid.UUID) {
	if id := m.customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCustomer resets all changes to the "customer" edge.
func (m *ShipmentMutation) ResetCustomer() {
	m.customer = nil
	m.clearedcustomer = false
}

// AddShipmentMoveIDs adds the "shipment_moves" edge to the ShipmentMove entity by ids.
func (m *ShipmentMutation) AddShipmentMoveIDs(ids ...uuid.UUID) {
	if m.shipment_moves == nil {
		m.shipment_moves = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.shipment_moves[ids[i]] = struct{}{}
	}
}

// ClearShipmentMoves clears the "shipment_moves" edge to the ShipmentMove entity.
func (m *ShipmentMutation) ClearShipmentMoves() {
	m.clearedshipment_moves = true
}

// ShipmentMovesCleared reports if the "shipment_moves" edge to the ShipmentMove entity was cleared.
func (m *ShipmentMutation) ShipmentMovesCleared() bool {
	return m.clearedshipment_moves
}

// RemoveShipmentMoveIDs removes the "shipment_moves" edge to the ShipmentMove entity by IDs.
func (m *ShipmentMutation) RemoveShipmentMoveIDs(ids ...uuid.UUID) {
	if m.removedshipment_moves == nil {
		m.removedshipment_moves = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.shipment_moves, ids[i])
		m.removedshipment_moves[ids[i]] = struct{}{}
	}
}

// RemovedShipmentMoves returns the removed IDs of the "shipment_moves" edge to the ShipmentMove entity.
func (m *ShipmentMutation) RemovedShipmentMovesIDs() (ids []uuid.UUID) {
	for id := range m.removedshipment_moves {
		ids = append(ids, id)
	}
	return
}

// ShipmentMovesIDs returns the "shipment_moves" edge IDs in the mutation.
func (m *ShipmentMutation) ShipmentMovesIDs() (ids []uuid.UUID) {
	for id := range m.shipment_moves {
		ids = append(ids, id)
	}
	return
}

// ResetShipmentMoves resets all changes to the "shipment_moves" edge.
func (m *ShipmentMutation) ResetShipmentMoves() {
	m.shipment_moves = nil
	m.clearedshipment_moves = false
	m.removedshipment_moves = nil
}

// Where appends a list predicates to the ShipmentMutation builder.
func (m *ShipmentMutation) Where(ps ...predicate.Shipment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ShipmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ShipmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Shipment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ShipmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ShipmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Shipment).
func (m *ShipmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShipmentMutation) Fields() []string {
	fields := make([]string, 0, 46)
	if m.business_unit != nil {
		fields = append(fields, shipment.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, shipment.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, shipment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, shipment.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, shipment.FieldVersion)
	}
	if m.pro_number != nil {
		fields = append(fields, shipment.FieldProNumber)
	}
	if m.status != nil {
		fields = append(fields, shipment.FieldStatus)
	}
	if m.origin_location != nil {
		fields = append(fields, shipment.FieldOriginLocationID)
	}
	if m.origin_address_line != nil {
		fields = append(fields, shipment.FieldOriginAddressLine)
	}
	if m.origin_appointment_start != nil {
		fields = append(fields, shipment.FieldOriginAppointmentStart)
	}
	if m.origin_appointment_end != nil {
		fields = append(fields, shipment.FieldOriginAppointmentEnd)
	}
	if m.destination_location != nil {
		fields = append(fields, shipment.FieldDestinationLocationID)
	}
	if m.destination_address_line != nil {
		fields = append(fields, shipment.FieldDestinationAddressLine)
	}
	if m.destination_appointment_start != nil {
		fields = append(fields, shipment.FieldDestinationAppointmentStart)
	}
	if m.destination_appointment_end != nil {
		fields = append(fields, shipment.FieldDestinationAppointmentEnd)
	}
	if m.shipment_type != nil {
		fields = append(fields, shipment.FieldShipmentTypeID)
	}
	if m.revenue_code != nil {
		fields = append(fields, shipment.FieldRevenueCodeID)
	}
	if m.service_type != nil {
		fields = append(fields, shipment.FieldServiceTypeID)
	}
	if m.rating_unit != nil {
		fields = append(fields, shipment.FieldRatingUnit)
	}
	if m.mileage != nil {
		fields = append(fields, shipment.FieldMileage)
	}
	if m.other_charge_amount != nil {
		fields = append(fields, shipment.FieldOtherChargeAmount)
	}
	if m.freight_charge_amount != nil {
		fields = append(fields, shipment.FieldFreightChargeAmount)
	}
	if m.rating_method != nil {
		fields = append(fields, shipment.FieldRatingMethod)
	}
	if m.customer != nil {
		fields = append(fields, shipment.FieldCustomerID)
	}
	if m.pieces != nil {
		fields = append(fields, shipment.FieldPieces)
	}
	if m.weight != nil {
		fields = append(fields, shipment.FieldWeight)
	}
	if m.ready_to_bill != nil {
		fields = append(fields, shipment.FieldReadyToBill)
	}
	if m.bill_date != nil {
		fields = append(fields, shipment.FieldBillDate)
	}
	if m.ship_date != nil {
		fields = append(fields, shipment.FieldShipDate)
	}
	if m.billed != nil {
		fields = append(fields, shipment.FieldBilled)
	}
	if m.transferred_to_billing != nil {
		fields = append(fields, shipment.FieldTransferredToBilling)
	}
	if m.transferred_to_billing_date != nil {
		fields = append(fields, shipment.FieldTransferredToBillingDate)
	}
	if m.total_charge_amount != nil {
		fields = append(fields, shipment.FieldTotalChargeAmount)
	}
	if m.trailer_type != nil {
		fields = append(fields, shipment.FieldTrailerTypeID)
	}
	if m.tractor_type != nil {
		fields = append(fields, shipment.FieldTractorTypeID)
	}
	if m.temperature_min != nil {
		fields = append(fields, shipment.FieldTemperatureMin)
	}
	if m.temperature_max != nil {
		fields = append(fields, shipment.FieldTemperatureMax)
	}
	if m.bill_of_lading_number != nil {
		fields = append(fields, shipment.FieldBillOfLadingNumber)
	}
	if m.consignee_reference_number != nil {
		fields = append(fields, shipment.FieldConsigneeReferenceNumber)
	}
	if m.comment != nil {
		fields = append(fields, shipment.FieldComment)
	}
	if m.voided_comment != nil {
		fields = append(fields, shipment.FieldVoidedComment)
	}
	if m.auto_rated != nil {
		fields = append(fields, shipment.FieldAutoRated)
	}
	if m.current_suffix != nil {
		fields = append(fields, shipment.FieldCurrentSuffix)
	}
	if m.entry_method != nil {
		fields = append(fields, shipment.FieldEntryMethod)
	}
	if m.created_by_user != nil {
		fields = append(fields, shipment.FieldCreatedBy)
	}
	if m.is_hazardous != nil {
		fields = append(fields, shipment.FieldIsHazardous)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShipmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shipment.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case shipment.FieldOrganizationID:
		return m.OrganizationID()
	case shipment.FieldCreatedAt:
		return m.CreatedAt()
	case shipment.FieldUpdatedAt:
		return m.UpdatedAt()
	case shipment.FieldVersion:
		return m.Version()
	case shipment.FieldProNumber:
		return m.ProNumber()
	case shipment.FieldStatus:
		return m.Status()
	case shipment.FieldOriginLocationID:
		return m.OriginLocationID()
	case shipment.FieldOriginAddressLine:
		return m.OriginAddressLine()
	case shipment.FieldOriginAppointmentStart:
		return m.OriginAppointmentStart()
	case shipment.FieldOriginAppointmentEnd:
		return m.OriginAppointmentEnd()
	case shipment.FieldDestinationLocationID:
		return m.DestinationLocationID()
	case shipment.FieldDestinationAddressLine:
		return m.DestinationAddressLine()
	case shipment.FieldDestinationAppointmentStart:
		return m.DestinationAppointmentStart()
	case shipment.FieldDestinationAppointmentEnd:
		return m.DestinationAppointmentEnd()
	case shipment.FieldShipmentTypeID:
		return m.ShipmentTypeID()
	case shipment.FieldRevenueCodeID:
		return m.RevenueCodeID()
	case shipment.FieldServiceTypeID:
		return m.ServiceTypeID()
	case shipment.FieldRatingUnit:
		return m.RatingUnit()
	case shipment.FieldMileage:
		return m.Mileage()
	case shipment.FieldOtherChargeAmount:
		return m.OtherChargeAmount()
	case shipment.FieldFreightChargeAmount:
		return m.FreightChargeAmount()
	case shipment.FieldRatingMethod:
		return m.RatingMethod()
	case shipment.FieldCustomerID:
		return m.CustomerID()
	case shipment.FieldPieces:
		return m.Pieces()
	case shipment.FieldWeight:
		return m.Weight()
	case shipment.FieldReadyToBill:
		return m.ReadyToBill()
	case shipment.FieldBillDate:
		return m.BillDate()
	case shipment.FieldShipDate:
		return m.ShipDate()
	case shipment.FieldBilled:
		return m.Billed()
	case shipment.FieldTransferredToBilling:
		return m.TransferredToBilling()
	case shipment.FieldTransferredToBillingDate:
		return m.TransferredToBillingDate()
	case shipment.FieldTotalChargeAmount:
		return m.TotalChargeAmount()
	case shipment.FieldTrailerTypeID:
		return m.TrailerTypeID()
	case shipment.FieldTractorTypeID:
		return m.TractorTypeID()
	case shipment.FieldTemperatureMin:
		return m.TemperatureMin()
	case shipment.FieldTemperatureMax:
		return m.TemperatureMax()
	case shipment.FieldBillOfLadingNumber:
		return m.BillOfLadingNumber()
	case shipment.FieldConsigneeReferenceNumber:
		return m.ConsigneeReferenceNumber()
	case shipment.FieldComment:
		return m.Comment()
	case shipment.FieldVoidedComment:
		return m.VoidedComment()
	case shipment.FieldAutoRated:
		return m.AutoRated()
	case shipment.FieldCurrentSuffix:
		return m.CurrentSuffix()
	case shipment.FieldEntryMethod:
		return m.EntryMethod()
	case shipment.FieldCreatedBy:
		return m.CreatedBy()
	case shipment.FieldIsHazardous:
		return m.IsHazardous()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShipmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shipment.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case shipment.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case shipment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case shipment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case shipment.FieldVersion:
		return m.OldVersion(ctx)
	case shipment.FieldProNumber:
		return m.OldProNumber(ctx)
	case shipment.FieldStatus:
		return m.OldStatus(ctx)
	case shipment.FieldOriginLocationID:
		return m.OldOriginLocationID(ctx)
	case shipment.FieldOriginAddressLine:
		return m.OldOriginAddressLine(ctx)
	case shipment.FieldOriginAppointmentStart:
		return m.OldOriginAppointmentStart(ctx)
	case shipment.FieldOriginAppointmentEnd:
		return m.OldOriginAppointmentEnd(ctx)
	case shipment.FieldDestinationLocationID:
		return m.OldDestinationLocationID(ctx)
	case shipment.FieldDestinationAddressLine:
		return m.OldDestinationAddressLine(ctx)
	case shipment.FieldDestinationAppointmentStart:
		return m.OldDestinationAppointmentStart(ctx)
	case shipment.FieldDestinationAppointmentEnd:
		return m.OldDestinationAppointmentEnd(ctx)
	case shipment.FieldShipmentTypeID:
		return m.OldShipmentTypeID(ctx)
	case shipment.FieldRevenueCodeID:
		return m.OldRevenueCodeID(ctx)
	case shipment.FieldServiceTypeID:
		return m.OldServiceTypeID(ctx)
	case shipment.FieldRatingUnit:
		return m.OldRatingUnit(ctx)
	case shipment.FieldMileage:
		return m.OldMileage(ctx)
	case shipment.FieldOtherChargeAmount:
		return m.OldOtherChargeAmount(ctx)
	case shipment.FieldFreightChargeAmount:
		return m.OldFreightChargeAmount(ctx)
	case shipment.FieldRatingMethod:
		return m.OldRatingMethod(ctx)
	case shipment.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case shipment.FieldPieces:
		return m.OldPieces(ctx)
	case shipment.FieldWeight:
		return m.OldWeight(ctx)
	case shipment.FieldReadyToBill:
		return m.OldReadyToBill(ctx)
	case shipment.FieldBillDate:
		return m.OldBillDate(ctx)
	case shipment.FieldShipDate:
		return m.OldShipDate(ctx)
	case shipment.FieldBilled:
		return m.OldBilled(ctx)
	case shipment.FieldTransferredToBilling:
		return m.OldTransferredToBilling(ctx)
	case shipment.FieldTransferredToBillingDate:
		return m.OldTransferredToBillingDate(ctx)
	case shipment.FieldTotalChargeAmount:
		return m.OldTotalChargeAmount(ctx)
	case shipment.FieldTrailerTypeID:
		return m.OldTrailerTypeID(ctx)
	case shipment.FieldTractorTypeID:
		return m.OldTractorTypeID(ctx)
	case shipment.FieldTemperatureMin:
		return m.OldTemperatureMin(ctx)
	case shipment.FieldTemperatureMax:
		return m.OldTemperatureMax(ctx)
	case shipment.FieldBillOfLadingNumber:
		return m.OldBillOfLadingNumber(ctx)
	case shipment.FieldConsigneeReferenceNumber:
		return m.OldConsigneeReferenceNumber(ctx)
	case shipment.FieldComment:
		return m.OldComment(ctx)
	case shipment.FieldVoidedComment:
		return m.OldVoidedComment(ctx)
	case shipment.FieldAutoRated:
		return m.OldAutoRated(ctx)
	case shipment.FieldCurrentSuffix:
		return m.OldCurrentSuffix(ctx)
	case shipment.FieldEntryMethod:
		return m.OldEntryMethod(ctx)
	case shipment.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case shipment.FieldIsHazardous:
		return m.OldIsHazardous(ctx)
	}
	return nil, fmt.Errorf("unknown Shipment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shipment.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case shipment.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case shipment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case shipment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case shipment.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case shipment.FieldProNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProNumber(v)
		return nil
	case shipment.FieldStatus:
		v, ok := value.(shipment.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case shipment.FieldOriginLocationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginLocationID(v)
		return nil
	case shipment.FieldOriginAddressLine:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginAddressLine(v)
		return nil
	case shipment.FieldOriginAppointmentStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginAppointmentStart(v)
		return nil
	case shipment.FieldOriginAppointmentEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginAppointmentEnd(v)
		return nil
	case shipment.FieldDestinationLocationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDestinationLocationID(v)
		return nil
	case shipment.FieldDestinationAddressLine:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDestinationAddressLine(v)
		return nil
	case shipment.FieldDestinationAppointmentStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDestinationAppointmentStart(v)
		return nil
	case shipment.FieldDestinationAppointmentEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDestinationAppointmentEnd(v)
		return nil
	case shipment.FieldShipmentTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipmentTypeID(v)
		return nil
	case shipment.FieldRevenueCodeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevenueCodeID(v)
		return nil
	case shipment.FieldServiceTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceTypeID(v)
		return nil
	case shipment.FieldRatingUnit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRatingUnit(v)
		return nil
	case shipment.FieldMileage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMileage(v)
		return nil
	case shipment.FieldOtherChargeAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherChargeAmount(v)
		return nil
	case shipment.FieldFreightChargeAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFreightChargeAmount(v)
		return nil
	case shipment.FieldRatingMethod:
		v, ok := value.(shipment.RatingMethod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRatingMethod(v)
		return nil
	case shipment.FieldCustomerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case shipment.FieldPieces:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPieces(v)
		return nil
	case shipment.FieldWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case shipment.FieldReadyToBill:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReadyToBill(v)
		return nil
	case shipment.FieldBillDate:
		v, ok := value.(*pgtype.Date)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillDate(v)
		return nil
	case shipment.FieldShipDate:
		v, ok := value.(*pgtype.Date)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipDate(v)
		return nil
	case shipment.FieldBilled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBilled(v)
		return nil
	case shipment.FieldTransferredToBilling:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransferredToBilling(v)
		return nil
	case shipment.FieldTransferredToBillingDate:
		v, ok := value.(*pgtype.Date)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransferredToBillingDate(v)
		return nil
	case shipment.FieldTotalChargeAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalChargeAmount(v)
		return nil
	case shipment.FieldTrailerTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrailerTypeID(v)
		return nil
	case shipment.FieldTractorTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTractorTypeID(v)
		return nil
	case shipment.FieldTemperatureMin:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemperatureMin(v)
		return nil
	case shipment.FieldTemperatureMax:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemperatureMax(v)
		return nil
	case shipment.FieldBillOfLadingNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillOfLadingNumber(v)
		return nil
	case shipment.FieldConsigneeReferenceNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConsigneeReferenceNumber(v)
		return nil
	case shipment.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case shipment.FieldVoidedComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVoidedComment(v)
		return nil
	case shipment.FieldAutoRated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoRated(v)
		return nil
	case shipment.FieldCurrentSuffix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentSuffix(v)
		return nil
	case shipment.FieldEntryMethod:
		v, ok := value.(shipment.EntryMethod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntryMethod(v)
		return nil
	case shipment.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case shipment.FieldIsHazardous:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsHazardous(v)
		return nil
	}
	return fmt.Errorf("unknown Shipment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShipmentMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, shipment.FieldVersion)
	}
	if m.addrating_unit != nil {
		fields = append(fields, shipment.FieldRatingUnit)
	}
	if m.addmileage != nil {
		fields = append(fields, shipment.FieldMileage)
	}
	if m.addother_charge_amount != nil {
		fields = append(fields, shipment.FieldOtherChargeAmount)
	}
	if m.addfreight_charge_amount != nil {
		fields = append(fields, shipment.FieldFreightChargeAmount)
	}
	if m.addpieces != nil {
		fields = append(fields, shipment.FieldPieces)
	}
	if m.addweight != nil {
		fields = append(fields, shipment.FieldWeight)
	}
	if m.addtotal_charge_amount != nil {
		fields = append(fields, shipment.FieldTotalChargeAmount)
	}
	if m.addtemperature_min != nil {
		fields = append(fields, shipment.FieldTemperatureMin)
	}
	if m.addtemperature_max != nil {
		fields = append(fields, shipment.FieldTemperatureMax)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShipmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case shipment.FieldVersion:
		return m.AddedVersion()
	case shipment.FieldRatingUnit:
		return m.AddedRatingUnit()
	case shipment.FieldMileage:
		return m.AddedMileage()
	case shipment.FieldOtherChargeAmount:
		return m.AddedOtherChargeAmount()
	case shipment.FieldFreightChargeAmount:
		return m.AddedFreightChargeAmount()
	case shipment.FieldPieces:
		return m.AddedPieces()
	case shipment.FieldWeight:
		return m.AddedWeight()
	case shipment.FieldTotalChargeAmount:
		return m.AddedTotalChargeAmount()
	case shipment.FieldTemperatureMin:
		return m.AddedTemperatureMin()
	case shipment.FieldTemperatureMax:
		return m.AddedTemperatureMax()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case shipment.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case shipment.FieldRatingUnit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRatingUnit(v)
		return nil
	case shipment.FieldMileage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMileage(v)
		return nil
	case shipment.FieldOtherChargeAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOtherChargeAmount(v)
		return nil
	case shipment.FieldFreightChargeAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFreightChargeAmount(v)
		return nil
	case shipment.FieldPieces:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPieces(v)
		return nil
	case shipment.FieldWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	case shipment.FieldTotalChargeAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalChargeAmount(v)
		return nil
	case shipment.FieldTemperatureMin:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTemperatureMin(v)
		return nil
	case shipment.FieldTemperatureMax:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTemperatureMax(v)
		return nil
	}
	return fmt.Errorf("unknown Shipment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShipmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(shipment.FieldOriginLocationID) {
		fields = append(fields, shipment.FieldOriginLocationID)
	}
	if m.FieldCleared(shipment.FieldOriginAddressLine) {
		fields = append(fields, shipment.FieldOriginAddressLine)
	}
	if m.FieldCleared(shipment.FieldOriginAppointmentStart) {
		fields = append(fields, shipment.FieldOriginAppointmentStart)
	}
	if m.FieldCleared(shipment.FieldOriginAppointmentEnd) {
		fields = append(fields, shipment.FieldOriginAppointmentEnd)
	}
	if m.FieldCleared(shipment.FieldDestinationLocationID) {
		fields = append(fields, shipment.FieldDestinationLocationID)
	}
	if m.FieldCleared(shipment.FieldDestinationAddressLine) {
		fields = append(fields, shipment.FieldDestinationAddressLine)
	}
	if m.FieldCleared(shipment.FieldDestinationAppointmentStart) {
		fields = append(fields, shipment.FieldDestinationAppointmentStart)
	}
	if m.FieldCleared(shipment.FieldDestinationAppointmentEnd) {
		fields = append(fields, shipment.FieldDestinationAppointmentEnd)
	}
	if m.FieldCleared(shipment.FieldRevenueCodeID) {
		fields = append(fields, shipment.FieldRevenueCodeID)
	}
	if m.FieldCleared(shipment.FieldServiceTypeID) {
		fields = append(fields, shipment.FieldServiceTypeID)
	}
	if m.FieldCleared(shipment.FieldMileage) {
		fields = append(fields, shipment.FieldMileage)
	}
	if m.FieldCleared(shipment.FieldOtherChargeAmount) {
		fields = append(fields, shipment.FieldOtherChargeAmount)
	}
	if m.FieldCleared(shipment.FieldFreightChargeAmount) {
		fields = append(fields, shipment.FieldFreightChargeAmount)
	}
	if m.FieldCleared(shipment.FieldPieces) {
		fields = append(fields, shipment.FieldPieces)
	}
	if m.FieldCleared(shipment.FieldWeight) {
		fields = append(fields, shipment.FieldWeight)
	}
	if m.FieldCleared(shipment.FieldBillDate) {
		fields = append(fields, shipment.FieldBillDate)
	}
	if m.FieldCleared(shipment.FieldShipDate) {
		fields = append(fields, shipment.FieldShipDate)
	}
	if m.FieldCleared(shipment.FieldTransferredToBillingDate) {
		fields = append(fields, shipment.FieldTransferredToBillingDate)
	}
	if m.FieldCleared(shipment.FieldTotalChargeAmount) {
		fields = append(fields, shipment.FieldTotalChargeAmount)
	}
	if m.FieldCleared(shipment.FieldTrailerTypeID) {
		fields = append(fields, shipment.FieldTrailerTypeID)
	}
	if m.FieldCleared(shipment.FieldTractorTypeID) {
		fields = append(fields, shipment.FieldTractorTypeID)
	}
	if m.FieldCleared(shipment.FieldTemperatureMin) {
		fields = append(fields, shipment.FieldTemperatureMin)
	}
	if m.FieldCleared(shipment.FieldTemperatureMax) {
		fields = append(fields, shipment.FieldTemperatureMax)
	}
	if m.FieldCleared(shipment.FieldBillOfLadingNumber) {
		fields = append(fields, shipment.FieldBillOfLadingNumber)
	}
	if m.FieldCleared(shipment.FieldConsigneeReferenceNumber) {
		fields = append(fields, shipment.FieldConsigneeReferenceNumber)
	}
	if m.FieldCleared(shipment.FieldComment) {
		fields = append(fields, shipment.FieldComment)
	}
	if m.FieldCleared(shipment.FieldVoidedComment) {
		fields = append(fields, shipment.FieldVoidedComment)
	}
	if m.FieldCleared(shipment.FieldCurrentSuffix) {
		fields = append(fields, shipment.FieldCurrentSuffix)
	}
	if m.FieldCleared(shipment.FieldCreatedBy) {
		fields = append(fields, shipment.FieldCreatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShipmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShipmentMutation) ClearField(name string) error {
	switch name {
	case shipment.FieldOriginLocationID:
		m.ClearOriginLocationID()
		return nil
	case shipment.FieldOriginAddressLine:
		m.ClearOriginAddressLine()
		return nil
	case shipment.FieldOriginAppointmentStart:
		m.ClearOriginAppointmentStart()
		return nil
	case shipment.FieldOriginAppointmentEnd:
		m.ClearOriginAppointmentEnd()
		return nil
	case shipment.FieldDestinationLocationID:
		m.ClearDestinationLocationID()
		return nil
	case shipment.FieldDestinationAddressLine:
		m.ClearDestinationAddressLine()
		return nil
	case shipment.FieldDestinationAppointmentStart:
		m.ClearDestinationAppointmentStart()
		return nil
	case shipment.FieldDestinationAppointmentEnd:
		m.ClearDestinationAppointmentEnd()
		return nil
	case shipment.FieldRevenueCodeID:
		m.ClearRevenueCodeID()
		return nil
	case shipment.FieldServiceTypeID:
		m.ClearServiceTypeID()
		return nil
	case shipment.FieldMileage:
		m.ClearMileage()
		return nil
	case shipment.FieldOtherChargeAmount:
		m.ClearOtherChargeAmount()
		return nil
	case shipment.FieldFreightChargeAmount:
		m.ClearFreightChargeAmount()
		return nil
	case shipment.FieldPieces:
		m.ClearPieces()
		return nil
	case shipment.FieldWeight:
		m.ClearWeight()
		return nil
	case shipment.FieldBillDate:
		m.ClearBillDate()
		return nil
	case shipment.FieldShipDate:
		m.ClearShipDate()
		return nil
	case shipment.FieldTransferredToBillingDate:
		m.ClearTransferredToBillingDate()
		return nil
	case shipment.FieldTotalChargeAmount:
		m.ClearTotalChargeAmount()
		return nil
	case shipment.FieldTrailerTypeID:
		m.ClearTrailerTypeID()
		return nil
	case shipment.FieldTractorTypeID:
		m.ClearTractorTypeID()
		return nil
	case shipment.FieldTemperatureMin:
		m.ClearTemperatureMin()
		return nil
	case shipment.FieldTemperatureMax:
		m.ClearTemperatureMax()
		return nil
	case shipment.FieldBillOfLadingNumber:
		m.ClearBillOfLadingNumber()
		return nil
	case shipment.FieldConsigneeReferenceNumber:
		m.ClearConsigneeReferenceNumber()
		return nil
	case shipment.FieldComment:
		m.ClearComment()
		return nil
	case shipment.FieldVoidedComment:
		m.ClearVoidedComment()
		return nil
	case shipment.FieldCurrentSuffix:
		m.ClearCurrentSuffix()
		return nil
	case shipment.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown Shipment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShipmentMutation) ResetField(name string) error {
	switch name {
	case shipment.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case shipment.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case shipment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case shipment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case shipment.FieldVersion:
		m.ResetVersion()
		return nil
	case shipment.FieldProNumber:
		m.ResetProNumber()
		return nil
	case shipment.FieldStatus:
		m.ResetStatus()
		return nil
	case shipment.FieldOriginLocationID:
		m.ResetOriginLocationID()
		return nil
	case shipment.FieldOriginAddressLine:
		m.ResetOriginAddressLine()
		return nil
	case shipment.FieldOriginAppointmentStart:
		m.ResetOriginAppointmentStart()
		return nil
	case shipment.FieldOriginAppointmentEnd:
		m.ResetOriginAppointmentEnd()
		return nil
	case shipment.FieldDestinationLocationID:
		m.ResetDestinationLocationID()
		return nil
	case shipment.FieldDestinationAddressLine:
		m.ResetDestinationAddressLine()
		return nil
	case shipment.FieldDestinationAppointmentStart:
		m.ResetDestinationAppointmentStart()
		return nil
	case shipment.FieldDestinationAppointmentEnd:
		m.ResetDestinationAppointmentEnd()
		return nil
	case shipment.FieldShipmentTypeID:
		m.ResetShipmentTypeID()
		return nil
	case shipment.FieldRevenueCodeID:
		m.ResetRevenueCodeID()
		return nil
	case shipment.FieldServiceTypeID:
		m.ResetServiceTypeID()
		return nil
	case shipment.FieldRatingUnit:
		m.ResetRatingUnit()
		return nil
	case shipment.FieldMileage:
		m.ResetMileage()
		return nil
	case shipment.FieldOtherChargeAmount:
		m.ResetOtherChargeAmount()
		return nil
	case shipment.FieldFreightChargeAmount:
		m.ResetFreightChargeAmount()
		return nil
	case shipment.FieldRatingMethod:
		m.ResetRatingMethod()
		return nil
	case shipment.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case shipment.FieldPieces:
		m.ResetPieces()
		return nil
	case shipment.FieldWeight:
		m.ResetWeight()
		return nil
	case shipment.FieldReadyToBill:
		m.ResetReadyToBill()
		return nil
	case shipment.FieldBillDate:
		m.ResetBillDate()
		return nil
	case shipment.FieldShipDate:
		m.ResetShipDate()
		return nil
	case shipment.FieldBilled:
		m.ResetBilled()
		return nil
	case shipment.FieldTransferredToBilling:
		m.ResetTransferredToBilling()
		return nil
	case shipment.FieldTransferredToBillingDate:
		m.ResetTransferredToBillingDate()
		return nil
	case shipment.FieldTotalChargeAmount:
		m.ResetTotalChargeAmount()
		return nil
	case shipment.FieldTrailerTypeID:
		m.ResetTrailerTypeID()
		return nil
	case shipment.FieldTractorTypeID:
		m.ResetTractorTypeID()
		return nil
	case shipment.FieldTemperatureMin:
		m.ResetTemperatureMin()
		return nil
	case shipment.FieldTemperatureMax:
		m.ResetTemperatureMax()
		return nil
	case shipment.FieldBillOfLadingNumber:
		m.ResetBillOfLadingNumber()
		return nil
	case shipment.FieldConsigneeReferenceNumber:
		m.ResetConsigneeReferenceNumber()
		return nil
	case shipment.FieldComment:
		m.ResetComment()
		return nil
	case shipment.FieldVoidedComment:
		m.ResetVoidedComment()
		return nil
	case shipment.FieldAutoRated:
		m.ResetAutoRated()
		return nil
	case shipment.FieldCurrentSuffix:
		m.ResetCurrentSuffix()
		return nil
	case shipment.FieldEntryMethod:
		m.ResetEntryMethod()
		return nil
	case shipment.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case shipment.FieldIsHazardous:
		m.ResetIsHazardous()
		return nil
	}
	return fmt.Errorf("unknown Shipment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShipmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 16)
	if m.business_unit != nil {
		edges = append(edges, shipment.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, shipment.EdgeOrganization)
	}
	if m.shipment_type != nil {
		edges = append(edges, shipment.EdgeShipmentType)
	}
	if m.service_type != nil {
		edges = append(edges, shipment.EdgeServiceType)
	}
	if m.revenue_code != nil {
		edges = append(edges, shipment.EdgeRevenueCode)
	}
	if m.origin_location != nil {
		edges = append(edges, shipment.EdgeOriginLocation)
	}
	if m.destination_location != nil {
		edges = append(edges, shipment.EdgeDestinationLocation)
	}
	if m.trailer_type != nil {
		edges = append(edges, shipment.EdgeTrailerType)
	}
	if m.tractor_type != nil {
		edges = append(edges, shipment.EdgeTractorType)
	}
	if m.shipment_documentation != nil {
		edges = append(edges, shipment.EdgeShipmentDocumentation)
	}
	if m.shipment_comments != nil {
		edges = append(edges, shipment.EdgeShipmentComments)
	}
	if m.shipment_charges != nil {
		edges = append(edges, shipment.EdgeShipmentCharges)
	}
	if m.shipment_commodities != nil {
		edges = append(edges, shipment.EdgeShipmentCommodities)
	}
	if m.created_by_user != nil {
		edges = append(edges, shipment.EdgeCreatedByUser)
	}
	if m.customer != nil {
		edges = append(edges, shipment.EdgeCustomer)
	}
	if m.shipment_moves != nil {
		edges = append(edges, shipment.EdgeShipmentMoves)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShipmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case shipment.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case shipment.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case shipment.EdgeShipmentType:
		if id := m.shipment_type; id != nil {
			return []ent.Value{*id}
		}
	case shipment.EdgeServiceType:
		if id := m.service_type; id != nil {
			return []ent.Value{*id}
		}
	case shipment.EdgeRevenueCode:
		if id := m.revenue_code; id != nil {
			return []ent.Value{*id}
		}
	case shipment.EdgeOriginLocation:
		if id := m.origin_location; id != nil {
			return []ent.Value{*id}
		}
	case shipment.EdgeDestinationLocation:
		if id := m.destination_location; id != nil {
			return []ent.Value{*id}
		}
	case shipment.EdgeTrailerType:
		if id := m.trailer_type; id != nil {
			return []ent.Value{*id}
		}
	case shipment.EdgeTractorType:
		if id := m.tractor_type; id != nil {
			return []ent.Value{*id}
		}
	case shipment.EdgeShipmentDocumentation:
		ids := make([]ent.Value, 0, len(m.shipment_documentation))
		for id := range m.shipment_documentation {
			ids = append(ids, id)
		}
		return ids
	case shipment.EdgeShipmentComments:
		ids := make([]ent.Value, 0, len(m.shipment_comments))
		for id := range m.shipment_comments {
			ids = append(ids, id)
		}
		return ids
	case shipment.EdgeShipmentCharges:
		ids := make([]ent.Value, 0, len(m.shipment_charges))
		for id := range m.shipment_charges {
			ids = append(ids, id)
		}
		return ids
	case shipment.EdgeShipmentCommodities:
		ids := make([]ent.Value, 0, len(m.shipment_commodities))
		for id := range m.shipment_commodities {
			ids = append(ids, id)
		}
		return ids
	case shipment.EdgeCreatedByUser:
		if id := m.created_by_user; id != nil {
			return []ent.Value{*id}
		}
	case shipment.EdgeCustomer:
		if id := m.customer; id != nil {
			return []ent.Value{*id}
		}
	case shipment.EdgeShipmentMoves:
		ids := make([]ent.Value, 0, len(m.shipment_moves))
		for id := range m.shipment_moves {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShipmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 16)
	if m.removedshipment_documentation != nil {
		edges = append(edges, shipment.EdgeShipmentDocumentation)
	}
	if m.removedshipment_comments != nil {
		edges = append(edges, shipment.EdgeShipmentComments)
	}
	if m.removedshipment_charges != nil {
		edges = append(edges, shipment.EdgeShipmentCharges)
	}
	if m.removedshipment_commodities != nil {
		edges = append(edges, shipment.EdgeShipmentCommodities)
	}
	if m.removedshipment_moves != nil {
		edges = append(edges, shipment.EdgeShipmentMoves)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShipmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case shipment.EdgeShipmentDocumentation:
		ids := make([]ent.Value, 0, len(m.removedshipment_documentation))
		for id := range m.removedshipment_documentation {
			ids = append(ids, id)
		}
		return ids
	case shipment.EdgeShipmentComments:
		ids := make([]ent.Value, 0, len(m.removedshipment_comments))
		for id := range m.removedshipment_comments {
			ids = append(ids, id)
		}
		return ids
	case shipment.EdgeShipmentCharges:
		ids := make([]ent.Value, 0, len(m.removedshipment_charges))
		for id := range m.removedshipment_charges {
			ids = append(ids, id)
		}
		return ids
	case shipment.EdgeShipmentCommodities:
		ids := make([]ent.Value, 0, len(m.removedshipment_commodities))
		for id := range m.removedshipment_commodities {
			ids = append(ids, id)
		}
		return ids
	case shipment.EdgeShipmentMoves:
		ids := make([]ent.Value, 0, len(m.removedshipment_moves))
		for id := range m.removedshipment_moves {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShipmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 16)
	if m.clearedbusiness_unit {
		edges = append(edges, shipment.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, shipment.EdgeOrganization)
	}
	if m.clearedshipment_type {
		edges = append(edges, shipment.EdgeShipmentType)
	}
	if m.clearedservice_type {
		edges = append(edges, shipment.EdgeServiceType)
	}
	if m.clearedrevenue_code {
		edges = append(edges, shipment.EdgeRevenueCode)
	}
	if m.clearedorigin_location {
		edges = append(edges, shipment.EdgeOriginLocation)
	}
	if m.cleareddestination_location {
		edges = append(edges, shipment.EdgeDestinationLocation)
	}
	if m.clearedtrailer_type {
		edges = append(edges, shipment.EdgeTrailerType)
	}
	if m.clearedtractor_type {
		edges = append(edges, shipment.EdgeTractorType)
	}
	if m.clearedshipment_documentation {
		edges = append(edges, shipment.EdgeShipmentDocumentation)
	}
	if m.clearedshipment_comments {
		edges = append(edges, shipment.EdgeShipmentComments)
	}
	if m.clearedshipment_charges {
		edges = append(edges, shipment.EdgeShipmentCharges)
	}
	if m.clearedshipment_commodities {
		edges = append(edges, shipment.EdgeShipmentCommodities)
	}
	if m.clearedcreated_by_user {
		edges = append(edges, shipment.EdgeCreatedByUser)
	}
	if m.clearedcustomer {
		edges = append(edges, shipment.EdgeCustomer)
	}
	if m.clearedshipment_moves {
		edges = append(edges, shipment.EdgeShipmentMoves)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShipmentMutation) EdgeCleared(name string) bool {
	switch name {
	case shipment.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case shipment.EdgeOrganization:
		return m.clearedorganization
	case shipment.EdgeShipmentType:
		return m.clearedshipment_type
	case shipment.EdgeServiceType:
		return m.clearedservice_type
	case shipment.EdgeRevenueCode:
		return m.clearedrevenue_code
	case shipment.EdgeOriginLocation:
		return m.clearedorigin_location
	case shipment.EdgeDestinationLocation:
		return m.cleareddestination_location
	case shipment.EdgeTrailerType:
		return m.clearedtrailer_type
	case shipment.EdgeTractorType:
		return m.clearedtractor_type
	case shipment.EdgeShipmentDocumentation:
		return m.clearedshipment_documentation
	case shipment.EdgeShipmentComments:
		return m.clearedshipment_comments
	case shipment.EdgeShipmentCharges:
		return m.clearedshipment_charges
	case shipment.EdgeShipmentCommodities:
		return m.clearedshipment_commodities
	case shipment.EdgeCreatedByUser:
		return m.clearedcreated_by_user
	case shipment.EdgeCustomer:
		return m.clearedcustomer
	case shipment.EdgeShipmentMoves:
		return m.clearedshipment_moves
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShipmentMutation) ClearEdge(name string) error {
	switch name {
	case shipment.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case shipment.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case shipment.EdgeShipmentType:
		m.ClearShipmentType()
		return nil
	case shipment.EdgeServiceType:
		m.ClearServiceType()
		return nil
	case shipment.EdgeRevenueCode:
		m.ClearRevenueCode()
		return nil
	case shipment.EdgeOriginLocation:
		m.ClearOriginLocation()
		return nil
	case shipment.EdgeDestinationLocation:
		m.ClearDestinationLocation()
		return nil
	case shipment.EdgeTrailerType:
		m.ClearTrailerType()
		return nil
	case shipment.EdgeTractorType:
		m.ClearTractorType()
		return nil
	case shipment.EdgeCreatedByUser:
		m.ClearCreatedByUser()
		return nil
	case shipment.EdgeCustomer:
		m.ClearCustomer()
		return nil
	}
	return fmt.Errorf("unknown Shipment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShipmentMutation) ResetEdge(name string) error {
	switch name {
	case shipment.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case shipment.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case shipment.EdgeShipmentType:
		m.ResetShipmentType()
		return nil
	case shipment.EdgeServiceType:
		m.ResetServiceType()
		return nil
	case shipment.EdgeRevenueCode:
		m.ResetRevenueCode()
		return nil
	case shipment.EdgeOriginLocation:
		m.ResetOriginLocation()
		return nil
	case shipment.EdgeDestinationLocation:
		m.ResetDestinationLocation()
		return nil
	case shipment.EdgeTrailerType:
		m.ResetTrailerType()
		return nil
	case shipment.EdgeTractorType:
		m.ResetTractorType()
		return nil
	case shipment.EdgeShipmentDocumentation:
		m.ResetShipmentDocumentation()
		return nil
	case shipment.EdgeShipmentComments:
		m.ResetShipmentComments()
		return nil
	case shipment.EdgeShipmentCharges:
		m.ResetShipmentCharges()
		return nil
	case shipment.EdgeShipmentCommodities:
		m.ResetShipmentCommodities()
		return nil
	case shipment.EdgeCreatedByUser:
		m.ResetCreatedByUser()
		return nil
	case shipment.EdgeCustomer:
		m.ResetCustomer()
		return nil
	case shipment.EdgeShipmentMoves:
		m.ResetShipmentMoves()
		return nil
	}
	return fmt.Errorf("unknown Shipment edge %s", name)
}

// ShipmentChargesMutation represents an operation that mutates the ShipmentCharges nodes in the graph.
type ShipmentChargesMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	created_at                *time.Time
	updated_at                *time.Time
	version                   *int
	addversion                *int
	description               *string
	charge_amount             *float64
	addcharge_amount          *float64
	units                     *int
	addunits                  *int
	sub_total                 *float64
	addsub_total              *float64
	clearedFields             map[string]struct{}
	business_unit             *uuid.UUID
	clearedbusiness_unit      bool
	organization              *uuid.UUID
	clearedorganization       bool
	shipment                  *uuid.UUID
	clearedshipment           bool
	accessorial_charge        *uuid.UUID
	clearedaccessorial_charge bool
	user                      *uuid.UUID
	cleareduser               bool
	done                      bool
	oldValue                  func(context.Context) (*ShipmentCharges, error)
	predicates                []predicate.ShipmentCharges
}

var _ ent.Mutation = (*ShipmentChargesMutation)(nil)

// shipmentchargesOption allows management of the mutation configuration using functional options.
type shipmentchargesOption func(*ShipmentChargesMutation)

// newShipmentChargesMutation creates new mutation for the ShipmentCharges entity.
func newShipmentChargesMutation(c config, op Op, opts ...shipmentchargesOption) *ShipmentChargesMutation {
	m := &ShipmentChargesMutation{
		config:        c,
		op:            op,
		typ:           TypeShipmentCharges,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShipmentChargesID sets the ID field of the mutation.
func withShipmentChargesID(id uuid.UUID) shipmentchargesOption {
	return func(m *ShipmentChargesMutation) {
		var (
			err   error
			once  sync.Once
			value *ShipmentCharges
		)
		m.oldValue = func(ctx context.Context) (*ShipmentCharges, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShipmentCharges.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShipmentCharges sets the old ShipmentCharges of the mutation.
func withShipmentCharges(node *ShipmentCharges) shipmentchargesOption {
	return func(m *ShipmentChargesMutation) {
		m.oldValue = func(context.Context) (*ShipmentCharges, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShipmentChargesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShipmentChargesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ShipmentCharges entities.
func (m *ShipmentChargesMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShipmentChargesMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ShipmentChargesMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ShipmentCharges.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *ShipmentChargesMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *ShipmentChargesMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the ShipmentCharges entity.
// If the ShipmentCharges object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentChargesMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *ShipmentChargesMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *ShipmentChargesMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *ShipmentChargesMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the ShipmentCharges entity.
// If the ShipmentCharges object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentChargesMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *ShipmentChargesMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ShipmentChargesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ShipmentChargesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ShipmentCharges entity.
// If the ShipmentCharges object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentChargesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ShipmentChargesMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ShipmentChargesMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ShipmentChargesMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ShipmentCharges entity.
// If the ShipmentCharges object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentChargesMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ShipmentChargesMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *ShipmentChargesMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *ShipmentChargesMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the ShipmentCharges entity.
// If the ShipmentCharges object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentChargesMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *ShipmentChargesMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *ShipmentChargesMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *ShipmentChargesMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetShipmentID sets the "shipment_id" field.
func (m *ShipmentChargesMutation) SetShipmentID(u uuid.UUID) {
	m.shipment = &u
}

// ShipmentID returns the value of the "shipment_id" field in the mutation.
func (m *ShipmentChargesMutation) ShipmentID() (r uuid.UUID, exists bool) {
	v := m.shipment
	if v == nil {
		return
	}
	return *v, true
}

// OldShipmentID returns the old "shipment_id" field's value of the ShipmentCharges entity.
// If the ShipmentCharges object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentChargesMutation) OldShipmentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShipmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShipmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipmentID: %w", err)
	}
	return oldValue.ShipmentID, nil
}

// ResetShipmentID resets all changes to the "shipment_id" field.
func (m *ShipmentChargesMutation) ResetShipmentID() {
	m.shipment = nil
}

// SetAccessorialChargeID sets the "accessorial_charge_id" field.
func (m *ShipmentChargesMutation) SetAccessorialChargeID(u uuid.UUID) {
	m.accessorial_charge = &u
}

// AccessorialChargeID returns the value of the "accessorial_charge_id" field in the mutation.
func (m *ShipmentChargesMutation) AccessorialChargeID() (r uuid.UUID, exists bool) {
	v := m.accessorial_charge
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessorialChargeID returns the old "accessorial_charge_id" field's value of the ShipmentCharges entity.
// If the ShipmentCharges object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentChargesMutation) OldAccessorialChargeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessorialChargeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessorialChargeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessorialChargeID: %w", err)
	}
	return oldValue.AccessorialChargeID, nil
}

// ResetAccessorialChargeID resets all changes to the "accessorial_charge_id" field.
func (m *ShipmentChargesMutation) ResetAccessorialChargeID() {
	m.accessorial_charge = nil
}

// SetDescription sets the "description" field.
func (m *ShipmentChargesMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ShipmentChargesMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ShipmentCharges entity.
// If the ShipmentCharges object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentChargesMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ShipmentChargesMutation) ResetDescription() {
	m.description = nil
}

// SetChargeAmount sets the "charge_amount" field.
func (m *ShipmentChargesMutation) SetChargeAmount(f float64) {
	m.charge_amount = &f
	m.addcharge_amount = nil
}

// ChargeAmount returns the value of the "charge_amount" field in the mutation.
func (m *ShipmentChargesMutation) ChargeAmount() (r float64, exists bool) {
	v := m.charge_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldChargeAmount returns the old "charge_amount" field's value of the ShipmentCharges entity.
// If the ShipmentCharges object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentChargesMutation) OldChargeAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChargeAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChargeAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChargeAmount: %w", err)
	}
	return oldValue.ChargeAmount, nil
}

// AddChargeAmount adds f to the "charge_amount" field.
func (m *ShipmentChargesMutation) AddChargeAmount(f float64) {
	if m.addcharge_amount != nil {
		*m.addcharge_amount += f
	} else {
		m.addcharge_amount = &f
	}
}

// AddedChargeAmount returns the value that was added to the "charge_amount" field in this mutation.
func (m *ShipmentChargesMutation) AddedChargeAmount() (r float64, exists bool) {
	v := m.addcharge_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetChargeAmount resets all changes to the "charge_amount" field.
func (m *ShipmentChargesMutation) ResetChargeAmount() {
	m.charge_amount = nil
	m.addcharge_amount = nil
}

// SetUnits sets the "units" field.
func (m *ShipmentChargesMutation) SetUnits(i int) {
	m.units = &i
	m.addunits = nil
}

// Units returns the value of the "units" field in the mutation.
func (m *ShipmentChargesMutation) Units() (r int, exists bool) {
	v := m.units
	if v == nil {
		return
	}
	return *v, true
}

// OldUnits returns the old "units" field's value of the ShipmentCharges entity.
// If the ShipmentCharges object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentChargesMutation) OldUnits(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnits: %w", err)
	}
	return oldValue.Units, nil
}

// AddUnits adds i to the "units" field.
func (m *ShipmentChargesMutation) AddUnits(i int) {
	if m.addunits != nil {
		*m.addunits += i
	} else {
		m.addunits = &i
	}
}

// AddedUnits returns the value that was added to the "units" field in this mutation.
func (m *ShipmentChargesMutation) AddedUnits() (r int, exists bool) {
	v := m.addunits
	if v == nil {
		return
	}
	return *v, true
}

// ResetUnits resets all changes to the "units" field.
func (m *ShipmentChargesMutation) ResetUnits() {
	m.units = nil
	m.addunits = nil
}

// SetSubTotal sets the "sub_total" field.
func (m *ShipmentChargesMutation) SetSubTotal(f float64) {
	m.sub_total = &f
	m.addsub_total = nil
}

// SubTotal returns the value of the "sub_total" field in the mutation.
func (m *ShipmentChargesMutation) SubTotal() (r float64, exists bool) {
	v := m.sub_total
	if v == nil {
		return
	}
	return *v, true
}

// OldSubTotal returns the old "sub_total" field's value of the ShipmentCharges entity.
// If the ShipmentCharges object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentChargesMutation) OldSubTotal(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubTotal: %w", err)
	}
	return oldValue.SubTotal, nil
}

// AddSubTotal adds f to the "sub_total" field.
func (m *ShipmentChargesMutation) AddSubTotal(f float64) {
	if m.addsub_total != nil {
		*m.addsub_total += f
	} else {
		m.addsub_total = &f
	}
}

// AddedSubTotal returns the value that was added to the "sub_total" field in this mutation.
func (m *ShipmentChargesMutation) AddedSubTotal() (r float64, exists bool) {
	v := m.addsub_total
	if v == nil {
		return
	}
	return *v, true
}

// ResetSubTotal resets all changes to the "sub_total" field.
func (m *ShipmentChargesMutation) ResetSubTotal() {
	m.sub_total = nil
	m.addsub_total = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ShipmentChargesMutation) SetCreatedBy(u uuid.UUID) {
	m.user = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ShipmentChargesMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ShipmentCharges entity.
// If the ShipmentCharges object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentChargesMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ShipmentChargesMutation) ResetCreatedBy() {
	m.user = nil
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *ShipmentChargesMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[shipmentcharges.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *ShipmentChargesMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *ShipmentChargesMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *ShipmentChargesMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *ShipmentChargesMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[shipmentcharges.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *ShipmentChargesMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *ShipmentChargesMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *ShipmentChargesMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearShipment clears the "shipment" edge to the Shipment entity.
func (m *ShipmentChargesMutation) ClearShipment() {
	m.clearedshipment = true
	m.clearedFields[shipmentcharges.FieldShipmentID] = struct{}{}
}

// ShipmentCleared reports if the "shipment" edge to the Shipment entity was cleared.
func (m *ShipmentChargesMutation) ShipmentCleared() bool {
	return m.clearedshipment
}

// ShipmentIDs returns the "shipment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentID instead. It exists only for internal usage by the builders.
func (m *ShipmentChargesMutation) ShipmentIDs() (ids []uuid.UUID) {
	if id := m.shipment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipment resets all changes to the "shipment" edge.
func (m *ShipmentChargesMutation) ResetShipment() {
	m.shipment = nil
	m.clearedshipment = false
}

// ClearAccessorialCharge clears the "accessorial_charge" edge to the AccessorialCharge entity.
func (m *ShipmentChargesMutation) ClearAccessorialCharge() {
	m.clearedaccessorial_charge = true
	m.clearedFields[shipmentcharges.FieldAccessorialChargeID] = struct{}{}
}

// AccessorialChargeCleared reports if the "accessorial_charge" edge to the AccessorialCharge entity was cleared.
func (m *ShipmentChargesMutation) AccessorialChargeCleared() bool {
	return m.clearedaccessorial_charge
}

// AccessorialChargeIDs returns the "accessorial_charge" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccessorialChargeID instead. It exists only for internal usage by the builders.
func (m *ShipmentChargesMutation) AccessorialChargeIDs() (ids []uuid.UUID) {
	if id := m.accessorial_charge; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccessorialCharge resets all changes to the "accessorial_charge" edge.
func (m *ShipmentChargesMutation) ResetAccessorialCharge() {
	m.accessorial_charge = nil
	m.clearedaccessorial_charge = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ShipmentChargesMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ShipmentChargesMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[shipmentcharges.FieldCreatedBy] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ShipmentChargesMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ShipmentChargesMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ShipmentChargesMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ShipmentChargesMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the ShipmentChargesMutation builder.
func (m *ShipmentChargesMutation) Where(ps ...predicate.ShipmentCharges) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ShipmentChargesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ShipmentChargesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ShipmentCharges, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ShipmentChargesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ShipmentChargesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ShipmentCharges).
func (m *ShipmentChargesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShipmentChargesMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.business_unit != nil {
		fields = append(fields, shipmentcharges.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, shipmentcharges.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, shipmentcharges.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, shipmentcharges.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, shipmentcharges.FieldVersion)
	}
	if m.shipment != nil {
		fields = append(fields, shipmentcharges.FieldShipmentID)
	}
	if m.accessorial_charge != nil {
		fields = append(fields, shipmentcharges.FieldAccessorialChargeID)
	}
	if m.description != nil {
		fields = append(fields, shipmentcharges.FieldDescription)
	}
	if m.charge_amount != nil {
		fields = append(fields, shipmentcharges.FieldChargeAmount)
	}
	if m.units != nil {
		fields = append(fields, shipmentcharges.FieldUnits)
	}
	if m.sub_total != nil {
		fields = append(fields, shipmentcharges.FieldSubTotal)
	}
	if m.user != nil {
		fields = append(fields, shipmentcharges.FieldCreatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShipmentChargesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shipmentcharges.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case shipmentcharges.FieldOrganizationID:
		return m.OrganizationID()
	case shipmentcharges.FieldCreatedAt:
		return m.CreatedAt()
	case shipmentcharges.FieldUpdatedAt:
		return m.UpdatedAt()
	case shipmentcharges.FieldVersion:
		return m.Version()
	case shipmentcharges.FieldShipmentID:
		return m.ShipmentID()
	case shipmentcharges.FieldAccessorialChargeID:
		return m.AccessorialChargeID()
	case shipmentcharges.FieldDescription:
		return m.Description()
	case shipmentcharges.FieldChargeAmount:
		return m.ChargeAmount()
	case shipmentcharges.FieldUnits:
		return m.Units()
	case shipmentcharges.FieldSubTotal:
		return m.SubTotal()
	case shipmentcharges.FieldCreatedBy:
		return m.CreatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShipmentChargesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shipmentcharges.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case shipmentcharges.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case shipmentcharges.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case shipmentcharges.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case shipmentcharges.FieldVersion:
		return m.OldVersion(ctx)
	case shipmentcharges.FieldShipmentID:
		return m.OldShipmentID(ctx)
	case shipmentcharges.FieldAccessorialChargeID:
		return m.OldAccessorialChargeID(ctx)
	case shipmentcharges.FieldDescription:
		return m.OldDescription(ctx)
	case shipmentcharges.FieldChargeAmount:
		return m.OldChargeAmount(ctx)
	case shipmentcharges.FieldUnits:
		return m.OldUnits(ctx)
	case shipmentcharges.FieldSubTotal:
		return m.OldSubTotal(ctx)
	case shipmentcharges.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown ShipmentCharges field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentChargesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shipmentcharges.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case shipmentcharges.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case shipmentcharges.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case shipmentcharges.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case shipmentcharges.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case shipmentcharges.FieldShipmentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipmentID(v)
		return nil
	case shipmentcharges.FieldAccessorialChargeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessorialChargeID(v)
		return nil
	case shipmentcharges.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case shipmentcharges.FieldChargeAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChargeAmount(v)
		return nil
	case shipmentcharges.FieldUnits:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnits(v)
		return nil
	case shipmentcharges.FieldSubTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubTotal(v)
		return nil
	case shipmentcharges.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentCharges field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShipmentChargesMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, shipmentcharges.FieldVersion)
	}
	if m.addcharge_amount != nil {
		fields = append(fields, shipmentcharges.FieldChargeAmount)
	}
	if m.addunits != nil {
		fields = append(fields, shipmentcharges.FieldUnits)
	}
	if m.addsub_total != nil {
		fields = append(fields, shipmentcharges.FieldSubTotal)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShipmentChargesMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case shipmentcharges.FieldVersion:
		return m.AddedVersion()
	case shipmentcharges.FieldChargeAmount:
		return m.AddedChargeAmount()
	case shipmentcharges.FieldUnits:
		return m.AddedUnits()
	case shipmentcharges.FieldSubTotal:
		return m.AddedSubTotal()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentChargesMutation) AddField(name string, value ent.Value) error {
	switch name {
	case shipmentcharges.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case shipmentcharges.FieldChargeAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChargeAmount(v)
		return nil
	case shipmentcharges.FieldUnits:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnits(v)
		return nil
	case shipmentcharges.FieldSubTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSubTotal(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentCharges numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShipmentChargesMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShipmentChargesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShipmentChargesMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ShipmentCharges nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShipmentChargesMutation) ResetField(name string) error {
	switch name {
	case shipmentcharges.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case shipmentcharges.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case shipmentcharges.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case shipmentcharges.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case shipmentcharges.FieldVersion:
		m.ResetVersion()
		return nil
	case shipmentcharges.FieldShipmentID:
		m.ResetShipmentID()
		return nil
	case shipmentcharges.FieldAccessorialChargeID:
		m.ResetAccessorialChargeID()
		return nil
	case shipmentcharges.FieldDescription:
		m.ResetDescription()
		return nil
	case shipmentcharges.FieldChargeAmount:
		m.ResetChargeAmount()
		return nil
	case shipmentcharges.FieldUnits:
		m.ResetUnits()
		return nil
	case shipmentcharges.FieldSubTotal:
		m.ResetSubTotal()
		return nil
	case shipmentcharges.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown ShipmentCharges field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShipmentChargesMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.business_unit != nil {
		edges = append(edges, shipmentcharges.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, shipmentcharges.EdgeOrganization)
	}
	if m.shipment != nil {
		edges = append(edges, shipmentcharges.EdgeShipment)
	}
	if m.accessorial_charge != nil {
		edges = append(edges, shipmentcharges.EdgeAccessorialCharge)
	}
	if m.user != nil {
		edges = append(edges, shipmentcharges.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShipmentChargesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case shipmentcharges.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case shipmentcharges.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case shipmentcharges.EdgeShipment:
		if id := m.shipment; id != nil {
			return []ent.Value{*id}
		}
	case shipmentcharges.EdgeAccessorialCharge:
		if id := m.accessorial_charge; id != nil {
			return []ent.Value{*id}
		}
	case shipmentcharges.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShipmentChargesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShipmentChargesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShipmentChargesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedbusiness_unit {
		edges = append(edges, shipmentcharges.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, shipmentcharges.EdgeOrganization)
	}
	if m.clearedshipment {
		edges = append(edges, shipmentcharges.EdgeShipment)
	}
	if m.clearedaccessorial_charge {
		edges = append(edges, shipmentcharges.EdgeAccessorialCharge)
	}
	if m.cleareduser {
		edges = append(edges, shipmentcharges.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShipmentChargesMutation) EdgeCleared(name string) bool {
	switch name {
	case shipmentcharges.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case shipmentcharges.EdgeOrganization:
		return m.clearedorganization
	case shipmentcharges.EdgeShipment:
		return m.clearedshipment
	case shipmentcharges.EdgeAccessorialCharge:
		return m.clearedaccessorial_charge
	case shipmentcharges.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShipmentChargesMutation) ClearEdge(name string) error {
	switch name {
	case shipmentcharges.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case shipmentcharges.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case shipmentcharges.EdgeShipment:
		m.ClearShipment()
		return nil
	case shipmentcharges.EdgeAccessorialCharge:
		m.ClearAccessorialCharge()
		return nil
	case shipmentcharges.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown ShipmentCharges unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShipmentChargesMutation) ResetEdge(name string) error {
	switch name {
	case shipmentcharges.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case shipmentcharges.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case shipmentcharges.EdgeShipment:
		m.ResetShipment()
		return nil
	case shipmentcharges.EdgeAccessorialCharge:
		m.ResetAccessorialCharge()
		return nil
	case shipmentcharges.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown ShipmentCharges edge %s", name)
}

// ShipmentCommentMutation represents an operation that mutates the ShipmentComment nodes in the graph.
type ShipmentCommentMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	created_at             *time.Time
	updated_at             *time.Time
	version                *int
	addversion             *int
	comment                *string
	clearedFields          map[string]struct{}
	business_unit          *uuid.UUID
	clearedbusiness_unit   bool
	organization           *uuid.UUID
	clearedorganization    bool
	shipment               *uuid.UUID
	clearedshipment        bool
	comment_type           *uuid.UUID
	clearedcomment_type    bool
	created_by_user        *uuid.UUID
	clearedcreated_by_user bool
	done                   bool
	oldValue               func(context.Context) (*ShipmentComment, error)
	predicates             []predicate.ShipmentComment
}

var _ ent.Mutation = (*ShipmentCommentMutation)(nil)

// shipmentcommentOption allows management of the mutation configuration using functional options.
type shipmentcommentOption func(*ShipmentCommentMutation)

// newShipmentCommentMutation creates new mutation for the ShipmentComment entity.
func newShipmentCommentMutation(c config, op Op, opts ...shipmentcommentOption) *ShipmentCommentMutation {
	m := &ShipmentCommentMutation{
		config:        c,
		op:            op,
		typ:           TypeShipmentComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShipmentCommentID sets the ID field of the mutation.
func withShipmentCommentID(id uuid.UUID) shipmentcommentOption {
	return func(m *ShipmentCommentMutation) {
		var (
			err   error
			once  sync.Once
			value *ShipmentComment
		)
		m.oldValue = func(ctx context.Context) (*ShipmentComment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShipmentComment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShipmentComment sets the old ShipmentComment of the mutation.
func withShipmentComment(node *ShipmentComment) shipmentcommentOption {
	return func(m *ShipmentCommentMutation) {
		m.oldValue = func(context.Context) (*ShipmentComment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShipmentCommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShipmentCommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ShipmentComment entities.
func (m *ShipmentCommentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShipmentCommentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ShipmentCommentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ShipmentComment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *ShipmentCommentMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *ShipmentCommentMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the ShipmentComment entity.
// If the ShipmentComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentCommentMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *ShipmentCommentMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *ShipmentCommentMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *ShipmentCommentMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the ShipmentComment entity.
// If the ShipmentComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentCommentMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *ShipmentCommentMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ShipmentCommentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ShipmentCommentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ShipmentComment entity.
// If the ShipmentComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentCommentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ShipmentCommentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ShipmentCommentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ShipmentCommentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ShipmentComment entity.
// If the ShipmentComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentCommentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ShipmentCommentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *ShipmentCommentMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *ShipmentCommentMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the ShipmentComment entity.
// If the ShipmentComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentCommentMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *ShipmentCommentMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *ShipmentCommentMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *ShipmentCommentMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetShipmentID sets the "shipment_id" field.
func (m *ShipmentCommentMutation) SetShipmentID(u uuid.UUID) {
	m.shipment = &u
}

// ShipmentID returns the value of the "shipment_id" field in the mutation.
func (m *ShipmentCommentMutation) ShipmentID() (r uuid.UUID, exists bool) {
	v := m.shipment
	if v == nil {
		return
	}
	return *v, true
}

// OldShipmentID returns the old "shipment_id" field's value of the ShipmentComment entity.
// If the ShipmentComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentCommentMutation) OldShipmentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShipmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShipmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipmentID: %w", err)
	}
	return oldValue.ShipmentID, nil
}

// ResetShipmentID resets all changes to the "shipment_id" field.
func (m *ShipmentCommentMutation) ResetShipmentID() {
	m.shipment = nil
}

// SetCommentTypeID sets the "comment_type_id" field.
func (m *ShipmentCommentMutation) SetCommentTypeID(u uuid.UUID) {
	m.comment_type = &u
}

// CommentTypeID returns the value of the "comment_type_id" field in the mutation.
func (m *ShipmentCommentMutation) CommentTypeID() (r uuid.UUID, exists bool) {
	v := m.comment_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCommentTypeID returns the old "comment_type_id" field's value of the ShipmentComment entity.
// If the ShipmentComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentCommentMutation) OldCommentTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommentTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommentTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommentTypeID: %w", err)
	}
	return oldValue.CommentTypeID, nil
}

// ResetCommentTypeID resets all changes to the "comment_type_id" field.
func (m *ShipmentCommentMutation) ResetCommentTypeID() {
	m.comment_type = nil
}

// SetComment sets the "comment" field.
func (m *ShipmentCommentMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *ShipmentCommentMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the ShipmentComment entity.
// If the ShipmentComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentCommentMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ResetComment resets all changes to the "comment" field.
func (m *ShipmentCommentMutation) ResetComment() {
	m.comment = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ShipmentCommentMutation) SetCreatedBy(u uuid.UUID) {
	m.created_by_user = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ShipmentCommentMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.created_by_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ShipmentComment entity.
// If the ShipmentComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentCommentMutation) OldCreatedBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ShipmentCommentMutation) ResetCreatedBy() {
	m.created_by_user = nil
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *ShipmentCommentMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[shipmentcomment.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *ShipmentCommentMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *ShipmentCommentMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *ShipmentCommentMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *ShipmentCommentMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[shipmentcomment.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *ShipmentCommentMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *ShipmentCommentMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *ShipmentCommentMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearShipment clears the "shipment" edge to the Shipment entity.
func (m *ShipmentCommentMutation) ClearShipment() {
	m.clearedshipment = true
	m.clearedFields[shipmentcomment.FieldShipmentID] = struct{}{}
}

// ShipmentCleared reports if the "shipment" edge to the Shipment entity was cleared.
func (m *ShipmentCommentMutation) ShipmentCleared() bool {
	return m.clearedshipment
}

// ShipmentIDs returns the "shipment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentID instead. It exists only for internal usage by the builders.
func (m *ShipmentCommentMutation) ShipmentIDs() (ids []uuid.UUID) {
	if id := m.shipment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipment resets all changes to the "shipment" edge.
func (m *ShipmentCommentMutation) ResetShipment() {
	m.shipment = nil
	m.clearedshipment = false
}

// ClearCommentType clears the "comment_type" edge to the CommentType entity.
func (m *ShipmentCommentMutation) ClearCommentType() {
	m.clearedcomment_type = true
	m.clearedFields[shipmentcomment.FieldCommentTypeID] = struct{}{}
}

// CommentTypeCleared reports if the "comment_type" edge to the CommentType entity was cleared.
func (m *ShipmentCommentMutation) CommentTypeCleared() bool {
	return m.clearedcomment_type
}

// CommentTypeIDs returns the "comment_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CommentTypeID instead. It exists only for internal usage by the builders.
func (m *ShipmentCommentMutation) CommentTypeIDs() (ids []uuid.UUID) {
	if id := m.comment_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCommentType resets all changes to the "comment_type" edge.
func (m *ShipmentCommentMutation) ResetCommentType() {
	m.comment_type = nil
	m.clearedcomment_type = false
}

// SetCreatedByUserID sets the "created_by_user" edge to the User entity by id.
func (m *ShipmentCommentMutation) SetCreatedByUserID(id uuid.UUID) {
	m.created_by_user = &id
}

// ClearCreatedByUser clears the "created_by_user" edge to the User entity.
func (m *ShipmentCommentMutation) ClearCreatedByUser() {
	m.clearedcreated_by_user = true
	m.clearedFields[shipmentcomment.FieldCreatedBy] = struct{}{}
}

// CreatedByUserCleared reports if the "created_by_user" edge to the User entity was cleared.
func (m *ShipmentCommentMutation) CreatedByUserCleared() bool {
	return m.clearedcreated_by_user
}

// CreatedByUserID returns the "created_by_user" edge ID in the mutation.
func (m *ShipmentCommentMutation) CreatedByUserID() (id uuid.UUID, exists bool) {
	if m.created_by_user != nil {
		return *m.created_by_user, true
	}
	return
}

// CreatedByUserIDs returns the "created_by_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByUserID instead. It exists only for internal usage by the builders.
func (m *ShipmentCommentMutation) CreatedByUserIDs() (ids []uuid.UUID) {
	if id := m.created_by_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedByUser resets all changes to the "created_by_user" edge.
func (m *ShipmentCommentMutation) ResetCreatedByUser() {
	m.created_by_user = nil
	m.clearedcreated_by_user = false
}

// Where appends a list predicates to the ShipmentCommentMutation builder.
func (m *ShipmentCommentMutation) Where(ps ...predicate.ShipmentComment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ShipmentCommentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ShipmentCommentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ShipmentComment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ShipmentCommentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ShipmentCommentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ShipmentComment).
func (m *ShipmentCommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShipmentCommentMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.business_unit != nil {
		fields = append(fields, shipmentcomment.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, shipmentcomment.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, shipmentcomment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, shipmentcomment.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, shipmentcomment.FieldVersion)
	}
	if m.shipment != nil {
		fields = append(fields, shipmentcomment.FieldShipmentID)
	}
	if m.comment_type != nil {
		fields = append(fields, shipmentcomment.FieldCommentTypeID)
	}
	if m.comment != nil {
		fields = append(fields, shipmentcomment.FieldComment)
	}
	if m.created_by_user != nil {
		fields = append(fields, shipmentcomment.FieldCreatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShipmentCommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shipmentcomment.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case shipmentcomment.FieldOrganizationID:
		return m.OrganizationID()
	case shipmentcomment.FieldCreatedAt:
		return m.CreatedAt()
	case shipmentcomment.FieldUpdatedAt:
		return m.UpdatedAt()
	case shipmentcomment.FieldVersion:
		return m.Version()
	case shipmentcomment.FieldShipmentID:
		return m.ShipmentID()
	case shipmentcomment.FieldCommentTypeID:
		return m.CommentTypeID()
	case shipmentcomment.FieldComment:
		return m.Comment()
	case shipmentcomment.FieldCreatedBy:
		return m.CreatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShipmentCommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shipmentcomment.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case shipmentcomment.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case shipmentcomment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case shipmentcomment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case shipmentcomment.FieldVersion:
		return m.OldVersion(ctx)
	case shipmentcomment.FieldShipmentID:
		return m.OldShipmentID(ctx)
	case shipmentcomment.FieldCommentTypeID:
		return m.OldCommentTypeID(ctx)
	case shipmentcomment.FieldComment:
		return m.OldComment(ctx)
	case shipmentcomment.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown ShipmentComment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentCommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shipmentcomment.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case shipmentcomment.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case shipmentcomment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case shipmentcomment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case shipmentcomment.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case shipmentcomment.FieldShipmentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipmentID(v)
		return nil
	case shipmentcomment.FieldCommentTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentTypeID(v)
		return nil
	case shipmentcomment.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case shipmentcomment.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentComment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShipmentCommentMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, shipmentcomment.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShipmentCommentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case shipmentcomment.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentCommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case shipmentcomment.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentComment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShipmentCommentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShipmentCommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShipmentCommentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ShipmentComment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShipmentCommentMutation) ResetField(name string) error {
	switch name {
	case shipmentcomment.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case shipmentcomment.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case shipmentcomment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case shipmentcomment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case shipmentcomment.FieldVersion:
		m.ResetVersion()
		return nil
	case shipmentcomment.FieldShipmentID:
		m.ResetShipmentID()
		return nil
	case shipmentcomment.FieldCommentTypeID:
		m.ResetCommentTypeID()
		return nil
	case shipmentcomment.FieldComment:
		m.ResetComment()
		return nil
	case shipmentcomment.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown ShipmentComment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShipmentCommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.business_unit != nil {
		edges = append(edges, shipmentcomment.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, shipmentcomment.EdgeOrganization)
	}
	if m.shipment != nil {
		edges = append(edges, shipmentcomment.EdgeShipment)
	}
	if m.comment_type != nil {
		edges = append(edges, shipmentcomment.EdgeCommentType)
	}
	if m.created_by_user != nil {
		edges = append(edges, shipmentcomment.EdgeCreatedByUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShipmentCommentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case shipmentcomment.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case shipmentcomment.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case shipmentcomment.EdgeShipment:
		if id := m.shipment; id != nil {
			return []ent.Value{*id}
		}
	case shipmentcomment.EdgeCommentType:
		if id := m.comment_type; id != nil {
			return []ent.Value{*id}
		}
	case shipmentcomment.EdgeCreatedByUser:
		if id := m.created_by_user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShipmentCommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShipmentCommentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShipmentCommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedbusiness_unit {
		edges = append(edges, shipmentcomment.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, shipmentcomment.EdgeOrganization)
	}
	if m.clearedshipment {
		edges = append(edges, shipmentcomment.EdgeShipment)
	}
	if m.clearedcomment_type {
		edges = append(edges, shipmentcomment.EdgeCommentType)
	}
	if m.clearedcreated_by_user {
		edges = append(edges, shipmentcomment.EdgeCreatedByUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShipmentCommentMutation) EdgeCleared(name string) bool {
	switch name {
	case shipmentcomment.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case shipmentcomment.EdgeOrganization:
		return m.clearedorganization
	case shipmentcomment.EdgeShipment:
		return m.clearedshipment
	case shipmentcomment.EdgeCommentType:
		return m.clearedcomment_type
	case shipmentcomment.EdgeCreatedByUser:
		return m.clearedcreated_by_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShipmentCommentMutation) ClearEdge(name string) error {
	switch name {
	case shipmentcomment.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case shipmentcomment.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case shipmentcomment.EdgeShipment:
		m.ClearShipment()
		return nil
	case shipmentcomment.EdgeCommentType:
		m.ClearCommentType()
		return nil
	case shipmentcomment.EdgeCreatedByUser:
		m.ClearCreatedByUser()
		return nil
	}
	return fmt.Errorf("unknown ShipmentComment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShipmentCommentMutation) ResetEdge(name string) error {
	switch name {
	case shipmentcomment.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case shipmentcomment.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case shipmentcomment.EdgeShipment:
		m.ResetShipment()
		return nil
	case shipmentcomment.EdgeCommentType:
		m.ResetCommentType()
		return nil
	case shipmentcomment.EdgeCreatedByUser:
		m.ResetCreatedByUser()
		return nil
	}
	return fmt.Errorf("unknown ShipmentComment edge %s", name)
}

// ShipmentCommodityMutation represents an operation that mutates the ShipmentCommodity nodes in the graph.
type ShipmentCommodityMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	created_at            *time.Time
	updated_at            *time.Time
	version               *int
	addversion            *int
	commodity_id          *uuid.UUID
	hazardous_material_id *uuid.UUID
	sub_total             *float64
	addsub_total          *float64
	placard_needed        *bool
	clearedFields         map[string]struct{}
	business_unit         *uuid.UUID
	clearedbusiness_unit  bool
	organization          *uuid.UUID
	clearedorganization   bool
	shipment              *uuid.UUID
	clearedshipment       bool
	done                  bool
	oldValue              func(context.Context) (*ShipmentCommodity, error)
	predicates            []predicate.ShipmentCommodity
}

var _ ent.Mutation = (*ShipmentCommodityMutation)(nil)

// shipmentcommodityOption allows management of the mutation configuration using functional options.
type shipmentcommodityOption func(*ShipmentCommodityMutation)

// newShipmentCommodityMutation creates new mutation for the ShipmentCommodity entity.
func newShipmentCommodityMutation(c config, op Op, opts ...shipmentcommodityOption) *ShipmentCommodityMutation {
	m := &ShipmentCommodityMutation{
		config:        c,
		op:            op,
		typ:           TypeShipmentCommodity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShipmentCommodityID sets the ID field of the mutation.
func withShipmentCommodityID(id uuid.UUID) shipmentcommodityOption {
	return func(m *ShipmentCommodityMutation) {
		var (
			err   error
			once  sync.Once
			value *ShipmentCommodity
		)
		m.oldValue = func(ctx context.Context) (*ShipmentCommodity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShipmentCommodity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShipmentCommodity sets the old ShipmentCommodity of the mutation.
func withShipmentCommodity(node *ShipmentCommodity) shipmentcommodityOption {
	return func(m *ShipmentCommodityMutation) {
		m.oldValue = func(context.Context) (*ShipmentCommodity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShipmentCommodityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShipmentCommodityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ShipmentCommodity entities.
func (m *ShipmentCommodityMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShipmentCommodityMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ShipmentCommodityMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ShipmentCommodity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *ShipmentCommodityMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *ShipmentCommodityMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the ShipmentCommodity entity.
// If the ShipmentCommodity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentCommodityMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *ShipmentCommodityMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *ShipmentCommodityMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *ShipmentCommodityMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the ShipmentCommodity entity.
// If the ShipmentCommodity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentCommodityMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *ShipmentCommodityMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ShipmentCommodityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ShipmentCommodityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ShipmentCommodity entity.
// If the ShipmentCommodity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentCommodityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ShipmentCommodityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ShipmentCommodityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ShipmentCommodityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ShipmentCommodity entity.
// If the ShipmentCommodity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentCommodityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ShipmentCommodityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *ShipmentCommodityMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *ShipmentCommodityMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the ShipmentCommodity entity.
// If the ShipmentCommodity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentCommodityMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *ShipmentCommodityMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *ShipmentCommodityMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *ShipmentCommodityMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetShipmentID sets the "shipment_id" field.
func (m *ShipmentCommodityMutation) SetShipmentID(u uuid.UUID) {
	m.shipment = &u
}

// ShipmentID returns the value of the "shipment_id" field in the mutation.
func (m *ShipmentCommodityMutation) ShipmentID() (r uuid.UUID, exists bool) {
	v := m.shipment
	if v == nil {
		return
	}
	return *v, true
}

// OldShipmentID returns the old "shipment_id" field's value of the ShipmentCommodity entity.
// If the ShipmentCommodity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentCommodityMutation) OldShipmentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShipmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShipmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipmentID: %w", err)
	}
	return oldValue.ShipmentID, nil
}

// ResetShipmentID resets all changes to the "shipment_id" field.
func (m *ShipmentCommodityMutation) ResetShipmentID() {
	m.shipment = nil
}

// SetCommodityID sets the "commodity_id" field.
func (m *ShipmentCommodityMutation) SetCommodityID(u uuid.UUID) {
	m.commodity_id = &u
}

// CommodityID returns the value of the "commodity_id" field in the mutation.
func (m *ShipmentCommodityMutation) CommodityID() (r uuid.UUID, exists bool) {
	v := m.commodity_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCommodityID returns the old "commodity_id" field's value of the ShipmentCommodity entity.
// If the ShipmentCommodity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentCommodityMutation) OldCommodityID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommodityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommodityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommodityID: %w", err)
	}
	return oldValue.CommodityID, nil
}

// ResetCommodityID resets all changes to the "commodity_id" field.
func (m *ShipmentCommodityMutation) ResetCommodityID() {
	m.commodity_id = nil
}

// SetHazardousMaterialID sets the "hazardous_material_id" field.
func (m *ShipmentCommodityMutation) SetHazardousMaterialID(u uuid.UUID) {
	m.hazardous_material_id = &u
}

// HazardousMaterialID returns the value of the "hazardous_material_id" field in the mutation.
func (m *ShipmentCommodityMutation) HazardousMaterialID() (r uuid.UUID, exists bool) {
	v := m.hazardous_material_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHazardousMaterialID returns the old "hazardous_material_id" field's value of the ShipmentCommodity entity.
// If the ShipmentCommodity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentCommodityMutation) OldHazardousMaterialID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHazardousMaterialID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHazardousMaterialID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHazardousMaterialID: %w", err)
	}
	return oldValue.HazardousMaterialID, nil
}

// ResetHazardousMaterialID resets all changes to the "hazardous_material_id" field.
func (m *ShipmentCommodityMutation) ResetHazardousMaterialID() {
	m.hazardous_material_id = nil
}

// SetSubTotal sets the "sub_total" field.
func (m *ShipmentCommodityMutation) SetSubTotal(f float64) {
	m.sub_total = &f
	m.addsub_total = nil
}

// SubTotal returns the value of the "sub_total" field in the mutation.
func (m *ShipmentCommodityMutation) SubTotal() (r float64, exists bool) {
	v := m.sub_total
	if v == nil {
		return
	}
	return *v, true
}

// OldSubTotal returns the old "sub_total" field's value of the ShipmentCommodity entity.
// If the ShipmentCommodity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentCommodityMutation) OldSubTotal(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubTotal: %w", err)
	}
	return oldValue.SubTotal, nil
}

// AddSubTotal adds f to the "sub_total" field.
func (m *ShipmentCommodityMutation) AddSubTotal(f float64) {
	if m.addsub_total != nil {
		*m.addsub_total += f
	} else {
		m.addsub_total = &f
	}
}

// AddedSubTotal returns the value that was added to the "sub_total" field in this mutation.
func (m *ShipmentCommodityMutation) AddedSubTotal() (r float64, exists bool) {
	v := m.addsub_total
	if v == nil {
		return
	}
	return *v, true
}

// ResetSubTotal resets all changes to the "sub_total" field.
func (m *ShipmentCommodityMutation) ResetSubTotal() {
	m.sub_total = nil
	m.addsub_total = nil
}

// SetPlacardNeeded sets the "placard_needed" field.
func (m *ShipmentCommodityMutation) SetPlacardNeeded(b bool) {
	m.placard_needed = &b
}

// PlacardNeeded returns the value of the "placard_needed" field in the mutation.
func (m *ShipmentCommodityMutation) PlacardNeeded() (r bool, exists bool) {
	v := m.placard_needed
	if v == nil {
		return
	}
	return *v, true
}

// OldPlacardNeeded returns the old "placard_needed" field's value of the ShipmentCommodity entity.
// If the ShipmentCommodity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentCommodityMutation) OldPlacardNeeded(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlacardNeeded is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlacardNeeded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlacardNeeded: %w", err)
	}
	return oldValue.PlacardNeeded, nil
}

// ResetPlacardNeeded resets all changes to the "placard_needed" field.
func (m *ShipmentCommodityMutation) ResetPlacardNeeded() {
	m.placard_needed = nil
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *ShipmentCommodityMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[shipmentcommodity.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *ShipmentCommodityMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *ShipmentCommodityMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *ShipmentCommodityMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *ShipmentCommodityMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[shipmentcommodity.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *ShipmentCommodityMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *ShipmentCommodityMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *ShipmentCommodityMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearShipment clears the "shipment" edge to the Shipment entity.
func (m *ShipmentCommodityMutation) ClearShipment() {
	m.clearedshipment = true
	m.clearedFields[shipmentcommodity.FieldShipmentID] = struct{}{}
}

// ShipmentCleared reports if the "shipment" edge to the Shipment entity was cleared.
func (m *ShipmentCommodityMutation) ShipmentCleared() bool {
	return m.clearedshipment
}

// ShipmentIDs returns the "shipment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentID instead. It exists only for internal usage by the builders.
func (m *ShipmentCommodityMutation) ShipmentIDs() (ids []uuid.UUID) {
	if id := m.shipment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipment resets all changes to the "shipment" edge.
func (m *ShipmentCommodityMutation) ResetShipment() {
	m.shipment = nil
	m.clearedshipment = false
}

// Where appends a list predicates to the ShipmentCommodityMutation builder.
func (m *ShipmentCommodityMutation) Where(ps ...predicate.ShipmentCommodity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ShipmentCommodityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ShipmentCommodityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ShipmentCommodity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ShipmentCommodityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ShipmentCommodityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ShipmentCommodity).
func (m *ShipmentCommodityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShipmentCommodityMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.business_unit != nil {
		fields = append(fields, shipmentcommodity.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, shipmentcommodity.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, shipmentcommodity.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, shipmentcommodity.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, shipmentcommodity.FieldVersion)
	}
	if m.shipment != nil {
		fields = append(fields, shipmentcommodity.FieldShipmentID)
	}
	if m.commodity_id != nil {
		fields = append(fields, shipmentcommodity.FieldCommodityID)
	}
	if m.hazardous_material_id != nil {
		fields = append(fields, shipmentcommodity.FieldHazardousMaterialID)
	}
	if m.sub_total != nil {
		fields = append(fields, shipmentcommodity.FieldSubTotal)
	}
	if m.placard_needed != nil {
		fields = append(fields, shipmentcommodity.FieldPlacardNeeded)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShipmentCommodityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shipmentcommodity.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case shipmentcommodity.FieldOrganizationID:
		return m.OrganizationID()
	case shipmentcommodity.FieldCreatedAt:
		return m.CreatedAt()
	case shipmentcommodity.FieldUpdatedAt:
		return m.UpdatedAt()
	case shipmentcommodity.FieldVersion:
		return m.Version()
	case shipmentcommodity.FieldShipmentID:
		return m.ShipmentID()
	case shipmentcommodity.FieldCommodityID:
		return m.CommodityID()
	case shipmentcommodity.FieldHazardousMaterialID:
		return m.HazardousMaterialID()
	case shipmentcommodity.FieldSubTotal:
		return m.SubTotal()
	case shipmentcommodity.FieldPlacardNeeded:
		return m.PlacardNeeded()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShipmentCommodityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shipmentcommodity.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case shipmentcommodity.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case shipmentcommodity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case shipmentcommodity.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case shipmentcommodity.FieldVersion:
		return m.OldVersion(ctx)
	case shipmentcommodity.FieldShipmentID:
		return m.OldShipmentID(ctx)
	case shipmentcommodity.FieldCommodityID:
		return m.OldCommodityID(ctx)
	case shipmentcommodity.FieldHazardousMaterialID:
		return m.OldHazardousMaterialID(ctx)
	case shipmentcommodity.FieldSubTotal:
		return m.OldSubTotal(ctx)
	case shipmentcommodity.FieldPlacardNeeded:
		return m.OldPlacardNeeded(ctx)
	}
	return nil, fmt.Errorf("unknown ShipmentCommodity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentCommodityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shipmentcommodity.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case shipmentcommodity.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case shipmentcommodity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case shipmentcommodity.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case shipmentcommodity.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case shipmentcommodity.FieldShipmentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipmentID(v)
		return nil
	case shipmentcommodity.FieldCommodityID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommodityID(v)
		return nil
	case shipmentcommodity.FieldHazardousMaterialID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHazardousMaterialID(v)
		return nil
	case shipmentcommodity.FieldSubTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubTotal(v)
		return nil
	case shipmentcommodity.FieldPlacardNeeded:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlacardNeeded(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentCommodity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShipmentCommodityMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, shipmentcommodity.FieldVersion)
	}
	if m.addsub_total != nil {
		fields = append(fields, shipmentcommodity.FieldSubTotal)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShipmentCommodityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case shipmentcommodity.FieldVersion:
		return m.AddedVersion()
	case shipmentcommodity.FieldSubTotal:
		return m.AddedSubTotal()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentCommodityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case shipmentcommodity.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case shipmentcommodity.FieldSubTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSubTotal(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentCommodity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShipmentCommodityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShipmentCommodityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShipmentCommodityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ShipmentCommodity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShipmentCommodityMutation) ResetField(name string) error {
	switch name {
	case shipmentcommodity.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case shipmentcommodity.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case shipmentcommodity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case shipmentcommodity.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case shipmentcommodity.FieldVersion:
		m.ResetVersion()
		return nil
	case shipmentcommodity.FieldShipmentID:
		m.ResetShipmentID()
		return nil
	case shipmentcommodity.FieldCommodityID:
		m.ResetCommodityID()
		return nil
	case shipmentcommodity.FieldHazardousMaterialID:
		m.ResetHazardousMaterialID()
		return nil
	case shipmentcommodity.FieldSubTotal:
		m.ResetSubTotal()
		return nil
	case shipmentcommodity.FieldPlacardNeeded:
		m.ResetPlacardNeeded()
		return nil
	}
	return fmt.Errorf("unknown ShipmentCommodity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShipmentCommodityMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.business_unit != nil {
		edges = append(edges, shipmentcommodity.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, shipmentcommodity.EdgeOrganization)
	}
	if m.shipment != nil {
		edges = append(edges, shipmentcommodity.EdgeShipment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShipmentCommodityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case shipmentcommodity.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case shipmentcommodity.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case shipmentcommodity.EdgeShipment:
		if id := m.shipment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShipmentCommodityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShipmentCommodityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShipmentCommodityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbusiness_unit {
		edges = append(edges, shipmentcommodity.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, shipmentcommodity.EdgeOrganization)
	}
	if m.clearedshipment {
		edges = append(edges, shipmentcommodity.EdgeShipment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShipmentCommodityMutation) EdgeCleared(name string) bool {
	switch name {
	case shipmentcommodity.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case shipmentcommodity.EdgeOrganization:
		return m.clearedorganization
	case shipmentcommodity.EdgeShipment:
		return m.clearedshipment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShipmentCommodityMutation) ClearEdge(name string) error {
	switch name {
	case shipmentcommodity.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case shipmentcommodity.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case shipmentcommodity.EdgeShipment:
		m.ClearShipment()
		return nil
	}
	return fmt.Errorf("unknown ShipmentCommodity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShipmentCommodityMutation) ResetEdge(name string) error {
	switch name {
	case shipmentcommodity.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case shipmentcommodity.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case shipmentcommodity.EdgeShipment:
		m.ResetShipment()
		return nil
	}
	return fmt.Errorf("unknown ShipmentCommodity edge %s", name)
}

// ShipmentControlMutation represents an operation that mutates the ShipmentControl nodes in the graph.
type ShipmentControlMutation struct {
	config
	op                         Op
	typ                        string
	id                         *uuid.UUID
	created_at                 *time.Time
	updated_at                 *time.Time
	auto_rate_shipment         *bool
	calculate_distance         *bool
	enforce_rev_code           *bool
	enforce_voided_comm        *bool
	generate_routes            *bool
	enforce_commodity          *bool
	auto_sequence_stops        *bool
	auto_shipment_total        *bool
	enforce_origin_destination *bool
	check_for_duplicate_bol    *bool
	send_placard_info          *bool
	enforce_hazmat_seg_rules   *bool
	clearedFields              map[string]struct{}
	organization               *uuid.UUID
	clearedorganization        bool
	business_unit              *uuid.UUID
	clearedbusiness_unit       bool
	done                       bool
	oldValue                   func(context.Context) (*ShipmentControl, error)
	predicates                 []predicate.ShipmentControl
}

var _ ent.Mutation = (*ShipmentControlMutation)(nil)

// shipmentcontrolOption allows management of the mutation configuration using functional options.
type shipmentcontrolOption func(*ShipmentControlMutation)

// newShipmentControlMutation creates new mutation for the ShipmentControl entity.
func newShipmentControlMutation(c config, op Op, opts ...shipmentcontrolOption) *ShipmentControlMutation {
	m := &ShipmentControlMutation{
		config:        c,
		op:            op,
		typ:           TypeShipmentControl,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShipmentControlID sets the ID field of the mutation.
func withShipmentControlID(id uuid.UUID) shipmentcontrolOption {
	return func(m *ShipmentControlMutation) {
		var (
			err   error
			once  sync.Once
			value *ShipmentControl
		)
		m.oldValue = func(ctx context.Context) (*ShipmentControl, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShipmentControl.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShipmentControl sets the old ShipmentControl of the mutation.
func withShipmentControl(node *ShipmentControl) shipmentcontrolOption {
	return func(m *ShipmentControlMutation) {
		m.oldValue = func(context.Context) (*ShipmentControl, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShipmentControlMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShipmentControlMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ShipmentControl entities.
func (m *ShipmentControlMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShipmentControlMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ShipmentControlMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ShipmentControl.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ShipmentControlMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ShipmentControlMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ShipmentControl entity.
// If the ShipmentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentControlMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ShipmentControlMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ShipmentControlMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ShipmentControlMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ShipmentControl entity.
// If the ShipmentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentControlMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ShipmentControlMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAutoRateShipment sets the "auto_rate_shipment" field.
func (m *ShipmentControlMutation) SetAutoRateShipment(b bool) {
	m.auto_rate_shipment = &b
}

// AutoRateShipment returns the value of the "auto_rate_shipment" field in the mutation.
func (m *ShipmentControlMutation) AutoRateShipment() (r bool, exists bool) {
	v := m.auto_rate_shipment
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoRateShipment returns the old "auto_rate_shipment" field's value of the ShipmentControl entity.
// If the ShipmentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentControlMutation) OldAutoRateShipment(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoRateShipment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoRateShipment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoRateShipment: %w", err)
	}
	return oldValue.AutoRateShipment, nil
}

// ResetAutoRateShipment resets all changes to the "auto_rate_shipment" field.
func (m *ShipmentControlMutation) ResetAutoRateShipment() {
	m.auto_rate_shipment = nil
}

// SetCalculateDistance sets the "calculate_distance" field.
func (m *ShipmentControlMutation) SetCalculateDistance(b bool) {
	m.calculate_distance = &b
}

// CalculateDistance returns the value of the "calculate_distance" field in the mutation.
func (m *ShipmentControlMutation) CalculateDistance() (r bool, exists bool) {
	v := m.calculate_distance
	if v == nil {
		return
	}
	return *v, true
}

// OldCalculateDistance returns the old "calculate_distance" field's value of the ShipmentControl entity.
// If the ShipmentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentControlMutation) OldCalculateDistance(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCalculateDistance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCalculateDistance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCalculateDistance: %w", err)
	}
	return oldValue.CalculateDistance, nil
}

// ResetCalculateDistance resets all changes to the "calculate_distance" field.
func (m *ShipmentControlMutation) ResetCalculateDistance() {
	m.calculate_distance = nil
}

// SetEnforceRevCode sets the "enforce_rev_code" field.
func (m *ShipmentControlMutation) SetEnforceRevCode(b bool) {
	m.enforce_rev_code = &b
}

// EnforceRevCode returns the value of the "enforce_rev_code" field in the mutation.
func (m *ShipmentControlMutation) EnforceRevCode() (r bool, exists bool) {
	v := m.enforce_rev_code
	if v == nil {
		return
	}
	return *v, true
}

// OldEnforceRevCode returns the old "enforce_rev_code" field's value of the ShipmentControl entity.
// If the ShipmentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentControlMutation) OldEnforceRevCode(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnforceRevCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnforceRevCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnforceRevCode: %w", err)
	}
	return oldValue.EnforceRevCode, nil
}

// ResetEnforceRevCode resets all changes to the "enforce_rev_code" field.
func (m *ShipmentControlMutation) ResetEnforceRevCode() {
	m.enforce_rev_code = nil
}

// SetEnforceVoidedComm sets the "enforce_voided_comm" field.
func (m *ShipmentControlMutation) SetEnforceVoidedComm(b bool) {
	m.enforce_voided_comm = &b
}

// EnforceVoidedComm returns the value of the "enforce_voided_comm" field in the mutation.
func (m *ShipmentControlMutation) EnforceVoidedComm() (r bool, exists bool) {
	v := m.enforce_voided_comm
	if v == nil {
		return
	}
	return *v, true
}

// OldEnforceVoidedComm returns the old "enforce_voided_comm" field's value of the ShipmentControl entity.
// If the ShipmentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentControlMutation) OldEnforceVoidedComm(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnforceVoidedComm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnforceVoidedComm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnforceVoidedComm: %w", err)
	}
	return oldValue.EnforceVoidedComm, nil
}

// ResetEnforceVoidedComm resets all changes to the "enforce_voided_comm" field.
func (m *ShipmentControlMutation) ResetEnforceVoidedComm() {
	m.enforce_voided_comm = nil
}

// SetGenerateRoutes sets the "generate_routes" field.
func (m *ShipmentControlMutation) SetGenerateRoutes(b bool) {
	m.generate_routes = &b
}

// GenerateRoutes returns the value of the "generate_routes" field in the mutation.
func (m *ShipmentControlMutation) GenerateRoutes() (r bool, exists bool) {
	v := m.generate_routes
	if v == nil {
		return
	}
	return *v, true
}

// OldGenerateRoutes returns the old "generate_routes" field's value of the ShipmentControl entity.
// If the ShipmentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentControlMutation) OldGenerateRoutes(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGenerateRoutes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGenerateRoutes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenerateRoutes: %w", err)
	}
	return oldValue.GenerateRoutes, nil
}

// ResetGenerateRoutes resets all changes to the "generate_routes" field.
func (m *ShipmentControlMutation) ResetGenerateRoutes() {
	m.generate_routes = nil
}

// SetEnforceCommodity sets the "enforce_commodity" field.
func (m *ShipmentControlMutation) SetEnforceCommodity(b bool) {
	m.enforce_commodity = &b
}

// EnforceCommodity returns the value of the "enforce_commodity" field in the mutation.
func (m *ShipmentControlMutation) EnforceCommodity() (r bool, exists bool) {
	v := m.enforce_commodity
	if v == nil {
		return
	}
	return *v, true
}

// OldEnforceCommodity returns the old "enforce_commodity" field's value of the ShipmentControl entity.
// If the ShipmentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentControlMutation) OldEnforceCommodity(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnforceCommodity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnforceCommodity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnforceCommodity: %w", err)
	}
	return oldValue.EnforceCommodity, nil
}

// ResetEnforceCommodity resets all changes to the "enforce_commodity" field.
func (m *ShipmentControlMutation) ResetEnforceCommodity() {
	m.enforce_commodity = nil
}

// SetAutoSequenceStops sets the "auto_sequence_stops" field.
func (m *ShipmentControlMutation) SetAutoSequenceStops(b bool) {
	m.auto_sequence_stops = &b
}

// AutoSequenceStops returns the value of the "auto_sequence_stops" field in the mutation.
func (m *ShipmentControlMutation) AutoSequenceStops() (r bool, exists bool) {
	v := m.auto_sequence_stops
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoSequenceStops returns the old "auto_sequence_stops" field's value of the ShipmentControl entity.
// If the ShipmentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentControlMutation) OldAutoSequenceStops(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoSequenceStops is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoSequenceStops requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoSequenceStops: %w", err)
	}
	return oldValue.AutoSequenceStops, nil
}

// ResetAutoSequenceStops resets all changes to the "auto_sequence_stops" field.
func (m *ShipmentControlMutation) ResetAutoSequenceStops() {
	m.auto_sequence_stops = nil
}

// SetAutoShipmentTotal sets the "auto_shipment_total" field.
func (m *ShipmentControlMutation) SetAutoShipmentTotal(b bool) {
	m.auto_shipment_total = &b
}

// AutoShipmentTotal returns the value of the "auto_shipment_total" field in the mutation.
func (m *ShipmentControlMutation) AutoShipmentTotal() (r bool, exists bool) {
	v := m.auto_shipment_total
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoShipmentTotal returns the old "auto_shipment_total" field's value of the ShipmentControl entity.
// If the ShipmentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentControlMutation) OldAutoShipmentTotal(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoShipmentTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoShipmentTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoShipmentTotal: %w", err)
	}
	return oldValue.AutoShipmentTotal, nil
}

// ResetAutoShipmentTotal resets all changes to the "auto_shipment_total" field.
func (m *ShipmentControlMutation) ResetAutoShipmentTotal() {
	m.auto_shipment_total = nil
}

// SetEnforceOriginDestination sets the "enforce_origin_destination" field.
func (m *ShipmentControlMutation) SetEnforceOriginDestination(b bool) {
	m.enforce_origin_destination = &b
}

// EnforceOriginDestination returns the value of the "enforce_origin_destination" field in the mutation.
func (m *ShipmentControlMutation) EnforceOriginDestination() (r bool, exists bool) {
	v := m.enforce_origin_destination
	if v == nil {
		return
	}
	return *v, true
}

// OldEnforceOriginDestination returns the old "enforce_origin_destination" field's value of the ShipmentControl entity.
// If the ShipmentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentControlMutation) OldEnforceOriginDestination(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnforceOriginDestination is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnforceOriginDestination requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnforceOriginDestination: %w", err)
	}
	return oldValue.EnforceOriginDestination, nil
}

// ResetEnforceOriginDestination resets all changes to the "enforce_origin_destination" field.
func (m *ShipmentControlMutation) ResetEnforceOriginDestination() {
	m.enforce_origin_destination = nil
}

// SetCheckForDuplicateBol sets the "check_for_duplicate_bol" field.
func (m *ShipmentControlMutation) SetCheckForDuplicateBol(b bool) {
	m.check_for_duplicate_bol = &b
}

// CheckForDuplicateBol returns the value of the "check_for_duplicate_bol" field in the mutation.
func (m *ShipmentControlMutation) CheckForDuplicateBol() (r bool, exists bool) {
	v := m.check_for_duplicate_bol
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckForDuplicateBol returns the old "check_for_duplicate_bol" field's value of the ShipmentControl entity.
// If the ShipmentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentControlMutation) OldCheckForDuplicateBol(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCheckForDuplicateBol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCheckForDuplicateBol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckForDuplicateBol: %w", err)
	}
	return oldValue.CheckForDuplicateBol, nil
}

// ResetCheckForDuplicateBol resets all changes to the "check_for_duplicate_bol" field.
func (m *ShipmentControlMutation) ResetCheckForDuplicateBol() {
	m.check_for_duplicate_bol = nil
}

// SetSendPlacardInfo sets the "send_placard_info" field.
func (m *ShipmentControlMutation) SetSendPlacardInfo(b bool) {
	m.send_placard_info = &b
}

// SendPlacardInfo returns the value of the "send_placard_info" field in the mutation.
func (m *ShipmentControlMutation) SendPlacardInfo() (r bool, exists bool) {
	v := m.send_placard_info
	if v == nil {
		return
	}
	return *v, true
}

// OldSendPlacardInfo returns the old "send_placard_info" field's value of the ShipmentControl entity.
// If the ShipmentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentControlMutation) OldSendPlacardInfo(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSendPlacardInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSendPlacardInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSendPlacardInfo: %w", err)
	}
	return oldValue.SendPlacardInfo, nil
}

// ResetSendPlacardInfo resets all changes to the "send_placard_info" field.
func (m *ShipmentControlMutation) ResetSendPlacardInfo() {
	m.send_placard_info = nil
}

// SetEnforceHazmatSegRules sets the "enforce_hazmat_seg_rules" field.
func (m *ShipmentControlMutation) SetEnforceHazmatSegRules(b bool) {
	m.enforce_hazmat_seg_rules = &b
}

// EnforceHazmatSegRules returns the value of the "enforce_hazmat_seg_rules" field in the mutation.
func (m *ShipmentControlMutation) EnforceHazmatSegRules() (r bool, exists bool) {
	v := m.enforce_hazmat_seg_rules
	if v == nil {
		return
	}
	return *v, true
}

// OldEnforceHazmatSegRules returns the old "enforce_hazmat_seg_rules" field's value of the ShipmentControl entity.
// If the ShipmentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentControlMutation) OldEnforceHazmatSegRules(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnforceHazmatSegRules is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnforceHazmatSegRules requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnforceHazmatSegRules: %w", err)
	}
	return oldValue.EnforceHazmatSegRules, nil
}

// ResetEnforceHazmatSegRules resets all changes to the "enforce_hazmat_seg_rules" field.
func (m *ShipmentControlMutation) ResetEnforceHazmatSegRules() {
	m.enforce_hazmat_seg_rules = nil
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *ShipmentControlMutation) SetOrganizationID(id uuid.UUID) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *ShipmentControlMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *ShipmentControlMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *ShipmentControlMutation) OrganizationID() (id uuid.UUID, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *ShipmentControlMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *ShipmentControlMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// SetBusinessUnitID sets the "business_unit" edge to the BusinessUnit entity by id.
func (m *ShipmentControlMutation) SetBusinessUnitID(id uuid.UUID) {
	m.business_unit = &id
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *ShipmentControlMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *ShipmentControlMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitID returns the "business_unit" edge ID in the mutation.
func (m *ShipmentControlMutation) BusinessUnitID() (id uuid.UUID, exists bool) {
	if m.business_unit != nil {
		return *m.business_unit, true
	}
	return
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *ShipmentControlMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *ShipmentControlMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// Where appends a list predicates to the ShipmentControlMutation builder.
func (m *ShipmentControlMutation) Where(ps ...predicate.ShipmentControl) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ShipmentControlMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ShipmentControlMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ShipmentControl, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ShipmentControlMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ShipmentControlMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ShipmentControl).
func (m *ShipmentControlMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShipmentControlMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, shipmentcontrol.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, shipmentcontrol.FieldUpdatedAt)
	}
	if m.auto_rate_shipment != nil {
		fields = append(fields, shipmentcontrol.FieldAutoRateShipment)
	}
	if m.calculate_distance != nil {
		fields = append(fields, shipmentcontrol.FieldCalculateDistance)
	}
	if m.enforce_rev_code != nil {
		fields = append(fields, shipmentcontrol.FieldEnforceRevCode)
	}
	if m.enforce_voided_comm != nil {
		fields = append(fields, shipmentcontrol.FieldEnforceVoidedComm)
	}
	if m.generate_routes != nil {
		fields = append(fields, shipmentcontrol.FieldGenerateRoutes)
	}
	if m.enforce_commodity != nil {
		fields = append(fields, shipmentcontrol.FieldEnforceCommodity)
	}
	if m.auto_sequence_stops != nil {
		fields = append(fields, shipmentcontrol.FieldAutoSequenceStops)
	}
	if m.auto_shipment_total != nil {
		fields = append(fields, shipmentcontrol.FieldAutoShipmentTotal)
	}
	if m.enforce_origin_destination != nil {
		fields = append(fields, shipmentcontrol.FieldEnforceOriginDestination)
	}
	if m.check_for_duplicate_bol != nil {
		fields = append(fields, shipmentcontrol.FieldCheckForDuplicateBol)
	}
	if m.send_placard_info != nil {
		fields = append(fields, shipmentcontrol.FieldSendPlacardInfo)
	}
	if m.enforce_hazmat_seg_rules != nil {
		fields = append(fields, shipmentcontrol.FieldEnforceHazmatSegRules)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShipmentControlMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shipmentcontrol.FieldCreatedAt:
		return m.CreatedAt()
	case shipmentcontrol.FieldUpdatedAt:
		return m.UpdatedAt()
	case shipmentcontrol.FieldAutoRateShipment:
		return m.AutoRateShipment()
	case shipmentcontrol.FieldCalculateDistance:
		return m.CalculateDistance()
	case shipmentcontrol.FieldEnforceRevCode:
		return m.EnforceRevCode()
	case shipmentcontrol.FieldEnforceVoidedComm:
		return m.EnforceVoidedComm()
	case shipmentcontrol.FieldGenerateRoutes:
		return m.GenerateRoutes()
	case shipmentcontrol.FieldEnforceCommodity:
		return m.EnforceCommodity()
	case shipmentcontrol.FieldAutoSequenceStops:
		return m.AutoSequenceStops()
	case shipmentcontrol.FieldAutoShipmentTotal:
		return m.AutoShipmentTotal()
	case shipmentcontrol.FieldEnforceOriginDestination:
		return m.EnforceOriginDestination()
	case shipmentcontrol.FieldCheckForDuplicateBol:
		return m.CheckForDuplicateBol()
	case shipmentcontrol.FieldSendPlacardInfo:
		return m.SendPlacardInfo()
	case shipmentcontrol.FieldEnforceHazmatSegRules:
		return m.EnforceHazmatSegRules()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShipmentControlMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shipmentcontrol.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case shipmentcontrol.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case shipmentcontrol.FieldAutoRateShipment:
		return m.OldAutoRateShipment(ctx)
	case shipmentcontrol.FieldCalculateDistance:
		return m.OldCalculateDistance(ctx)
	case shipmentcontrol.FieldEnforceRevCode:
		return m.OldEnforceRevCode(ctx)
	case shipmentcontrol.FieldEnforceVoidedComm:
		return m.OldEnforceVoidedComm(ctx)
	case shipmentcontrol.FieldGenerateRoutes:
		return m.OldGenerateRoutes(ctx)
	case shipmentcontrol.FieldEnforceCommodity:
		return m.OldEnforceCommodity(ctx)
	case shipmentcontrol.FieldAutoSequenceStops:
		return m.OldAutoSequenceStops(ctx)
	case shipmentcontrol.FieldAutoShipmentTotal:
		return m.OldAutoShipmentTotal(ctx)
	case shipmentcontrol.FieldEnforceOriginDestination:
		return m.OldEnforceOriginDestination(ctx)
	case shipmentcontrol.FieldCheckForDuplicateBol:
		return m.OldCheckForDuplicateBol(ctx)
	case shipmentcontrol.FieldSendPlacardInfo:
		return m.OldSendPlacardInfo(ctx)
	case shipmentcontrol.FieldEnforceHazmatSegRules:
		return m.OldEnforceHazmatSegRules(ctx)
	}
	return nil, fmt.Errorf("unknown ShipmentControl field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentControlMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shipmentcontrol.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case shipmentcontrol.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case shipmentcontrol.FieldAutoRateShipment:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoRateShipment(v)
		return nil
	case shipmentcontrol.FieldCalculateDistance:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCalculateDistance(v)
		return nil
	case shipmentcontrol.FieldEnforceRevCode:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnforceRevCode(v)
		return nil
	case shipmentcontrol.FieldEnforceVoidedComm:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnforceVoidedComm(v)
		return nil
	case shipmentcontrol.FieldGenerateRoutes:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenerateRoutes(v)
		return nil
	case shipmentcontrol.FieldEnforceCommodity:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnforceCommodity(v)
		return nil
	case shipmentcontrol.FieldAutoSequenceStops:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoSequenceStops(v)
		return nil
	case shipmentcontrol.FieldAutoShipmentTotal:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoShipmentTotal(v)
		return nil
	case shipmentcontrol.FieldEnforceOriginDestination:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnforceOriginDestination(v)
		return nil
	case shipmentcontrol.FieldCheckForDuplicateBol:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckForDuplicateBol(v)
		return nil
	case shipmentcontrol.FieldSendPlacardInfo:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSendPlacardInfo(v)
		return nil
	case shipmentcontrol.FieldEnforceHazmatSegRules:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnforceHazmatSegRules(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentControl field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShipmentControlMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShipmentControlMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentControlMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ShipmentControl numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShipmentControlMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShipmentControlMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShipmentControlMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ShipmentControl nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShipmentControlMutation) ResetField(name string) error {
	switch name {
	case shipmentcontrol.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case shipmentcontrol.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case shipmentcontrol.FieldAutoRateShipment:
		m.ResetAutoRateShipment()
		return nil
	case shipmentcontrol.FieldCalculateDistance:
		m.ResetCalculateDistance()
		return nil
	case shipmentcontrol.FieldEnforceRevCode:
		m.ResetEnforceRevCode()
		return nil
	case shipmentcontrol.FieldEnforceVoidedComm:
		m.ResetEnforceVoidedComm()
		return nil
	case shipmentcontrol.FieldGenerateRoutes:
		m.ResetGenerateRoutes()
		return nil
	case shipmentcontrol.FieldEnforceCommodity:
		m.ResetEnforceCommodity()
		return nil
	case shipmentcontrol.FieldAutoSequenceStops:
		m.ResetAutoSequenceStops()
		return nil
	case shipmentcontrol.FieldAutoShipmentTotal:
		m.ResetAutoShipmentTotal()
		return nil
	case shipmentcontrol.FieldEnforceOriginDestination:
		m.ResetEnforceOriginDestination()
		return nil
	case shipmentcontrol.FieldCheckForDuplicateBol:
		m.ResetCheckForDuplicateBol()
		return nil
	case shipmentcontrol.FieldSendPlacardInfo:
		m.ResetSendPlacardInfo()
		return nil
	case shipmentcontrol.FieldEnforceHazmatSegRules:
		m.ResetEnforceHazmatSegRules()
		return nil
	}
	return fmt.Errorf("unknown ShipmentControl field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShipmentControlMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.organization != nil {
		edges = append(edges, shipmentcontrol.EdgeOrganization)
	}
	if m.business_unit != nil {
		edges = append(edges, shipmentcontrol.EdgeBusinessUnit)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShipmentControlMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case shipmentcontrol.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case shipmentcontrol.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShipmentControlMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShipmentControlMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShipmentControlMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorganization {
		edges = append(edges, shipmentcontrol.EdgeOrganization)
	}
	if m.clearedbusiness_unit {
		edges = append(edges, shipmentcontrol.EdgeBusinessUnit)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShipmentControlMutation) EdgeCleared(name string) bool {
	switch name {
	case shipmentcontrol.EdgeOrganization:
		return m.clearedorganization
	case shipmentcontrol.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShipmentControlMutation) ClearEdge(name string) error {
	switch name {
	case shipmentcontrol.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case shipmentcontrol.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	}
	return fmt.Errorf("unknown ShipmentControl unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShipmentControlMutation) ResetEdge(name string) error {
	switch name {
	case shipmentcontrol.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case shipmentcontrol.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	}
	return fmt.Errorf("unknown ShipmentControl edge %s", name)
}

// ShipmentDocumentationMutation represents an operation that mutates the ShipmentDocumentation nodes in the graph.
type ShipmentDocumentationMutation struct {
	config
	op                             Op
	typ                            string
	id                             *uuid.UUID
	created_at                     *time.Time
	updated_at                     *time.Time
	version                        *int
	addversion                     *int
	document_url                   *string
	clearedFields                  map[string]struct{}
	business_unit                  *uuid.UUID
	clearedbusiness_unit           bool
	organization                   *uuid.UUID
	clearedorganization            bool
	shipment                       *uuid.UUID
	clearedshipment                bool
	document_classification        *uuid.UUID
	cleareddocument_classification bool
	done                           bool
	oldValue                       func(context.Context) (*ShipmentDocumentation, error)
	predicates                     []predicate.ShipmentDocumentation
}

var _ ent.Mutation = (*ShipmentDocumentationMutation)(nil)

// shipmentdocumentationOption allows management of the mutation configuration using functional options.
type shipmentdocumentationOption func(*ShipmentDocumentationMutation)

// newShipmentDocumentationMutation creates new mutation for the ShipmentDocumentation entity.
func newShipmentDocumentationMutation(c config, op Op, opts ...shipmentdocumentationOption) *ShipmentDocumentationMutation {
	m := &ShipmentDocumentationMutation{
		config:        c,
		op:            op,
		typ:           TypeShipmentDocumentation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShipmentDocumentationID sets the ID field of the mutation.
func withShipmentDocumentationID(id uuid.UUID) shipmentdocumentationOption {
	return func(m *ShipmentDocumentationMutation) {
		var (
			err   error
			once  sync.Once
			value *ShipmentDocumentation
		)
		m.oldValue = func(ctx context.Context) (*ShipmentDocumentation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShipmentDocumentation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShipmentDocumentation sets the old ShipmentDocumentation of the mutation.
func withShipmentDocumentation(node *ShipmentDocumentation) shipmentdocumentationOption {
	return func(m *ShipmentDocumentationMutation) {
		m.oldValue = func(context.Context) (*ShipmentDocumentation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShipmentDocumentationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShipmentDocumentationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ShipmentDocumentation entities.
func (m *ShipmentDocumentationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShipmentDocumentationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ShipmentDocumentationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ShipmentDocumentation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *ShipmentDocumentationMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *ShipmentDocumentationMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the ShipmentDocumentation entity.
// If the ShipmentDocumentation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentDocumentationMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *ShipmentDocumentationMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *ShipmentDocumentationMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *ShipmentDocumentationMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the ShipmentDocumentation entity.
// If the ShipmentDocumentation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentDocumentationMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *ShipmentDocumentationMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ShipmentDocumentationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ShipmentDocumentationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ShipmentDocumentation entity.
// If the ShipmentDocumentation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentDocumentationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ShipmentDocumentationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ShipmentDocumentationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ShipmentDocumentationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ShipmentDocumentation entity.
// If the ShipmentDocumentation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentDocumentationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ShipmentDocumentationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *ShipmentDocumentationMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *ShipmentDocumentationMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the ShipmentDocumentation entity.
// If the ShipmentDocumentation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentDocumentationMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *ShipmentDocumentationMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *ShipmentDocumentationMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *ShipmentDocumentationMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetShipmentID sets the "shipment_id" field.
func (m *ShipmentDocumentationMutation) SetShipmentID(u uuid.UUID) {
	m.shipment = &u
}

// ShipmentID returns the value of the "shipment_id" field in the mutation.
func (m *ShipmentDocumentationMutation) ShipmentID() (r uuid.UUID, exists bool) {
	v := m.shipment
	if v == nil {
		return
	}
	return *v, true
}

// OldShipmentID returns the old "shipment_id" field's value of the ShipmentDocumentation entity.
// If the ShipmentDocumentation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentDocumentationMutation) OldShipmentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShipmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShipmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipmentID: %w", err)
	}
	return oldValue.ShipmentID, nil
}

// ResetShipmentID resets all changes to the "shipment_id" field.
func (m *ShipmentDocumentationMutation) ResetShipmentID() {
	m.shipment = nil
}

// SetDocumentURL sets the "document_url" field.
func (m *ShipmentDocumentationMutation) SetDocumentURL(s string) {
	m.document_url = &s
}

// DocumentURL returns the value of the "document_url" field in the mutation.
func (m *ShipmentDocumentationMutation) DocumentURL() (r string, exists bool) {
	v := m.document_url
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentURL returns the old "document_url" field's value of the ShipmentDocumentation entity.
// If the ShipmentDocumentation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentDocumentationMutation) OldDocumentURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentURL: %w", err)
	}
	return oldValue.DocumentURL, nil
}

// ResetDocumentURL resets all changes to the "document_url" field.
func (m *ShipmentDocumentationMutation) ResetDocumentURL() {
	m.document_url = nil
}

// SetDocumentClassificationID sets the "document_classification_id" field.
func (m *ShipmentDocumentationMutation) SetDocumentClassificationID(u uuid.UUID) {
	m.document_classification = &u
}

// DocumentClassificationID returns the value of the "document_classification_id" field in the mutation.
func (m *ShipmentDocumentationMutation) DocumentClassificationID() (r uuid.UUID, exists bool) {
	v := m.document_classification
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentClassificationID returns the old "document_classification_id" field's value of the ShipmentDocumentation entity.
// If the ShipmentDocumentation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentDocumentationMutation) OldDocumentClassificationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentClassificationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentClassificationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentClassificationID: %w", err)
	}
	return oldValue.DocumentClassificationID, nil
}

// ResetDocumentClassificationID resets all changes to the "document_classification_id" field.
func (m *ShipmentDocumentationMutation) ResetDocumentClassificationID() {
	m.document_classification = nil
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *ShipmentDocumentationMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[shipmentdocumentation.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *ShipmentDocumentationMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *ShipmentDocumentationMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *ShipmentDocumentationMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *ShipmentDocumentationMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[shipmentdocumentation.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *ShipmentDocumentationMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *ShipmentDocumentationMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *ShipmentDocumentationMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearShipment clears the "shipment" edge to the Shipment entity.
func (m *ShipmentDocumentationMutation) ClearShipment() {
	m.clearedshipment = true
	m.clearedFields[shipmentdocumentation.FieldShipmentID] = struct{}{}
}

// ShipmentCleared reports if the "shipment" edge to the Shipment entity was cleared.
func (m *ShipmentDocumentationMutation) ShipmentCleared() bool {
	return m.clearedshipment
}

// ShipmentIDs returns the "shipment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentID instead. It exists only for internal usage by the builders.
func (m *ShipmentDocumentationMutation) ShipmentIDs() (ids []uuid.UUID) {
	if id := m.shipment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipment resets all changes to the "shipment" edge.
func (m *ShipmentDocumentationMutation) ResetShipment() {
	m.shipment = nil
	m.clearedshipment = false
}

// ClearDocumentClassification clears the "document_classification" edge to the DocumentClassification entity.
func (m *ShipmentDocumentationMutation) ClearDocumentClassification() {
	m.cleareddocument_classification = true
	m.clearedFields[shipmentdocumentation.FieldDocumentClassificationID] = struct{}{}
}

// DocumentClassificationCleared reports if the "document_classification" edge to the DocumentClassification entity was cleared.
func (m *ShipmentDocumentationMutation) DocumentClassificationCleared() bool {
	return m.cleareddocument_classification
}

// DocumentClassificationIDs returns the "document_classification" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DocumentClassificationID instead. It exists only for internal usage by the builders.
func (m *ShipmentDocumentationMutation) DocumentClassificationIDs() (ids []uuid.UUID) {
	if id := m.document_classification; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDocumentClassification resets all changes to the "document_classification" edge.
func (m *ShipmentDocumentationMutation) ResetDocumentClassification() {
	m.document_classification = nil
	m.cleareddocument_classification = false
}

// Where appends a list predicates to the ShipmentDocumentationMutation builder.
func (m *ShipmentDocumentationMutation) Where(ps ...predicate.ShipmentDocumentation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ShipmentDocumentationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ShipmentDocumentationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ShipmentDocumentation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ShipmentDocumentationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ShipmentDocumentationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ShipmentDocumentation).
func (m *ShipmentDocumentationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShipmentDocumentationMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.business_unit != nil {
		fields = append(fields, shipmentdocumentation.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, shipmentdocumentation.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, shipmentdocumentation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, shipmentdocumentation.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, shipmentdocumentation.FieldVersion)
	}
	if m.shipment != nil {
		fields = append(fields, shipmentdocumentation.FieldShipmentID)
	}
	if m.document_url != nil {
		fields = append(fields, shipmentdocumentation.FieldDocumentURL)
	}
	if m.document_classification != nil {
		fields = append(fields, shipmentdocumentation.FieldDocumentClassificationID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShipmentDocumentationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shipmentdocumentation.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case shipmentdocumentation.FieldOrganizationID:
		return m.OrganizationID()
	case shipmentdocumentation.FieldCreatedAt:
		return m.CreatedAt()
	case shipmentdocumentation.FieldUpdatedAt:
		return m.UpdatedAt()
	case shipmentdocumentation.FieldVersion:
		return m.Version()
	case shipmentdocumentation.FieldShipmentID:
		return m.ShipmentID()
	case shipmentdocumentation.FieldDocumentURL:
		return m.DocumentURL()
	case shipmentdocumentation.FieldDocumentClassificationID:
		return m.DocumentClassificationID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShipmentDocumentationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shipmentdocumentation.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case shipmentdocumentation.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case shipmentdocumentation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case shipmentdocumentation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case shipmentdocumentation.FieldVersion:
		return m.OldVersion(ctx)
	case shipmentdocumentation.FieldShipmentID:
		return m.OldShipmentID(ctx)
	case shipmentdocumentation.FieldDocumentURL:
		return m.OldDocumentURL(ctx)
	case shipmentdocumentation.FieldDocumentClassificationID:
		return m.OldDocumentClassificationID(ctx)
	}
	return nil, fmt.Errorf("unknown ShipmentDocumentation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentDocumentationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shipmentdocumentation.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case shipmentdocumentation.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case shipmentdocumentation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case shipmentdocumentation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case shipmentdocumentation.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case shipmentdocumentation.FieldShipmentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipmentID(v)
		return nil
	case shipmentdocumentation.FieldDocumentURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentURL(v)
		return nil
	case shipmentdocumentation.FieldDocumentClassificationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentClassificationID(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentDocumentation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShipmentDocumentationMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, shipmentdocumentation.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShipmentDocumentationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case shipmentdocumentation.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentDocumentationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case shipmentdocumentation.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentDocumentation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShipmentDocumentationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShipmentDocumentationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShipmentDocumentationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ShipmentDocumentation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShipmentDocumentationMutation) ResetField(name string) error {
	switch name {
	case shipmentdocumentation.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case shipmentdocumentation.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case shipmentdocumentation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case shipmentdocumentation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case shipmentdocumentation.FieldVersion:
		m.ResetVersion()
		return nil
	case shipmentdocumentation.FieldShipmentID:
		m.ResetShipmentID()
		return nil
	case shipmentdocumentation.FieldDocumentURL:
		m.ResetDocumentURL()
		return nil
	case shipmentdocumentation.FieldDocumentClassificationID:
		m.ResetDocumentClassificationID()
		return nil
	}
	return fmt.Errorf("unknown ShipmentDocumentation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShipmentDocumentationMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.business_unit != nil {
		edges = append(edges, shipmentdocumentation.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, shipmentdocumentation.EdgeOrganization)
	}
	if m.shipment != nil {
		edges = append(edges, shipmentdocumentation.EdgeShipment)
	}
	if m.document_classification != nil {
		edges = append(edges, shipmentdocumentation.EdgeDocumentClassification)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShipmentDocumentationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case shipmentdocumentation.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case shipmentdocumentation.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case shipmentdocumentation.EdgeShipment:
		if id := m.shipment; id != nil {
			return []ent.Value{*id}
		}
	case shipmentdocumentation.EdgeDocumentClassification:
		if id := m.document_classification; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShipmentDocumentationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShipmentDocumentationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShipmentDocumentationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedbusiness_unit {
		edges = append(edges, shipmentdocumentation.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, shipmentdocumentation.EdgeOrganization)
	}
	if m.clearedshipment {
		edges = append(edges, shipmentdocumentation.EdgeShipment)
	}
	if m.cleareddocument_classification {
		edges = append(edges, shipmentdocumentation.EdgeDocumentClassification)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShipmentDocumentationMutation) EdgeCleared(name string) bool {
	switch name {
	case shipmentdocumentation.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case shipmentdocumentation.EdgeOrganization:
		return m.clearedorganization
	case shipmentdocumentation.EdgeShipment:
		return m.clearedshipment
	case shipmentdocumentation.EdgeDocumentClassification:
		return m.cleareddocument_classification
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShipmentDocumentationMutation) ClearEdge(name string) error {
	switch name {
	case shipmentdocumentation.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case shipmentdocumentation.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case shipmentdocumentation.EdgeShipment:
		m.ClearShipment()
		return nil
	case shipmentdocumentation.EdgeDocumentClassification:
		m.ClearDocumentClassification()
		return nil
	}
	return fmt.Errorf("unknown ShipmentDocumentation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShipmentDocumentationMutation) ResetEdge(name string) error {
	switch name {
	case shipmentdocumentation.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case shipmentdocumentation.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case shipmentdocumentation.EdgeShipment:
		m.ResetShipment()
		return nil
	case shipmentdocumentation.EdgeDocumentClassification:
		m.ResetDocumentClassification()
		return nil
	}
	return fmt.Errorf("unknown ShipmentDocumentation edge %s", name)
}

// ShipmentMoveMutation represents an operation that mutates the ShipmentMove nodes in the graph.
type ShipmentMoveMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	created_at              *time.Time
	updated_at              *time.Time
	version                 *int
	addversion              *int
	reference_number        *string
	status                  *shipmentmove.Status
	is_loaded               *bool
	clearedFields           map[string]struct{}
	business_unit           *uuid.UUID
	clearedbusiness_unit    bool
	organization            *uuid.UUID
	clearedorganization     bool
	shipment                *uuid.UUID
	clearedshipment         bool
	tractor                 *uuid.UUID
	clearedtractor          bool
	trailer                 *uuid.UUID
	clearedtrailer          bool
	primary_worker          *uuid.UUID
	clearedprimary_worker   bool
	secondary_worker        *uuid.UUID
	clearedsecondary_worker bool
	move_stops              map[uuid.UUID]struct{}
	removedmove_stops       map[uuid.UUID]struct{}
	clearedmove_stops       bool
	done                    bool
	oldValue                func(context.Context) (*ShipmentMove, error)
	predicates              []predicate.ShipmentMove
}

var _ ent.Mutation = (*ShipmentMoveMutation)(nil)

// shipmentmoveOption allows management of the mutation configuration using functional options.
type shipmentmoveOption func(*ShipmentMoveMutation)

// newShipmentMoveMutation creates new mutation for the ShipmentMove entity.
func newShipmentMoveMutation(c config, op Op, opts ...shipmentmoveOption) *ShipmentMoveMutation {
	m := &ShipmentMoveMutation{
		config:        c,
		op:            op,
		typ:           TypeShipmentMove,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShipmentMoveID sets the ID field of the mutation.
func withShipmentMoveID(id uuid.UUID) shipmentmoveOption {
	return func(m *ShipmentMoveMutation) {
		var (
			err   error
			once  sync.Once
			value *ShipmentMove
		)
		m.oldValue = func(ctx context.Context) (*ShipmentMove, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShipmentMove.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShipmentMove sets the old ShipmentMove of the mutation.
func withShipmentMove(node *ShipmentMove) shipmentmoveOption {
	return func(m *ShipmentMoveMutation) {
		m.oldValue = func(context.Context) (*ShipmentMove, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShipmentMoveMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShipmentMoveMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ShipmentMove entities.
func (m *ShipmentMoveMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShipmentMoveMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ShipmentMoveMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ShipmentMove.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *ShipmentMoveMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *ShipmentMoveMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the ShipmentMove entity.
// If the ShipmentMove object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMoveMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *ShipmentMoveMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *ShipmentMoveMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *ShipmentMoveMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the ShipmentMove entity.
// If the ShipmentMove object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMoveMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *ShipmentMoveMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ShipmentMoveMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ShipmentMoveMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ShipmentMove entity.
// If the ShipmentMove object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMoveMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ShipmentMoveMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ShipmentMoveMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ShipmentMoveMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ShipmentMove entity.
// If the ShipmentMove object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMoveMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ShipmentMoveMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *ShipmentMoveMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *ShipmentMoveMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the ShipmentMove entity.
// If the ShipmentMove object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMoveMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *ShipmentMoveMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *ShipmentMoveMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *ShipmentMoveMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetReferenceNumber sets the "reference_number" field.
func (m *ShipmentMoveMutation) SetReferenceNumber(s string) {
	m.reference_number = &s
}

// ReferenceNumber returns the value of the "reference_number" field in the mutation.
func (m *ShipmentMoveMutation) ReferenceNumber() (r string, exists bool) {
	v := m.reference_number
	if v == nil {
		return
	}
	return *v, true
}

// OldReferenceNumber returns the old "reference_number" field's value of the ShipmentMove entity.
// If the ShipmentMove object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMoveMutation) OldReferenceNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferenceNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferenceNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferenceNumber: %w", err)
	}
	return oldValue.ReferenceNumber, nil
}

// ResetReferenceNumber resets all changes to the "reference_number" field.
func (m *ShipmentMoveMutation) ResetReferenceNumber() {
	m.reference_number = nil
}

// SetStatus sets the "status" field.
func (m *ShipmentMoveMutation) SetStatus(s shipmentmove.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ShipmentMoveMutation) Status() (r shipmentmove.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ShipmentMove entity.
// If the ShipmentMove object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMoveMutation) OldStatus(ctx context.Context) (v shipmentmove.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ShipmentMoveMutation) ResetStatus() {
	m.status = nil
}

// SetIsLoaded sets the "is_loaded" field.
func (m *ShipmentMoveMutation) SetIsLoaded(b bool) {
	m.is_loaded = &b
}

// IsLoaded returns the value of the "is_loaded" field in the mutation.
func (m *ShipmentMoveMutation) IsLoaded() (r bool, exists bool) {
	v := m.is_loaded
	if v == nil {
		return
	}
	return *v, true
}

// OldIsLoaded returns the old "is_loaded" field's value of the ShipmentMove entity.
// If the ShipmentMove object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMoveMutation) OldIsLoaded(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsLoaded is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsLoaded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsLoaded: %w", err)
	}
	return oldValue.IsLoaded, nil
}

// ResetIsLoaded resets all changes to the "is_loaded" field.
func (m *ShipmentMoveMutation) ResetIsLoaded() {
	m.is_loaded = nil
}

// SetShipmentID sets the "shipment_id" field.
func (m *ShipmentMoveMutation) SetShipmentID(u uuid.UUID) {
	m.shipment = &u
}

// ShipmentID returns the value of the "shipment_id" field in the mutation.
func (m *ShipmentMoveMutation) ShipmentID() (r uuid.UUID, exists bool) {
	v := m.shipment
	if v == nil {
		return
	}
	return *v, true
}

// OldShipmentID returns the old "shipment_id" field's value of the ShipmentMove entity.
// If the ShipmentMove object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMoveMutation) OldShipmentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShipmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShipmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipmentID: %w", err)
	}
	return oldValue.ShipmentID, nil
}

// ResetShipmentID resets all changes to the "shipment_id" field.
func (m *ShipmentMoveMutation) ResetShipmentID() {
	m.shipment = nil
}

// SetTractorID sets the "tractor_id" field.
func (m *ShipmentMoveMutation) SetTractorID(u uuid.UUID) {
	m.tractor = &u
}

// TractorID returns the value of the "tractor_id" field in the mutation.
func (m *ShipmentMoveMutation) TractorID() (r uuid.UUID, exists bool) {
	v := m.tractor
	if v == nil {
		return
	}
	return *v, true
}

// OldTractorID returns the old "tractor_id" field's value of the ShipmentMove entity.
// If the ShipmentMove object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMoveMutation) OldTractorID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTractorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTractorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTractorID: %w", err)
	}
	return oldValue.TractorID, nil
}

// ClearTractorID clears the value of the "tractor_id" field.
func (m *ShipmentMoveMutation) ClearTractorID() {
	m.tractor = nil
	m.clearedFields[shipmentmove.FieldTractorID] = struct{}{}
}

// TractorIDCleared returns if the "tractor_id" field was cleared in this mutation.
func (m *ShipmentMoveMutation) TractorIDCleared() bool {
	_, ok := m.clearedFields[shipmentmove.FieldTractorID]
	return ok
}

// ResetTractorID resets all changes to the "tractor_id" field.
func (m *ShipmentMoveMutation) ResetTractorID() {
	m.tractor = nil
	delete(m.clearedFields, shipmentmove.FieldTractorID)
}

// SetTrailerID sets the "trailer_id" field.
func (m *ShipmentMoveMutation) SetTrailerID(u uuid.UUID) {
	m.trailer = &u
}

// TrailerID returns the value of the "trailer_id" field in the mutation.
func (m *ShipmentMoveMutation) TrailerID() (r uuid.UUID, exists bool) {
	v := m.trailer
	if v == nil {
		return
	}
	return *v, true
}

// OldTrailerID returns the old "trailer_id" field's value of the ShipmentMove entity.
// If the ShipmentMove object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMoveMutation) OldTrailerID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrailerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrailerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrailerID: %w", err)
	}
	return oldValue.TrailerID, nil
}

// ClearTrailerID clears the value of the "trailer_id" field.
func (m *ShipmentMoveMutation) ClearTrailerID() {
	m.trailer = nil
	m.clearedFields[shipmentmove.FieldTrailerID] = struct{}{}
}

// TrailerIDCleared returns if the "trailer_id" field was cleared in this mutation.
func (m *ShipmentMoveMutation) TrailerIDCleared() bool {
	_, ok := m.clearedFields[shipmentmove.FieldTrailerID]
	return ok
}

// ResetTrailerID resets all changes to the "trailer_id" field.
func (m *ShipmentMoveMutation) ResetTrailerID() {
	m.trailer = nil
	delete(m.clearedFields, shipmentmove.FieldTrailerID)
}

// SetPrimaryWorkerID sets the "primary_worker_id" field.
func (m *ShipmentMoveMutation) SetPrimaryWorkerID(u uuid.UUID) {
	m.primary_worker = &u
}

// PrimaryWorkerID returns the value of the "primary_worker_id" field in the mutation.
func (m *ShipmentMoveMutation) PrimaryWorkerID() (r uuid.UUID, exists bool) {
	v := m.primary_worker
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryWorkerID returns the old "primary_worker_id" field's value of the ShipmentMove entity.
// If the ShipmentMove object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMoveMutation) OldPrimaryWorkerID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryWorkerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryWorkerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryWorkerID: %w", err)
	}
	return oldValue.PrimaryWorkerID, nil
}

// ClearPrimaryWorkerID clears the value of the "primary_worker_id" field.
func (m *ShipmentMoveMutation) ClearPrimaryWorkerID() {
	m.primary_worker = nil
	m.clearedFields[shipmentmove.FieldPrimaryWorkerID] = struct{}{}
}

// PrimaryWorkerIDCleared returns if the "primary_worker_id" field was cleared in this mutation.
func (m *ShipmentMoveMutation) PrimaryWorkerIDCleared() bool {
	_, ok := m.clearedFields[shipmentmove.FieldPrimaryWorkerID]
	return ok
}

// ResetPrimaryWorkerID resets all changes to the "primary_worker_id" field.
func (m *ShipmentMoveMutation) ResetPrimaryWorkerID() {
	m.primary_worker = nil
	delete(m.clearedFields, shipmentmove.FieldPrimaryWorkerID)
}

// SetSecondaryWorkerID sets the "secondary_worker_id" field.
func (m *ShipmentMoveMutation) SetSecondaryWorkerID(u uuid.UUID) {
	m.secondary_worker = &u
}

// SecondaryWorkerID returns the value of the "secondary_worker_id" field in the mutation.
func (m *ShipmentMoveMutation) SecondaryWorkerID() (r uuid.UUID, exists bool) {
	v := m.secondary_worker
	if v == nil {
		return
	}
	return *v, true
}

// OldSecondaryWorkerID returns the old "secondary_worker_id" field's value of the ShipmentMove entity.
// If the ShipmentMove object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMoveMutation) OldSecondaryWorkerID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecondaryWorkerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecondaryWorkerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecondaryWorkerID: %w", err)
	}
	return oldValue.SecondaryWorkerID, nil
}

// ClearSecondaryWorkerID clears the value of the "secondary_worker_id" field.
func (m *ShipmentMoveMutation) ClearSecondaryWorkerID() {
	m.secondary_worker = nil
	m.clearedFields[shipmentmove.FieldSecondaryWorkerID] = struct{}{}
}

// SecondaryWorkerIDCleared returns if the "secondary_worker_id" field was cleared in this mutation.
func (m *ShipmentMoveMutation) SecondaryWorkerIDCleared() bool {
	_, ok := m.clearedFields[shipmentmove.FieldSecondaryWorkerID]
	return ok
}

// ResetSecondaryWorkerID resets all changes to the "secondary_worker_id" field.
func (m *ShipmentMoveMutation) ResetSecondaryWorkerID() {
	m.secondary_worker = nil
	delete(m.clearedFields, shipmentmove.FieldSecondaryWorkerID)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *ShipmentMoveMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[shipmentmove.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *ShipmentMoveMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *ShipmentMoveMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *ShipmentMoveMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *ShipmentMoveMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[shipmentmove.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *ShipmentMoveMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *ShipmentMoveMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *ShipmentMoveMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearShipment clears the "shipment" edge to the Shipment entity.
func (m *ShipmentMoveMutation) ClearShipment() {
	m.clearedshipment = true
	m.clearedFields[shipmentmove.FieldShipmentID] = struct{}{}
}

// ShipmentCleared reports if the "shipment" edge to the Shipment entity was cleared.
func (m *ShipmentMoveMutation) ShipmentCleared() bool {
	return m.clearedshipment
}

// ShipmentIDs returns the "shipment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentID instead. It exists only for internal usage by the builders.
func (m *ShipmentMoveMutation) ShipmentIDs() (ids []uuid.UUID) {
	if id := m.shipment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipment resets all changes to the "shipment" edge.
func (m *ShipmentMoveMutation) ResetShipment() {
	m.shipment = nil
	m.clearedshipment = false
}

// ClearTractor clears the "tractor" edge to the Tractor entity.
func (m *ShipmentMoveMutation) ClearTractor() {
	m.clearedtractor = true
	m.clearedFields[shipmentmove.FieldTractorID] = struct{}{}
}

// TractorCleared reports if the "tractor" edge to the Tractor entity was cleared.
func (m *ShipmentMoveMutation) TractorCleared() bool {
	return m.TractorIDCleared() || m.clearedtractor
}

// TractorIDs returns the "tractor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TractorID instead. It exists only for internal usage by the builders.
func (m *ShipmentMoveMutation) TractorIDs() (ids []uuid.UUID) {
	if id := m.tractor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTractor resets all changes to the "tractor" edge.
func (m *ShipmentMoveMutation) ResetTractor() {
	m.tractor = nil
	m.clearedtractor = false
}

// ClearTrailer clears the "trailer" edge to the Tractor entity.
func (m *ShipmentMoveMutation) ClearTrailer() {
	m.clearedtrailer = true
	m.clearedFields[shipmentmove.FieldTrailerID] = struct{}{}
}

// TrailerCleared reports if the "trailer" edge to the Tractor entity was cleared.
func (m *ShipmentMoveMutation) TrailerCleared() bool {
	return m.TrailerIDCleared() || m.clearedtrailer
}

// TrailerIDs returns the "trailer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TrailerID instead. It exists only for internal usage by the builders.
func (m *ShipmentMoveMutation) TrailerIDs() (ids []uuid.UUID) {
	if id := m.trailer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTrailer resets all changes to the "trailer" edge.
func (m *ShipmentMoveMutation) ResetTrailer() {
	m.trailer = nil
	m.clearedtrailer = false
}

// ClearPrimaryWorker clears the "primary_worker" edge to the Worker entity.
func (m *ShipmentMoveMutation) ClearPrimaryWorker() {
	m.clearedprimary_worker = true
	m.clearedFields[shipmentmove.FieldPrimaryWorkerID] = struct{}{}
}

// PrimaryWorkerCleared reports if the "primary_worker" edge to the Worker entity was cleared.
func (m *ShipmentMoveMutation) PrimaryWorkerCleared() bool {
	return m.PrimaryWorkerIDCleared() || m.clearedprimary_worker
}

// PrimaryWorkerIDs returns the "primary_worker" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PrimaryWorkerID instead. It exists only for internal usage by the builders.
func (m *ShipmentMoveMutation) PrimaryWorkerIDs() (ids []uuid.UUID) {
	if id := m.primary_worker; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrimaryWorker resets all changes to the "primary_worker" edge.
func (m *ShipmentMoveMutation) ResetPrimaryWorker() {
	m.primary_worker = nil
	m.clearedprimary_worker = false
}

// ClearSecondaryWorker clears the "secondary_worker" edge to the Worker entity.
func (m *ShipmentMoveMutation) ClearSecondaryWorker() {
	m.clearedsecondary_worker = true
	m.clearedFields[shipmentmove.FieldSecondaryWorkerID] = struct{}{}
}

// SecondaryWorkerCleared reports if the "secondary_worker" edge to the Worker entity was cleared.
func (m *ShipmentMoveMutation) SecondaryWorkerCleared() bool {
	return m.SecondaryWorkerIDCleared() || m.clearedsecondary_worker
}

// SecondaryWorkerIDs returns the "secondary_worker" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SecondaryWorkerID instead. It exists only for internal usage by the builders.
func (m *ShipmentMoveMutation) SecondaryWorkerIDs() (ids []uuid.UUID) {
	if id := m.secondary_worker; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSecondaryWorker resets all changes to the "secondary_worker" edge.
func (m *ShipmentMoveMutation) ResetSecondaryWorker() {
	m.secondary_worker = nil
	m.clearedsecondary_worker = false
}

// AddMoveStopIDs adds the "move_stops" edge to the Stop entity by ids.
func (m *ShipmentMoveMutation) AddMoveStopIDs(ids ...uuid.UUID) {
	if m.move_stops == nil {
		m.move_stops = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.move_stops[ids[i]] = struct{}{}
	}
}

// ClearMoveStops clears the "move_stops" edge to the Stop entity.
func (m *ShipmentMoveMutation) ClearMoveStops() {
	m.clearedmove_stops = true
}

// MoveStopsCleared reports if the "move_stops" edge to the Stop entity was cleared.
func (m *ShipmentMoveMutation) MoveStopsCleared() bool {
	return m.clearedmove_stops
}

// RemoveMoveStopIDs removes the "move_stops" edge to the Stop entity by IDs.
func (m *ShipmentMoveMutation) RemoveMoveStopIDs(ids ...uuid.UUID) {
	if m.removedmove_stops == nil {
		m.removedmove_stops = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.move_stops, ids[i])
		m.removedmove_stops[ids[i]] = struct{}{}
	}
}

// RemovedMoveStops returns the removed IDs of the "move_stops" edge to the Stop entity.
func (m *ShipmentMoveMutation) RemovedMoveStopsIDs() (ids []uuid.UUID) {
	for id := range m.removedmove_stops {
		ids = append(ids, id)
	}
	return
}

// MoveStopsIDs returns the "move_stops" edge IDs in the mutation.
func (m *ShipmentMoveMutation) MoveStopsIDs() (ids []uuid.UUID) {
	for id := range m.move_stops {
		ids = append(ids, id)
	}
	return
}

// ResetMoveStops resets all changes to the "move_stops" edge.
func (m *ShipmentMoveMutation) ResetMoveStops() {
	m.move_stops = nil
	m.clearedmove_stops = false
	m.removedmove_stops = nil
}

// Where appends a list predicates to the ShipmentMoveMutation builder.
func (m *ShipmentMoveMutation) Where(ps ...predicate.ShipmentMove) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ShipmentMoveMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ShipmentMoveMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ShipmentMove, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ShipmentMoveMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ShipmentMoveMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ShipmentMove).
func (m *ShipmentMoveMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShipmentMoveMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.business_unit != nil {
		fields = append(fields, shipmentmove.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, shipmentmove.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, shipmentmove.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, shipmentmove.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, shipmentmove.FieldVersion)
	}
	if m.reference_number != nil {
		fields = append(fields, shipmentmove.FieldReferenceNumber)
	}
	if m.status != nil {
		fields = append(fields, shipmentmove.FieldStatus)
	}
	if m.is_loaded != nil {
		fields = append(fields, shipmentmove.FieldIsLoaded)
	}
	if m.shipment != nil {
		fields = append(fields, shipmentmove.FieldShipmentID)
	}
	if m.tractor != nil {
		fields = append(fields, shipmentmove.FieldTractorID)
	}
	if m.trailer != nil {
		fields = append(fields, shipmentmove.FieldTrailerID)
	}
	if m.primary_worker != nil {
		fields = append(fields, shipmentmove.FieldPrimaryWorkerID)
	}
	if m.secondary_worker != nil {
		fields = append(fields, shipmentmove.FieldSecondaryWorkerID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShipmentMoveMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shipmentmove.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case shipmentmove.FieldOrganizationID:
		return m.OrganizationID()
	case shipmentmove.FieldCreatedAt:
		return m.CreatedAt()
	case shipmentmove.FieldUpdatedAt:
		return m.UpdatedAt()
	case shipmentmove.FieldVersion:
		return m.Version()
	case shipmentmove.FieldReferenceNumber:
		return m.ReferenceNumber()
	case shipmentmove.FieldStatus:
		return m.Status()
	case shipmentmove.FieldIsLoaded:
		return m.IsLoaded()
	case shipmentmove.FieldShipmentID:
		return m.ShipmentID()
	case shipmentmove.FieldTractorID:
		return m.TractorID()
	case shipmentmove.FieldTrailerID:
		return m.TrailerID()
	case shipmentmove.FieldPrimaryWorkerID:
		return m.PrimaryWorkerID()
	case shipmentmove.FieldSecondaryWorkerID:
		return m.SecondaryWorkerID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShipmentMoveMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shipmentmove.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case shipmentmove.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case shipmentmove.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case shipmentmove.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case shipmentmove.FieldVersion:
		return m.OldVersion(ctx)
	case shipmentmove.FieldReferenceNumber:
		return m.OldReferenceNumber(ctx)
	case shipmentmove.FieldStatus:
		return m.OldStatus(ctx)
	case shipmentmove.FieldIsLoaded:
		return m.OldIsLoaded(ctx)
	case shipmentmove.FieldShipmentID:
		return m.OldShipmentID(ctx)
	case shipmentmove.FieldTractorID:
		return m.OldTractorID(ctx)
	case shipmentmove.FieldTrailerID:
		return m.OldTrailerID(ctx)
	case shipmentmove.FieldPrimaryWorkerID:
		return m.OldPrimaryWorkerID(ctx)
	case shipmentmove.FieldSecondaryWorkerID:
		return m.OldSecondaryWorkerID(ctx)
	}
	return nil, fmt.Errorf("unknown ShipmentMove field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentMoveMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shipmentmove.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case shipmentmove.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case shipmentmove.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case shipmentmove.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case shipmentmove.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case shipmentmove.FieldReferenceNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferenceNumber(v)
		return nil
	case shipmentmove.FieldStatus:
		v, ok := value.(shipmentmove.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case shipmentmove.FieldIsLoaded:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsLoaded(v)
		return nil
	case shipmentmove.FieldShipmentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipmentID(v)
		return nil
	case shipmentmove.FieldTractorID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTractorID(v)
		return nil
	case shipmentmove.FieldTrailerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrailerID(v)
		return nil
	case shipmentmove.FieldPrimaryWorkerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryWorkerID(v)
		return nil
	case shipmentmove.FieldSecondaryWorkerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecondaryWorkerID(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentMove field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShipmentMoveMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, shipmentmove.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShipmentMoveMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case shipmentmove.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentMoveMutation) AddField(name string, value ent.Value) error {
	switch name {
	case shipmentmove.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentMove numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShipmentMoveMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(shipmentmove.FieldTractorID) {
		fields = append(fields, shipmentmove.FieldTractorID)
	}
	if m.FieldCleared(shipmentmove.FieldTrailerID) {
		fields = append(fields, shipmentmove.FieldTrailerID)
	}
	if m.FieldCleared(shipmentmove.FieldPrimaryWorkerID) {
		fields = append(fields, shipmentmove.FieldPrimaryWorkerID)
	}
	if m.FieldCleared(shipmentmove.FieldSecondaryWorkerID) {
		fields = append(fields, shipmentmove.FieldSecondaryWorkerID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShipmentMoveMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShipmentMoveMutation) ClearField(name string) error {
	switch name {
	case shipmentmove.FieldTractorID:
		m.ClearTractorID()
		return nil
	case shipmentmove.FieldTrailerID:
		m.ClearTrailerID()
		return nil
	case shipmentmove.FieldPrimaryWorkerID:
		m.ClearPrimaryWorkerID()
		return nil
	case shipmentmove.FieldSecondaryWorkerID:
		m.ClearSecondaryWorkerID()
		return nil
	}
	return fmt.Errorf("unknown ShipmentMove nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShipmentMoveMutation) ResetField(name string) error {
	switch name {
	case shipmentmove.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case shipmentmove.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case shipmentmove.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case shipmentmove.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case shipmentmove.FieldVersion:
		m.ResetVersion()
		return nil
	case shipmentmove.FieldReferenceNumber:
		m.ResetReferenceNumber()
		return nil
	case shipmentmove.FieldStatus:
		m.ResetStatus()
		return nil
	case shipmentmove.FieldIsLoaded:
		m.ResetIsLoaded()
		return nil
	case shipmentmove.FieldShipmentID:
		m.ResetShipmentID()
		return nil
	case shipmentmove.FieldTractorID:
		m.ResetTractorID()
		return nil
	case shipmentmove.FieldTrailerID:
		m.ResetTrailerID()
		return nil
	case shipmentmove.FieldPrimaryWorkerID:
		m.ResetPrimaryWorkerID()
		return nil
	case shipmentmove.FieldSecondaryWorkerID:
		m.ResetSecondaryWorkerID()
		return nil
	}
	return fmt.Errorf("unknown ShipmentMove field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShipmentMoveMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.business_unit != nil {
		edges = append(edges, shipmentmove.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, shipmentmove.EdgeOrganization)
	}
	if m.shipment != nil {
		edges = append(edges, shipmentmove.EdgeShipment)
	}
	if m.tractor != nil {
		edges = append(edges, shipmentmove.EdgeTractor)
	}
	if m.trailer != nil {
		edges = append(edges, shipmentmove.EdgeTrailer)
	}
	if m.primary_worker != nil {
		edges = append(edges, shipmentmove.EdgePrimaryWorker)
	}
	if m.secondary_worker != nil {
		edges = append(edges, shipmentmove.EdgeSecondaryWorker)
	}
	if m.move_stops != nil {
		edges = append(edges, shipmentmove.EdgeMoveStops)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShipmentMoveMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case shipmentmove.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case shipmentmove.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case shipmentmove.EdgeShipment:
		if id := m.shipment; id != nil {
			return []ent.Value{*id}
		}
	case shipmentmove.EdgeTractor:
		if id := m.tractor; id != nil {
			return []ent.Value{*id}
		}
	case shipmentmove.EdgeTrailer:
		if id := m.trailer; id != nil {
			return []ent.Value{*id}
		}
	case shipmentmove.EdgePrimaryWorker:
		if id := m.primary_worker; id != nil {
			return []ent.Value{*id}
		}
	case shipmentmove.EdgeSecondaryWorker:
		if id := m.secondary_worker; id != nil {
			return []ent.Value{*id}
		}
	case shipmentmove.EdgeMoveStops:
		ids := make([]ent.Value, 0, len(m.move_stops))
		for id := range m.move_stops {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShipmentMoveMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedmove_stops != nil {
		edges = append(edges, shipmentmove.EdgeMoveStops)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShipmentMoveMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case shipmentmove.EdgeMoveStops:
		ids := make([]ent.Value, 0, len(m.removedmove_stops))
		for id := range m.removedmove_stops {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShipmentMoveMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedbusiness_unit {
		edges = append(edges, shipmentmove.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, shipmentmove.EdgeOrganization)
	}
	if m.clearedshipment {
		edges = append(edges, shipmentmove.EdgeShipment)
	}
	if m.clearedtractor {
		edges = append(edges, shipmentmove.EdgeTractor)
	}
	if m.clearedtrailer {
		edges = append(edges, shipmentmove.EdgeTrailer)
	}
	if m.clearedprimary_worker {
		edges = append(edges, shipmentmove.EdgePrimaryWorker)
	}
	if m.clearedsecondary_worker {
		edges = append(edges, shipmentmove.EdgeSecondaryWorker)
	}
	if m.clearedmove_stops {
		edges = append(edges, shipmentmove.EdgeMoveStops)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShipmentMoveMutation) EdgeCleared(name string) bool {
	switch name {
	case shipmentmove.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case shipmentmove.EdgeOrganization:
		return m.clearedorganization
	case shipmentmove.EdgeShipment:
		return m.clearedshipment
	case shipmentmove.EdgeTractor:
		return m.clearedtractor
	case shipmentmove.EdgeTrailer:
		return m.clearedtrailer
	case shipmentmove.EdgePrimaryWorker:
		return m.clearedprimary_worker
	case shipmentmove.EdgeSecondaryWorker:
		return m.clearedsecondary_worker
	case shipmentmove.EdgeMoveStops:
		return m.clearedmove_stops
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShipmentMoveMutation) ClearEdge(name string) error {
	switch name {
	case shipmentmove.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case shipmentmove.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case shipmentmove.EdgeShipment:
		m.ClearShipment()
		return nil
	case shipmentmove.EdgeTractor:
		m.ClearTractor()
		return nil
	case shipmentmove.EdgeTrailer:
		m.ClearTrailer()
		return nil
	case shipmentmove.EdgePrimaryWorker:
		m.ClearPrimaryWorker()
		return nil
	case shipmentmove.EdgeSecondaryWorker:
		m.ClearSecondaryWorker()
		return nil
	}
	return fmt.Errorf("unknown ShipmentMove unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShipmentMoveMutation) ResetEdge(name string) error {
	switch name {
	case shipmentmove.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case shipmentmove.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case shipmentmove.EdgeShipment:
		m.ResetShipment()
		return nil
	case shipmentmove.EdgeTractor:
		m.ResetTractor()
		return nil
	case shipmentmove.EdgeTrailer:
		m.ResetTrailer()
		return nil
	case shipmentmove.EdgePrimaryWorker:
		m.ResetPrimaryWorker()
		return nil
	case shipmentmove.EdgeSecondaryWorker:
		m.ResetSecondaryWorker()
		return nil
	case shipmentmove.EdgeMoveStops:
		m.ResetMoveStops()
		return nil
	}
	return fmt.Errorf("unknown ShipmentMove edge %s", name)
}

// ShipmentRouteMutation represents an operation that mutates the ShipmentRoute nodes in the graph.
type ShipmentRouteMutation struct {
	config
	op                          Op
	typ                         string
	id                          *uuid.UUID
	created_at                  *time.Time
	updated_at                  *time.Time
	version                     *int
	addversion                  *int
	mileage                     *float64
	addmileage                  *float64
	duration                    *int
	addduration                 *int
	distance_method             *string
	auto_generated              *bool
	clearedFields               map[string]struct{}
	business_unit               *uuid.UUID
	clearedbusiness_unit        bool
	organization                *uuid.UUID
	clearedorganization         bool
	origin_location             *uuid.UUID
	clearedorigin_location      bool
	destination_location        *uuid.UUID
	cleareddestination_location bool
	done                        bool
	oldValue                    func(context.Context) (*ShipmentRoute, error)
	predicates                  []predicate.ShipmentRoute
}

var _ ent.Mutation = (*ShipmentRouteMutation)(nil)

// shipmentrouteOption allows management of the mutation configuration using functional options.
type shipmentrouteOption func(*ShipmentRouteMutation)

// newShipmentRouteMutation creates new mutation for the ShipmentRoute entity.
func newShipmentRouteMutation(c config, op Op, opts ...shipmentrouteOption) *ShipmentRouteMutation {
	m := &ShipmentRouteMutation{
		config:        c,
		op:            op,
		typ:           TypeShipmentRoute,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShipmentRouteID sets the ID field of the mutation.
func withShipmentRouteID(id uuid.UUID) shipmentrouteOption {
	return func(m *ShipmentRouteMutation) {
		var (
			err   error
			once  sync.Once
			value *ShipmentRoute
		)
		m.oldValue = func(ctx context.Context) (*ShipmentRoute, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShipmentRoute.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShipmentRoute sets the old ShipmentRoute of the mutation.
func withShipmentRoute(node *ShipmentRoute) shipmentrouteOption {
	return func(m *ShipmentRouteMutation) {
		m.oldValue = func(context.Context) (*ShipmentRoute, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShipmentRouteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShipmentRouteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ShipmentRoute entities.
func (m *ShipmentRouteMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShipmentRouteMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ShipmentRouteMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ShipmentRoute.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *ShipmentRouteMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *ShipmentRouteMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the ShipmentRoute entity.
// If the ShipmentRoute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentRouteMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *ShipmentRouteMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *ShipmentRouteMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *ShipmentRouteMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the ShipmentRoute entity.
// If the ShipmentRoute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentRouteMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *ShipmentRouteMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ShipmentRouteMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ShipmentRouteMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ShipmentRoute entity.
// If the ShipmentRoute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentRouteMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ShipmentRouteMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ShipmentRouteMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ShipmentRouteMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ShipmentRoute entity.
// If the ShipmentRoute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentRouteMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ShipmentRouteMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *ShipmentRouteMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *ShipmentRouteMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the ShipmentRoute entity.
// If the ShipmentRoute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentRouteMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *ShipmentRouteMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *ShipmentRouteMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *ShipmentRouteMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetOriginLocationID sets the "origin_location_id" field.
func (m *ShipmentRouteMutation) SetOriginLocationID(u uuid.UUID) {
	m.origin_location = &u
}

// OriginLocationID returns the value of the "origin_location_id" field in the mutation.
func (m *ShipmentRouteMutation) OriginLocationID() (r uuid.UUID, exists bool) {
	v := m.origin_location
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginLocationID returns the old "origin_location_id" field's value of the ShipmentRoute entity.
// If the ShipmentRoute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentRouteMutation) OldOriginLocationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginLocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginLocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginLocationID: %w", err)
	}
	return oldValue.OriginLocationID, nil
}

// ResetOriginLocationID resets all changes to the "origin_location_id" field.
func (m *ShipmentRouteMutation) ResetOriginLocationID() {
	m.origin_location = nil
}

// SetDestinationLocationID sets the "destination_location_id" field.
func (m *ShipmentRouteMutation) SetDestinationLocationID(u uuid.UUID) {
	m.destination_location = &u
}

// DestinationLocationID returns the value of the "destination_location_id" field in the mutation.
func (m *ShipmentRouteMutation) DestinationLocationID() (r uuid.UUID, exists bool) {
	v := m.destination_location
	if v == nil {
		return
	}
	return *v, true
}

// OldDestinationLocationID returns the old "destination_location_id" field's value of the ShipmentRoute entity.
// If the ShipmentRoute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentRouteMutation) OldDestinationLocationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDestinationLocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDestinationLocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDestinationLocationID: %w", err)
	}
	return oldValue.DestinationLocationID, nil
}

// ResetDestinationLocationID resets all changes to the "destination_location_id" field.
func (m *ShipmentRouteMutation) ResetDestinationLocationID() {
	m.destination_location = nil
}

// SetMileage sets the "mileage" field.
func (m *ShipmentRouteMutation) SetMileage(f float64) {
	m.mileage = &f
	m.addmileage = nil
}

// Mileage returns the value of the "mileage" field in the mutation.
func (m *ShipmentRouteMutation) Mileage() (r float64, exists bool) {
	v := m.mileage
	if v == nil {
		return
	}
	return *v, true
}

// OldMileage returns the old "mileage" field's value of the ShipmentRoute entity.
// If the ShipmentRoute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentRouteMutation) OldMileage(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMileage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMileage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMileage: %w", err)
	}
	return oldValue.Mileage, nil
}

// AddMileage adds f to the "mileage" field.
func (m *ShipmentRouteMutation) AddMileage(f float64) {
	if m.addmileage != nil {
		*m.addmileage += f
	} else {
		m.addmileage = &f
	}
}

// AddedMileage returns the value that was added to the "mileage" field in this mutation.
func (m *ShipmentRouteMutation) AddedMileage() (r float64, exists bool) {
	v := m.addmileage
	if v == nil {
		return
	}
	return *v, true
}

// ResetMileage resets all changes to the "mileage" field.
func (m *ShipmentRouteMutation) ResetMileage() {
	m.mileage = nil
	m.addmileage = nil
}

// SetDuration sets the "duration" field.
func (m *ShipmentRouteMutation) SetDuration(i int) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *ShipmentRouteMutation) Duration() (r int, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the ShipmentRoute entity.
// If the ShipmentRoute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentRouteMutation) OldDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *ShipmentRouteMutation) AddDuration(i int) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *ShipmentRouteMutation) AddedDuration() (r int, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ClearDuration clears the value of the "duration" field.
func (m *ShipmentRouteMutation) ClearDuration() {
	m.duration = nil
	m.addduration = nil
	m.clearedFields[shipmentroute.FieldDuration] = struct{}{}
}

// DurationCleared returns if the "duration" field was cleared in this mutation.
func (m *ShipmentRouteMutation) DurationCleared() bool {
	_, ok := m.clearedFields[shipmentroute.FieldDuration]
	return ok
}

// ResetDuration resets all changes to the "duration" field.
func (m *ShipmentRouteMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
	delete(m.clearedFields, shipmentroute.FieldDuration)
}

// SetDistanceMethod sets the "distance_method" field.
func (m *ShipmentRouteMutation) SetDistanceMethod(s string) {
	m.distance_method = &s
}

// DistanceMethod returns the value of the "distance_method" field in the mutation.
func (m *ShipmentRouteMutation) DistanceMethod() (r string, exists bool) {
	v := m.distance_method
	if v == nil {
		return
	}
	return *v, true
}

// OldDistanceMethod returns the old "distance_method" field's value of the ShipmentRoute entity.
// If the ShipmentRoute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentRouteMutation) OldDistanceMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDistanceMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDistanceMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistanceMethod: %w", err)
	}
	return oldValue.DistanceMethod, nil
}

// ClearDistanceMethod clears the value of the "distance_method" field.
func (m *ShipmentRouteMutation) ClearDistanceMethod() {
	m.distance_method = nil
	m.clearedFields[shipmentroute.FieldDistanceMethod] = struct{}{}
}

// DistanceMethodCleared returns if the "distance_method" field was cleared in this mutation.
func (m *ShipmentRouteMutation) DistanceMethodCleared() bool {
	_, ok := m.clearedFields[shipmentroute.FieldDistanceMethod]
	return ok
}

// ResetDistanceMethod resets all changes to the "distance_method" field.
func (m *ShipmentRouteMutation) ResetDistanceMethod() {
	m.distance_method = nil
	delete(m.clearedFields, shipmentroute.FieldDistanceMethod)
}

// SetAutoGenerated sets the "auto_generated" field.
func (m *ShipmentRouteMutation) SetAutoGenerated(b bool) {
	m.auto_generated = &b
}

// AutoGenerated returns the value of the "auto_generated" field in the mutation.
func (m *ShipmentRouteMutation) AutoGenerated() (r bool, exists bool) {
	v := m.auto_generated
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoGenerated returns the old "auto_generated" field's value of the ShipmentRoute entity.
// If the ShipmentRoute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentRouteMutation) OldAutoGenerated(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoGenerated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoGenerated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoGenerated: %w", err)
	}
	return oldValue.AutoGenerated, nil
}

// ResetAutoGenerated resets all changes to the "auto_generated" field.
func (m *ShipmentRouteMutation) ResetAutoGenerated() {
	m.auto_generated = nil
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *ShipmentRouteMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[shipmentroute.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *ShipmentRouteMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *ShipmentRouteMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *ShipmentRouteMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *ShipmentRouteMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[shipmentroute.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *ShipmentRouteMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *ShipmentRouteMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *ShipmentRouteMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearOriginLocation clears the "origin_location" edge to the Location entity.
func (m *ShipmentRouteMutation) ClearOriginLocation() {
	m.clearedorigin_location = true
	m.clearedFields[shipmentroute.FieldOriginLocationID] = struct{}{}
}

// OriginLocationCleared reports if the "origin_location" edge to the Location entity was cleared.
func (m *ShipmentRouteMutation) OriginLocationCleared() bool {
	return m.clearedorigin_location
}

// OriginLocationIDs returns the "origin_location" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OriginLocationID instead. It exists only for internal usage by the builders.
func (m *ShipmentRouteMutation) OriginLocationIDs() (ids []uuid.UUID) {
	if id := m.origin_location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOriginLocation resets all changes to the "origin_location" edge.
func (m *ShipmentRouteMutation) ResetOriginLocation() {
	m.origin_location = nil
	m.clearedorigin_location = false
}

// ClearDestinationLocation clears the "destination_location" edge to the Location entity.
func (m *ShipmentRouteMutation) ClearDestinationLocation() {
	m.cleareddestination_location = true
	m.clearedFields[shipmentroute.FieldDestinationLocationID] = struct{}{}
}

// DestinationLocationCleared reports if the "destination_location" edge to the Location entity was cleared.
func (m *ShipmentRouteMutation) DestinationLocationCleared() bool {
	return m.cleareddestination_location
}

// DestinationLocationIDs returns the "destination_location" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DestinationLocationID instead. It exists only for internal usage by the builders.
func (m *ShipmentRouteMutation) DestinationLocationIDs() (ids []uuid.UUID) {
	if id := m.destination_location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDestinationLocation resets all changes to the "destination_location" edge.
func (m *ShipmentRouteMutation) ResetDestinationLocation() {
	m.destination_location = nil
	m.cleareddestination_location = false
}

// Where appends a list predicates to the ShipmentRouteMutation builder.
func (m *ShipmentRouteMutation) Where(ps ...predicate.ShipmentRoute) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ShipmentRouteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ShipmentRouteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ShipmentRoute, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ShipmentRouteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ShipmentRouteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ShipmentRoute).
func (m *ShipmentRouteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShipmentRouteMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.business_unit != nil {
		fields = append(fields, shipmentroute.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, shipmentroute.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, shipmentroute.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, shipmentroute.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, shipmentroute.FieldVersion)
	}
	if m.origin_location != nil {
		fields = append(fields, shipmentroute.FieldOriginLocationID)
	}
	if m.destination_location != nil {
		fields = append(fields, shipmentroute.FieldDestinationLocationID)
	}
	if m.mileage != nil {
		fields = append(fields, shipmentroute.FieldMileage)
	}
	if m.duration != nil {
		fields = append(fields, shipmentroute.FieldDuration)
	}
	if m.distance_method != nil {
		fields = append(fields, shipmentroute.FieldDistanceMethod)
	}
	if m.auto_generated != nil {
		fields = append(fields, shipmentroute.FieldAutoGenerated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShipmentRouteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shipmentroute.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case shipmentroute.FieldOrganizationID:
		return m.OrganizationID()
	case shipmentroute.FieldCreatedAt:
		return m.CreatedAt()
	case shipmentroute.FieldUpdatedAt:
		return m.UpdatedAt()
	case shipmentroute.FieldVersion:
		return m.Version()
	case shipmentroute.FieldOriginLocationID:
		return m.OriginLocationID()
	case shipmentroute.FieldDestinationLocationID:
		return m.DestinationLocationID()
	case shipmentroute.FieldMileage:
		return m.Mileage()
	case shipmentroute.FieldDuration:
		return m.Duration()
	case shipmentroute.FieldDistanceMethod:
		return m.DistanceMethod()
	case shipmentroute.FieldAutoGenerated:
		return m.AutoGenerated()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShipmentRouteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shipmentroute.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case shipmentroute.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case shipmentroute.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case shipmentroute.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case shipmentroute.FieldVersion:
		return m.OldVersion(ctx)
	case shipmentroute.FieldOriginLocationID:
		return m.OldOriginLocationID(ctx)
	case shipmentroute.FieldDestinationLocationID:
		return m.OldDestinationLocationID(ctx)
	case shipmentroute.FieldMileage:
		return m.OldMileage(ctx)
	case shipmentroute.FieldDuration:
		return m.OldDuration(ctx)
	case shipmentroute.FieldDistanceMethod:
		return m.OldDistanceMethod(ctx)
	case shipmentroute.FieldAutoGenerated:
		return m.OldAutoGenerated(ctx)
	}
	return nil, fmt.Errorf("unknown ShipmentRoute field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentRouteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shipmentroute.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case shipmentroute.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case shipmentroute.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case shipmentroute.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case shipmentroute.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case shipmentroute.FieldOriginLocationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginLocationID(v)
		return nil
	case shipmentroute.FieldDestinationLocationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDestinationLocationID(v)
		return nil
	case shipmentroute.FieldMileage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMileage(v)
		return nil
	case shipmentroute.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case shipmentroute.FieldDistanceMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistanceMethod(v)
		return nil
	case shipmentroute.FieldAutoGenerated:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoGenerated(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentRoute field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShipmentRouteMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, shipmentroute.FieldVersion)
	}
	if m.addmileage != nil {
		fields = append(fields, shipmentroute.FieldMileage)
	}
	if m.addduration != nil {
		fields = append(fields, shipmentroute.FieldDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShipmentRouteMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case shipmentroute.FieldVersion:
		return m.AddedVersion()
	case shipmentroute.FieldMileage:
		return m.AddedMileage()
	case shipmentroute.FieldDuration:
		return m.AddedDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentRouteMutation) AddField(name string, value ent.Value) error {
	switch name {
	case shipmentroute.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case shipmentroute.FieldMileage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMileage(v)
		return nil
	case shipmentroute.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentRoute numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShipmentRouteMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(shipmentroute.FieldDuration) {
		fields = append(fields, shipmentroute.FieldDuration)
	}
	if m.FieldCleared(shipmentroute.FieldDistanceMethod) {
		fields = append(fields, shipmentroute.FieldDistanceMethod)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShipmentRouteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShipmentRouteMutation) ClearField(name string) error {
	switch name {
	case shipmentroute.FieldDuration:
		m.ClearDuration()
		return nil
	case shipmentroute.FieldDistanceMethod:
		m.ClearDistanceMethod()
		return nil
	}
	return fmt.Errorf("unknown ShipmentRoute nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShipmentRouteMutation) ResetField(name string) error {
	switch name {
	case shipmentroute.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case shipmentroute.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case shipmentroute.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case shipmentroute.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case shipmentroute.FieldVersion:
		m.ResetVersion()
		return nil
	case shipmentroute.FieldOriginLocationID:
		m.ResetOriginLocationID()
		return nil
	case shipmentroute.FieldDestinationLocationID:
		m.ResetDestinationLocationID()
		return nil
	case shipmentroute.FieldMileage:
		m.ResetMileage()
		return nil
	case shipmentroute.FieldDuration:
		m.ResetDuration()
		return nil
	case shipmentroute.FieldDistanceMethod:
		m.ResetDistanceMethod()
		return nil
	case shipmentroute.FieldAutoGenerated:
		m.ResetAutoGenerated()
		return nil
	}
	return fmt.Errorf("unknown ShipmentRoute field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShipmentRouteMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.business_unit != nil {
		edges = append(edges, shipmentroute.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, shipmentroute.EdgeOrganization)
	}
	if m.origin_location != nil {
		edges = append(edges, shipmentroute.EdgeOriginLocation)
	}
	if m.destination_location != nil {
		edges = append(edges, shipmentroute.EdgeDestinationLocation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShipmentRouteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case shipmentroute.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case shipmentroute.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case shipmentroute.EdgeOriginLocation:
		if id := m.origin_location; id != nil {
			return []ent.Value{*id}
		}
	case shipmentroute.EdgeDestinationLocation:
		if id := m.destination_location; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShipmentRouteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShipmentRouteMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShipmentRouteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedbusiness_unit {
		edges = append(edges, shipmentroute.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, shipmentroute.EdgeOrganization)
	}
	if m.clearedorigin_location {
		edges = append(edges, shipmentroute.EdgeOriginLocation)
	}
	if m.cleareddestination_location {
		edges = append(edges, shipmentroute.EdgeDestinationLocation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShipmentRouteMutation) EdgeCleared(name string) bool {
	switch name {
	case shipmentroute.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case shipmentroute.EdgeOrganization:
		return m.clearedorganization
	case shipmentroute.EdgeOriginLocation:
		return m.clearedorigin_location
	case shipmentroute.EdgeDestinationLocation:
		return m.cleareddestination_location
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShipmentRouteMutation) ClearEdge(name string) error {
	switch name {
	case shipmentroute.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case shipmentroute.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case shipmentroute.EdgeOriginLocation:
		m.ClearOriginLocation()
		return nil
	case shipmentroute.EdgeDestinationLocation:
		m.ClearDestinationLocation()
		return nil
	}
	return fmt.Errorf("unknown ShipmentRoute unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShipmentRouteMutation) ResetEdge(name string) error {
	switch name {
	case shipmentroute.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case shipmentroute.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case shipmentroute.EdgeOriginLocation:
		m.ResetOriginLocation()
		return nil
	case shipmentroute.EdgeDestinationLocation:
		m.ResetDestinationLocation()
		return nil
	}
	return fmt.Errorf("unknown ShipmentRoute edge %s", name)
}

// ShipmentTypeMutation represents an operation that mutates the ShipmentType nodes in the graph.
type ShipmentTypeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	version              *int
	addversion           *int
	status               *shipmenttype.Status
	code                 *string
	description          *string
	color                *string
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	done                 bool
	oldValue             func(context.Context) (*ShipmentType, error)
	predicates           []predicate.ShipmentType
}

var _ ent.Mutation = (*ShipmentTypeMutation)(nil)

// shipmenttypeOption allows management of the mutation configuration using functional options.
type shipmenttypeOption func(*ShipmentTypeMutation)

// newShipmentTypeMutation creates new mutation for the ShipmentType entity.
func newShipmentTypeMutation(c config, op Op, opts ...shipmenttypeOption) *ShipmentTypeMutation {
	m := &ShipmentTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeShipmentType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShipmentTypeID sets the ID field of the mutation.
func withShipmentTypeID(id uuid.UUID) shipmenttypeOption {
	return func(m *ShipmentTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ShipmentType
		)
		m.oldValue = func(ctx context.Context) (*ShipmentType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShipmentType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShipmentType sets the old ShipmentType of the mutation.
func withShipmentType(node *ShipmentType) shipmenttypeOption {
	return func(m *ShipmentTypeMutation) {
		m.oldValue = func(context.Context) (*ShipmentType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShipmentTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShipmentTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ShipmentType entities.
func (m *ShipmentTypeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShipmentTypeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ShipmentTypeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ShipmentType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *ShipmentTypeMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *ShipmentTypeMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the ShipmentType entity.
// If the ShipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentTypeMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *ShipmentTypeMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *ShipmentTypeMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *ShipmentTypeMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the ShipmentType entity.
// If the ShipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentTypeMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *ShipmentTypeMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ShipmentTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ShipmentTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ShipmentType entity.
// If the ShipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ShipmentTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ShipmentTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ShipmentTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ShipmentType entity.
// If the ShipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ShipmentTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *ShipmentTypeMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *ShipmentTypeMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the ShipmentType entity.
// If the ShipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentTypeMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *ShipmentTypeMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *ShipmentTypeMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *ShipmentTypeMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetStatus sets the "status" field.
func (m *ShipmentTypeMutation) SetStatus(s shipmenttype.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ShipmentTypeMutation) Status() (r shipmenttype.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ShipmentType entity.
// If the ShipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentTypeMutation) OldStatus(ctx context.Context) (v shipmenttype.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ShipmentTypeMutation) ResetStatus() {
	m.status = nil
}

// SetCode sets the "code" field.
func (m *ShipmentTypeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *ShipmentTypeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the ShipmentType entity.
// If the ShipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentTypeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *ShipmentTypeMutation) ResetCode() {
	m.code = nil
}

// SetDescription sets the "description" field.
func (m *ShipmentTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ShipmentTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ShipmentType entity.
// If the ShipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ShipmentTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[shipmenttype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ShipmentTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[shipmenttype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ShipmentTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, shipmenttype.FieldDescription)
}

// SetColor sets the "color" field.
func (m *ShipmentTypeMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *ShipmentTypeMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the ShipmentType entity.
// If the ShipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentTypeMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *ShipmentTypeMutation) ClearColor() {
	m.color = nil
	m.clearedFields[shipmenttype.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *ShipmentTypeMutation) ColorCleared() bool {
	_, ok := m.clearedFields[shipmenttype.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *ShipmentTypeMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, shipmenttype.FieldColor)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *ShipmentTypeMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[shipmenttype.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *ShipmentTypeMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *ShipmentTypeMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *ShipmentTypeMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *ShipmentTypeMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[shipmenttype.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *ShipmentTypeMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *ShipmentTypeMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *ShipmentTypeMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the ShipmentTypeMutation builder.
func (m *ShipmentTypeMutation) Where(ps ...predicate.ShipmentType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ShipmentTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ShipmentTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ShipmentType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ShipmentTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ShipmentTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ShipmentType).
func (m *ShipmentTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShipmentTypeMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.business_unit != nil {
		fields = append(fields, shipmenttype.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, shipmenttype.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, shipmenttype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, shipmenttype.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, shipmenttype.FieldVersion)
	}
	if m.status != nil {
		fields = append(fields, shipmenttype.FieldStatus)
	}
	if m.code != nil {
		fields = append(fields, shipmenttype.FieldCode)
	}
	if m.description != nil {
		fields = append(fields, shipmenttype.FieldDescription)
	}
	if m.color != nil {
		fields = append(fields, shipmenttype.FieldColor)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShipmentTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shipmenttype.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case shipmenttype.FieldOrganizationID:
		return m.OrganizationID()
	case shipmenttype.FieldCreatedAt:
		return m.CreatedAt()
	case shipmenttype.FieldUpdatedAt:
		return m.UpdatedAt()
	case shipmenttype.FieldVersion:
		return m.Version()
	case shipmenttype.FieldStatus:
		return m.Status()
	case shipmenttype.FieldCode:
		return m.Code()
	case shipmenttype.FieldDescription:
		return m.Description()
	case shipmenttype.FieldColor:
		return m.Color()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShipmentTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shipmenttype.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case shipmenttype.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case shipmenttype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case shipmenttype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case shipmenttype.FieldVersion:
		return m.OldVersion(ctx)
	case shipmenttype.FieldStatus:
		return m.OldStatus(ctx)
	case shipmenttype.FieldCode:
		return m.OldCode(ctx)
	case shipmenttype.FieldDescription:
		return m.OldDescription(ctx)
	case shipmenttype.FieldColor:
		return m.OldColor(ctx)
	}
	return nil, fmt.Errorf("unknown ShipmentType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shipmenttype.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case shipmenttype.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case shipmenttype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case shipmenttype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case shipmenttype.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case shipmenttype.FieldStatus:
		v, ok := value.(shipmenttype.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case shipmenttype.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case shipmenttype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case shipmenttype.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShipmentTypeMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, shipmenttype.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShipmentTypeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case shipmenttype.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case shipmenttype.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShipmentTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(shipmenttype.FieldDescription) {
		fields = append(fields, shipmenttype.FieldDescription)
	}
	if m.FieldCleared(shipmenttype.FieldColor) {
		fields = append(fields, shipmenttype.FieldColor)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShipmentTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShipmentTypeMutation) ClearField(name string) error {
	switch name {
	case shipmenttype.FieldDescription:
		m.ClearDescription()
		return nil
	case shipmenttype.FieldColor:
		m.ClearColor()
		return nil
	}
	return fmt.Errorf("unknown ShipmentType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShipmentTypeMutation) ResetField(name string) error {
	switch name {
	case shipmenttype.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case shipmenttype.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case shipmenttype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case shipmenttype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case shipmenttype.FieldVersion:
		m.ResetVersion()
		return nil
	case shipmenttype.FieldStatus:
		m.ResetStatus()
		return nil
	case shipmenttype.FieldCode:
		m.ResetCode()
		return nil
	case shipmenttype.FieldDescription:
		m.ResetDescription()
		return nil
	case shipmenttype.FieldColor:
		m.ResetColor()
		return nil
	}
	return fmt.Errorf("unknown ShipmentType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShipmentTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.business_unit != nil {
		edges = append(edges, shipmenttype.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, shipmenttype.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShipmentTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case shipmenttype.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case shipmenttype.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShipmentTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShipmentTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShipmentTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbusiness_unit {
		edges = append(edges, shipmenttype.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, shipmenttype.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShipmentTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case shipmenttype.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case shipmenttype.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShipmentTypeMutation) ClearEdge(name string) error {
	switch name {
	case shipmenttype.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case shipmenttype.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown ShipmentType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShipmentTypeMutation) ResetEdge(name string) error {
	switch name {
	case shipmenttype.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case shipmenttype.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown ShipmentType edge %s", name)
}

// StopMutation represents an operation that mutates the Stop nodes in the graph.
type StopMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	version              *int
	addversion           *int
	status               *stop.Status
	stop_type            *stop.StopType
	sequence             *int
	addsequence          *int
	location_id          *uuid.UUID
	pieces               *float64
	addpieces            *float64
	weight               *float64
	addweight            *float64
	address_line         *string
	appointment_start    *time.Time
	appointment_end      *time.Time
	arrival_time         *time.Time
	departure_time       *time.Time
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	shipment_move        *uuid.UUID
	clearedshipment_move bool
	done                 bool
	oldValue             func(context.Context) (*Stop, error)
	predicates           []predicate.Stop
}

var _ ent.Mutation = (*StopMutation)(nil)

// stopOption allows management of the mutation configuration using functional options.
type stopOption func(*StopMutation)

// newStopMutation creates new mutation for the Stop entity.
func newStopMutation(c config, op Op, opts ...stopOption) *StopMutation {
	m := &StopMutation{
		config:        c,
		op:            op,
		typ:           TypeStop,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStopID sets the ID field of the mutation.
func withStopID(id uuid.UUID) stopOption {
	return func(m *StopMutation) {
		var (
			err   error
			once  sync.Once
			value *Stop
		)
		m.oldValue = func(ctx context.Context) (*Stop, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Stop.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStop sets the old Stop of the mutation.
func withStop(node *Stop) stopOption {
	return func(m *StopMutation) {
		m.oldValue = func(context.Context) (*Stop, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StopMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StopMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Stop entities.
func (m *StopMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StopMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StopMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Stop.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *StopMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *StopMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the Stop entity.
// If the Stop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StopMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *StopMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *StopMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *StopMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Stop entity.
// If the Stop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StopMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *StopMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *StopMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StopMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Stop entity.
// If the Stop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StopMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StopMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StopMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StopMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Stop entity.
// If the Stop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StopMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StopMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *StopMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *StopMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Stop entity.
// If the Stop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StopMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *StopMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *StopMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *StopMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetStatus sets the "status" field.
func (m *StopMutation) SetStatus(s stop.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *StopMutation) Status() (r stop.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Stop entity.
// If the Stop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StopMutation) OldStatus(ctx context.Context) (v stop.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *StopMutation) ResetStatus() {
	m.status = nil
}

// SetShipmentMoveID sets the "shipment_move_id" field.
func (m *StopMutation) SetShipmentMoveID(u uuid.UUID) {
	m.shipment_move = &u
}

// ShipmentMoveID returns the value of the "shipment_move_id" field in the mutation.
func (m *StopMutation) ShipmentMoveID() (r uuid.UUID, exists bool) {
	v := m.shipment_move
	if v == nil {
		return
	}
	return *v, true
}

// OldShipmentMoveID returns the old "shipment_move_id" field's value of the Stop entity.
// If the Stop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StopMutation) OldShipmentMoveID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShipmentMoveID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShipmentMoveID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipmentMoveID: %w", err)
	}
	return oldValue.ShipmentMoveID, nil
}

// ResetShipmentMoveID resets all changes to the "shipment_move_id" field.
func (m *StopMutation) ResetShipmentMoveID() {
	m.shipment_move = nil
}

// SetStopType sets the "stop_type" field.
func (m *StopMutation) SetStopType(st stop.StopType) {
	m.stop_type = &st
}

// StopType returns the value of the "stop_type" field in the mutation.
func (m *StopMutation) StopType() (r stop.StopType, exists bool) {
	v := m.stop_type
	if v == nil {
		return
	}
	return *v, true
}

// OldStopType returns the old "stop_type" field's value of the Stop entity.
// If the Stop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StopMutation) OldStopType(ctx context.Context) (v stop.StopType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStopType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStopType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStopType: %w", err)
	}
	return oldValue.StopType, nil
}

// ResetStopType resets all changes to the "stop_type" field.
func (m *StopMutation) ResetStopType() {
	m.stop_type = nil
}

// SetSequence sets the "sequence" field.
func (m *StopMutation) SetSequence(i int) {
	m.sequence = &i
	m.addsequence = nil
}

// Sequence returns the value of the "sequence" field in the mutation.
func (m *StopMutation) Sequence() (r int, exists bool) {
	v := m.sequence
	if v == nil {
		return
	}
	return *v, true
}

// OldSequence returns the old "sequence" field's value of the Stop entity.
// If the Stop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StopMutation) OldSequence(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSequence is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSequence requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSequence: %w", err)
	}
	return oldValue.Sequence, nil
}

// AddSequence adds i to the "sequence" field.
func (m *StopMutation) AddSequence(i int) {
	if m.addsequence != nil {
		*m.addsequence += i
	} else {
		m.addsequence = &i
	}
}

// AddedSequence returns the value that was added to the "sequence" field in this mutation.
func (m *StopMutation) AddedSequence() (r int, exists bool) {
	v := m.addsequence
	if v == nil {
		return
	}
	return *v, true
}

// ResetSequence resets all changes to the "sequence" field.
func (m *StopMutation) ResetSequence() {
	m.sequence = nil
	m.addsequence = nil
}

// SetLocationID sets the "location_id" field.
func (m *StopMutation) SetLocationID(u uuid.UUID) {
	m.location_id = &u
}

// LocationID returns the value of the "location_id" field in the mutation.
func (m *StopMutation) LocationID() (r uuid.UUID, exists bool) {
	v := m.location_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationID returns the old "location_id" field's value of the Stop entity.
// If the Stop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StopMutation) OldLocationID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationID: %w", err)
	}
	return oldValue.LocationID, nil
}

// ClearLocationID clears the value of the "location_id" field.
func (m *StopMutation) ClearLocationID() {
	m.location_id = nil
	m.clearedFields[stop.FieldLocationID] = struct{}{}
}

// LocationIDCleared returns if the "location_id" field was cleared in this mutation.
func (m *StopMutation) LocationIDCleared() bool {
	_, ok := m.clearedFields[stop.FieldLocationID]
	return ok
}

// ResetLocationID resets all changes to the "location_id" field.
func (m *StopMutation) ResetLocationID() {
	m.location_id = nil
	delete(m.clearedFields, stop.FieldLocationID)
}

// SetPieces sets the "pieces" field.
func (m *StopMutation) SetPieces(f float64) {
	m.pieces = &f
	m.addpieces = nil
}

// Pieces returns the value of the "pieces" field in the mutation.
func (m *StopMutation) Pieces() (r float64, exists bool) {
	v := m.pieces
	if v == nil {
		return
	}
	return *v, true
}

// OldPieces returns the old "pieces" field's value of the Stop entity.
// If the Stop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StopMutation) OldPieces(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPieces is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPieces requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPieces: %w", err)
	}
	return oldValue.Pieces, nil
}

// AddPieces adds f to the "pieces" field.
func (m *StopMutation) AddPieces(f float64) {
	if m.addpieces != nil {
		*m.addpieces += f
	} else {
		m.addpieces = &f
	}
}

// AddedPieces returns the value that was added to the "pieces" field in this mutation.
func (m *StopMutation) AddedPieces() (r float64, exists bool) {
	v := m.addpieces
	if v == nil {
		return
	}
	return *v, true
}

// ClearPieces clears the value of the "pieces" field.
func (m *StopMutation) ClearPieces() {
	m.pieces = nil
	m.addpieces = nil
	m.clearedFields[stop.FieldPieces] = struct{}{}
}

// PiecesCleared returns if the "pieces" field was cleared in this mutation.
func (m *StopMutation) PiecesCleared() bool {
	_, ok := m.clearedFields[stop.FieldPieces]
	return ok
}

// ResetPieces resets all changes to the "pieces" field.
func (m *StopMutation) ResetPieces() {
	m.pieces = nil
	m.addpieces = nil
	delete(m.clearedFields, stop.FieldPieces)
}

// SetWeight sets the "weight" field.
func (m *StopMutation) SetWeight(f float64) {
	m.weight = &f
	m.addweight = nil
}

// Weight returns the value of the "weight" field in the mutation.
func (m *StopMutation) Weight() (r float64, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old "weight" field's value of the Stop entity.
// If the Stop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StopMutation) OldWeight(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds f to the "weight" field.
func (m *StopMutation) AddWeight(f float64) {
	if m.addweight != nil {
		*m.addweight += f
	} else {
		m.addweight = &f
	}
}

// AddedWeight returns the value that was added to the "weight" field in this mutation.
func (m *StopMutation) AddedWeight() (r float64, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ClearWeight clears the value of the "weight" field.
func (m *StopMutation) ClearWeight() {
	m.weight = nil
	m.addweight = nil
	m.clearedFields[stop.FieldWeight] = struct{}{}
}

// WeightCleared returns if the "weight" field was cleared in this mutation.
func (m *StopMutation) WeightCleared() bool {
	_, ok := m.clearedFields[stop.FieldWeight]
	return ok
}

// ResetWeight resets all changes to the "weight" field.
func (m *StopMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
	delete(m.clearedFields, stop.FieldWeight)
}

// SetAddressLine sets the "address_line" field.
func (m *StopMutation) SetAddressLine(s string) {
	m.address_line = &s
}

// AddressLine returns the value of the "address_line" field in the mutation.
func (m *StopMutation) AddressLine() (r string, exists bool) {
	v := m.address_line
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressLine returns the old "address_line" field's value of the Stop entity.
// If the Stop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StopMutation) OldAddressLine(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddressLine is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddressLine requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressLine: %w", err)
	}
	return oldValue.AddressLine, nil
}

// ClearAddressLine clears the value of the "address_line" field.
func (m *StopMutation) ClearAddressLine() {
	m.address_line = nil
	m.clearedFields[stop.FieldAddressLine] = struct{}{}
}

// AddressLineCleared returns if the "address_line" field was cleared in this mutation.
func (m *StopMutation) AddressLineCleared() bool {
	_, ok := m.clearedFields[stop.FieldAddressLine]
	return ok
}

// ResetAddressLine resets all changes to the "address_line" field.
func (m *StopMutation) ResetAddressLine() {
	m.address_line = nil
	delete(m.clearedFields, stop.FieldAddressLine)
}

// SetAppointmentStart sets the "appointment_start" field.
func (m *StopMutation) SetAppointmentStart(t time.Time) {
	m.appointment_start = &t
}

// AppointmentStart returns the value of the "appointment_start" field in the mutation.
func (m *StopMutation) AppointmentStart() (r time.Time, exists bool) {
	v := m.appointment_start
	if v == nil {
		return
	}
	return *v, true
}

// OldAppointmentStart returns the old "appointment_start" field's value of the Stop entity.
// If the Stop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StopMutation) OldAppointmentStart(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppointmentStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppointmentStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppointmentStart: %w", err)
	}
	return oldValue.AppointmentStart, nil
}

// ClearAppointmentStart clears the value of the "appointment_start" field.
func (m *StopMutation) ClearAppointmentStart() {
	m.appointment_start = nil
	m.clearedFields[stop.FieldAppointmentStart] = struct{}{}
}

// AppointmentStartCleared returns if the "appointment_start" field was cleared in this mutation.
func (m *StopMutation) AppointmentStartCleared() bool {
	_, ok := m.clearedFields[stop.FieldAppointmentStart]
	return ok
}

// ResetAppointmentStart resets all changes to the "appointment_start" field.
func (m *StopMutation) ResetAppointmentStart() {
	m.appointment_start = nil
	delete(m.clearedFields, stop.FieldAppointmentStart)
}

// SetAppointmentEnd sets the "appointment_end" field.
func (m *StopMutation) SetAppointmentEnd(t time.Time) {
	m.appointment_end = &t
}

// AppointmentEnd returns the value of the "appointment_end" field in the mutation.
func (m *StopMutation) AppointmentEnd() (r time.Time, exists bool) {
	v := m.appointment_end
	if v == nil {
		return
	}
	return *v, true
}

// OldAppointmentEnd returns the old "appointment_end" field's value of the Stop entity.
// If the Stop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StopMutation) OldAppointmentEnd(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppointmentEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppointmentEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppointmentEnd: %w", err)
	}
	return oldValue.AppointmentEnd, nil
}

// ClearAppointmentEnd clears the value of the "appointment_end" field.
func (m *StopMutation) ClearAppointmentEnd() {
	m.appointment_end = nil
	m.clearedFields[stop.FieldAppointmentEnd] = struct{}{}
}

// AppointmentEndCleared returns if the "appointment_end" field was cleared in this mutation.
func (m *StopMutation) AppointmentEndCleared() bool {
	_, ok := m.clearedFields[stop.FieldAppointmentEnd]
	return ok
}

// ResetAppointmentEnd resets all changes to the "appointment_end" field.
func (m *StopMutation) ResetAppointmentEnd() {
	m.appointment_end = nil
	delete(m.clearedFields, stop.FieldAppointmentEnd)
}

// SetArrivalTime sets the "arrival_time" field.
func (m *StopMutation) SetArrivalTime(t time.Time) {
	m.arrival_time = &t
}

// ArrivalTime returns the value of the "arrival_time" field in the mutation.
func (m *StopMutation) ArrivalTime() (r time.Time, exists bool) {
	v := m.arrival_time
	if v == nil {
		return
	}
	return *v, true
}

// OldArrivalTime returns the old "arrival_time" field's value of the Stop entity.
// If the Stop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StopMutation) OldArrivalTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArrivalTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArrivalTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArrivalTime: %w", err)
	}
	return oldValue.ArrivalTime, nil
}

// ClearArrivalTime clears the value of the "arrival_time" field.
func (m *StopMutation) ClearArrivalTime() {
	m.arrival_time = nil
	m.clearedFields[stop.FieldArrivalTime] = struct{}{}
}

// ArrivalTimeCleared returns if the "arrival_time" field was cleared in this mutation.
func (m *StopMutation) ArrivalTimeCleared() bool {
	_, ok := m.clearedFields[stop.FieldArrivalTime]
	return ok
}

// ResetArrivalTime resets all changes to the "arrival_time" field.
func (m *StopMutation) ResetArrivalTime() {
	m.arrival_time = nil
	delete(m.clearedFields, stop.FieldArrivalTime)
}

// SetDepartureTime sets the "departure_time" field.
func (m *StopMutation) SetDepartureTime(t time.Time) {
	m.departure_time = &t
}

// DepartureTime returns the value of the "departure_time" field in the mutation.
func (m *StopMutation) DepartureTime() (r time.Time, exists bool) {
	v := m.departure_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartureTime returns the old "departure_time" field's value of the Stop entity.
// If the Stop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StopMutation) OldDepartureTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartureTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartureTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartureTime: %w", err)
	}
	return oldValue.DepartureTime, nil
}

// ClearDepartureTime clears the value of the "departure_time" field.
func (m *StopMutation) ClearDepartureTime() {
	m.departure_time = nil
	m.clearedFields[stop.FieldDepartureTime] = struct{}{}
}

// DepartureTimeCleared returns if the "departure_time" field was cleared in this mutation.
func (m *StopMutation) DepartureTimeCleared() bool {
	_, ok := m.clearedFields[stop.FieldDepartureTime]
	return ok
}

// ResetDepartureTime resets all changes to the "departure_time" field.
func (m *StopMutation) ResetDepartureTime() {
	m.departure_time = nil
	delete(m.clearedFields, stop.FieldDepartureTime)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *StopMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[stop.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *StopMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *StopMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *StopMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *StopMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[stop.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *StopMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *StopMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *StopMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearShipmentMove clears the "shipment_move" edge to the ShipmentMove entity.
func (m *StopMutation) ClearShipmentMove() {
	m.clearedshipment_move = true
	m.clearedFields[stop.FieldShipmentMoveID] = struct{}{}
}

// ShipmentMoveCleared reports if the "shipment_move" edge to the ShipmentMove entity was cleared.
func (m *StopMutation) ShipmentMoveCleared() bool {
	return m.clearedshipment_move
}

// ShipmentMoveIDs returns the "shipment_move" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentMoveID instead. It exists only for internal usage by the builders.
func (m *StopMutation) ShipmentMoveIDs() (ids []uuid.UUID) {
	if id := m.shipment_move; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipmentMove resets all changes to the "shipment_move" edge.
func (m *StopMutation) ResetShipmentMove() {
	m.shipment_move = nil
	m.clearedshipment_move = false
}

// Where appends a list predicates to the StopMutation builder.
func (m *StopMutation) Where(ps ...predicate.Stop) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StopMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StopMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Stop, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StopMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StopMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Stop).
func (m *StopMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StopMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.business_unit != nil {
		fields = append(fields, stop.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, stop.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, stop.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, stop.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, stop.FieldVersion)
	}
	if m.status != nil {
		fields = append(fields, stop.FieldStatus)
	}
	if m.shipment_move != nil {
		fields = append(fields, stop.FieldShipmentMoveID)
	}
	if m.stop_type != nil {
		fields = append(fields, stop.FieldStopType)
	}
	if m.sequence != nil {
		fields = append(fields, stop.FieldSequence)
	}
	if m.location_id != nil {
		fields = append(fields, stop.FieldLocationID)
	}
	if m.pieces != nil {
		fields = append(fields, stop.FieldPieces)
	}
	if m.weight != nil {
		fields = append(fields, stop.FieldWeight)
	}
	if m.address_line != nil {
		fields = append(fields, stop.FieldAddressLine)
	}
	if m.appointment_start != nil {
		fields = append(fields, stop.FieldAppointmentStart)
	}
	if m.appointment_end != nil {
		fields = append(fields, stop.FieldAppointmentEnd)
	}
	if m.arrival_time != nil {
		fields = append(fields, stop.FieldArrivalTime)
	}
	if m.departure_time != nil {
		fields = append(fields, stop.FieldDepartureTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StopMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case stop.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case stop.FieldOrganizationID:
		return m.OrganizationID()
	case stop.FieldCreatedAt:
		return m.CreatedAt()
	case stop.FieldUpdatedAt:
		return m.UpdatedAt()
	case stop.FieldVersion:
		return m.Version()
	case stop.FieldStatus:
		return m.Status()
	case stop.FieldShipmentMoveID:
		return m.ShipmentMoveID()
	case stop.FieldStopType:
		return m.StopType()
	case stop.FieldSequence:
		return m.Sequence()
	case stop.FieldLocationID:
		return m.LocationID()
	case stop.FieldPieces:
		return m.Pieces()
	case stop.FieldWeight:
		return m.Weight()
	case stop.FieldAddressLine:
		return m.AddressLine()
	case stop.FieldAppointmentStart:
		return m.AppointmentStart()
	case stop.FieldAppointmentEnd:
		return m.AppointmentEnd()
	case stop.FieldArrivalTime:
		return m.ArrivalTime()
	case stop.FieldDepartureTime:
		return m.DepartureTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StopMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case stop.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case stop.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case stop.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case stop.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case stop.FieldVersion:
		return m.OldVersion(ctx)
	case stop.FieldStatus:
		return m.OldStatus(ctx)
	case stop.FieldShipmentMoveID:
		return m.OldShipmentMoveID(ctx)
	case stop.FieldStopType:
		return m.OldStopType(ctx)
	case stop.FieldSequence:
		return m.OldSequence(ctx)
	case stop.FieldLocationID:
		return m.OldLocationID(ctx)
	case stop.FieldPieces:
		return m.OldPieces(ctx)
	case stop.FieldWeight:
		return m.OldWeight(ctx)
	case stop.FieldAddressLine:
		return m.OldAddressLine(ctx)
	case stop.FieldAppointmentStart:
		return m.OldAppointmentStart(ctx)
	case stop.FieldAppointmentEnd:
		return m.OldAppointmentEnd(ctx)
	case stop.FieldArrivalTime:
		return m.OldArrivalTime(ctx)
	case stop.FieldDepartureTime:
		return m.OldDepartureTime(ctx)
	}
	return nil, fmt.Errorf("unknown Stop field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StopMutation) SetField(name string, value ent.Value) error {
	switch name {
	case stop.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case stop.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case stop.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case stop.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case stop.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case stop.FieldStatus:
		v, ok := value.(stop.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case stop.FieldShipmentMoveID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipmentMoveID(v)
		return nil
	case stop.FieldStopType:
		v, ok := value.(stop.StopType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStopType(v)
		return nil
	case stop.FieldSequence:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSequence(v)
		return nil
	case stop.FieldLocationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationID(v)
		return nil
	case stop.FieldPieces:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPieces(v)
		return nil
	case stop.FieldWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case stop.FieldAddressLine:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressLine(v)
		return nil
	case stop.FieldAppointmentStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppointmentStart(v)
		return nil
	case stop.FieldAppointmentEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppointmentEnd(v)
		return nil
	case stop.FieldArrivalTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArrivalTime(v)
		return nil
	case stop.FieldDepartureTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartureTime(v)
		return nil
	}
	return fmt.Errorf("unknown Stop field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StopMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, stop.FieldVersion)
	}
	if m.addsequence != nil {
		fields = append(fields, stop.FieldSequence)
	}
	if m.addpieces != nil {
		fields = append(fields, stop.FieldPieces)
	}
	if m.addweight != nil {
		fields = append(fields, stop.FieldWeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StopMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case stop.FieldVersion:
		return m.AddedVersion()
	case stop.FieldSequence:
		return m.AddedSequence()
	case stop.FieldPieces:
		return m.AddedPieces()
	case stop.FieldWeight:
		return m.AddedWeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StopMutation) AddField(name string, value ent.Value) error {
	switch name {
	case stop.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case stop.FieldSequence:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSequence(v)
		return nil
	case stop.FieldPieces:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPieces(v)
		return nil
	case stop.FieldWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	}
	return fmt.Errorf("unknown Stop numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StopMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(stop.FieldLocationID) {
		fields = append(fields, stop.FieldLocationID)
	}
	if m.FieldCleared(stop.FieldPieces) {
		fields = append(fields, stop.FieldPieces)
	}
	if m.FieldCleared(stop.FieldWeight) {
		fields = append(fields, stop.FieldWeight)
	}
	if m.FieldCleared(stop.FieldAddressLine) {
		fields = append(fields, stop.FieldAddressLine)
	}
	if m.FieldCleared(stop.FieldAppointmentStart) {
		fields = append(fields, stop.FieldAppointmentStart)
	}
	if m.FieldCleared(stop.FieldAppointmentEnd) {
		fields = append(fields, stop.FieldAppointmentEnd)
	}
	if m.FieldCleared(stop.FieldArrivalTime) {
		fields = append(fields, stop.FieldArrivalTime)
	}
	if m.FieldCleared(stop.FieldDepartureTime) {
		fields = append(fields, stop.FieldDepartureTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StopMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StopMutation) ClearField(name string) error {
	switch name {
	case stop.FieldLocationID:
		m.ClearLocationID()
		return nil
	case stop.FieldPieces:
		m.ClearPieces()
		return nil
	case stop.FieldWeight:
		m.ClearWeight()
		return nil
	case stop.FieldAddressLine:
		m.ClearAddressLine()
		return nil
	case stop.FieldAppointmentStart:
		m.ClearAppointmentStart()
		return nil
	case stop.FieldAppointmentEnd:
		m.ClearAppointmentEnd()
		return nil
	case stop.FieldArrivalTime:
		m.ClearArrivalTime()
		return nil
	case stop.FieldDepartureTime:
		m.ClearDepartureTime()
		return nil
	}
	return fmt.Errorf("unknown Stop nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StopMutation) ResetField(name string) error {
	switch name {
	case stop.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case stop.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case stop.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case stop.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case stop.FieldVersion:
		m.ResetVersion()
		return nil
	case stop.FieldStatus:
		m.ResetStatus()
		return nil
	case stop.FieldShipmentMoveID:
		m.ResetShipmentMoveID()
		return nil
	case stop.FieldStopType:
		m.ResetStopType()
		return nil
	case stop.FieldSequence:
		m.ResetSequence()
		return nil
	case stop.FieldLocationID:
		m.ResetLocationID()
		return nil
	case stop.FieldPieces:
		m.ResetPieces()
		return nil
	case stop.FieldWeight:
		m.ResetWeight()
		return nil
	case stop.FieldAddressLine:
		m.ResetAddressLine()
		return nil
	case stop.FieldAppointmentStart:
		m.ResetAppointmentStart()
		return nil
	case stop.FieldAppointmentEnd:
		m.ResetAppointmentEnd()
		return nil
	case stop.FieldArrivalTime:
		m.ResetArrivalTime()
		return nil
	case stop.FieldDepartureTime:
		m.ResetDepartureTime()
		return nil
	}
	return fmt.Errorf("unknown Stop field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StopMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.business_unit != nil {
		edges = append(edges, stop.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, stop.EdgeOrganization)
	}
	if m.shipment_move != nil {
		edges = append(edges, stop.EdgeShipmentMove)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StopMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case stop.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case stop.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case stop.EdgeShipmentMove:
		if id := m.shipment_move; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StopMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StopMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StopMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbusiness_unit {
		edges = append(edges, stop.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, stop.EdgeOrganization)
	}
	if m.clearedshipment_move {
		edges = append(edges, stop.EdgeShipmentMove)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StopMutation) EdgeCleared(name string) bool {
	switch name {
	case stop.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case stop.EdgeOrganization:
		return m.clearedorganization
	case stop.EdgeShipmentMove:
		return m.clearedshipment_move
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StopMutation) ClearEdge(name string) error {
	switch name {
	case stop.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case stop.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case stop.EdgeShipmentMove:
		m.ClearShipmentMove()
		return nil
	}
	return fmt.Errorf("unknown Stop unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StopMutation) ResetEdge(name string) error {
	switch name {
	case stop.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case stop.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case stop.EdgeShipmentMove:
		m.ResetShipmentMove()
		return nil
	}
	return fmt.Errorf("unknown Stop edge %s", name)
}

// TableChangeAlertMutation represents an operation that mutates the TableChangeAlert nodes in the graph.
type TableChangeAlertMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	version              *int
	addversion           *int
	status               *tablechangealert.Status
	name                 *string
	database_action      *tablechangealert.DatabaseAction
	source               *tablechangealert.Source
	table_name           *string
	topic_name           *string
	description          *string
	custom_subject       *string
	function_name        *string
	trigger_name         *string
	listener_name        *string
	email_recipients     *string
	effective_date       **pgtype.Date
	expiration_date      **pgtype.Date
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	done                 bool
	oldValue             func(context.Context) (*TableChangeAlert, error)
	predicates           []predicate.TableChangeAlert
}

var _ ent.Mutation = (*TableChangeAlertMutation)(nil)

// tablechangealertOption allows management of the mutation configuration using functional options.
type tablechangealertOption func(*TableChangeAlertMutation)

// newTableChangeAlertMutation creates new mutation for the TableChangeAlert entity.
func newTableChangeAlertMutation(c config, op Op, opts ...tablechangealertOption) *TableChangeAlertMutation {
	m := &TableChangeAlertMutation{
		config:        c,
		op:            op,
		typ:           TypeTableChangeAlert,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTableChangeAlertID sets the ID field of the mutation.
func withTableChangeAlertID(id uuid.UUID) tablechangealertOption {
	return func(m *TableChangeAlertMutation) {
		var (
			err   error
			once  sync.Once
			value *TableChangeAlert
		)
		m.oldValue = func(ctx context.Context) (*TableChangeAlert, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TableChangeAlert.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTableChangeAlert sets the old TableChangeAlert of the mutation.
func withTableChangeAlert(node *TableChangeAlert) tablechangealertOption {
	return func(m *TableChangeAlertMutation) {
		m.oldValue = func(context.Context) (*TableChangeAlert, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TableChangeAlertMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TableChangeAlertMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TableChangeAlert entities.
func (m *TableChangeAlertMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TableChangeAlertMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TableChangeAlertMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TableChangeAlert.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *TableChangeAlertMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *TableChangeAlertMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *TableChangeAlertMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *TableChangeAlertMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *TableChangeAlertMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *TableChangeAlertMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TableChangeAlertMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TableChangeAlertMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TableChangeAlertMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TableChangeAlertMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TableChangeAlertMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TableChangeAlertMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *TableChangeAlertMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *TableChangeAlertMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *TableChangeAlertMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *TableChangeAlertMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *TableChangeAlertMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetStatus sets the "status" field.
func (m *TableChangeAlertMutation) SetStatus(t tablechangealert.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *TableChangeAlertMutation) Status() (r tablechangealert.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldStatus(ctx context.Context) (v tablechangealert.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TableChangeAlertMutation) ResetStatus() {
	m.status = nil
}

// SetName sets the "name" field.
func (m *TableChangeAlertMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TableChangeAlertMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TableChangeAlertMutation) ResetName() {
	m.name = nil
}

// SetDatabaseAction sets the "database_action" field.
func (m *TableChangeAlertMutation) SetDatabaseAction(ta tablechangealert.DatabaseAction) {
	m.database_action = &ta
}

// DatabaseAction returns the value of the "database_action" field in the mutation.
func (m *TableChangeAlertMutation) DatabaseAction() (r tablechangealert.DatabaseAction, exists bool) {
	v := m.database_action
	if v == nil {
		return
	}
	return *v, true
}

// OldDatabaseAction returns the old "database_action" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldDatabaseAction(ctx context.Context) (v tablechangealert.DatabaseAction, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDatabaseAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDatabaseAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDatabaseAction: %w", err)
	}
	return oldValue.DatabaseAction, nil
}

// ResetDatabaseAction resets all changes to the "database_action" field.
func (m *TableChangeAlertMutation) ResetDatabaseAction() {
	m.database_action = nil
}

// SetSource sets the "source" field.
func (m *TableChangeAlertMutation) SetSource(t tablechangealert.Source) {
	m.source = &t
}

// Source returns the value of the "source" field in the mutation.
func (m *TableChangeAlertMutation) Source() (r tablechangealert.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldSource(ctx context.Context) (v tablechangealert.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *TableChangeAlertMutation) ResetSource() {
	m.source = nil
}

// SetTableName sets the "table_name" field.
func (m *TableChangeAlertMutation) SetTableName(s string) {
	m.table_name = &s
}

// TableName returns the value of the "table_name" field in the mutation.
func (m *TableChangeAlertMutation) TableName() (r string, exists bool) {
	v := m.table_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTableName returns the old "table_name" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldTableName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTableName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTableName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTableName: %w", err)
	}
	return oldValue.TableName, nil
}

// ClearTableName clears the value of the "table_name" field.
func (m *TableChangeAlertMutation) ClearTableName() {
	m.table_name = nil
	m.clearedFields[tablechangealert.FieldTableName] = struct{}{}
}

// TableNameCleared returns if the "table_name" field was cleared in this mutation.
func (m *TableChangeAlertMutation) TableNameCleared() bool {
	_, ok := m.clearedFields[tablechangealert.FieldTableName]
	return ok
}

// ResetTableName resets all changes to the "table_name" field.
func (m *TableChangeAlertMutation) ResetTableName() {
	m.table_name = nil
	delete(m.clearedFields, tablechangealert.FieldTableName)
}

// SetTopicName sets the "topic_name" field.
func (m *TableChangeAlertMutation) SetTopicName(s string) {
	m.topic_name = &s
}

// TopicName returns the value of the "topic_name" field in the mutation.
func (m *TableChangeAlertMutation) TopicName() (r string, exists bool) {
	v := m.topic_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTopicName returns the old "topic_name" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldTopicName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopicName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopicName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopicName: %w", err)
	}
	return oldValue.TopicName, nil
}

// ClearTopicName clears the value of the "topic_name" field.
func (m *TableChangeAlertMutation) ClearTopicName() {
	m.topic_name = nil
	m.clearedFields[tablechangealert.FieldTopicName] = struct{}{}
}

// TopicNameCleared returns if the "topic_name" field was cleared in this mutation.
func (m *TableChangeAlertMutation) TopicNameCleared() bool {
	_, ok := m.clearedFields[tablechangealert.FieldTopicName]
	return ok
}

// ResetTopicName resets all changes to the "topic_name" field.
func (m *TableChangeAlertMutation) ResetTopicName() {
	m.topic_name = nil
	delete(m.clearedFields, tablechangealert.FieldTopicName)
}

// SetDescription sets the "description" field.
func (m *TableChangeAlertMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TableChangeAlertMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TableChangeAlertMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[tablechangealert.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TableChangeAlertMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[tablechangealert.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TableChangeAlertMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, tablechangealert.FieldDescription)
}

// SetCustomSubject sets the "custom_subject" field.
func (m *TableChangeAlertMutation) SetCustomSubject(s string) {
	m.custom_subject = &s
}

// CustomSubject returns the value of the "custom_subject" field in the mutation.
func (m *TableChangeAlertMutation) CustomSubject() (r string, exists bool) {
	v := m.custom_subject
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomSubject returns the old "custom_subject" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldCustomSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomSubject: %w", err)
	}
	return oldValue.CustomSubject, nil
}

// ClearCustomSubject clears the value of the "custom_subject" field.
func (m *TableChangeAlertMutation) ClearCustomSubject() {
	m.custom_subject = nil
	m.clearedFields[tablechangealert.FieldCustomSubject] = struct{}{}
}

// CustomSubjectCleared returns if the "custom_subject" field was cleared in this mutation.
func (m *TableChangeAlertMutation) CustomSubjectCleared() bool {
	_, ok := m.clearedFields[tablechangealert.FieldCustomSubject]
	return ok
}

// ResetCustomSubject resets all changes to the "custom_subject" field.
func (m *TableChangeAlertMutation) ResetCustomSubject() {
	m.custom_subject = nil
	delete(m.clearedFields, tablechangealert.FieldCustomSubject)
}

// SetFunctionName sets the "function_name" field.
func (m *TableChangeAlertMutation) SetFunctionName(s string) {
	m.function_name = &s
}

// FunctionName returns the value of the "function_name" field in the mutation.
func (m *TableChangeAlertMutation) FunctionName() (r string, exists bool) {
	v := m.function_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFunctionName returns the old "function_name" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldFunctionName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFunctionName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFunctionName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFunctionName: %w", err)
	}
	return oldValue.FunctionName, nil
}

// ClearFunctionName clears the value of the "function_name" field.
func (m *TableChangeAlertMutation) ClearFunctionName() {
	m.function_name = nil
	m.clearedFields[tablechangealert.FieldFunctionName] = struct{}{}
}

// FunctionNameCleared returns if the "function_name" field was cleared in this mutation.
func (m *TableChangeAlertMutation) FunctionNameCleared() bool {
	_, ok := m.clearedFields[tablechangealert.FieldFunctionName]
	return ok
}

// ResetFunctionName resets all changes to the "function_name" field.
func (m *TableChangeAlertMutation) ResetFunctionName() {
	m.function_name = nil
	delete(m.clearedFields, tablechangealert.FieldFunctionName)
}

// SetTriggerName sets the "trigger_name" field.
func (m *TableChangeAlertMutation) SetTriggerName(s string) {
	m.trigger_name = &s
}

// TriggerName returns the value of the "trigger_name" field in the mutation.
func (m *TableChangeAlertMutation) TriggerName() (r string, exists bool) {
	v := m.trigger_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTriggerName returns the old "trigger_name" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldTriggerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTriggerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTriggerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTriggerName: %w", err)
	}
	return oldValue.TriggerName, nil
}

// ClearTriggerName clears the value of the "trigger_name" field.
func (m *TableChangeAlertMutation) ClearTriggerName() {
	m.trigger_name = nil
	m.clearedFields[tablechangealert.FieldTriggerName] = struct{}{}
}

// TriggerNameCleared returns if the "trigger_name" field was cleared in this mutation.
func (m *TableChangeAlertMutation) TriggerNameCleared() bool {
	_, ok := m.clearedFields[tablechangealert.FieldTriggerName]
	return ok
}

// ResetTriggerName resets all changes to the "trigger_name" field.
func (m *TableChangeAlertMutation) ResetTriggerName() {
	m.trigger_name = nil
	delete(m.clearedFields, tablechangealert.FieldTriggerName)
}

// SetListenerName sets the "listener_name" field.
func (m *TableChangeAlertMutation) SetListenerName(s string) {
	m.listener_name = &s
}

// ListenerName returns the value of the "listener_name" field in the mutation.
func (m *TableChangeAlertMutation) ListenerName() (r string, exists bool) {
	v := m.listener_name
	if v == nil {
		return
	}
	return *v, true
}

// OldListenerName returns the old "listener_name" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldListenerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldListenerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldListenerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldListenerName: %w", err)
	}
	return oldValue.ListenerName, nil
}

// ClearListenerName clears the value of the "listener_name" field.
func (m *TableChangeAlertMutation) ClearListenerName() {
	m.listener_name = nil
	m.clearedFields[tablechangealert.FieldListenerName] = struct{}{}
}

// ListenerNameCleared returns if the "listener_name" field was cleared in this mutation.
func (m *TableChangeAlertMutation) ListenerNameCleared() bool {
	_, ok := m.clearedFields[tablechangealert.FieldListenerName]
	return ok
}

// ResetListenerName resets all changes to the "listener_name" field.
func (m *TableChangeAlertMutation) ResetListenerName() {
	m.listener_name = nil
	delete(m.clearedFields, tablechangealert.FieldListenerName)
}

// SetEmailRecipients sets the "email_recipients" field.
func (m *TableChangeAlertMutation) SetEmailRecipients(s string) {
	m.email_recipients = &s
}

// EmailRecipients returns the value of the "email_recipients" field in the mutation.
func (m *TableChangeAlertMutation) EmailRecipients() (r string, exists bool) {
	v := m.email_recipients
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailRecipients returns the old "email_recipients" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldEmailRecipients(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailRecipients is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailRecipients requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailRecipients: %w", err)
	}
	return oldValue.EmailRecipients, nil
}

// ClearEmailRecipients clears the value of the "email_recipients" field.
func (m *TableChangeAlertMutation) ClearEmailRecipients() {
	m.email_recipients = nil
	m.clearedFields[tablechangealert.FieldEmailRecipients] = struct{}{}
}

// EmailRecipientsCleared returns if the "email_recipients" field was cleared in this mutation.
func (m *TableChangeAlertMutation) EmailRecipientsCleared() bool {
	_, ok := m.clearedFields[tablechangealert.FieldEmailRecipients]
	return ok
}

// ResetEmailRecipients resets all changes to the "email_recipients" field.
func (m *TableChangeAlertMutation) ResetEmailRecipients() {
	m.email_recipients = nil
	delete(m.clearedFields, tablechangealert.FieldEmailRecipients)
}

// SetEffectiveDate sets the "effective_date" field.
func (m *TableChangeAlertMutation) SetEffectiveDate(pg *pgtype.Date) {
	m.effective_date = &pg
}

// EffectiveDate returns the value of the "effective_date" field in the mutation.
func (m *TableChangeAlertMutation) EffectiveDate() (r *pgtype.Date, exists bool) {
	v := m.effective_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectiveDate returns the old "effective_date" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldEffectiveDate(ctx context.Context) (v *pgtype.Date, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectiveDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectiveDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectiveDate: %w", err)
	}
	return oldValue.EffectiveDate, nil
}

// ClearEffectiveDate clears the value of the "effective_date" field.
func (m *TableChangeAlertMutation) ClearEffectiveDate() {
	m.effective_date = nil
	m.clearedFields[tablechangealert.FieldEffectiveDate] = struct{}{}
}

// EffectiveDateCleared returns if the "effective_date" field was cleared in this mutation.
func (m *TableChangeAlertMutation) EffectiveDateCleared() bool {
	_, ok := m.clearedFields[tablechangealert.FieldEffectiveDate]
	return ok
}

// ResetEffectiveDate resets all changes to the "effective_date" field.
func (m *TableChangeAlertMutation) ResetEffectiveDate() {
	m.effective_date = nil
	delete(m.clearedFields, tablechangealert.FieldEffectiveDate)
}

// SetExpirationDate sets the "expiration_date" field.
func (m *TableChangeAlertMutation) SetExpirationDate(pg *pgtype.Date) {
	m.expiration_date = &pg
}

// ExpirationDate returns the value of the "expiration_date" field in the mutation.
func (m *TableChangeAlertMutation) ExpirationDate() (r *pgtype.Date, exists bool) {
	v := m.expiration_date
	if v == nil {
		return
	}
	return *v, true
}

// OldExpirationDate returns the old "expiration_date" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldExpirationDate(ctx context.Context) (v *pgtype.Date, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpirationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpirationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpirationDate: %w", err)
	}
	return oldValue.ExpirationDate, nil
}

// ClearExpirationDate clears the value of the "expiration_date" field.
func (m *TableChangeAlertMutation) ClearExpirationDate() {
	m.expiration_date = nil
	m.clearedFields[tablechangealert.FieldExpirationDate] = struct{}{}
}

// ExpirationDateCleared returns if the "expiration_date" field was cleared in this mutation.
func (m *TableChangeAlertMutation) ExpirationDateCleared() bool {
	_, ok := m.clearedFields[tablechangealert.FieldExpirationDate]
	return ok
}

// ResetExpirationDate resets all changes to the "expiration_date" field.
func (m *TableChangeAlertMutation) ResetExpirationDate() {
	m.expiration_date = nil
	delete(m.clearedFields, tablechangealert.FieldExpirationDate)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *TableChangeAlertMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[tablechangealert.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *TableChangeAlertMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *TableChangeAlertMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *TableChangeAlertMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *TableChangeAlertMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[tablechangealert.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *TableChangeAlertMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *TableChangeAlertMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *TableChangeAlertMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the TableChangeAlertMutation builder.
func (m *TableChangeAlertMutation) Where(ps ...predicate.TableChangeAlert) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TableChangeAlertMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TableChangeAlertMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TableChangeAlert, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TableChangeAlertMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TableChangeAlertMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TableChangeAlert).
func (m *TableChangeAlertMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TableChangeAlertMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.business_unit != nil {
		fields = append(fields, tablechangealert.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, tablechangealert.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, tablechangealert.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tablechangealert.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, tablechangealert.FieldVersion)
	}
	if m.status != nil {
		fields = append(fields, tablechangealert.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, tablechangealert.FieldName)
	}
	if m.database_action != nil {
		fields = append(fields, tablechangealert.FieldDatabaseAction)
	}
	if m.source != nil {
		fields = append(fields, tablechangealert.FieldSource)
	}
	if m.table_name != nil {
		fields = append(fields, tablechangealert.FieldTableName)
	}
	if m.topic_name != nil {
		fields = append(fields, tablechangealert.FieldTopicName)
	}
	if m.description != nil {
		fields = append(fields, tablechangealert.FieldDescription)
	}
	if m.custom_subject != nil {
		fields = append(fields, tablechangealert.FieldCustomSubject)
	}
	if m.function_name != nil {
		fields = append(fields, tablechangealert.FieldFunctionName)
	}
	if m.trigger_name != nil {
		fields = append(fields, tablechangealert.FieldTriggerName)
	}
	if m.listener_name != nil {
		fields = append(fields, tablechangealert.FieldListenerName)
	}
	if m.email_recipients != nil {
		fields = append(fields, tablechangealert.FieldEmailRecipients)
	}
	if m.effective_date != nil {
		fields = append(fields, tablechangealert.FieldEffectiveDate)
	}
	if m.expiration_date != nil {
		fields = append(fields, tablechangealert.FieldExpirationDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TableChangeAlertMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tablechangealert.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case tablechangealert.FieldOrganizationID:
		return m.OrganizationID()
	case tablechangealert.FieldCreatedAt:
		return m.CreatedAt()
	case tablechangealert.FieldUpdatedAt:
		return m.UpdatedAt()
	case tablechangealert.FieldVersion:
		return m.Version()
	case tablechangealert.FieldStatus:
		return m.Status()
	case tablechangealert.FieldName:
		return m.Name()
	case tablechangealert.FieldDatabaseAction:
		return m.DatabaseAction()
	case tablechangealert.FieldSource:
		return m.Source()
	case tablechangealert.FieldTableName:
		return m.TableName()
	case tablechangealert.FieldTopicName:
		return m.TopicName()
	case tablechangealert.FieldDescription:
		return m.Description()
	case tablechangealert.FieldCustomSubject:
		return m.CustomSubject()
	case tablechangealert.FieldFunctionName:
		return m.FunctionName()
	case tablechangealert.FieldTriggerName:
		return m.TriggerName()
	case tablechangealert.FieldListenerName:
		return m.ListenerName()
	case tablechangealert.FieldEmailRecipients:
		return m.EmailRecipients()
	case tablechangealert.FieldEffectiveDate:
		return m.EffectiveDate()
	case tablechangealert.FieldExpirationDate:
		return m.ExpirationDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TableChangeAlertMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tablechangealert.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case tablechangealert.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case tablechangealert.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tablechangealert.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tablechangealert.FieldVersion:
		return m.OldVersion(ctx)
	case tablechangealert.FieldStatus:
		return m.OldStatus(ctx)
	case tablechangealert.FieldName:
		return m.OldName(ctx)
	case tablechangealert.FieldDatabaseAction:
		return m.OldDatabaseAction(ctx)
	case tablechangealert.FieldSource:
		return m.OldSource(ctx)
	case tablechangealert.FieldTableName:
		return m.OldTableName(ctx)
	case tablechangealert.FieldTopicName:
		return m.OldTopicName(ctx)
	case tablechangealert.FieldDescription:
		return m.OldDescription(ctx)
	case tablechangealert.FieldCustomSubject:
		return m.OldCustomSubject(ctx)
	case tablechangealert.FieldFunctionName:
		return m.OldFunctionName(ctx)
	case tablechangealert.FieldTriggerName:
		return m.OldTriggerName(ctx)
	case tablechangealert.FieldListenerName:
		return m.OldListenerName(ctx)
	case tablechangealert.FieldEmailRecipients:
		return m.OldEmailRecipients(ctx)
	case tablechangealert.FieldEffectiveDate:
		return m.OldEffectiveDate(ctx)
	case tablechangealert.FieldExpirationDate:
		return m.OldExpirationDate(ctx)
	}
	return nil, fmt.Errorf("unknown TableChangeAlert field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TableChangeAlertMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tablechangealert.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case tablechangealert.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case tablechangealert.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tablechangealert.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tablechangealert.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case tablechangealert.FieldStatus:
		v, ok := value.(tablechangealert.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case tablechangealert.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tablechangealert.FieldDatabaseAction:
		v, ok := value.(tablechangealert.DatabaseAction)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDatabaseAction(v)
		return nil
	case tablechangealert.FieldSource:
		v, ok := value.(tablechangealert.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case tablechangealert.FieldTableName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTableName(v)
		return nil
	case tablechangealert.FieldTopicName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopicName(v)
		return nil
	case tablechangealert.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case tablechangealert.FieldCustomSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomSubject(v)
		return nil
	case tablechangealert.FieldFunctionName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFunctionName(v)
		return nil
	case tablechangealert.FieldTriggerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTriggerName(v)
		return nil
	case tablechangealert.FieldListenerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetListenerName(v)
		return nil
	case tablechangealert.FieldEmailRecipients:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailRecipients(v)
		return nil
	case tablechangealert.FieldEffectiveDate:
		v, ok := value.(*pgtype.Date)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectiveDate(v)
		return nil
	case tablechangealert.FieldExpirationDate:
		v, ok := value.(*pgtype.Date)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpirationDate(v)
		return nil
	}
	return fmt.Errorf("unknown TableChangeAlert field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TableChangeAlertMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, tablechangealert.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TableChangeAlertMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tablechangealert.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TableChangeAlertMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tablechangealert.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown TableChangeAlert numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TableChangeAlertMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tablechangealert.FieldTableName) {
		fields = append(fields, tablechangealert.FieldTableName)
	}
	if m.FieldCleared(tablechangealert.FieldTopicName) {
		fields = append(fields, tablechangealert.FieldTopicName)
	}
	if m.FieldCleared(tablechangealert.FieldDescription) {
		fields = append(fields, tablechangealert.FieldDescription)
	}
	if m.FieldCleared(tablechangealert.FieldCustomSubject) {
		fields = append(fields, tablechangealert.FieldCustomSubject)
	}
	if m.FieldCleared(tablechangealert.FieldFunctionName) {
		fields = append(fields, tablechangealert.FieldFunctionName)
	}
	if m.FieldCleared(tablechangealert.FieldTriggerName) {
		fields = append(fields, tablechangealert.FieldTriggerName)
	}
	if m.FieldCleared(tablechangealert.FieldListenerName) {
		fields = append(fields, tablechangealert.FieldListenerName)
	}
	if m.FieldCleared(tablechangealert.FieldEmailRecipients) {
		fields = append(fields, tablechangealert.FieldEmailRecipients)
	}
	if m.FieldCleared(tablechangealert.FieldEffectiveDate) {
		fields = append(fields, tablechangealert.FieldEffectiveDate)
	}
	if m.FieldCleared(tablechangealert.FieldExpirationDate) {
		fields = append(fields, tablechangealert.FieldExpirationDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TableChangeAlertMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TableChangeAlertMutation) ClearField(name string) error {
	switch name {
	case tablechangealert.FieldTableName:
		m.ClearTableName()
		return nil
	case tablechangealert.FieldTopicName:
		m.ClearTopicName()
		return nil
	case tablechangealert.FieldDescription:
		m.ClearDescription()
		return nil
	case tablechangealert.FieldCustomSubject:
		m.ClearCustomSubject()
		return nil
	case tablechangealert.FieldFunctionName:
		m.ClearFunctionName()
		return nil
	case tablechangealert.FieldTriggerName:
		m.ClearTriggerName()
		return nil
	case tablechangealert.FieldListenerName:
		m.ClearListenerName()
		return nil
	case tablechangealert.FieldEmailRecipients:
		m.ClearEmailRecipients()
		return nil
	case tablechangealert.FieldEffectiveDate:
		m.ClearEffectiveDate()
		return nil
	case tablechangealert.FieldExpirationDate:
		m.ClearExpirationDate()
		return nil
	}
	return fmt.Errorf("unknown TableChangeAlert nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TableChangeAlertMutation) ResetField(name string) error {
	switch name {
	case tablechangealert.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case tablechangealert.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case tablechangealert.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tablechangealert.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tablechangealert.FieldVersion:
		m.ResetVersion()
		return nil
	case tablechangealert.FieldStatus:
		m.ResetStatus()
		return nil
	case tablechangealert.FieldName:
		m.ResetName()
		return nil
	case tablechangealert.FieldDatabaseAction:
		m.ResetDatabaseAction()
		return nil
	case tablechangealert.FieldSource:
		m.ResetSource()
		return nil
	case tablechangealert.FieldTableName:
		m.ResetTableName()
		return nil
	case tablechangealert.FieldTopicName:
		m.ResetTopicName()
		return nil
	case tablechangealert.FieldDescription:
		m.ResetDescription()
		return nil
	case tablechangealert.FieldCustomSubject:
		m.ResetCustomSubject()
		return nil
	case tablechangealert.FieldFunctionName:
		m.ResetFunctionName()
		return nil
	case tablechangealert.FieldTriggerName:
		m.ResetTriggerName()
		return nil
	case tablechangealert.FieldListenerName:
		m.ResetListenerName()
		return nil
	case tablechangealert.FieldEmailRecipients:
		m.ResetEmailRecipients()
		return nil
	case tablechangealert.FieldEffectiveDate:
		m.ResetEffectiveDate()
		return nil
	case tablechangealert.FieldExpirationDate:
		m.ResetExpirationDate()
		return nil
	}
	return fmt.Errorf("unknown TableChangeAlert field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TableChangeAlertMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.business_unit != nil {
		edges = append(edges, tablechangealert.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, tablechangealert.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TableChangeAlertMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tablechangealert.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case tablechangealert.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TableChangeAlertMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TableChangeAlertMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TableChangeAlertMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbusiness_unit {
		edges = append(edges, tablechangealert.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, tablechangealert.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TableChangeAlertMutation) EdgeCleared(name string) bool {
	switch name {
	case tablechangealert.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case tablechangealert.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TableChangeAlertMutation) ClearEdge(name string) error {
	switch name {
	case tablechangealert.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case tablechangealert.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown TableChangeAlert unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TableChangeAlertMutation) ResetEdge(name string) error {
	switch name {
	case tablechangealert.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case tablechangealert.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown TableChangeAlert edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op                            Op
	typ                           string
	id                            *uuid.UUID
	created_at                    *time.Time
	updated_at                    *time.Time
	version                       *int
	addversion                    *int
	name                          *string
	description                   *string
	color                         *string
	clearedFields                 map[string]struct{}
	business_unit                 *uuid.UUID
	clearedbusiness_unit          bool
	organization                  *uuid.UUID
	clearedorganization           bool
	general_ledger_account        map[uuid.UUID]struct{}
	removedgeneral_ledger_account map[uuid.UUID]struct{}
	clearedgeneral_ledger_account bool
	done                          bool
	oldValue                      func(context.Context) (*Tag, error)
	predicates                    []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id uuid.UUID) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tag entities.
func (m *TagMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *TagMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *TagMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *TagMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *TagMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *TagMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *TagMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TagMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *TagMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *TagMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *TagMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *TagMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *TagMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetName sets the "name" field.
func (m *TagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TagMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *TagMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TagMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TagMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[tag.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TagMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[tag.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TagMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, tag.FieldDescription)
}

// SetColor sets the "color" field.
func (m *TagMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *TagMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *TagMutation) ClearColor() {
	m.color = nil
	m.clearedFields[tag.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *TagMutation) ColorCleared() bool {
	_, ok := m.clearedFields[tag.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *TagMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, tag.FieldColor)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *TagMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[tag.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *TagMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *TagMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *TagMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *TagMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[tag.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *TagMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *TagMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *TagMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// AddGeneralLedgerAccountIDs adds the "general_ledger_account" edge to the GeneralLedgerAccount entity by ids.
func (m *TagMutation) AddGeneralLedgerAccountIDs(ids ...uuid.UUID) {
	if m.general_ledger_account == nil {
		m.general_ledger_account = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.general_ledger_account[ids[i]] = struct{}{}
	}
}

// ClearGeneralLedgerAccount clears the "general_ledger_account" edge to the GeneralLedgerAccount entity.
func (m *TagMutation) ClearGeneralLedgerAccount() {
	m.clearedgeneral_ledger_account = true
}

// GeneralLedgerAccountCleared reports if the "general_ledger_account" edge to the GeneralLedgerAccount entity was cleared.
func (m *TagMutation) GeneralLedgerAccountCleared() bool {
	return m.clearedgeneral_ledger_account
}

// RemoveGeneralLedgerAccountIDs removes the "general_ledger_account" edge to the GeneralLedgerAccount entity by IDs.
func (m *TagMutation) RemoveGeneralLedgerAccountIDs(ids ...uuid.UUID) {
	if m.removedgeneral_ledger_account == nil {
		m.removedgeneral_ledger_account = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.general_ledger_account, ids[i])
		m.removedgeneral_ledger_account[ids[i]] = struct{}{}
	}
}

// RemovedGeneralLedgerAccount returns the removed IDs of the "general_ledger_account" edge to the GeneralLedgerAccount entity.
func (m *TagMutation) RemovedGeneralLedgerAccountIDs() (ids []uuid.UUID) {
	for id := range m.removedgeneral_ledger_account {
		ids = append(ids, id)
	}
	return
}

// GeneralLedgerAccountIDs returns the "general_ledger_account" edge IDs in the mutation.
func (m *TagMutation) GeneralLedgerAccountIDs() (ids []uuid.UUID) {
	for id := range m.general_ledger_account {
		ids = append(ids, id)
	}
	return
}

// ResetGeneralLedgerAccount resets all changes to the "general_ledger_account" edge.
func (m *TagMutation) ResetGeneralLedgerAccount() {
	m.general_ledger_account = nil
	m.clearedgeneral_ledger_account = false
	m.removedgeneral_ledger_account = nil
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.business_unit != nil {
		fields = append(fields, tag.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, tag.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, tag.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tag.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, tag.FieldVersion)
	}
	if m.name != nil {
		fields = append(fields, tag.FieldName)
	}
	if m.description != nil {
		fields = append(fields, tag.FieldDescription)
	}
	if m.color != nil {
		fields = append(fields, tag.FieldColor)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case tag.FieldOrganizationID:
		return m.OrganizationID()
	case tag.FieldCreatedAt:
		return m.CreatedAt()
	case tag.FieldUpdatedAt:
		return m.UpdatedAt()
	case tag.FieldVersion:
		return m.Version()
	case tag.FieldName:
		return m.Name()
	case tag.FieldDescription:
		return m.Description()
	case tag.FieldColor:
		return m.Color()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case tag.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case tag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tag.FieldVersion:
		return m.OldVersion(ctx)
	case tag.FieldName:
		return m.OldName(ctx)
	case tag.FieldDescription:
		return m.OldDescription(ctx)
	case tag.FieldColor:
		return m.OldColor(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case tag.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case tag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tag.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case tag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tag.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case tag.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, tag.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tag.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tag.FieldDescription) {
		fields = append(fields, tag.FieldDescription)
	}
	if m.FieldCleared(tag.FieldColor) {
		fields = append(fields, tag.FieldColor)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	switch name {
	case tag.FieldDescription:
		m.ClearDescription()
		return nil
	case tag.FieldColor:
		m.ClearColor()
		return nil
	}
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case tag.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case tag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tag.FieldVersion:
		m.ResetVersion()
		return nil
	case tag.FieldName:
		m.ResetName()
		return nil
	case tag.FieldDescription:
		m.ResetDescription()
		return nil
	case tag.FieldColor:
		m.ResetColor()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.business_unit != nil {
		edges = append(edges, tag.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, tag.EdgeOrganization)
	}
	if m.general_ledger_account != nil {
		edges = append(edges, tag.EdgeGeneralLedgerAccount)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case tag.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case tag.EdgeGeneralLedgerAccount:
		ids := make([]ent.Value, 0, len(m.general_ledger_account))
		for id := range m.general_ledger_account {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedgeneral_ledger_account != nil {
		edges = append(edges, tag.EdgeGeneralLedgerAccount)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeGeneralLedgerAccount:
		ids := make([]ent.Value, 0, len(m.removedgeneral_ledger_account))
		for id := range m.removedgeneral_ledger_account {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbusiness_unit {
		edges = append(edges, tag.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, tag.EdgeOrganization)
	}
	if m.clearedgeneral_ledger_account {
		edges = append(edges, tag.EdgeGeneralLedgerAccount)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	switch name {
	case tag.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case tag.EdgeOrganization:
		return m.clearedorganization
	case tag.EdgeGeneralLedgerAccount:
		return m.clearedgeneral_ledger_account
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	switch name {
	case tag.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case tag.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	switch name {
	case tag.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case tag.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case tag.EdgeGeneralLedgerAccount:
		m.ResetGeneralLedgerAccount()
		return nil
	}
	return fmt.Errorf("unknown Tag edge %s", name)
}

// TractorMutation represents an operation that mutates the Tractor nodes in the graph.
type TractorMutation struct {
	config
	op                            Op
	typ                           string
	id                            *uuid.UUID
	created_at                    *time.Time
	updated_at                    *time.Time
	version                       *int
	addversion                    *int
	code                          *string
	status                        *tractor.Status
	license_plate_number          *string
	vin                           *string
	model                         *string
	year                          *int16
	addyear                       *int16
	leased                        *bool
	leased_date                   **pgtype.Date
	clearedFields                 map[string]struct{}
	business_unit                 *uuid.UUID
	clearedbusiness_unit          bool
	organization                  *uuid.UUID
	clearedorganization           bool
	equipment_type                *uuid.UUID
	clearedequipment_type         bool
	equipment_manufacturer        *uuid.UUID
	clearedequipment_manufacturer bool
	state                         *uuid.UUID
	clearedstate                  bool
	primary_worker                *uuid.UUID
	clearedprimary_worker         bool
	secondary_worker              *uuid.UUID
	clearedsecondary_worker       bool
	fleet_code                    *uuid.UUID
	clearedfleet_code             bool
	done                          bool
	oldValue                      func(context.Context) (*Tractor, error)
	predicates                    []predicate.Tractor
}

var _ ent.Mutation = (*TractorMutation)(nil)

// tractorOption allows management of the mutation configuration using functional options.
type tractorOption func(*TractorMutation)

// newTractorMutation creates new mutation for the Tractor entity.
func newTractorMutation(c config, op Op, opts ...tractorOption) *TractorMutation {
	m := &TractorMutation{
		config:        c,
		op:            op,
		typ:           TypeTractor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTractorID sets the ID field of the mutation.
func withTractorID(id uuid.UUID) tractorOption {
	return func(m *TractorMutation) {
		var (
			err   error
			once  sync.Once
			value *Tractor
		)
		m.oldValue = func(ctx context.Context) (*Tractor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tractor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTractor sets the old Tractor of the mutation.
func withTractor(node *Tractor) tractorOption {
	return func(m *TractorMutation) {
		m.oldValue = func(context.Context) (*Tractor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TractorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TractorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tractor entities.
func (m *TractorMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TractorMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TractorMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tractor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *TractorMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *TractorMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the Tractor entity.
// If the Tractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TractorMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *TractorMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *TractorMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *TractorMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Tractor entity.
// If the Tractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TractorMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *TractorMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TractorMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TractorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tractor entity.
// If the Tractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TractorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TractorMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TractorMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TractorMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Tractor entity.
// If the Tractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TractorMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TractorMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *TractorMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *TractorMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Tractor entity.
// If the Tractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TractorMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *TractorMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *TractorMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *TractorMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetCode sets the "code" field.
func (m *TractorMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *TractorMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Tractor entity.
// If the Tractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TractorMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *TractorMutation) ResetCode() {
	m.code = nil
}

// SetStatus sets the "status" field.
func (m *TractorMutation) SetStatus(t tractor.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *TractorMutation) Status() (r tractor.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Tractor entity.
// If the Tractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TractorMutation) OldStatus(ctx context.Context) (v tractor.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TractorMutation) ResetStatus() {
	m.status = nil
}

// SetEquipmentTypeID sets the "equipment_type_id" field.
func (m *TractorMutation) SetEquipmentTypeID(u uuid.UUID) {
	m.equipment_type = &u
}

// EquipmentTypeID returns the value of the "equipment_type_id" field in the mutation.
func (m *TractorMutation) EquipmentTypeID() (r uuid.UUID, exists bool) {
	v := m.equipment_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEquipmentTypeID returns the old "equipment_type_id" field's value of the Tractor entity.
// If the Tractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TractorMutation) OldEquipmentTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEquipmentTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEquipmentTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEquipmentTypeID: %w", err)
	}
	return oldValue.EquipmentTypeID, nil
}

// ClearEquipmentTypeID clears the value of the "equipment_type_id" field.
func (m *TractorMutation) ClearEquipmentTypeID() {
	m.equipment_type = nil
	m.clearedFields[tractor.FieldEquipmentTypeID] = struct{}{}
}

// EquipmentTypeIDCleared returns if the "equipment_type_id" field was cleared in this mutation.
func (m *TractorMutation) EquipmentTypeIDCleared() bool {
	_, ok := m.clearedFields[tractor.FieldEquipmentTypeID]
	return ok
}

// ResetEquipmentTypeID resets all changes to the "equipment_type_id" field.
func (m *TractorMutation) ResetEquipmentTypeID() {
	m.equipment_type = nil
	delete(m.clearedFields, tractor.FieldEquipmentTypeID)
}

// SetLicensePlateNumber sets the "license_plate_number" field.
func (m *TractorMutation) SetLicensePlateNumber(s string) {
	m.license_plate_number = &s
}

// LicensePlateNumber returns the value of the "license_plate_number" field in the mutation.
func (m *TractorMutation) LicensePlateNumber() (r string, exists bool) {
	v := m.license_plate_number
	if v == nil {
		return
	}
	return *v, true
}

// OldLicensePlateNumber returns the old "license_plate_number" field's value of the Tractor entity.
// If the Tractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TractorMutation) OldLicensePlateNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLicensePlateNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLicensePlateNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicensePlateNumber: %w", err)
	}
	return oldValue.LicensePlateNumber, nil
}

// ClearLicensePlateNumber clears the value of the "license_plate_number" field.
func (m *TractorMutation) ClearLicensePlateNumber() {
	m.license_plate_number = nil
	m.clearedFields[tractor.FieldLicensePlateNumber] = struct{}{}
}

// LicensePlateNumberCleared returns if the "license_plate_number" field was cleared in this mutation.
func (m *TractorMutation) LicensePlateNumberCleared() bool {
	_, ok := m.clearedFields[tractor.FieldLicensePlateNumber]
	return ok
}

// ResetLicensePlateNumber resets all changes to the "license_plate_number" field.
func (m *TractorMutation) ResetLicensePlateNumber() {
	m.license_plate_number = nil
	delete(m.clearedFields, tractor.FieldLicensePlateNumber)
}

// SetVin sets the "vin" field.
func (m *TractorMutation) SetVin(s string) {
	m.vin = &s
}

// Vin returns the value of the "vin" field in the mutation.
func (m *TractorMutation) Vin() (r string, exists bool) {
	v := m.vin
	if v == nil {
		return
	}
	return *v, true
}

// OldVin returns the old "vin" field's value of the Tractor entity.
// If the Tractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TractorMutation) OldVin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVin: %w", err)
	}
	return oldValue.Vin, nil
}

// ClearVin clears the value of the "vin" field.
func (m *TractorMutation) ClearVin() {
	m.vin = nil
	m.clearedFields[tractor.FieldVin] = struct{}{}
}

// VinCleared returns if the "vin" field was cleared in this mutation.
func (m *TractorMutation) VinCleared() bool {
	_, ok := m.clearedFields[tractor.FieldVin]
	return ok
}

// ResetVin resets all changes to the "vin" field.
func (m *TractorMutation) ResetVin() {
	m.vin = nil
	delete(m.clearedFields, tractor.FieldVin)
}

// SetEquipmentManufacturerID sets the "equipment_manufacturer_id" field.
func (m *TractorMutation) SetEquipmentManufacturerID(u uuid.UUID) {
	m.equipment_manufacturer = &u
}

// EquipmentManufacturerID returns the value of the "equipment_manufacturer_id" field in the mutation.
func (m *TractorMutation) EquipmentManufacturerID() (r uuid.UUID, exists bool) {
	v := m.equipment_manufacturer
	if v == nil {
		return
	}
	return *v, true
}

// OldEquipmentManufacturerID returns the old "equipment_manufacturer_id" field's value of the Tractor entity.
// If the Tractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TractorMutation) OldEquipmentManufacturerID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEquipmentManufacturerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEquipmentManufacturerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEquipmentManufacturerID: %w", err)
	}
	return oldValue.EquipmentManufacturerID, nil
}

// ClearEquipmentManufacturerID clears the value of the "equipment_manufacturer_id" field.
func (m *TractorMutation) ClearEquipmentManufacturerID() {
	m.equipment_manufacturer = nil
	m.clearedFields[tractor.FieldEquipmentManufacturerID] = struct{}{}
}

// EquipmentManufacturerIDCleared returns if the "equipment_manufacturer_id" field was cleared in this mutation.
func (m *TractorMutation) EquipmentManufacturerIDCleared() bool {
	_, ok := m.clearedFields[tractor.FieldEquipmentManufacturerID]
	return ok
}

// ResetEquipmentManufacturerID resets all changes to the "equipment_manufacturer_id" field.
func (m *TractorMutation) ResetEquipmentManufacturerID() {
	m.equipment_manufacturer = nil
	delete(m.clearedFields, tractor.FieldEquipmentManufacturerID)
}

// SetModel sets the "model" field.
func (m *TractorMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *TractorMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the Tractor entity.
// If the Tractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TractorMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ClearModel clears the value of the "model" field.
func (m *TractorMutation) ClearModel() {
	m.model = nil
	m.clearedFields[tractor.FieldModel] = struct{}{}
}

// ModelCleared returns if the "model" field was cleared in this mutation.
func (m *TractorMutation) ModelCleared() bool {
	_, ok := m.clearedFields[tractor.FieldModel]
	return ok
}

// ResetModel resets all changes to the "model" field.
func (m *TractorMutation) ResetModel() {
	m.model = nil
	delete(m.clearedFields, tractor.FieldModel)
}

// SetYear sets the "year" field.
func (m *TractorMutation) SetYear(i int16) {
	m.year = &i
	m.addyear = nil
}

// Year returns the value of the "year" field in the mutation.
func (m *TractorMutation) Year() (r int16, exists bool) {
	v := m.year
	if v == nil {
		return
	}
	return *v, true
}

// OldYear returns the old "year" field's value of the Tractor entity.
// If the Tractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TractorMutation) OldYear(ctx context.Context) (v *int16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYear: %w", err)
	}
	return oldValue.Year, nil
}

// AddYear adds i to the "year" field.
func (m *TractorMutation) AddYear(i int16) {
	if m.addyear != nil {
		*m.addyear += i
	} else {
		m.addyear = &i
	}
}

// AddedYear returns the value that was added to the "year" field in this mutation.
func (m *TractorMutation) AddedYear() (r int16, exists bool) {
	v := m.addyear
	if v == nil {
		return
	}
	return *v, true
}

// ClearYear clears the value of the "year" field.
func (m *TractorMutation) ClearYear() {
	m.year = nil
	m.addyear = nil
	m.clearedFields[tractor.FieldYear] = struct{}{}
}

// YearCleared returns if the "year" field was cleared in this mutation.
func (m *TractorMutation) YearCleared() bool {
	_, ok := m.clearedFields[tractor.FieldYear]
	return ok
}

// ResetYear resets all changes to the "year" field.
func (m *TractorMutation) ResetYear() {
	m.year = nil
	m.addyear = nil
	delete(m.clearedFields, tractor.FieldYear)
}

// SetStateID sets the "state_id" field.
func (m *TractorMutation) SetStateID(u uuid.UUID) {
	m.state = &u
}

// StateID returns the value of the "state_id" field in the mutation.
func (m *TractorMutation) StateID() (r uuid.UUID, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldStateID returns the old "state_id" field's value of the Tractor entity.
// If the Tractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TractorMutation) OldStateID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStateID: %w", err)
	}
	return oldValue.StateID, nil
}

// ClearStateID clears the value of the "state_id" field.
func (m *TractorMutation) ClearStateID() {
	m.state = nil
	m.clearedFields[tractor.FieldStateID] = struct{}{}
}

// StateIDCleared returns if the "state_id" field was cleared in this mutation.
func (m *TractorMutation) StateIDCleared() bool {
	_, ok := m.clearedFields[tractor.FieldStateID]
	return ok
}

// ResetStateID resets all changes to the "state_id" field.
func (m *TractorMutation) ResetStateID() {
	m.state = nil
	delete(m.clearedFields, tractor.FieldStateID)
}

// SetLeased sets the "leased" field.
func (m *TractorMutation) SetLeased(b bool) {
	m.leased = &b
}

// Leased returns the value of the "leased" field in the mutation.
func (m *TractorMutation) Leased() (r bool, exists bool) {
	v := m.leased
	if v == nil {
		return
	}
	return *v, true
}

// OldLeased returns the old "leased" field's value of the Tractor entity.
// If the Tractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TractorMutation) OldLeased(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeased is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeased requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeased: %w", err)
	}
	return oldValue.Leased, nil
}

// ResetLeased resets all changes to the "leased" field.
func (m *TractorMutation) ResetLeased() {
	m.leased = nil
}

// SetLeasedDate sets the "leased_date" field.
func (m *TractorMutation) SetLeasedDate(pg *pgtype.Date) {
	m.leased_date = &pg
}

// LeasedDate returns the value of the "leased_date" field in the mutation.
func (m *TractorMutation) LeasedDate() (r *pgtype.Date, exists bool) {
	v := m.leased_date
	if v == nil {
		return
	}
	return *v, true
}

// OldLeasedDate returns the old "leased_date" field's value of the Tractor entity.
// If the Tractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TractorMutation) OldLeasedDate(ctx context.Context) (v *pgtype.Date, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeasedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeasedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeasedDate: %w", err)
	}
	return oldValue.LeasedDate, nil
}

// ClearLeasedDate clears the value of the "leased_date" field.
func (m *TractorMutation) ClearLeasedDate() {
	m.leased_date = nil
	m.clearedFields[tractor.FieldLeasedDate] = struct{}{}
}

// LeasedDateCleared returns if the "leased_date" field was cleared in this mutation.
func (m *TractorMutation) LeasedDateCleared() bool {
	_, ok := m.clearedFields[tractor.FieldLeasedDate]
	return ok
}

// ResetLeasedDate resets all changes to the "leased_date" field.
func (m *TractorMutation) ResetLeasedDate() {
	m.leased_date = nil
	delete(m.clearedFields, tractor.FieldLeasedDate)
}

// SetPrimaryWorkerID sets the "primary_worker_id" field.
func (m *TractorMutation) SetPrimaryWorkerID(u uuid.UUID) {
	m.primary_worker = &u
}

// PrimaryWorkerID returns the value of the "primary_worker_id" field in the mutation.
func (m *TractorMutation) PrimaryWorkerID() (r uuid.UUID, exists bool) {
	v := m.primary_worker
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryWorkerID returns the old "primary_worker_id" field's value of the Tractor entity.
// If the Tractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TractorMutation) OldPrimaryWorkerID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryWorkerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryWorkerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryWorkerID: %w", err)
	}
	return oldValue.PrimaryWorkerID, nil
}

// ResetPrimaryWorkerID resets all changes to the "primary_worker_id" field.
func (m *TractorMutation) ResetPrimaryWorkerID() {
	m.primary_worker = nil
}

// SetSecondaryWorkerID sets the "secondary_worker_id" field.
func (m *TractorMutation) SetSecondaryWorkerID(u uuid.UUID) {
	m.secondary_worker = &u
}

// SecondaryWorkerID returns the value of the "secondary_worker_id" field in the mutation.
func (m *TractorMutation) SecondaryWorkerID() (r uuid.UUID, exists bool) {
	v := m.secondary_worker
	if v == nil {
		return
	}
	return *v, true
}

// OldSecondaryWorkerID returns the old "secondary_worker_id" field's value of the Tractor entity.
// If the Tractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TractorMutation) OldSecondaryWorkerID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecondaryWorkerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecondaryWorkerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecondaryWorkerID: %w", err)
	}
	return oldValue.SecondaryWorkerID, nil
}

// ClearSecondaryWorkerID clears the value of the "secondary_worker_id" field.
func (m *TractorMutation) ClearSecondaryWorkerID() {
	m.secondary_worker = nil
	m.clearedFields[tractor.FieldSecondaryWorkerID] = struct{}{}
}

// SecondaryWorkerIDCleared returns if the "secondary_worker_id" field was cleared in this mutation.
func (m *TractorMutation) SecondaryWorkerIDCleared() bool {
	_, ok := m.clearedFields[tractor.FieldSecondaryWorkerID]
	return ok
}

// ResetSecondaryWorkerID resets all changes to the "secondary_worker_id" field.
func (m *TractorMutation) ResetSecondaryWorkerID() {
	m.secondary_worker = nil
	delete(m.clearedFields, tractor.FieldSecondaryWorkerID)
}

// SetFleetCodeID sets the "fleet_code_id" field.
func (m *TractorMutation) SetFleetCodeID(u uuid.UUID) {
	m.fleet_code = &u
}

// FleetCodeID returns the value of the "fleet_code_id" field in the mutation.
func (m *TractorMutation) FleetCodeID() (r uuid.UUID, exists bool) {
	v := m.fleet_code
	if v == nil {
		return
	}
	return *v, true
}

// OldFleetCodeID returns the old "fleet_code_id" field's value of the Tractor entity.
// If the Tractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TractorMutation) OldFleetCodeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFleetCodeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFleetCodeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFleetCodeID: %w", err)
	}
	return oldValue.FleetCodeID, nil
}

// ResetFleetCodeID resets all changes to the "fleet_code_id" field.
func (m *TractorMutation) ResetFleetCodeID() {
	m.fleet_code = nil
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *TractorMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[tractor.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *TractorMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *TractorMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *TractorMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *TractorMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[tractor.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *TractorMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *TractorMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *TractorMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearEquipmentType clears the "equipment_type" edge to the EquipmentType entity.
func (m *TractorMutation) ClearEquipmentType() {
	m.clearedequipment_type = true
	m.clearedFields[tractor.FieldEquipmentTypeID] = struct{}{}
}

// EquipmentTypeCleared reports if the "equipment_type" edge to the EquipmentType entity was cleared.
func (m *TractorMutation) EquipmentTypeCleared() bool {
	return m.EquipmentTypeIDCleared() || m.clearedequipment_type
}

// EquipmentTypeIDs returns the "equipment_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EquipmentTypeID instead. It exists only for internal usage by the builders.
func (m *TractorMutation) EquipmentTypeIDs() (ids []uuid.UUID) {
	if id := m.equipment_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEquipmentType resets all changes to the "equipment_type" edge.
func (m *TractorMutation) ResetEquipmentType() {
	m.equipment_type = nil
	m.clearedequipment_type = false
}

// ClearEquipmentManufacturer clears the "equipment_manufacturer" edge to the EquipmentManufactuer entity.
func (m *TractorMutation) ClearEquipmentManufacturer() {
	m.clearedequipment_manufacturer = true
	m.clearedFields[tractor.FieldEquipmentManufacturerID] = struct{}{}
}

// EquipmentManufacturerCleared reports if the "equipment_manufacturer" edge to the EquipmentManufactuer entity was cleared.
func (m *TractorMutation) EquipmentManufacturerCleared() bool {
	return m.EquipmentManufacturerIDCleared() || m.clearedequipment_manufacturer
}

// EquipmentManufacturerIDs returns the "equipment_manufacturer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EquipmentManufacturerID instead. It exists only for internal usage by the builders.
func (m *TractorMutation) EquipmentManufacturerIDs() (ids []uuid.UUID) {
	if id := m.equipment_manufacturer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEquipmentManufacturer resets all changes to the "equipment_manufacturer" edge.
func (m *TractorMutation) ResetEquipmentManufacturer() {
	m.equipment_manufacturer = nil
	m.clearedequipment_manufacturer = false
}

// ClearState clears the "state" edge to the UsState entity.
func (m *TractorMutation) ClearState() {
	m.clearedstate = true
	m.clearedFields[tractor.FieldStateID] = struct{}{}
}

// StateCleared reports if the "state" edge to the UsState entity was cleared.
func (m *TractorMutation) StateCleared() bool {
	return m.StateIDCleared() || m.clearedstate
}

// StateIDs returns the "state" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StateID instead. It exists only for internal usage by the builders.
func (m *TractorMutation) StateIDs() (ids []uuid.UUID) {
	if id := m.state; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetState resets all changes to the "state" edge.
func (m *TractorMutation) ResetState() {
	m.state = nil
	m.clearedstate = false
}

// ClearPrimaryWorker clears the "primary_worker" edge to the Worker entity.
func (m *TractorMutation) ClearPrimaryWorker() {
	m.clearedprimary_worker = true
	m.clearedFields[tractor.FieldPrimaryWorkerID] = struct{}{}
}

// PrimaryWorkerCleared reports if the "primary_worker" edge to the Worker entity was cleared.
func (m *TractorMutation) PrimaryWorkerCleared() bool {
	return m.clearedprimary_worker
}

// PrimaryWorkerIDs returns the "primary_worker" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PrimaryWorkerID instead. It exists only for internal usage by the builders.
func (m *TractorMutation) PrimaryWorkerIDs() (ids []uuid.UUID) {
	if id := m.primary_worker; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrimaryWorker resets all changes to the "primary_worker" edge.
func (m *TractorMutation) ResetPrimaryWorker() {
	m.primary_worker = nil
	m.clearedprimary_worker = false
}

// ClearSecondaryWorker clears the "secondary_worker" edge to the Worker entity.
func (m *TractorMutation) ClearSecondaryWorker() {
	m.clearedsecondary_worker = true
	m.clearedFields[tractor.FieldSecondaryWorkerID] = struct{}{}
}

// SecondaryWorkerCleared reports if the "secondary_worker" edge to the Worker entity was cleared.
func (m *TractorMutation) SecondaryWorkerCleared() bool {
	return m.SecondaryWorkerIDCleared() || m.clearedsecondary_worker
}

// SecondaryWorkerIDs returns the "secondary_worker" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SecondaryWorkerID instead. It exists only for internal usage by the builders.
func (m *TractorMutation) SecondaryWorkerIDs() (ids []uuid.UUID) {
	if id := m.secondary_worker; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSecondaryWorker resets all changes to the "secondary_worker" edge.
func (m *TractorMutation) ResetSecondaryWorker() {
	m.secondary_worker = nil
	m.clearedsecondary_worker = false
}

// ClearFleetCode clears the "fleet_code" edge to the FleetCode entity.
func (m *TractorMutation) ClearFleetCode() {
	m.clearedfleet_code = true
	m.clearedFields[tractor.FieldFleetCodeID] = struct{}{}
}

// FleetCodeCleared reports if the "fleet_code" edge to the FleetCode entity was cleared.
func (m *TractorMutation) FleetCodeCleared() bool {
	return m.clearedfleet_code
}

// FleetCodeIDs returns the "fleet_code" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FleetCodeID instead. It exists only for internal usage by the builders.
func (m *TractorMutation) FleetCodeIDs() (ids []uuid.UUID) {
	if id := m.fleet_code; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFleetCode resets all changes to the "fleet_code" edge.
func (m *TractorMutation) ResetFleetCode() {
	m.fleet_code = nil
	m.clearedfleet_code = false
}

// Where appends a list predicates to the TractorMutation builder.
func (m *TractorMutation) Where(ps ...predicate.Tractor) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TractorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TractorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tractor, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TractorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TractorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tractor).
func (m *TractorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TractorMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.business_unit != nil {
		fields = append(fields, tractor.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, tractor.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, tractor.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tractor.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, tractor.FieldVersion)
	}
	if m.code != nil {
		fields = append(fields, tractor.FieldCode)
	}
	if m.status != nil {
		fields = append(fields, tractor.FieldStatus)
	}
	if m.equipment_type != nil {
		fields = append(fields, tractor.FieldEquipmentTypeID)
	}
	if m.license_plate_number != nil {
		fields = append(fields, tractor.FieldLicensePlateNumber)
	}
	if m.vin != nil {
		fields = append(fields, tractor.FieldVin)
	}
	if m.equipment_manufacturer != nil {
		fields = append(fields, tractor.FieldEquipmentManufacturerID)
	}
	if m.model != nil {
		fields = append(fields, tractor.FieldModel)
	}
	if m.year != nil {
		fields = append(fields, tractor.FieldYear)
	}
	if m.state != nil {
		fields = append(fields, tractor.FieldStateID)
	}
	if m.leased != nil {
		fields = append(fields, tractor.FieldLeased)
	}
	if m.leased_date != nil {
		fields = append(fields, tractor.FieldLeasedDate)
	}
	if m.primary_worker != nil {
		fields = append(fields, tractor.FieldPrimaryWorkerID)
	}
	if m.secondary_worker != nil {
		fields = append(fields, tractor.FieldSecondaryWorkerID)
	}
	if m.fleet_code != nil {
		fields = append(fields, tractor.FieldFleetCodeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TractorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tractor.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case tractor.FieldOrganizationID:
		return m.OrganizationID()
	case tractor.FieldCreatedAt:
		return m.CreatedAt()
	case tractor.FieldUpdatedAt:
		return m.UpdatedAt()
	case tractor.FieldVersion:
		return m.Version()
	case tractor.FieldCode:
		return m.Code()
	case tractor.FieldStatus:
		return m.Status()
	case tractor.FieldEquipmentTypeID:
		return m.EquipmentTypeID()
	case tractor.FieldLicensePlateNumber:
		return m.LicensePlateNumber()
	case tractor.FieldVin:
		return m.Vin()
	case tractor.FieldEquipmentManufacturerID:
		return m.EquipmentManufacturerID()
	case tractor.FieldModel:
		return m.Model()
	case tractor.FieldYear:
		return m.Year()
	case tractor.FieldStateID:
		return m.StateID()
	case tractor.FieldLeased:
		return m.Leased()
	case tractor.FieldLeasedDate:
		return m.LeasedDate()
	case tractor.FieldPrimaryWorkerID:
		return m.PrimaryWorkerID()
	case tractor.FieldSecondaryWorkerID:
		return m.SecondaryWorkerID()
	case tractor.FieldFleetCodeID:
		return m.FleetCodeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TractorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tractor.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case tractor.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case tractor.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tractor.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tractor.FieldVersion:
		return m.OldVersion(ctx)
	case tractor.FieldCode:
		return m.OldCode(ctx)
	case tractor.FieldStatus:
		return m.OldStatus(ctx)
	case tractor.FieldEquipmentTypeID:
		return m.OldEquipmentTypeID(ctx)
	case tractor.FieldLicensePlateNumber:
		return m.OldLicensePlateNumber(ctx)
	case tractor.FieldVin:
		return m.OldVin(ctx)
	case tractor.FieldEquipmentManufacturerID:
		return m.OldEquipmentManufacturerID(ctx)
	case tractor.FieldModel:
		return m.OldModel(ctx)
	case tractor.FieldYear:
		return m.OldYear(ctx)
	case tractor.FieldStateID:
		return m.OldStateID(ctx)
	case tractor.FieldLeased:
		return m.OldLeased(ctx)
	case tractor.FieldLeasedDate:
		return m.OldLeasedDate(ctx)
	case tractor.FieldPrimaryWorkerID:
		return m.OldPrimaryWorkerID(ctx)
	case tractor.FieldSecondaryWorkerID:
		return m.OldSecondaryWorkerID(ctx)
	case tractor.FieldFleetCodeID:
		return m.OldFleetCodeID(ctx)
	}
	return nil, fmt.Errorf("unknown Tractor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TractorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tractor.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case tractor.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case tractor.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tractor.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tractor.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case tractor.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case tractor.FieldStatus:
		v, ok := value.(tractor.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case tractor.FieldEquipmentTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEquipmentTypeID(v)
		return nil
	case tractor.FieldLicensePlateNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicensePlateNumber(v)
		return nil
	case tractor.FieldVin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVin(v)
		return nil
	case tractor.FieldEquipmentManufacturerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEquipmentManufacturerID(v)
		return nil
	case tractor.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case tractor.FieldYear:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYear(v)
		return nil
	case tractor.FieldStateID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStateID(v)
		return nil
	case tractor.FieldLeased:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeased(v)
		return nil
	case tractor.FieldLeasedDate:
		v, ok := value.(*pgtype.Date)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeasedDate(v)
		return nil
	case tractor.FieldPrimaryWorkerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryWorkerID(v)
		return nil
	case tractor.FieldSecondaryWorkerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecondaryWorkerID(v)
		return nil
	case tractor.FieldFleetCodeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFleetCodeID(v)
		return nil
	}
	return fmt.Errorf("unknown Tractor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TractorMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, tractor.FieldVersion)
	}
	if m.addyear != nil {
		fields = append(fields, tractor.FieldYear)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TractorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tractor.FieldVersion:
		return m.AddedVersion()
	case tractor.FieldYear:
		return m.AddedYear()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TractorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tractor.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case tractor.FieldYear:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYear(v)
		return nil
	}
	return fmt.Errorf("unknown Tractor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TractorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tractor.FieldEquipmentTypeID) {
		fields = append(fields, tractor.FieldEquipmentTypeID)
	}
	if m.FieldCleared(tractor.FieldLicensePlateNumber) {
		fields = append(fields, tractor.FieldLicensePlateNumber)
	}
	if m.FieldCleared(tractor.FieldVin) {
		fields = append(fields, tractor.FieldVin)
	}
	if m.FieldCleared(tractor.FieldEquipmentManufacturerID) {
		fields = append(fields, tractor.FieldEquipmentManufacturerID)
	}
	if m.FieldCleared(tractor.FieldModel) {
		fields = append(fields, tractor.FieldModel)
	}
	if m.FieldCleared(tractor.FieldYear) {
		fields = append(fields, tractor.FieldYear)
	}
	if m.FieldCleared(tractor.FieldStateID) {
		fields = append(fields, tractor.FieldStateID)
	}
	if m.FieldCleared(tractor.FieldLeasedDate) {
		fields = append(fields, tractor.FieldLeasedDate)
	}
	if m.FieldCleared(tractor.FieldSecondaryWorkerID) {
		fields = append(fields, tractor.FieldSecondaryWorkerID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TractorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TractorMutation) ClearField(name string) error {
	switch name {
	case tractor.FieldEquipmentTypeID:
		m.ClearEquipmentTypeID()
		return nil
	case tractor.FieldLicensePlateNumber:
		m.ClearLicensePlateNumber()
		return nil
	case tractor.FieldVin:
		m.ClearVin()
		return nil
	case tractor.FieldEquipmentManufacturerID:
		m.ClearEquipmentManufacturerID()
		return nil
	case tractor.FieldModel:
		m.ClearModel()
		return nil
	case tractor.FieldYear:
		m.ClearYear()
		return nil
	case tractor.FieldStateID:
		m.ClearStateID()
		return nil
	case tractor.FieldLeasedDate:
		m.ClearLeasedDate()
		return nil
	case tractor.FieldSecondaryWorkerID:
		m.ClearSecondaryWorkerID()
		return nil
	}
	return fmt.Errorf("unknown Tractor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TractorMutation) ResetField(name string) error {
	switch name {
	case tractor.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case tractor.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case tractor.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tractor.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tractor.FieldVersion:
		m.ResetVersion()
		return nil
	case tractor.FieldCode:
		m.ResetCode()
		return nil
	case tractor.FieldStatus:
		m.ResetStatus()
		return nil
	case tractor.FieldEquipmentTypeID:
		m.ResetEquipmentTypeID()
		return nil
	case tractor.FieldLicensePlateNumber:
		m.ResetLicensePlateNumber()
		return nil
	case tractor.FieldVin:
		m.ResetVin()
		return nil
	case tractor.FieldEquipmentManufacturerID:
		m.ResetEquipmentManufacturerID()
		return nil
	case tractor.FieldModel:
		m.ResetModel()
		return nil
	case tractor.FieldYear:
		m.ResetYear()
		return nil
	case tractor.FieldStateID:
		m.ResetStateID()
		return nil
	case tractor.FieldLeased:
		m.ResetLeased()
		return nil
	case tractor.FieldLeasedDate:
		m.ResetLeasedDate()
		return nil
	case tractor.FieldPrimaryWorkerID:
		m.ResetPrimaryWorkerID()
		return nil
	case tractor.FieldSecondaryWorkerID:
		m.ResetSecondaryWorkerID()
		return nil
	case tractor.FieldFleetCodeID:
		m.ResetFleetCodeID()
		return nil
	}
	return fmt.Errorf("unknown Tractor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TractorMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.business_unit != nil {
		edges = append(edges, tractor.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, tractor.EdgeOrganization)
	}
	if m.equipment_type != nil {
		edges = append(edges, tractor.EdgeEquipmentType)
	}
	if m.equipment_manufacturer != nil {
		edges = append(edges, tractor.EdgeEquipmentManufacturer)
	}
	if m.state != nil {
		edges = append(edges, tractor.EdgeState)
	}
	if m.primary_worker != nil {
		edges = append(edges, tractor.EdgePrimaryWorker)
	}
	if m.secondary_worker != nil {
		edges = append(edges, tractor.EdgeSecondaryWorker)
	}
	if m.fleet_code != nil {
		edges = append(edges, tractor.EdgeFleetCode)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TractorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tractor.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case tractor.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case tractor.EdgeEquipmentType:
		if id := m.equipment_type; id != nil {
			return []ent.Value{*id}
		}
	case tractor.EdgeEquipmentManufacturer:
		if id := m.equipment_manufacturer; id != nil {
			return []ent.Value{*id}
		}
	case tractor.EdgeState:
		if id := m.state; id != nil {
			return []ent.Value{*id}
		}
	case tractor.EdgePrimaryWorker:
		if id := m.primary_worker; id != nil {
			return []ent.Value{*id}
		}
	case tractor.EdgeSecondaryWorker:
		if id := m.secondary_worker; id != nil {
			return []ent.Value{*id}
		}
	case tractor.EdgeFleetCode:
		if id := m.fleet_code; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TractorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TractorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TractorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedbusiness_unit {
		edges = append(edges, tractor.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, tractor.EdgeOrganization)
	}
	if m.clearedequipment_type {
		edges = append(edges, tractor.EdgeEquipmentType)
	}
	if m.clearedequipment_manufacturer {
		edges = append(edges, tractor.EdgeEquipmentManufacturer)
	}
	if m.clearedstate {
		edges = append(edges, tractor.EdgeState)
	}
	if m.clearedprimary_worker {
		edges = append(edges, tractor.EdgePrimaryWorker)
	}
	if m.clearedsecondary_worker {
		edges = append(edges, tractor.EdgeSecondaryWorker)
	}
	if m.clearedfleet_code {
		edges = append(edges, tractor.EdgeFleetCode)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TractorMutation) EdgeCleared(name string) bool {
	switch name {
	case tractor.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case tractor.EdgeOrganization:
		return m.clearedorganization
	case tractor.EdgeEquipmentType:
		return m.clearedequipment_type
	case tractor.EdgeEquipmentManufacturer:
		return m.clearedequipment_manufacturer
	case tractor.EdgeState:
		return m.clearedstate
	case tractor.EdgePrimaryWorker:
		return m.clearedprimary_worker
	case tractor.EdgeSecondaryWorker:
		return m.clearedsecondary_worker
	case tractor.EdgeFleetCode:
		return m.clearedfleet_code
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TractorMutation) ClearEdge(name string) error {
	switch name {
	case tractor.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case tractor.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case tractor.EdgeEquipmentType:
		m.ClearEquipmentType()
		return nil
	case tractor.EdgeEquipmentManufacturer:
		m.ClearEquipmentManufacturer()
		return nil
	case tractor.EdgeState:
		m.ClearState()
		return nil
	case tractor.EdgePrimaryWorker:
		m.ClearPrimaryWorker()
		return nil
	case tractor.EdgeSecondaryWorker:
		m.ClearSecondaryWorker()
		return nil
	case tractor.EdgeFleetCode:
		m.ClearFleetCode()
		return nil
	}
	return fmt.Errorf("unknown Tractor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TractorMutation) ResetEdge(name string) error {
	switch name {
	case tractor.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case tractor.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case tractor.EdgeEquipmentType:
		m.ResetEquipmentType()
		return nil
	case tractor.EdgeEquipmentManufacturer:
		m.ResetEquipmentManufacturer()
		return nil
	case tractor.EdgeState:
		m.ResetState()
		return nil
	case tractor.EdgePrimaryWorker:
		m.ResetPrimaryWorker()
		return nil
	case tractor.EdgeSecondaryWorker:
		m.ResetSecondaryWorker()
		return nil
	case tractor.EdgeFleetCode:
		m.ResetFleetCode()
		return nil
	}
	return fmt.Errorf("unknown Tractor edge %s", name)
}

// TrailerMutation represents an operation that mutates the Trailer nodes in the graph.
type TrailerMutation struct {
	config
	op                            Op
	typ                           string
	id                            *uuid.UUID
	created_at                    *time.Time
	updated_at                    *time.Time
	version                       *int
	addversion                    *int
	code                          *string
	status                        *trailer.Status
	vin                           *string
	model                         *string
	year                          *int16
	addyear                       *int16
	license_plate_number          *string
	last_inspection_date          **pgtype.Date
	registration_number           *string
	registration_expiration_date  **pgtype.Date
	clearedFields                 map[string]struct{}
	business_unit                 *uuid.UUID
	clearedbusiness_unit          bool
	organization                  *uuid.UUID
	clearedorganization           bool
	equipment_type                *uuid.UUID
	clearedequipment_type         bool
	equipment_manufacturer        *uuid.UUID
	clearedequipment_manufacturer bool
	state                         *uuid.UUID
	clearedstate                  bool
	registration_state            *uuid.UUID
	clearedregistration_state     bool
	fleet_code                    *uuid.UUID
	clearedfleet_code             bool
	done                          bool
	oldValue                      func(context.Context) (*Trailer, error)
	predicates                    []predicate.Trailer
}

var _ ent.Mutation = (*TrailerMutation)(nil)

// trailerOption allows management of the mutation configuration using functional options.
type trailerOption func(*TrailerMutation)

// newTrailerMutation creates new mutation for the Trailer entity.
func newTrailerMutation(c config, op Op, opts ...trailerOption) *TrailerMutation {
	m := &TrailerMutation{
		config:        c,
		op:            op,
		typ:           TypeTrailer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTrailerID sets the ID field of the mutation.
func withTrailerID(id uuid.UUID) trailerOption {
	return func(m *TrailerMutation) {
		var (
			err   error
			once  sync.Once
			value *Trailer
		)
		m.oldValue = func(ctx context.Context) (*Trailer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Trailer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTrailer sets the old Trailer of the mutation.
func withTrailer(node *Trailer) trailerOption {
	return func(m *TrailerMutation) {
		m.oldValue = func(context.Context) (*Trailer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TrailerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TrailerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Trailer entities.
func (m *TrailerMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TrailerMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TrailerMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Trailer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *TrailerMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *TrailerMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the Trailer entity.
// If the Trailer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrailerMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *TrailerMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *TrailerMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *TrailerMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Trailer entity.
// If the Trailer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrailerMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *TrailerMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TrailerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TrailerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Trailer entity.
// If the Trailer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrailerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TrailerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TrailerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TrailerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Trailer entity.
// If the Trailer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrailerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TrailerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *TrailerMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *TrailerMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Trailer entity.
// If the Trailer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrailerMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *TrailerMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *TrailerMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *TrailerMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetCode sets the "code" field.
func (m *TrailerMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *TrailerMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Trailer entity.
// If the Trailer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrailerMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *TrailerMutation) ResetCode() {
	m.code = nil
}

// SetStatus sets the "status" field.
func (m *TrailerMutation) SetStatus(t trailer.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *TrailerMutation) Status() (r trailer.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Trailer entity.
// If the Trailer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrailerMutation) OldStatus(ctx context.Context) (v trailer.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TrailerMutation) ResetStatus() {
	m.status = nil
}

// SetEquipmentTypeID sets the "equipment_type_id" field.
func (m *TrailerMutation) SetEquipmentTypeID(u uuid.UUID) {
	m.equipment_type = &u
}

// EquipmentTypeID returns the value of the "equipment_type_id" field in the mutation.
func (m *TrailerMutation) EquipmentTypeID() (r uuid.UUID, exists bool) {
	v := m.equipment_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEquipmentTypeID returns the old "equipment_type_id" field's value of the Trailer entity.
// If the Trailer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrailerMutation) OldEquipmentTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEquipmentTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEquipmentTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEquipmentTypeID: %w", err)
	}
	return oldValue.EquipmentTypeID, nil
}

// ResetEquipmentTypeID resets all changes to the "equipment_type_id" field.
func (m *TrailerMutation) ResetEquipmentTypeID() {
	m.equipment_type = nil
}

// SetVin sets the "vin" field.
func (m *TrailerMutation) SetVin(s string) {
	m.vin = &s
}

// Vin returns the value of the "vin" field in the mutation.
func (m *TrailerMutation) Vin() (r string, exists bool) {
	v := m.vin
	if v == nil {
		return
	}
	return *v, true
}

// OldVin returns the old "vin" field's value of the Trailer entity.
// If the Trailer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrailerMutation) OldVin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVin: %w", err)
	}
	return oldValue.Vin, nil
}

// ClearVin clears the value of the "vin" field.
func (m *TrailerMutation) ClearVin() {
	m.vin = nil
	m.clearedFields[trailer.FieldVin] = struct{}{}
}

// VinCleared returns if the "vin" field was cleared in this mutation.
func (m *TrailerMutation) VinCleared() bool {
	_, ok := m.clearedFields[trailer.FieldVin]
	return ok
}

// ResetVin resets all changes to the "vin" field.
func (m *TrailerMutation) ResetVin() {
	m.vin = nil
	delete(m.clearedFields, trailer.FieldVin)
}

// SetEquipmentManufacturerID sets the "equipment_manufacturer_id" field.
func (m *TrailerMutation) SetEquipmentManufacturerID(u uuid.UUID) {
	m.equipment_manufacturer = &u
}

// EquipmentManufacturerID returns the value of the "equipment_manufacturer_id" field in the mutation.
func (m *TrailerMutation) EquipmentManufacturerID() (r uuid.UUID, exists bool) {
	v := m.equipment_manufacturer
	if v == nil {
		return
	}
	return *v, true
}

// OldEquipmentManufacturerID returns the old "equipment_manufacturer_id" field's value of the Trailer entity.
// If the Trailer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrailerMutation) OldEquipmentManufacturerID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEquipmentManufacturerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEquipmentManufacturerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEquipmentManufacturerID: %w", err)
	}
	return oldValue.EquipmentManufacturerID, nil
}

// ClearEquipmentManufacturerID clears the value of the "equipment_manufacturer_id" field.
func (m *TrailerMutation) ClearEquipmentManufacturerID() {
	m.equipment_manufacturer = nil
	m.clearedFields[trailer.FieldEquipmentManufacturerID] = struct{}{}
}

// EquipmentManufacturerIDCleared returns if the "equipment_manufacturer_id" field was cleared in this mutation.
func (m *TrailerMutation) EquipmentManufacturerIDCleared() bool {
	_, ok := m.clearedFields[trailer.FieldEquipmentManufacturerID]
	return ok
}

// ResetEquipmentManufacturerID resets all changes to the "equipment_manufacturer_id" field.
func (m *TrailerMutation) ResetEquipmentManufacturerID() {
	m.equipment_manufacturer = nil
	delete(m.clearedFields, trailer.FieldEquipmentManufacturerID)
}

// SetModel sets the "model" field.
func (m *TrailerMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *TrailerMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the Trailer entity.
// If the Trailer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrailerMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ClearModel clears the value of the "model" field.
func (m *TrailerMutation) ClearModel() {
	m.model = nil
	m.clearedFields[trailer.FieldModel] = struct{}{}
}

// ModelCleared returns if the "model" field was cleared in this mutation.
func (m *TrailerMutation) ModelCleared() bool {
	_, ok := m.clearedFields[trailer.FieldModel]
	return ok
}

// ResetModel resets all changes to the "model" field.
func (m *TrailerMutation) ResetModel() {
	m.model = nil
	delete(m.clearedFields, trailer.FieldModel)
}

// SetYear sets the "year" field.
func (m *TrailerMutation) SetYear(i int16) {
	m.year = &i
	m.addyear = nil
}

// Year returns the value of the "year" field in the mutation.
func (m *TrailerMutation) Year() (r int16, exists bool) {
	v := m.year
	if v == nil {
		return
	}
	return *v, true
}

// OldYear returns the old "year" field's value of the Trailer entity.
// If the Trailer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrailerMutation) OldYear(ctx context.Context) (v *int16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYear: %w", err)
	}
	return oldValue.Year, nil
}

// AddYear adds i to the "year" field.
func (m *TrailerMutation) AddYear(i int16) {
	if m.addyear != nil {
		*m.addyear += i
	} else {
		m.addyear = &i
	}
}

// AddedYear returns the value that was added to the "year" field in this mutation.
func (m *TrailerMutation) AddedYear() (r int16, exists bool) {
	v := m.addyear
	if v == nil {
		return
	}
	return *v, true
}

// ClearYear clears the value of the "year" field.
func (m *TrailerMutation) ClearYear() {
	m.year = nil
	m.addyear = nil
	m.clearedFields[trailer.FieldYear] = struct{}{}
}

// YearCleared returns if the "year" field was cleared in this mutation.
func (m *TrailerMutation) YearCleared() bool {
	_, ok := m.clearedFields[trailer.FieldYear]
	return ok
}

// ResetYear resets all changes to the "year" field.
func (m *TrailerMutation) ResetYear() {
	m.year = nil
	m.addyear = nil
	delete(m.clearedFields, trailer.FieldYear)
}

// SetLicensePlateNumber sets the "license_plate_number" field.
func (m *TrailerMutation) SetLicensePlateNumber(s string) {
	m.license_plate_number = &s
}

// LicensePlateNumber returns the value of the "license_plate_number" field in the mutation.
func (m *TrailerMutation) LicensePlateNumber() (r string, exists bool) {
	v := m.license_plate_number
	if v == nil {
		return
	}
	return *v, true
}

// OldLicensePlateNumber returns the old "license_plate_number" field's value of the Trailer entity.
// If the Trailer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrailerMutation) OldLicensePlateNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLicensePlateNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLicensePlateNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicensePlateNumber: %w", err)
	}
	return oldValue.LicensePlateNumber, nil
}

// ClearLicensePlateNumber clears the value of the "license_plate_number" field.
func (m *TrailerMutation) ClearLicensePlateNumber() {
	m.license_plate_number = nil
	m.clearedFields[trailer.FieldLicensePlateNumber] = struct{}{}
}

// LicensePlateNumberCleared returns if the "license_plate_number" field was cleared in this mutation.
func (m *TrailerMutation) LicensePlateNumberCleared() bool {
	_, ok := m.clearedFields[trailer.FieldLicensePlateNumber]
	return ok
}

// ResetLicensePlateNumber resets all changes to the "license_plate_number" field.
func (m *TrailerMutation) ResetLicensePlateNumber() {
	m.license_plate_number = nil
	delete(m.clearedFields, trailer.FieldLicensePlateNumber)
}

// SetStateID sets the "state_id" field.
func (m *TrailerMutation) SetStateID(u uuid.UUID) {
	m.state = &u
}

// StateID returns the value of the "state_id" field in the mutation.
func (m *TrailerMutation) StateID() (r uuid.UUID, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldStateID returns the old "state_id" field's value of the Trailer entity.
// If the Trailer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrailerMutation) OldStateID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStateID: %w", err)
	}
	return oldValue.StateID, nil
}

// ClearStateID clears the value of the "state_id" field.
func (m *TrailerMutation) ClearStateID() {
	m.state = nil
	m.clearedFields[trailer.FieldStateID] = struct{}{}
}

// StateIDCleared returns if the "state_id" field was cleared in this mutation.
func (m *TrailerMutation) StateIDCleared() bool {
	_, ok := m.clearedFields[trailer.FieldStateID]
	return ok
}

// ResetStateID resets all changes to the "state_id" field.
func (m *TrailerMutation) ResetStateID() {
	m.state = nil
	delete(m.clearedFields, trailer.FieldStateID)
}

// SetFleetCodeID sets the "fleet_code_id" field.
func (m *TrailerMutation) SetFleetCodeID(u uuid.UUID) {
	m.fleet_code = &u
}

// FleetCodeID returns the value of the "fleet_code_id" field in the mutation.
func (m *TrailerMutation) FleetCodeID() (r uuid.UUID, exists bool) {
	v := m.fleet_code
	if v == nil {
		return
	}
	return *v, true
}

// OldFleetCodeID returns the old "fleet_code_id" field's value of the Trailer entity.
// If the Trailer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrailerMutation) OldFleetCodeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFleetCodeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFleetCodeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFleetCodeID: %w", err)
	}
	return oldValue.FleetCodeID, nil
}

// ResetFleetCodeID resets all changes to the "fleet_code_id" field.
func (m *TrailerMutation) ResetFleetCodeID() {
	m.fleet_code = nil
}

// SetLastInspectionDate sets the "last_inspection_date" field.
func (m *TrailerMutation) SetLastInspectionDate(pg *pgtype.Date) {
	m.last_inspection_date = &pg
}

// LastInspectionDate returns the value of the "last_inspection_date" field in the mutation.
func (m *TrailerMutation) LastInspectionDate() (r *pgtype.Date, exists bool) {
	v := m.last_inspection_date
	if v == nil {
		return
	}
	return *v, true
}

// OldLastInspectionDate returns the old "last_inspection_date" field's value of the Trailer entity.
// If the Trailer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrailerMutation) OldLastInspectionDate(ctx context.Context) (v *pgtype.Date, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastInspectionDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastInspectionDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastInspectionDate: %w", err)
	}
	return oldValue.LastInspectionDate, nil
}

// ClearLastInspectionDate clears the value of the "last_inspection_date" field.
func (m *TrailerMutation) ClearLastInspectionDate() {
	m.last_inspection_date = nil
	m.clearedFields[trailer.FieldLastInspectionDate] = struct{}{}
}

// LastInspectionDateCleared returns if the "last_inspection_date" field was cleared in this mutation.
func (m *TrailerMutation) LastInspectionDateCleared() bool {
	_, ok := m.clearedFields[trailer.FieldLastInspectionDate]
	return ok
}

// ResetLastInspectionDate resets all changes to the "last_inspection_date" field.
func (m *TrailerMutation) ResetLastInspectionDate() {
	m.last_inspection_date = nil
	delete(m.clearedFields, trailer.FieldLastInspectionDate)
}

// SetRegistrationNumber sets the "registration_number" field.
func (m *TrailerMutation) SetRegistrationNumber(s string) {
	m.registration_number = &s
}

// RegistrationNumber returns the value of the "registration_number" field in the mutation.
func (m *TrailerMutation) RegistrationNumber() (r string, exists bool) {
	v := m.registration_number
	if v == nil {
		return
	}
	return *v, true
}

// OldRegistrationNumber returns the old "registration_number" field's value of the Trailer entity.
// If the Trailer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrailerMutation) OldRegistrationNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegistrationNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegistrationNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegistrationNumber: %w", err)
	}
	return oldValue.RegistrationNumber, nil
}

// ClearRegistrationNumber clears the value of the "registration_number" field.
func (m *TrailerMutation) ClearRegistrationNumber() {
	m.registration_number = nil
	m.clearedFields[trailer.FieldRegistrationNumber] = struct{}{}
}

// RegistrationNumberCleared returns if the "registration_number" field was cleared in this mutation.
func (m *TrailerMutation) RegistrationNumberCleared() bool {
	_, ok := m.clearedFields[trailer.FieldRegistrationNumber]
	return ok
}

// ResetRegistrationNumber resets all changes to the "registration_number" field.
func (m *TrailerMutation) ResetRegistrationNumber() {
	m.registration_number = nil
	delete(m.clearedFields, trailer.FieldRegistrationNumber)
}

// SetRegistrationStateID sets the "registration_state_id" field.
func (m *TrailerMutation) SetRegistrationStateID(u uuid.UUID) {
	m.registration_state = &u
}

// RegistrationStateID returns the value of the "registration_state_id" field in the mutation.
func (m *TrailerMutation) RegistrationStateID() (r uuid.UUID, exists bool) {
	v := m.registration_state
	if v == nil {
		return
	}
	return *v, true
}

// OldRegistrationStateID returns the old "registration_state_id" field's value of the Trailer entity.
// If the Trailer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrailerMutation) OldRegistrationStateID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegistrationStateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegistrationStateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegistrationStateID: %w", err)
	}
	return oldValue.RegistrationStateID, nil
}

// ClearRegistrationStateID clears the value of the "registration_state_id" field.
func (m *TrailerMutation) ClearRegistrationStateID() {
	m.registration_state = nil
	m.clearedFields[trailer.FieldRegistrationStateID] = struct{}{}
}

// RegistrationStateIDCleared returns if the "registration_state_id" field was cleared in this mutation.
func (m *TrailerMutation) RegistrationStateIDCleared() bool {
	_, ok := m.clearedFields[trailer.FieldRegistrationStateID]
	return ok
}

// ResetRegistrationStateID resets all changes to the "registration_state_id" field.
func (m *TrailerMutation) ResetRegistrationStateID() {
	m.registration_state = nil
	delete(m.clearedFields, trailer.FieldRegistrationStateID)
}

// SetRegistrationExpirationDate sets the "registration_expiration_date" field.
func (m *TrailerMutation) SetRegistrationExpirationDate(pg *pgtype.Date) {
	m.registration_expiration_date = &pg
}

// RegistrationExpirationDate returns the value of the "registration_expiration_date" field in the mutation.
func (m *TrailerMutation) RegistrationExpirationDate() (r *pgtype.Date, exists bool) {
	v := m.registration_expiration_date
	if v == nil {
		return
	}
	return *v, true
}

// OldRegistrationExpirationDate returns the old "registration_expiration_date" field's value of the Trailer entity.
// If the Trailer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrailerMutation) OldRegistrationExpirationDate(ctx context.Context) (v *pgtype.Date, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegistrationExpirationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegistrationExpirationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegistrationExpirationDate: %w", err)
	}
	return oldValue.RegistrationExpirationDate, nil
}

// ClearRegistrationExpirationDate clears the value of the "registration_expiration_date" field.
func (m *TrailerMutation) ClearRegistrationExpirationDate() {
	m.registration_expiration_date = nil
	m.clearedFields[trailer.FieldRegistrationExpirationDate] = struct{}{}
}

// RegistrationExpirationDateCleared returns if the "registration_expiration_date" field was cleared in this mutation.
func (m *TrailerMutation) RegistrationExpirationDateCleared() bool {
	_, ok := m.clearedFields[trailer.FieldRegistrationExpirationDate]
	return ok
}

// ResetRegistrationExpirationDate resets all changes to the "registration_expiration_date" field.
func (m *TrailerMutation) ResetRegistrationExpirationDate() {
	m.registration_expiration_date = nil
	delete(m.clearedFields, trailer.FieldRegistrationExpirationDate)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *TrailerMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[trailer.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *TrailerMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *TrailerMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *TrailerMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *TrailerMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[trailer.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *TrailerMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *TrailerMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *TrailerMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearEquipmentType clears the "equipment_type" edge to the EquipmentType entity.
func (m *TrailerMutation) ClearEquipmentType() {
	m.clearedequipment_type = true
	m.clearedFields[trailer.FieldEquipmentTypeID] = struct{}{}
}

// EquipmentTypeCleared reports if the "equipment_type" edge to the EquipmentType entity was cleared.
func (m *TrailerMutation) EquipmentTypeCleared() bool {
	return m.clearedequipment_type
}

// EquipmentTypeIDs returns the "equipment_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EquipmentTypeID instead. It exists only for internal usage by the builders.
func (m *TrailerMutation) EquipmentTypeIDs() (ids []uuid.UUID) {
	if id := m.equipment_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEquipmentType resets all changes to the "equipment_type" edge.
func (m *TrailerMutation) ResetEquipmentType() {
	m.equipment_type = nil
	m.clearedequipment_type = false
}

// ClearEquipmentManufacturer clears the "equipment_manufacturer" edge to the EquipmentManufactuer entity.
func (m *TrailerMutation) ClearEquipmentManufacturer() {
	m.clearedequipment_manufacturer = true
	m.clearedFields[trailer.FieldEquipmentManufacturerID] = struct{}{}
}

// EquipmentManufacturerCleared reports if the "equipment_manufacturer" edge to the EquipmentManufactuer entity was cleared.
func (m *TrailerMutation) EquipmentManufacturerCleared() bool {
	return m.EquipmentManufacturerIDCleared() || m.clearedequipment_manufacturer
}

// EquipmentManufacturerIDs returns the "equipment_manufacturer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EquipmentManufacturerID instead. It exists only for internal usage by the builders.
func (m *TrailerMutation) EquipmentManufacturerIDs() (ids []uuid.UUID) {
	if id := m.equipment_manufacturer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEquipmentManufacturer resets all changes to the "equipment_manufacturer" edge.
func (m *TrailerMutation) ResetEquipmentManufacturer() {
	m.equipment_manufacturer = nil
	m.clearedequipment_manufacturer = false
}

// ClearState clears the "state" edge to the UsState entity.
func (m *TrailerMutation) ClearState() {
	m.clearedstate = true
	m.clearedFields[trailer.FieldStateID] = struct{}{}
}

// StateCleared reports if the "state" edge to the UsState entity was cleared.
func (m *TrailerMutation) StateCleared() bool {
	return m.StateIDCleared() || m.clearedstate
}

// StateIDs returns the "state" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StateID instead. It exists only for internal usage by the builders.
func (m *TrailerMutation) StateIDs() (ids []uuid.UUID) {
	if id := m.state; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetState resets all changes to the "state" edge.
func (m *TrailerMutation) ResetState() {
	m.state = nil
	m.clearedstate = false
}

// ClearRegistrationState clears the "registration_state" edge to the UsState entity.
func (m *TrailerMutation) ClearRegistrationState() {
	m.clearedregistration_state = true
	m.clearedFields[trailer.FieldRegistrationStateID] = struct{}{}
}

// RegistrationStateCleared reports if the "registration_state" edge to the UsState entity was cleared.
func (m *TrailerMutation) RegistrationStateCleared() bool {
	return m.RegistrationStateIDCleared() || m.clearedregistration_state
}

// RegistrationStateIDs returns the "registration_state" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RegistrationStateID instead. It exists only for internal usage by the builders.
func (m *TrailerMutation) RegistrationStateIDs() (ids []uuid.UUID) {
	if id := m.registration_state; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRegistrationState resets all changes to the "registration_state" edge.
func (m *TrailerMutation) ResetRegistrationState() {
	m.registration_state = nil
	m.clearedregistration_state = false
}

// ClearFleetCode clears the "fleet_code" edge to the FleetCode entity.
func (m *TrailerMutation) ClearFleetCode() {
	m.clearedfleet_code = true
	m.clearedFields[trailer.FieldFleetCodeID] = struct{}{}
}

// FleetCodeCleared reports if the "fleet_code" edge to the FleetCode entity was cleared.
func (m *TrailerMutation) FleetCodeCleared() bool {
	return m.clearedfleet_code
}

// FleetCodeIDs returns the "fleet_code" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FleetCodeID instead. It exists only for internal usage by the builders.
func (m *TrailerMutation) FleetCodeIDs() (ids []uuid.UUID) {
	if id := m.fleet_code; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFleetCode resets all changes to the "fleet_code" edge.
func (m *TrailerMutation) ResetFleetCode() {
	m.fleet_code = nil
	m.clearedfleet_code = false
}

// Where appends a list predicates to the TrailerMutation builder.
func (m *TrailerMutation) Where(ps ...predicate.Trailer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TrailerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TrailerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Trailer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TrailerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TrailerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Trailer).
func (m *TrailerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TrailerMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.business_unit != nil {
		fields = append(fields, trailer.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, trailer.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, trailer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, trailer.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, trailer.FieldVersion)
	}
	if m.code != nil {
		fields = append(fields, trailer.FieldCode)
	}
	if m.status != nil {
		fields = append(fields, trailer.FieldStatus)
	}
	if m.equipment_type != nil {
		fields = append(fields, trailer.FieldEquipmentTypeID)
	}
	if m.vin != nil {
		fields = append(fields, trailer.FieldVin)
	}
	if m.equipment_manufacturer != nil {
		fields = append(fields, trailer.FieldEquipmentManufacturerID)
	}
	if m.model != nil {
		fields = append(fields, trailer.FieldModel)
	}
	if m.year != nil {
		fields = append(fields, trailer.FieldYear)
	}
	if m.license_plate_number != nil {
		fields = append(fields, trailer.FieldLicensePlateNumber)
	}
	if m.state != nil {
		fields = append(fields, trailer.FieldStateID)
	}
	if m.fleet_code != nil {
		fields = append(fields, trailer.FieldFleetCodeID)
	}
	if m.last_inspection_date != nil {
		fields = append(fields, trailer.FieldLastInspectionDate)
	}
	if m.registration_number != nil {
		fields = append(fields, trailer.FieldRegistrationNumber)
	}
	if m.registration_state != nil {
		fields = append(fields, trailer.FieldRegistrationStateID)
	}
	if m.registration_expiration_date != nil {
		fields = append(fields, trailer.FieldRegistrationExpirationDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TrailerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case trailer.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case trailer.FieldOrganizationID:
		return m.OrganizationID()
	case trailer.FieldCreatedAt:
		return m.CreatedAt()
	case trailer.FieldUpdatedAt:
		return m.UpdatedAt()
	case trailer.FieldVersion:
		return m.Version()
	case trailer.FieldCode:
		return m.Code()
	case trailer.FieldStatus:
		return m.Status()
	case trailer.FieldEquipmentTypeID:
		return m.EquipmentTypeID()
	case trailer.FieldVin:
		return m.Vin()
	case trailer.FieldEquipmentManufacturerID:
		return m.EquipmentManufacturerID()
	case trailer.FieldModel:
		return m.Model()
	case trailer.FieldYear:
		return m.Year()
	case trailer.FieldLicensePlateNumber:
		return m.LicensePlateNumber()
	case trailer.FieldStateID:
		return m.StateID()
	case trailer.FieldFleetCodeID:
		return m.FleetCodeID()
	case trailer.FieldLastInspectionDate:
		return m.LastInspectionDate()
	case trailer.FieldRegistrationNumber:
		return m.RegistrationNumber()
	case trailer.FieldRegistrationStateID:
		return m.RegistrationStateID()
	case trailer.FieldRegistrationExpirationDate:
		return m.RegistrationExpirationDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TrailerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case trailer.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case trailer.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case trailer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case trailer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case trailer.FieldVersion:
		return m.OldVersion(ctx)
	case trailer.FieldCode:
		return m.OldCode(ctx)
	case trailer.FieldStatus:
		return m.OldStatus(ctx)
	case trailer.FieldEquipmentTypeID:
		return m.OldEquipmentTypeID(ctx)
	case trailer.FieldVin:
		return m.OldVin(ctx)
	case trailer.FieldEquipmentManufacturerID:
		return m.OldEquipmentManufacturerID(ctx)
	case trailer.FieldModel:
		return m.OldModel(ctx)
	case trailer.FieldYear:
		return m.OldYear(ctx)
	case trailer.FieldLicensePlateNumber:
		return m.OldLicensePlateNumber(ctx)
	case trailer.FieldStateID:
		return m.OldStateID(ctx)
	case trailer.FieldFleetCodeID:
		return m.OldFleetCodeID(ctx)
	case trailer.FieldLastInspectionDate:
		return m.OldLastInspectionDate(ctx)
	case trailer.FieldRegistrationNumber:
		return m.OldRegistrationNumber(ctx)
	case trailer.FieldRegistrationStateID:
		return m.OldRegistrationStateID(ctx)
	case trailer.FieldRegistrationExpirationDate:
		return m.OldRegistrationExpirationDate(ctx)
	}
	return nil, fmt.Errorf("unknown Trailer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TrailerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case trailer.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case trailer.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case trailer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case trailer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case trailer.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case trailer.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case trailer.FieldStatus:
		v, ok := value.(trailer.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case trailer.FieldEquipmentTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEquipmentTypeID(v)
		return nil
	case trailer.FieldVin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVin(v)
		return nil
	case trailer.FieldEquipmentManufacturerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEquipmentManufacturerID(v)
		return nil
	case trailer.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case trailer.FieldYear:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYear(v)
		return nil
	case trailer.FieldLicensePlateNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicensePlateNumber(v)
		return nil
	case trailer.FieldStateID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStateID(v)
		return nil
	case trailer.FieldFleetCodeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFleetCodeID(v)
		return nil
	case trailer.FieldLastInspectionDate:
		v, ok := value.(*pgtype.Date)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastInspectionDate(v)
		return nil
	case trailer.FieldRegistrationNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegistrationNumber(v)
		return nil
	case trailer.FieldRegistrationStateID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegistrationStateID(v)
		return nil
	case trailer.FieldRegistrationExpirationDate:
		v, ok := value.(*pgtype.Date)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegistrationExpirationDate(v)
		return nil
	}
	return fmt.Errorf("unknown Trailer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TrailerMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, trailer.FieldVersion)
	}
	if m.addyear != nil {
		fields = append(fields, trailer.FieldYear)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TrailerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case trailer.FieldVersion:
		return m.AddedVersion()
	case trailer.FieldYear:
		return m.AddedYear()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TrailerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case trailer.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	case trailer.FieldYear:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYear(v)
		return nil
	}
	return fmt.Errorf("unknown Trailer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TrailerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(trailer.FieldVin) {
		fields = append(fields, trailer.FieldVin)
	}
	if m.FieldCleared(trailer.FieldEquipmentManufacturerID) {
		fields = append(fields, trailer.FieldEquipmentManufacturerID)
	}
	if m.FieldCleared(trailer.FieldModel) {
		fields = append(fields, trailer.FieldModel)
	}
	if m.FieldCleared(trailer.FieldYear) {
		fields = append(fields, trailer.FieldYear)
	}
	if m.FieldCleared(trailer.FieldLicensePlateNumber) {
		fields = append(fields, trailer.FieldLicensePlateNumber)
	}
	if m.FieldCleared(trailer.FieldStateID) {
		fields = append(fields, trailer.FieldStateID)
	}
	if m.FieldCleared(trailer.FieldLastInspectionDate) {
		fields = append(fields, trailer.FieldLastInspectionDate)
	}
	if m.FieldCleared(trailer.FieldRegistrationNumber) {
		fields = append(fields, trailer.FieldRegistrationNumber)
	}
	if m.FieldCleared(trailer.FieldRegistrationStateID) {
		fields = append(fields, trailer.FieldRegistrationStateID)
	}
	if m.FieldCleared(trailer.FieldRegistrationExpirationDate) {
		fields = append(fields, trailer.FieldRegistrationExpirationDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TrailerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TrailerMutation) ClearField(name string) error {
	switch name {
	case trailer.FieldVin:
		m.ClearVin()
		return nil
	case trailer.FieldEquipmentManufacturerID:
		m.ClearEquipmentManufacturerID()
		return nil
	case trailer.FieldModel:
		m.ClearModel()
		return nil
	case trailer.FieldYear:
		m.ClearYear()
		return nil
	case trailer.FieldLicensePlateNumber:
		m.ClearLicensePlateNumber()
		return nil
	case trailer.FieldStateID:
		m.ClearStateID()
		return nil
	case trailer.FieldLastInspectionDate:
		m.ClearLastInspectionDate()
		return nil
	case trailer.FieldRegistrationNumber:
		m.ClearRegistrationNumber()
		return nil
	case trailer.FieldRegistrationStateID:
		m.ClearRegistrationStateID()
		return nil
	case trailer.FieldRegistrationExpirationDate:
		m.ClearRegistrationExpirationDate()
		return nil
	}
	return fmt.Errorf("unknown Trailer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TrailerMutation) ResetField(name string) error {
	switch name {
	case trailer.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case trailer.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case trailer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case trailer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case trailer.FieldVersion:
		m.ResetVersion()
		return nil
	case trailer.FieldCode:
		m.ResetCode()
		return nil
	case trailer.FieldStatus:
		m.ResetStatus()
		return nil
	case trailer.FieldEquipmentTypeID:
		m.ResetEquipmentTypeID()
		return nil
	case trailer.FieldVin:
		m.ResetVin()
		return nil
	case trailer.FieldEquipmentManufacturerID:
		m.ResetEquipmentManufacturerID()
		return nil
	case trailer.FieldModel:
		m.ResetModel()
		return nil
	case trailer.FieldYear:
		m.ResetYear()
		return nil
	case trailer.FieldLicensePlateNumber:
		m.ResetLicensePlateNumber()
		return nil
	case trailer.FieldStateID:
		m.ResetStateID()
		return nil
	case trailer.FieldFleetCodeID:
		m.ResetFleetCodeID()
		return nil
	case trailer.FieldLastInspectionDate:
		m.ResetLastInspectionDate()
		return nil
	case trailer.FieldRegistrationNumber:
		m.ResetRegistrationNumber()
		return nil
	case trailer.FieldRegistrationStateID:
		m.ResetRegistrationStateID()
		return nil
	case trailer.FieldRegistrationExpirationDate:
		m.ResetRegistrationExpirationDate()
		return nil
	}
	return fmt.Errorf("unknown Trailer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TrailerMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.business_unit != nil {
		edges = append(edges, trailer.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, trailer.EdgeOrganization)
	}
	if m.equipment_type != nil {
		edges = append(edges, trailer.EdgeEquipmentType)
	}
	if m.equipment_manufacturer != nil {
		edges = append(edges, trailer.EdgeEquipmentManufacturer)
	}
	if m.state != nil {
		edges = append(edges, trailer.EdgeState)
	}
	if m.registration_state != nil {
		edges = append(edges, trailer.EdgeRegistrationState)
	}
	if m.fleet_code != nil {
		edges = append(edges, trailer.EdgeFleetCode)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TrailerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case trailer.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case trailer.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case trailer.EdgeEquipmentType:
		if id := m.equipment_type; id != nil {
			return []ent.Value{*id}
		}
	case trailer.EdgeEquipmentManufacturer:
		if id := m.equipment_manufacturer; id != nil {
			return []ent.Value{*id}
		}
	case trailer.EdgeState:
		if id := m.state; id != nil {
			return []ent.Value{*id}
		}
	case trailer.EdgeRegistrationState:
		if id := m.registration_state; id != nil {
			return []ent.Value{*id}
		}
	case trailer.EdgeFleetCode:
		if id := m.fleet_code; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TrailerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TrailerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TrailerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedbusiness_unit {
		edges = append(edges, trailer.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, trailer.EdgeOrganization)
	}
	if m.clearedequipment_type {
		edges = append(edges, trailer.EdgeEquipmentType)
	}
	if m.clearedequipment_manufacturer {
		edges = append(edges, trailer.EdgeEquipmentManufacturer)
	}
	if m.clearedstate {
		edges = append(edges, trailer.EdgeState)
	}
	if m.clearedregistration_state {
		edges = append(edges, trailer.EdgeRegistrationState)
	}
	if m.clearedfleet_code {
		edges = append(edges, trailer.EdgeFleetCode)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TrailerMutation) EdgeCleared(name string) bool {
	switch name {
	case trailer.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case trailer.EdgeOrganization:
		return m.clearedorganization
	case trailer.EdgeEquipmentType:
		return m.clearedequipment_type
	case trailer.EdgeEquipmentManufacturer:
		return m.clearedequipment_manufacturer
	case trailer.EdgeState:
		return m.clearedstate
	case trailer.EdgeRegistrationState:
		return m.clearedregistration_state
	case trailer.EdgeFleetCode:
		return m.clearedfleet_code
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TrailerMutation) ClearEdge(name string) error {
	switch name {
	case trailer.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case trailer.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case trailer.EdgeEquipmentType:
		m.ClearEquipmentType()
		return nil
	case trailer.EdgeEquipmentManufacturer:
		m.ClearEquipmentManufacturer()
		return nil
	case trailer.EdgeState:
		m.ClearState()
		return nil
	case trailer.EdgeRegistrationState:
		m.ClearRegistrationState()
		return nil
	case trailer.EdgeFleetCode:
		m.ClearFleetCode()
		return nil
	}
	return fmt.Errorf("unknown Trailer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TrailerMutation) ResetEdge(name string) error {
	switch name {
	case trailer.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case trailer.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case trailer.EdgeEquipmentType:
		m.ResetEquipmentType()
		return nil
	case trailer.EdgeEquipmentManufacturer:
		m.ResetEquipmentManufacturer()
		return nil
	case trailer.EdgeState:
		m.ResetState()
		return nil
	case trailer.EdgeRegistrationState:
		m.ResetRegistrationState()
		return nil
	case trailer.EdgeFleetCode:
		m.ResetFleetCode()
		return nil
	}
	return fmt.Errorf("unknown Trailer edge %s", name)
}

// UsStateMutation represents an operation that mutates the UsState nodes in the graph.
type UsStateMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	abbreviation  *string
	country_name  *string
	country_iso3  *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UsState, error)
	predicates    []predicate.UsState
}

var _ ent.Mutation = (*UsStateMutation)(nil)

// usstateOption allows management of the mutation configuration using functional options.
type usstateOption func(*UsStateMutation)

// newUsStateMutation creates new mutation for the UsState entity.
func newUsStateMutation(c config, op Op, opts ...usstateOption) *UsStateMutation {
	m := &UsStateMutation{
		config:        c,
		op:            op,
		typ:           TypeUsState,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUsStateID sets the ID field of the mutation.
func withUsStateID(id uuid.UUID) usstateOption {
	return func(m *UsStateMutation) {
		var (
			err   error
			once  sync.Once
			value *UsState
		)
		m.oldValue = func(ctx context.Context) (*UsState, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UsState.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUsState sets the old UsState of the mutation.
func withUsState(node *UsState) usstateOption {
	return func(m *UsStateMutation) {
		m.oldValue = func(context.Context) (*UsState, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UsStateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UsStateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UsState entities.
func (m *UsStateMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UsStateMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UsStateMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UsState.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UsStateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UsStateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UsState entity.
// If the UsState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsStateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UsStateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UsStateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UsStateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UsState entity.
// If the UsState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsStateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UsStateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *UsStateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UsStateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the UsState entity.
// If the UsState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsStateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UsStateMutation) ResetName() {
	m.name = nil
}

// SetAbbreviation sets the "abbreviation" field.
func (m *UsStateMutation) SetAbbreviation(s string) {
	m.abbreviation = &s
}

// Abbreviation returns the value of the "abbreviation" field in the mutation.
func (m *UsStateMutation) Abbreviation() (r string, exists bool) {
	v := m.abbreviation
	if v == nil {
		return
	}
	return *v, true
}

// OldAbbreviation returns the old "abbreviation" field's value of the UsState entity.
// If the UsState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsStateMutation) OldAbbreviation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbbreviation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbbreviation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbbreviation: %w", err)
	}
	return oldValue.Abbreviation, nil
}

// ResetAbbreviation resets all changes to the "abbreviation" field.
func (m *UsStateMutation) ResetAbbreviation() {
	m.abbreviation = nil
}

// SetCountryName sets the "country_name" field.
func (m *UsStateMutation) SetCountryName(s string) {
	m.country_name = &s
}

// CountryName returns the value of the "country_name" field in the mutation.
func (m *UsStateMutation) CountryName() (r string, exists bool) {
	v := m.country_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryName returns the old "country_name" field's value of the UsState entity.
// If the UsState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsStateMutation) OldCountryName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountryName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountryName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryName: %w", err)
	}
	return oldValue.CountryName, nil
}

// ResetCountryName resets all changes to the "country_name" field.
func (m *UsStateMutation) ResetCountryName() {
	m.country_name = nil
}

// SetCountryIso3 sets the "country_iso3" field.
func (m *UsStateMutation) SetCountryIso3(s string) {
	m.country_iso3 = &s
}

// CountryIso3 returns the value of the "country_iso3" field in the mutation.
func (m *UsStateMutation) CountryIso3() (r string, exists bool) {
	v := m.country_iso3
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryIso3 returns the old "country_iso3" field's value of the UsState entity.
// If the UsState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsStateMutation) OldCountryIso3(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountryIso3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountryIso3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryIso3: %w", err)
	}
	return oldValue.CountryIso3, nil
}

// ResetCountryIso3 resets all changes to the "country_iso3" field.
func (m *UsStateMutation) ResetCountryIso3() {
	m.country_iso3 = nil
}

// Where appends a list predicates to the UsStateMutation builder.
func (m *UsStateMutation) Where(ps ...predicate.UsState) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UsStateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UsStateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UsState, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UsStateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UsStateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UsState).
func (m *UsStateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UsStateMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, usstate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usstate.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, usstate.FieldName)
	}
	if m.abbreviation != nil {
		fields = append(fields, usstate.FieldAbbreviation)
	}
	if m.country_name != nil {
		fields = append(fields, usstate.FieldCountryName)
	}
	if m.country_iso3 != nil {
		fields = append(fields, usstate.FieldCountryIso3)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UsStateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usstate.FieldCreatedAt:
		return m.CreatedAt()
	case usstate.FieldUpdatedAt:
		return m.UpdatedAt()
	case usstate.FieldName:
		return m.Name()
	case usstate.FieldAbbreviation:
		return m.Abbreviation()
	case usstate.FieldCountryName:
		return m.CountryName()
	case usstate.FieldCountryIso3:
		return m.CountryIso3()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UsStateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usstate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usstate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case usstate.FieldName:
		return m.OldName(ctx)
	case usstate.FieldAbbreviation:
		return m.OldAbbreviation(ctx)
	case usstate.FieldCountryName:
		return m.OldCountryName(ctx)
	case usstate.FieldCountryIso3:
		return m.OldCountryIso3(ctx)
	}
	return nil, fmt.Errorf("unknown UsState field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsStateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usstate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usstate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case usstate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case usstate.FieldAbbreviation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbbreviation(v)
		return nil
	case usstate.FieldCountryName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryName(v)
		return nil
	case usstate.FieldCountryIso3:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryIso3(v)
		return nil
	}
	return fmt.Errorf("unknown UsState field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UsStateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UsStateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsStateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UsState numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UsStateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UsStateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UsStateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UsState nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UsStateMutation) ResetField(name string) error {
	switch name {
	case usstate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usstate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case usstate.FieldName:
		m.ResetName()
		return nil
	case usstate.FieldAbbreviation:
		m.ResetAbbreviation()
		return nil
	case usstate.FieldCountryName:
		m.ResetCountryName()
		return nil
	case usstate.FieldCountryIso3:
		m.ResetCountryIso3()
		return nil
	}
	return fmt.Errorf("unknown UsState field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UsStateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UsStateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UsStateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UsStateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UsStateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UsStateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UsStateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UsState unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UsStateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UsState edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	created_at                *time.Time
	updated_at                *time.Time
	version                   *int
	addversion                *int
	status                    *user.Status
	name                      *string
	username                  *string
	password                  *string
	email                     *string
	timezone                  *string
	profile_pic_url           *string
	thumbnail_url             *string
	phone_number              *string
	is_admin                  *bool
	is_super_admin            *bool
	last_login                *time.Time
	clearedFields             map[string]struct{}
	business_unit             *uuid.UUID
	clearedbusiness_unit      bool
	organization              *uuid.UUID
	clearedorganization       bool
	user_favorites            map[uuid.UUID]struct{}
	removeduser_favorites     map[uuid.UUID]struct{}
	cleareduser_favorites     bool
	user_notifications        map[uuid.UUID]struct{}
	removeduser_notifications map[uuid.UUID]struct{}
	cleareduser_notifications bool
	shipments                 map[uuid.UUID]struct{}
	removedshipments          map[uuid.UUID]struct{}
	clearedshipments          bool
	shipment_comments         map[uuid.UUID]struct{}
	removedshipment_comments  map[uuid.UUID]struct{}
	clearedshipment_comments  bool
	shipment_charges          map[uuid.UUID]struct{}
	removedshipment_charges   map[uuid.UUID]struct{}
	clearedshipment_charges   bool
	reports                   map[uuid.UUID]struct{}
	removedreports            map[uuid.UUID]struct{}
	clearedreports            bool
	roles                     map[uuid.UUID]struct{}
	removedroles              map[uuid.UUID]struct{}
	clearedroles              bool
	done                      bool
	oldValue                  func(context.Context) (*User, error)
	predicates                []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *UserMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *UserMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *UserMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *UserMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *UserMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *UserMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *UserMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *UserMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *UserMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *UserMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *UserMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(u user.Status) {
	m.status = &u
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r user.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v user.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetTimezone sets the "timezone" field.
func (m *UserMutation) SetTimezone(s string) {
	m.timezone = &s
}

// Timezone returns the value of the "timezone" field in the mutation.
func (m *UserMutation) Timezone() (r string, exists bool) {
	v := m.timezone
	if v == nil {
		return
	}
	return *v, true
}

// OldTimezone returns the old "timezone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTimezone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimezone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimezone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimezone: %w", err)
	}
	return oldValue.Timezone, nil
}

// ResetTimezone resets all changes to the "timezone" field.
func (m *UserMutation) ResetTimezone() {
	m.timezone = nil
}

// SetProfilePicURL sets the "profile_pic_url" field.
func (m *UserMutation) SetProfilePicURL(s string) {
	m.profile_pic_url = &s
}

// ProfilePicURL returns the value of the "profile_pic_url" field in the mutation.
func (m *UserMutation) ProfilePicURL() (r string, exists bool) {
	v := m.profile_pic_url
	if v == nil {
		return
	}
	return *v, true
}

// OldProfilePicURL returns the old "profile_pic_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldProfilePicURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfilePicURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfilePicURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfilePicURL: %w", err)
	}
	return oldValue.ProfilePicURL, nil
}

// ClearProfilePicURL clears the value of the "profile_pic_url" field.
func (m *UserMutation) ClearProfilePicURL() {
	m.profile_pic_url = nil
	m.clearedFields[user.FieldProfilePicURL] = struct{}{}
}

// ProfilePicURLCleared returns if the "profile_pic_url" field was cleared in this mutation.
func (m *UserMutation) ProfilePicURLCleared() bool {
	_, ok := m.clearedFields[user.FieldProfilePicURL]
	return ok
}

// ResetProfilePicURL resets all changes to the "profile_pic_url" field.
func (m *UserMutation) ResetProfilePicURL() {
	m.profile_pic_url = nil
	delete(m.clearedFields, user.FieldProfilePicURL)
}

// SetThumbnailURL sets the "thumbnail_url" field.
func (m *UserMutation) SetThumbnailURL(s string) {
	m.thumbnail_url = &s
}

// ThumbnailURL returns the value of the "thumbnail_url" field in the mutation.
func (m *UserMutation) ThumbnailURL() (r string, exists bool) {
	v := m.thumbnail_url
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnailURL returns the old "thumbnail_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldThumbnailURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnailURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnailURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnailURL: %w", err)
	}
	return oldValue.ThumbnailURL, nil
}

// ClearThumbnailURL clears the value of the "thumbnail_url" field.
func (m *UserMutation) ClearThumbnailURL() {
	m.thumbnail_url = nil
	m.clearedFields[user.FieldThumbnailURL] = struct{}{}
}

// ThumbnailURLCleared returns if the "thumbnail_url" field was cleared in this mutation.
func (m *UserMutation) ThumbnailURLCleared() bool {
	_, ok := m.clearedFields[user.FieldThumbnailURL]
	return ok
}

// ResetThumbnailURL resets all changes to the "thumbnail_url" field.
func (m *UserMutation) ResetThumbnailURL() {
	m.thumbnail_url = nil
	delete(m.clearedFields, user.FieldThumbnailURL)
}

// SetPhoneNumber sets the "phone_number" field.
func (m *UserMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *UserMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ClearPhoneNumber clears the value of the "phone_number" field.
func (m *UserMutation) ClearPhoneNumber() {
	m.phone_number = nil
	m.clearedFields[user.FieldPhoneNumber] = struct{}{}
}

// PhoneNumberCleared returns if the "phone_number" field was cleared in this mutation.
func (m *UserMutation) PhoneNumberCleared() bool {
	_, ok := m.clearedFields[user.FieldPhoneNumber]
	return ok
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *UserMutation) ResetPhoneNumber() {
	m.phone_number = nil
	delete(m.clearedFields, user.FieldPhoneNumber)
}

// SetIsAdmin sets the "is_admin" field.
func (m *UserMutation) SetIsAdmin(b bool) {
	m.is_admin = &b
}

// IsAdmin returns the value of the "is_admin" field in the mutation.
func (m *UserMutation) IsAdmin() (r bool, exists bool) {
	v := m.is_admin
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAdmin returns the old "is_admin" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsAdmin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAdmin: %w", err)
	}
	return oldValue.IsAdmin, nil
}

// ResetIsAdmin resets all changes to the "is_admin" field.
func (m *UserMutation) ResetIsAdmin() {
	m.is_admin = nil
}

// SetIsSuperAdmin sets the "is_super_admin" field.
func (m *UserMutation) SetIsSuperAdmin(b bool) {
	m.is_super_admin = &b
}

// IsSuperAdmin returns the value of the "is_super_admin" field in the mutation.
func (m *UserMutation) IsSuperAdmin() (r bool, exists bool) {
	v := m.is_super_admin
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSuperAdmin returns the old "is_super_admin" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsSuperAdmin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSuperAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSuperAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSuperAdmin: %w", err)
	}
	return oldValue.IsSuperAdmin, nil
}

// ResetIsSuperAdmin resets all changes to the "is_super_admin" field.
func (m *UserMutation) ResetIsSuperAdmin() {
	m.is_super_admin = nil
}

// SetLastLogin sets the "last_login" field.
func (m *UserMutation) SetLastLogin(t time.Time) {
	m.last_login = &t
}

// LastLogin returns the value of the "last_login" field in the mutation.
func (m *UserMutation) LastLogin() (r time.Time, exists bool) {
	v := m.last_login
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLogin returns the old "last_login" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLogin(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLogin: %w", err)
	}
	return oldValue.LastLogin, nil
}

// ClearLastLogin clears the value of the "last_login" field.
func (m *UserMutation) ClearLastLogin() {
	m.last_login = nil
	m.clearedFields[user.FieldLastLogin] = struct{}{}
}

// LastLoginCleared returns if the "last_login" field was cleared in this mutation.
func (m *UserMutation) LastLoginCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLogin]
	return ok
}

// ResetLastLogin resets all changes to the "last_login" field.
func (m *UserMutation) ResetLastLogin() {
	m.last_login = nil
	delete(m.clearedFields, user.FieldLastLogin)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *UserMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[user.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *UserMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *UserMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *UserMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *UserMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[user.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *UserMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *UserMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *UserMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// AddUserFavoriteIDs adds the "user_favorites" edge to the UserFavorite entity by ids.
func (m *UserMutation) AddUserFavoriteIDs(ids ...uuid.UUID) {
	if m.user_favorites == nil {
		m.user_favorites = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_favorites[ids[i]] = struct{}{}
	}
}

// ClearUserFavorites clears the "user_favorites" edge to the UserFavorite entity.
func (m *UserMutation) ClearUserFavorites() {
	m.cleareduser_favorites = true
}

// UserFavoritesCleared reports if the "user_favorites" edge to the UserFavorite entity was cleared.
func (m *UserMutation) UserFavoritesCleared() bool {
	return m.cleareduser_favorites
}

// RemoveUserFavoriteIDs removes the "user_favorites" edge to the UserFavorite entity by IDs.
func (m *UserMutation) RemoveUserFavoriteIDs(ids ...uuid.UUID) {
	if m.removeduser_favorites == nil {
		m.removeduser_favorites = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_favorites, ids[i])
		m.removeduser_favorites[ids[i]] = struct{}{}
	}
}

// RemovedUserFavorites returns the removed IDs of the "user_favorites" edge to the UserFavorite entity.
func (m *UserMutation) RemovedUserFavoritesIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_favorites {
		ids = append(ids, id)
	}
	return
}

// UserFavoritesIDs returns the "user_favorites" edge IDs in the mutation.
func (m *UserMutation) UserFavoritesIDs() (ids []uuid.UUID) {
	for id := range m.user_favorites {
		ids = append(ids, id)
	}
	return
}

// ResetUserFavorites resets all changes to the "user_favorites" edge.
func (m *UserMutation) ResetUserFavorites() {
	m.user_favorites = nil
	m.cleareduser_favorites = false
	m.removeduser_favorites = nil
}

// AddUserNotificationIDs adds the "user_notifications" edge to the UserNotification entity by ids.
func (m *UserMutation) AddUserNotificationIDs(ids ...uuid.UUID) {
	if m.user_notifications == nil {
		m.user_notifications = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_notifications[ids[i]] = struct{}{}
	}
}

// ClearUserNotifications clears the "user_notifications" edge to the UserNotification entity.
func (m *UserMutation) ClearUserNotifications() {
	m.cleareduser_notifications = true
}

// UserNotificationsCleared reports if the "user_notifications" edge to the UserNotification entity was cleared.
func (m *UserMutation) UserNotificationsCleared() bool {
	return m.cleareduser_notifications
}

// RemoveUserNotificationIDs removes the "user_notifications" edge to the UserNotification entity by IDs.
func (m *UserMutation) RemoveUserNotificationIDs(ids ...uuid.UUID) {
	if m.removeduser_notifications == nil {
		m.removeduser_notifications = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_notifications, ids[i])
		m.removeduser_notifications[ids[i]] = struct{}{}
	}
}

// RemovedUserNotifications returns the removed IDs of the "user_notifications" edge to the UserNotification entity.
func (m *UserMutation) RemovedUserNotificationsIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_notifications {
		ids = append(ids, id)
	}
	return
}

// UserNotificationsIDs returns the "user_notifications" edge IDs in the mutation.
func (m *UserMutation) UserNotificationsIDs() (ids []uuid.UUID) {
	for id := range m.user_notifications {
		ids = append(ids, id)
	}
	return
}

// ResetUserNotifications resets all changes to the "user_notifications" edge.
func (m *UserMutation) ResetUserNotifications() {
	m.user_notifications = nil
	m.cleareduser_notifications = false
	m.removeduser_notifications = nil
}

// AddShipmentIDs adds the "shipments" edge to the Shipment entity by ids.
func (m *UserMutation) AddShipmentIDs(ids ...uuid.UUID) {
	if m.shipments == nil {
		m.shipments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.shipments[ids[i]] = struct{}{}
	}
}

// ClearShipments clears the "shipments" edge to the Shipment entity.
func (m *UserMutation) ClearShipments() {
	m.clearedshipments = true
}

// ShipmentsCleared reports if the "shipments" edge to the Shipment entity was cleared.
func (m *UserMutation) ShipmentsCleared() bool {
	return m.clearedshipments
}

// RemoveShipmentIDs removes the "shipments" edge to the Shipment entity by IDs.
func (m *UserMutation) RemoveShipmentIDs(ids ...uuid.UUID) {
	if m.removedshipments == nil {
		m.removedshipments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.shipments, ids[i])
		m.removedshipments[ids[i]] = struct{}{}
	}
}

// RemovedShipments returns the removed IDs of the "shipments" edge to the Shipment entity.
func (m *UserMutation) RemovedShipmentsIDs() (ids []uuid.UUID) {
	for id := range m.removedshipments {
		ids = append(ids, id)
	}
	return
}

// ShipmentsIDs returns the "shipments" edge IDs in the mutation.
func (m *UserMutation) ShipmentsIDs() (ids []uuid.UUID) {
	for id := range m.shipments {
		ids = append(ids, id)
	}
	return
}

// ResetShipments resets all changes to the "shipments" edge.
func (m *UserMutation) ResetShipments() {
	m.shipments = nil
	m.clearedshipments = false
	m.removedshipments = nil
}

// AddShipmentCommentIDs adds the "shipment_comments" edge to the ShipmentComment entity by ids.
func (m *UserMutation) AddShipmentCommentIDs(ids ...uuid.UUID) {
	if m.shipment_comments == nil {
		m.shipment_comments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.shipment_comments[ids[i]] = struct{}{}
	}
}

// ClearShipmentComments clears the "shipment_comments" edge to the ShipmentComment entity.
func (m *UserMutation) ClearShipmentComments() {
	m.clearedshipment_comments = true
}

// ShipmentCommentsCleared reports if the "shipment_comments" edge to the ShipmentComment entity was cleared.
func (m *UserMutation) ShipmentCommentsCleared() bool {
	return m.clearedshipment_comments
}

// RemoveShipmentCommentIDs removes the "shipment_comments" edge to the ShipmentComment entity by IDs.
func (m *UserMutation) RemoveShipmentCommentIDs(ids ...uuid.UUID) {
	if m.removedshipment_comments == nil {
		m.removedshipment_comments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.shipment_comments, ids[i])
		m.removedshipment_comments[ids[i]] = struct{}{}
	}
}

// RemovedShipmentComments returns the removed IDs of the "shipment_comments" edge to the ShipmentComment entity.
func (m *UserMutation) RemovedShipmentCommentsIDs() (ids []uuid.UUID) {
	for id := range m.removedshipment_comments {
		ids = append(ids, id)
	}
	return
}

// ShipmentCommentsIDs returns the "shipment_comments" edge IDs in the mutation.
func (m *UserMutation) ShipmentCommentsIDs() (ids []uuid.UUID) {
	for id := range m.shipment_comments {
		ids = append(ids, id)
	}
	return
}

// ResetShipmentComments resets all changes to the "shipment_comments" edge.
func (m *UserMutation) ResetShipmentComments() {
	m.shipment_comments = nil
	m.clearedshipment_comments = false
	m.removedshipment_comments = nil
}

// AddShipmentChargeIDs adds the "shipment_charges" edge to the ShipmentCharges entity by ids.
func (m *UserMutation) AddShipmentChargeIDs(ids ...uuid.UUID) {
	if m.shipment_charges == nil {
		m.shipment_charges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.shipment_charges[ids[i]] = struct{}{}
	}
}

// ClearShipmentCharges clears the "shipment_charges" edge to the ShipmentCharges entity.
func (m *UserMutation) ClearShipmentCharges() {
	m.clearedshipment_charges = true
}

// ShipmentChargesCleared reports if the "shipment_charges" edge to the ShipmentCharges entity was cleared.
func (m *UserMutation) ShipmentChargesCleared() bool {
	return m.clearedshipment_charges
}

// RemoveShipmentChargeIDs removes the "shipment_charges" edge to the ShipmentCharges entity by IDs.
func (m *UserMutation) RemoveShipmentChargeIDs(ids ...uuid.UUID) {
	if m.removedshipment_charges == nil {
		m.removedshipment_charges = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.shipment_charges, ids[i])
		m.removedshipment_charges[ids[i]] = struct{}{}
	}
}

// RemovedShipmentCharges returns the removed IDs of the "shipment_charges" edge to the ShipmentCharges entity.
func (m *UserMutation) RemovedShipmentChargesIDs() (ids []uuid.UUID) {
	for id := range m.removedshipment_charges {
		ids = append(ids, id)
	}
	return
}

// ShipmentChargesIDs returns the "shipment_charges" edge IDs in the mutation.
func (m *UserMutation) ShipmentChargesIDs() (ids []uuid.UUID) {
	for id := range m.shipment_charges {
		ids = append(ids, id)
	}
	return
}

// ResetShipmentCharges resets all changes to the "shipment_charges" edge.
func (m *UserMutation) ResetShipmentCharges() {
	m.shipment_charges = nil
	m.clearedshipment_charges = false
	m.removedshipment_charges = nil
}

// AddReportIDs adds the "reports" edge to the UserReport entity by ids.
func (m *UserMutation) AddReportIDs(ids ...uuid.UUID) {
	if m.reports == nil {
		m.reports = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.reports[ids[i]] = struct{}{}
	}
}

// ClearReports clears the "reports" edge to the UserReport entity.
func (m *UserMutation) ClearReports() {
	m.clearedreports = true
}

// ReportsCleared reports if the "reports" edge to the UserReport entity was cleared.
func (m *UserMutation) ReportsCleared() bool {
	return m.clearedreports
}

// RemoveReportIDs removes the "reports" edge to the UserReport entity by IDs.
func (m *UserMutation) RemoveReportIDs(ids ...uuid.UUID) {
	if m.removedreports == nil {
		m.removedreports = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.reports, ids[i])
		m.removedreports[ids[i]] = struct{}{}
	}
}

// RemovedReports returns the removed IDs of the "reports" edge to the UserReport entity.
func (m *UserMutation) RemovedReportsIDs() (ids []uuid.UUID) {
	for id := range m.removedreports {
		ids = append(ids, id)
	}
	return
}

// ReportsIDs returns the "reports" edge IDs in the mutation.
func (m *UserMutation) ReportsIDs() (ids []uuid.UUID) {
	for id := range m.reports {
		ids = append(ids, id)
	}
	return
}

// ResetReports resets all changes to the "reports" edge.
func (m *UserMutation) ResetReports() {
	m.reports = nil
	m.clearedreports = false
	m.removedreports = nil
}

// AddRoleIDs adds the "roles" edge to the Role entity by ids.
func (m *UserMutation) AddRoleIDs(ids ...uuid.UUID) {
	if m.roles == nil {
		m.roles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *UserMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *UserMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role entity by IDs.
func (m *UserMutation) RemoveRoleIDs(ids ...uuid.UUID) {
	if m.removedroles == nil {
		m.removedroles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role entity.
func (m *UserMutation) RemovedRolesIDs() (ids []uuid.UUID) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *UserMutation) RolesIDs() (ids []uuid.UUID) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *UserMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.business_unit != nil {
		fields = append(fields, user.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, user.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, user.FieldVersion)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.timezone != nil {
		fields = append(fields, user.FieldTimezone)
	}
	if m.profile_pic_url != nil {
		fields = append(fields, user.FieldProfilePicURL)
	}
	if m.thumbnail_url != nil {
		fields = append(fields, user.FieldThumbnailURL)
	}
	if m.phone_number != nil {
		fields = append(fields, user.FieldPhoneNumber)
	}
	if m.is_admin != nil {
		fields = append(fields, user.FieldIsAdmin)
	}
	if m.is_super_admin != nil {
		fields = append(fields, user.FieldIsSuperAdmin)
	}
	if m.last_login != nil {
		fields = append(fields, user.FieldLastLogin)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case user.FieldOrganizationID:
		return m.OrganizationID()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldVersion:
		return m.Version()
	case user.FieldStatus:
		return m.Status()
	case user.FieldName:
		return m.Name()
	case user.FieldUsername:
		return m.Username()
	case user.FieldPassword:
		return m.Password()
	case user.FieldEmail:
		return m.Email()
	case user.FieldTimezone:
		return m.Timezone()
	case user.FieldProfilePicURL:
		return m.ProfilePicURL()
	case user.FieldThumbnailURL:
		return m.ThumbnailURL()
	case user.FieldPhoneNumber:
		return m.PhoneNumber()
	case user.FieldIsAdmin:
		return m.IsAdmin()
	case user.FieldIsSuperAdmin:
		return m.IsSuperAdmin()
	case user.FieldLastLogin:
		return m.LastLogin()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case user.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldVersion:
		return m.OldVersion(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldTimezone:
		return m.OldTimezone(ctx)
	case user.FieldProfilePicURL:
		return m.OldProfilePicURL(ctx)
	case user.FieldThumbnailURL:
		return m.OldThumbnailURL(ctx)
	case user.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case user.FieldIsAdmin:
		return m.OldIsAdmin(ctx)
	case user.FieldIsSuperAdmin:
		return m.OldIsSuperAdmin(ctx)
	case user.FieldLastLogin:
		return m.OldLastLogin(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case user.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(user.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldTimezone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimezone(v)
		return nil
	case user.FieldProfilePicURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfilePicURL(v)
		return nil
	case user.FieldThumbnailURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnailURL(v)
		return nil
	case user.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case user.FieldIsAdmin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAdmin(v)
		return nil
	case user.FieldIsSuperAdmin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSuperAdmin(v)
		return nil
	case user.FieldLastLogin:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLogin(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, user.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldProfilePicURL) {
		fields = append(fields, user.FieldProfilePicURL)
	}
	if m.FieldCleared(user.FieldThumbnailURL) {
		fields = append(fields, user.FieldThumbnailURL)
	}
	if m.FieldCleared(user.FieldPhoneNumber) {
		fields = append(fields, user.FieldPhoneNumber)
	}
	if m.FieldCleared(user.FieldLastLogin) {
		fields = append(fields, user.FieldLastLogin)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldProfilePicURL:
		m.ClearProfilePicURL()
		return nil
	case user.FieldThumbnailURL:
		m.ClearThumbnailURL()
		return nil
	case user.FieldPhoneNumber:
		m.ClearPhoneNumber()
		return nil
	case user.FieldLastLogin:
		m.ClearLastLogin()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case user.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldVersion:
		m.ResetVersion()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldTimezone:
		m.ResetTimezone()
		return nil
	case user.FieldProfilePicURL:
		m.ResetProfilePicURL()
		return nil
	case user.FieldThumbnailURL:
		m.ResetThumbnailURL()
		return nil
	case user.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case user.FieldIsAdmin:
		m.ResetIsAdmin()
		return nil
	case user.FieldIsSuperAdmin:
		m.ResetIsSuperAdmin()
		return nil
	case user.FieldLastLogin:
		m.ResetLastLogin()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.business_unit != nil {
		edges = append(edges, user.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, user.EdgeOrganization)
	}
	if m.user_favorites != nil {
		edges = append(edges, user.EdgeUserFavorites)
	}
	if m.user_notifications != nil {
		edges = append(edges, user.EdgeUserNotifications)
	}
	if m.shipments != nil {
		edges = append(edges, user.EdgeShipments)
	}
	if m.shipment_comments != nil {
		edges = append(edges, user.EdgeShipmentComments)
	}
	if m.shipment_charges != nil {
		edges = append(edges, user.EdgeShipmentCharges)
	}
	if m.reports != nil {
		edges = append(edges, user.EdgeReports)
	}
	if m.roles != nil {
		edges = append(edges, user.EdgeRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeUserFavorites:
		ids := make([]ent.Value, 0, len(m.user_favorites))
		for id := range m.user_favorites {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserNotifications:
		ids := make([]ent.Value, 0, len(m.user_notifications))
		for id := range m.user_notifications {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeShipments:
		ids := make([]ent.Value, 0, len(m.shipments))
		for id := range m.shipments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeShipmentComments:
		ids := make([]ent.Value, 0, len(m.shipment_comments))
		for id := range m.shipment_comments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeShipmentCharges:
		ids := make([]ent.Value, 0, len(m.shipment_charges))
		for id := range m.shipment_charges {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReports:
		ids := make([]ent.Value, 0, len(m.reports))
		for id := range m.reports {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removeduser_favorites != nil {
		edges = append(edges, user.EdgeUserFavorites)
	}
	if m.removeduser_notifications != nil {
		edges = append(edges, user.EdgeUserNotifications)
	}
	if m.removedshipments != nil {
		edges = append(edges, user.EdgeShipments)
	}
	if m.removedshipment_comments != nil {
		edges = append(edges, user.EdgeShipmentComments)
	}
	if m.removedshipment_charges != nil {
		edges = append(edges, user.EdgeShipmentCharges)
	}
	if m.removedreports != nil {
		edges = append(edges, user.EdgeReports)
	}
	if m.removedroles != nil {
		edges = append(edges, user.EdgeRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserFavorites:
		ids := make([]ent.Value, 0, len(m.removeduser_favorites))
		for id := range m.removeduser_favorites {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserNotifications:
		ids := make([]ent.Value, 0, len(m.removeduser_notifications))
		for id := range m.removeduser_notifications {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeShipments:
		ids := make([]ent.Value, 0, len(m.removedshipments))
		for id := range m.removedshipments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeShipmentComments:
		ids := make([]ent.Value, 0, len(m.removedshipment_comments))
		for id := range m.removedshipment_comments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeShipmentCharges:
		ids := make([]ent.Value, 0, len(m.removedshipment_charges))
		for id := range m.removedshipment_charges {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReports:
		ids := make([]ent.Value, 0, len(m.removedreports))
		for id := range m.removedreports {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedbusiness_unit {
		edges = append(edges, user.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, user.EdgeOrganization)
	}
	if m.cleareduser_favorites {
		edges = append(edges, user.EdgeUserFavorites)
	}
	if m.cleareduser_notifications {
		edges = append(edges, user.EdgeUserNotifications)
	}
	if m.clearedshipments {
		edges = append(edges, user.EdgeShipments)
	}
	if m.clearedshipment_comments {
		edges = append(edges, user.EdgeShipmentComments)
	}
	if m.clearedshipment_charges {
		edges = append(edges, user.EdgeShipmentCharges)
	}
	if m.clearedreports {
		edges = append(edges, user.EdgeReports)
	}
	if m.clearedroles {
		edges = append(edges, user.EdgeRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case user.EdgeOrganization:
		return m.clearedorganization
	case user.EdgeUserFavorites:
		return m.cleareduser_favorites
	case user.EdgeUserNotifications:
		return m.cleareduser_notifications
	case user.EdgeShipments:
		return m.clearedshipments
	case user.EdgeShipmentComments:
		return m.clearedshipment_comments
	case user.EdgeShipmentCharges:
		return m.clearedshipment_charges
	case user.EdgeReports:
		return m.clearedreports
	case user.EdgeRoles:
		return m.clearedroles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case user.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case user.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case user.EdgeUserFavorites:
		m.ResetUserFavorites()
		return nil
	case user.EdgeUserNotifications:
		m.ResetUserNotifications()
		return nil
	case user.EdgeShipments:
		m.ResetShipments()
		return nil
	case user.EdgeShipmentComments:
		m.ResetShipmentComments()
		return nil
	case user.EdgeShipmentCharges:
		m.ResetShipmentCharges()
		return nil
	case user.EdgeReports:
		m.ResetReports()
		return nil
	case user.EdgeRoles:
		m.ResetRoles()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserFavoriteMutation represents an operation that mutates the UserFavorite nodes in the graph.
type UserFavoriteMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	version              *int
	addversion           *int
	page_link            *string
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	user                 *uuid.UUID
	cleareduser          bool
	done                 bool
	oldValue             func(context.Context) (*UserFavorite, error)
	predicates           []predicate.UserFavorite
}

var _ ent.Mutation = (*UserFavoriteMutation)(nil)

// userfavoriteOption allows management of the mutation configuration using functional options.
type userfavoriteOption func(*UserFavoriteMutation)

// newUserFavoriteMutation creates new mutation for the UserFavorite entity.
func newUserFavoriteMutation(c config, op Op, opts ...userfavoriteOption) *UserFavoriteMutation {
	m := &UserFavoriteMutation{
		config:        c,
		op:            op,
		typ:           TypeUserFavorite,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserFavoriteID sets the ID field of the mutation.
func withUserFavoriteID(id uuid.UUID) userfavoriteOption {
	return func(m *UserFavoriteMutation) {
		var (
			err   error
			once  sync.Once
			value *UserFavorite
		)
		m.oldValue = func(ctx context.Context) (*UserFavorite, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserFavorite.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserFavorite sets the old UserFavorite of the mutation.
func withUserFavorite(node *UserFavorite) userfavoriteOption {
	return func(m *UserFavoriteMutation) {
		m.oldValue = func(context.Context) (*UserFavorite, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserFavoriteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserFavoriteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserFavorite entities.
func (m *UserFavoriteMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserFavoriteMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserFavoriteMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserFavorite.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *UserFavoriteMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *UserFavoriteMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the UserFavorite entity.
// If the UserFavorite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFavoriteMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *UserFavoriteMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *UserFavoriteMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *UserFavoriteMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the UserFavorite entity.
// If the UserFavorite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFavoriteMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *UserFavoriteMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserFavoriteMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserFavoriteMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserFavorite entity.
// If the UserFavorite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFavoriteMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserFavoriteMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserFavoriteMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserFavoriteMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserFavorite entity.
// If the UserFavorite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFavoriteMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserFavoriteMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *UserFavoriteMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *UserFavoriteMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the UserFavorite entity.
// If the UserFavorite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFavoriteMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *UserFavoriteMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *UserFavoriteMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *UserFavoriteMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetPageLink sets the "page_link" field.
func (m *UserFavoriteMutation) SetPageLink(s string) {
	m.page_link = &s
}

// PageLink returns the value of the "page_link" field in the mutation.
func (m *UserFavoriteMutation) PageLink() (r string, exists bool) {
	v := m.page_link
	if v == nil {
		return
	}
	return *v, true
}

// OldPageLink returns the old "page_link" field's value of the UserFavorite entity.
// If the UserFavorite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFavoriteMutation) OldPageLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPageLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPageLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPageLink: %w", err)
	}
	return oldValue.PageLink, nil
}

// ResetPageLink resets all changes to the "page_link" field.
func (m *UserFavoriteMutation) ResetPageLink() {
	m.page_link = nil
}

// SetUserID sets the "user_id" field.
func (m *UserFavoriteMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserFavoriteMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserFavorite entity.
// If the UserFavorite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFavoriteMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserFavoriteMutation) ResetUserID() {
	m.user = nil
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *UserFavoriteMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[userfavorite.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *UserFavoriteMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *UserFavoriteMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *UserFavoriteMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *UserFavoriteMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[userfavorite.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *UserFavoriteMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *UserFavoriteMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *UserFavoriteMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserFavoriteMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userfavorite.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserFavoriteMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserFavoriteMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserFavoriteMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserFavoriteMutation builder.
func (m *UserFavoriteMutation) Where(ps ...predicate.UserFavorite) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserFavoriteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserFavoriteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserFavorite, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserFavoriteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserFavoriteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserFavorite).
func (m *UserFavoriteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserFavoriteMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.business_unit != nil {
		fields = append(fields, userfavorite.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, userfavorite.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, userfavorite.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userfavorite.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, userfavorite.FieldVersion)
	}
	if m.page_link != nil {
		fields = append(fields, userfavorite.FieldPageLink)
	}
	if m.user != nil {
		fields = append(fields, userfavorite.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserFavoriteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userfavorite.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case userfavorite.FieldOrganizationID:
		return m.OrganizationID()
	case userfavorite.FieldCreatedAt:
		return m.CreatedAt()
	case userfavorite.FieldUpdatedAt:
		return m.UpdatedAt()
	case userfavorite.FieldVersion:
		return m.Version()
	case userfavorite.FieldPageLink:
		return m.PageLink()
	case userfavorite.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserFavoriteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userfavorite.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case userfavorite.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case userfavorite.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userfavorite.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userfavorite.FieldVersion:
		return m.OldVersion(ctx)
	case userfavorite.FieldPageLink:
		return m.OldPageLink(ctx)
	case userfavorite.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown UserFavorite field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserFavoriteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userfavorite.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case userfavorite.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case userfavorite.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userfavorite.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userfavorite.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case userfavorite.FieldPageLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPageLink(v)
		return nil
	case userfavorite.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown UserFavorite field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserFavoriteMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, userfavorite.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserFavoriteMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userfavorite.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserFavoriteMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userfavorite.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown UserFavorite numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserFavoriteMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserFavoriteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserFavoriteMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserFavorite nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserFavoriteMutation) ResetField(name string) error {
	switch name {
	case userfavorite.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case userfavorite.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case userfavorite.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userfavorite.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userfavorite.FieldVersion:
		m.ResetVersion()
		return nil
	case userfavorite.FieldPageLink:
		m.ResetPageLink()
		return nil
	case userfavorite.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown UserFavorite field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserFavoriteMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.business_unit != nil {
		edges = append(edges, userfavorite.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, userfavorite.EdgeOrganization)
	}
	if m.user != nil {
		edges = append(edges, userfavorite.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserFavoriteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userfavorite.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case userfavorite.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case userfavorite.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserFavoriteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserFavoriteMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserFavoriteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbusiness_unit {
		edges = append(edges, userfavorite.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, userfavorite.EdgeOrganization)
	}
	if m.cleareduser {
		edges = append(edges, userfavorite.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserFavoriteMutation) EdgeCleared(name string) bool {
	switch name {
	case userfavorite.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case userfavorite.EdgeOrganization:
		return m.clearedorganization
	case userfavorite.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserFavoriteMutation) ClearEdge(name string) error {
	switch name {
	case userfavorite.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case userfavorite.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case userfavorite.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserFavorite unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserFavoriteMutation) ResetEdge(name string) error {
	switch name {
	case userfavorite.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case userfavorite.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case userfavorite.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserFavorite edge %s", name)
}

// UserNotificationMutation represents an operation that mutates the UserNotification nodes in the graph.
type UserNotificationMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	version              *int
	addversion           *int
	is_read              *bool
	title                *string
	description          *string
	action_url           *string
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	user                 *uuid.UUID
	cleareduser          bool
	done                 bool
	oldValue             func(context.Context) (*UserNotification, error)
	predicates           []predicate.UserNotification
}

var _ ent.Mutation = (*UserNotificationMutation)(nil)

// usernotificationOption allows management of the mutation configuration using functional options.
type usernotificationOption func(*UserNotificationMutation)

// newUserNotificationMutation creates new mutation for the UserNotification entity.
func newUserNotificationMutation(c config, op Op, opts ...usernotificationOption) *UserNotificationMutation {
	m := &UserNotificationMutation{
		config:        c,
		op:            op,
		typ:           TypeUserNotification,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserNotificationID sets the ID field of the mutation.
func withUserNotificationID(id uuid.UUID) usernotificationOption {
	return func(m *UserNotificationMutation) {
		var (
			err   error
			once  sync.Once
			value *UserNotification
		)
		m.oldValue = func(ctx context.Context) (*UserNotification, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserNotification.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserNotification sets the old UserNotification of the mutation.
func withUserNotification(node *UserNotification) usernotificationOption {
	return func(m *UserNotificationMutation) {
		m.oldValue = func(context.Context) (*UserNotification, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserNotificationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserNotificationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserNotification entities.
func (m *UserNotificationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserNotificationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserNotificationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserNotification.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *UserNotificationMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *UserNotificationMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the UserNotification entity.
// If the UserNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNotificationMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *UserNotificationMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *UserNotificationMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *UserNotificationMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the UserNotification entity.
// If the UserNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNotificationMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *UserNotificationMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserNotificationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserNotificationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserNotification entity.
// If the UserNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNotificationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserNotificationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserNotificationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserNotificationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserNotification entity.
// If the UserNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNotificationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserNotificationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *UserNotificationMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *UserNotificationMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the UserNotification entity.
// If the UserNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNotificationMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *UserNotificationMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *UserNotificationMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *UserNotificationMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetUserID sets the "user_id" field.
func (m *UserNotificationMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserNotificationMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserNotification entity.
// If the UserNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNotificationMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserNotificationMutation) ResetUserID() {
	m.user = nil
}

// SetIsRead sets the "is_read" field.
func (m *UserNotificationMutation) SetIsRead(b bool) {
	m.is_read = &b
}

// IsRead returns the value of the "is_read" field in the mutation.
func (m *UserNotificationMutation) IsRead() (r bool, exists bool) {
	v := m.is_read
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRead returns the old "is_read" field's value of the UserNotification entity.
// If the UserNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNotificationMutation) OldIsRead(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRead is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRead requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRead: %w", err)
	}
	return oldValue.IsRead, nil
}

// ResetIsRead resets all changes to the "is_read" field.
func (m *UserNotificationMutation) ResetIsRead() {
	m.is_read = nil
}

// SetTitle sets the "title" field.
func (m *UserNotificationMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *UserNotificationMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the UserNotification entity.
// If the UserNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNotificationMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *UserNotificationMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *UserNotificationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UserNotificationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the UserNotification entity.
// If the UserNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNotificationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *UserNotificationMutation) ResetDescription() {
	m.description = nil
}

// SetActionURL sets the "action_url" field.
func (m *UserNotificationMutation) SetActionURL(s string) {
	m.action_url = &s
}

// ActionURL returns the value of the "action_url" field in the mutation.
func (m *UserNotificationMutation) ActionURL() (r string, exists bool) {
	v := m.action_url
	if v == nil {
		return
	}
	return *v, true
}

// OldActionURL returns the old "action_url" field's value of the UserNotification entity.
// If the UserNotification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserNotificationMutation) OldActionURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionURL: %w", err)
	}
	return oldValue.ActionURL, nil
}

// ClearActionURL clears the value of the "action_url" field.
func (m *UserNotificationMutation) ClearActionURL() {
	m.action_url = nil
	m.clearedFields[usernotification.FieldActionURL] = struct{}{}
}

// ActionURLCleared returns if the "action_url" field was cleared in this mutation.
func (m *UserNotificationMutation) ActionURLCleared() bool {
	_, ok := m.clearedFields[usernotification.FieldActionURL]
	return ok
}

// ResetActionURL resets all changes to the "action_url" field.
func (m *UserNotificationMutation) ResetActionURL() {
	m.action_url = nil
	delete(m.clearedFields, usernotification.FieldActionURL)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *UserNotificationMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[usernotification.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *UserNotificationMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *UserNotificationMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *UserNotificationMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *UserNotificationMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[usernotification.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *UserNotificationMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *UserNotificationMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *UserNotificationMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserNotificationMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[usernotification.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserNotificationMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserNotificationMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserNotificationMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserNotificationMutation builder.
func (m *UserNotificationMutation) Where(ps ...predicate.UserNotification) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserNotificationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserNotificationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserNotification, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserNotificationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserNotificationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserNotification).
func (m *UserNotificationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserNotificationMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.business_unit != nil {
		fields = append(fields, usernotification.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, usernotification.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, usernotification.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usernotification.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, usernotification.FieldVersion)
	}
	if m.user != nil {
		fields = append(fields, usernotification.FieldUserID)
	}
	if m.is_read != nil {
		fields = append(fields, usernotification.FieldIsRead)
	}
	if m.title != nil {
		fields = append(fields, usernotification.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, usernotification.FieldDescription)
	}
	if m.action_url != nil {
		fields = append(fields, usernotification.FieldActionURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserNotificationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usernotification.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case usernotification.FieldOrganizationID:
		return m.OrganizationID()
	case usernotification.FieldCreatedAt:
		return m.CreatedAt()
	case usernotification.FieldUpdatedAt:
		return m.UpdatedAt()
	case usernotification.FieldVersion:
		return m.Version()
	case usernotification.FieldUserID:
		return m.UserID()
	case usernotification.FieldIsRead:
		return m.IsRead()
	case usernotification.FieldTitle:
		return m.Title()
	case usernotification.FieldDescription:
		return m.Description()
	case usernotification.FieldActionURL:
		return m.ActionURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserNotificationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usernotification.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case usernotification.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case usernotification.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usernotification.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case usernotification.FieldVersion:
		return m.OldVersion(ctx)
	case usernotification.FieldUserID:
		return m.OldUserID(ctx)
	case usernotification.FieldIsRead:
		return m.OldIsRead(ctx)
	case usernotification.FieldTitle:
		return m.OldTitle(ctx)
	case usernotification.FieldDescription:
		return m.OldDescription(ctx)
	case usernotification.FieldActionURL:
		return m.OldActionURL(ctx)
	}
	return nil, fmt.Errorf("unknown UserNotification field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserNotificationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usernotification.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case usernotification.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case usernotification.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usernotification.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case usernotification.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case usernotification.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case usernotification.FieldIsRead:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRead(v)
		return nil
	case usernotification.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case usernotification.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case usernotification.FieldActionURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionURL(v)
		return nil
	}
	return fmt.Errorf("unknown UserNotification field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserNotificationMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, usernotification.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserNotificationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case usernotification.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserNotificationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case usernotification.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown UserNotification numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserNotificationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usernotification.FieldActionURL) {
		fields = append(fields, usernotification.FieldActionURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserNotificationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserNotificationMutation) ClearField(name string) error {
	switch name {
	case usernotification.FieldActionURL:
		m.ClearActionURL()
		return nil
	}
	return fmt.Errorf("unknown UserNotification nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserNotificationMutation) ResetField(name string) error {
	switch name {
	case usernotification.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case usernotification.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case usernotification.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usernotification.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case usernotification.FieldVersion:
		m.ResetVersion()
		return nil
	case usernotification.FieldUserID:
		m.ResetUserID()
		return nil
	case usernotification.FieldIsRead:
		m.ResetIsRead()
		return nil
	case usernotification.FieldTitle:
		m.ResetTitle()
		return nil
	case usernotification.FieldDescription:
		m.ResetDescription()
		return nil
	case usernotification.FieldActionURL:
		m.ResetActionURL()
		return nil
	}
	return fmt.Errorf("unknown UserNotification field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserNotificationMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.business_unit != nil {
		edges = append(edges, usernotification.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, usernotification.EdgeOrganization)
	}
	if m.user != nil {
		edges = append(edges, usernotification.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserNotificationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usernotification.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case usernotification.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case usernotification.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserNotificationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserNotificationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserNotificationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbusiness_unit {
		edges = append(edges, usernotification.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, usernotification.EdgeOrganization)
	}
	if m.cleareduser {
		edges = append(edges, usernotification.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserNotificationMutation) EdgeCleared(name string) bool {
	switch name {
	case usernotification.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case usernotification.EdgeOrganization:
		return m.clearedorganization
	case usernotification.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserNotificationMutation) ClearEdge(name string) error {
	switch name {
	case usernotification.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case usernotification.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case usernotification.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserNotification unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserNotificationMutation) ResetEdge(name string) error {
	switch name {
	case usernotification.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case usernotification.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case usernotification.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserNotification edge %s", name)
}

// UserReportMutation represents an operation that mutates the UserReport nodes in the graph.
type UserReportMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	version              *int
	addversion           *int
	report_url           *string
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	user                 *uuid.UUID
	cleareduser          bool
	done                 bool
	oldValue             func(context.Context) (*UserReport, error)
	predicates           []predicate.UserReport
}

var _ ent.Mutation = (*UserReportMutation)(nil)

// userreportOption allows management of the mutation configuration using functional options.
type userreportOption func(*UserReportMutation)

// newUserReportMutation creates new mutation for the UserReport entity.
func newUserReportMutation(c config, op Op, opts ...userreportOption) *UserReportMutation {
	m := &UserReportMutation{
		config:        c,
		op:            op,
		typ:           TypeUserReport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserReportID sets the ID field of the mutation.
func withUserReportID(id uuid.UUID) userreportOption {
	return func(m *UserReportMutation) {
		var (
			err   error
			once  sync.Once
			value *UserReport
		)
		m.oldValue = func(ctx context.Context) (*UserReport, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserReport.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserReport sets the old UserReport of the mutation.
func withUserReport(node *UserReport) userreportOption {
	return func(m *UserReportMutation) {
		m.oldValue = func(context.Context) (*UserReport, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserReportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserReportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserReport entities.
func (m *UserReportMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserReportMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserReportMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserReport.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *UserReportMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *UserReportMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the UserReport entity.
// If the UserReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserReportMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *UserReportMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *UserReportMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *UserReportMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the UserReport entity.
// If the UserReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserReportMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *UserReportMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserReportMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserReportMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserReport entity.
// If the UserReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserReportMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserReportMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserReportMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserReportMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserReport entity.
// If the UserReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserReportMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserReportMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *UserReportMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *UserReportMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the UserReport entity.
// If the UserReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserReportMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *UserReportMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *UserReportMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *UserReportMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetReportURL sets the "report_url" field.
func (m *UserReportMutation) SetReportURL(s string) {
	m.report_url = &s
}

// ReportURL returns the value of the "report_url" field in the mutation.
func (m *UserReportMutation) ReportURL() (r string, exists bool) {
	v := m.report_url
	if v == nil {
		return
	}
	return *v, true
}

// OldReportURL returns the old "report_url" field's value of the UserReport entity.
// If the UserReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserReportMutation) OldReportURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportURL: %w", err)
	}
	return oldValue.ReportURL, nil
}

// ResetReportURL resets all changes to the "report_url" field.
func (m *UserReportMutation) ResetReportURL() {
	m.report_url = nil
}

// SetUserID sets the "user_id" field.
func (m *UserReportMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserReportMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserReport entity.
// If the UserReport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserReportMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserReportMutation) ResetUserID() {
	m.user = nil
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *UserReportMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[userreport.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *UserReportMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *UserReportMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *UserReportMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *UserReportMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[userreport.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *UserReportMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *UserReportMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *UserReportMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserReportMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userreport.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserReportMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserReportMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserReportMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserReportMutation builder.
func (m *UserReportMutation) Where(ps ...predicate.UserReport) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserReportMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserReportMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserReport, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserReportMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserReportMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserReport).
func (m *UserReportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserReportMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.business_unit != nil {
		fields = append(fields, userreport.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, userreport.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, userreport.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userreport.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, userreport.FieldVersion)
	}
	if m.report_url != nil {
		fields = append(fields, userreport.FieldReportURL)
	}
	if m.user != nil {
		fields = append(fields, userreport.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserReportMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userreport.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case userreport.FieldOrganizationID:
		return m.OrganizationID()
	case userreport.FieldCreatedAt:
		return m.CreatedAt()
	case userreport.FieldUpdatedAt:
		return m.UpdatedAt()
	case userreport.FieldVersion:
		return m.Version()
	case userreport.FieldReportURL:
		return m.ReportURL()
	case userreport.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserReportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userreport.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case userreport.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case userreport.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userreport.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userreport.FieldVersion:
		return m.OldVersion(ctx)
	case userreport.FieldReportURL:
		return m.OldReportURL(ctx)
	case userreport.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown UserReport field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserReportMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userreport.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case userreport.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case userreport.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userreport.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userreport.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case userreport.FieldReportURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportURL(v)
		return nil
	case userreport.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown UserReport field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserReportMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, userreport.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserReportMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userreport.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserReportMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userreport.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown UserReport numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserReportMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserReportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserReportMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserReport nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserReportMutation) ResetField(name string) error {
	switch name {
	case userreport.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case userreport.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case userreport.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userreport.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userreport.FieldVersion:
		m.ResetVersion()
		return nil
	case userreport.FieldReportURL:
		m.ResetReportURL()
		return nil
	case userreport.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown UserReport field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserReportMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.business_unit != nil {
		edges = append(edges, userreport.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, userreport.EdgeOrganization)
	}
	if m.user != nil {
		edges = append(edges, userreport.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserReportMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userreport.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case userreport.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case userreport.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserReportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserReportMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserReportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbusiness_unit {
		edges = append(edges, userreport.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, userreport.EdgeOrganization)
	}
	if m.cleareduser {
		edges = append(edges, userreport.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserReportMutation) EdgeCleared(name string) bool {
	switch name {
	case userreport.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case userreport.EdgeOrganization:
		return m.clearedorganization
	case userreport.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserReportMutation) ClearEdge(name string) error {
	switch name {
	case userreport.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case userreport.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case userreport.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserReport unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserReportMutation) ResetEdge(name string) error {
	switch name {
	case userreport.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case userreport.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case userreport.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserReport edge %s", name)
}

// WorkerMutation represents an operation that mutates the Worker nodes in the graph.
type WorkerMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	created_at               *time.Time
	updated_at               *time.Time
	version                  *int
	addversion               *int
	status                   *worker.Status
	code                     *string
	profile_picture_url      *string
	worker_type              *worker.WorkerType
	first_name               *string
	last_name                *string
	address_line_1           *string
	address_line_2           *string
	city                     *string
	postal_code              *string
	external_id              *string
	clearedFields            map[string]struct{}
	business_unit            *uuid.UUID
	clearedbusiness_unit     bool
	organization             *uuid.UUID
	clearedorganization      bool
	state                    *uuid.UUID
	clearedstate             bool
	fleet_code               *uuid.UUID
	clearedfleet_code        bool
	manager                  *uuid.UUID
	clearedmanager           bool
	primary_tractor          *uuid.UUID
	clearedprimary_tractor   bool
	secondary_tractor        *uuid.UUID
	clearedsecondary_tractor bool
	worker_profile           *uuid.UUID
	clearedworker_profile    bool
	worker_comments          map[uuid.UUID]struct{}
	removedworker_comments   map[uuid.UUID]struct{}
	clearedworker_comments   bool
	worker_contacts          map[uuid.UUID]struct{}
	removedworker_contacts   map[uuid.UUID]struct{}
	clearedworker_contacts   bool
	done                     bool
	oldValue                 func(context.Context) (*Worker, error)
	predicates               []predicate.Worker
}

var _ ent.Mutation = (*WorkerMutation)(nil)

// workerOption allows management of the mutation configuration using functional options.
type workerOption func(*WorkerMutation)

// newWorkerMutation creates new mutation for the Worker entity.
func newWorkerMutation(c config, op Op, opts ...workerOption) *WorkerMutation {
	m := &WorkerMutation{
		config:        c,
		op:            op,
		typ:           TypeWorker,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkerID sets the ID field of the mutation.
func withWorkerID(id uuid.UUID) workerOption {
	return func(m *WorkerMutation) {
		var (
			err   error
			once  sync.Once
			value *Worker
		)
		m.oldValue = func(ctx context.Context) (*Worker, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Worker.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorker sets the old Worker of the mutation.
func withWorker(node *Worker) workerOption {
	return func(m *WorkerMutation) {
		m.oldValue = func(context.Context) (*Worker, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Worker entities.
func (m *WorkerMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkerMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkerMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Worker.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *WorkerMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *WorkerMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the Worker entity.
// If the Worker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *WorkerMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *WorkerMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *WorkerMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Worker entity.
// If the Worker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *WorkerMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Worker entity.
// If the Worker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Worker entity.
// If the Worker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *WorkerMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *WorkerMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Worker entity.
// If the Worker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *WorkerMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *WorkerMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *WorkerMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetStatus sets the "status" field.
func (m *WorkerMutation) SetStatus(w worker.Status) {
	m.status = &w
}

// Status returns the value of the "status" field in the mutation.
func (m *WorkerMutation) Status() (r worker.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Worker entity.
// If the Worker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerMutation) OldStatus(ctx context.Context) (v worker.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *WorkerMutation) ResetStatus() {
	m.status = nil
}

// SetCode sets the "code" field.
func (m *WorkerMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *WorkerMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Worker entity.
// If the Worker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *WorkerMutation) ResetCode() {
	m.code = nil
}

// SetProfilePictureURL sets the "profile_picture_url" field.
func (m *WorkerMutation) SetProfilePictureURL(s string) {
	m.profile_picture_url = &s
}

// ProfilePictureURL returns the value of the "profile_picture_url" field in the mutation.
func (m *WorkerMutation) ProfilePictureURL() (r string, exists bool) {
	v := m.profile_picture_url
	if v == nil {
		return
	}
	return *v, true
}

// OldProfilePictureURL returns the old "profile_picture_url" field's value of the Worker entity.
// If the Worker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerMutation) OldProfilePictureURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfilePictureURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfilePictureURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfilePictureURL: %w", err)
	}
	return oldValue.ProfilePictureURL, nil
}

// ClearProfilePictureURL clears the value of the "profile_picture_url" field.
func (m *WorkerMutation) ClearProfilePictureURL() {
	m.profile_picture_url = nil
	m.clearedFields[worker.FieldProfilePictureURL] = struct{}{}
}

// ProfilePictureURLCleared returns if the "profile_picture_url" field was cleared in this mutation.
func (m *WorkerMutation) ProfilePictureURLCleared() bool {
	_, ok := m.clearedFields[worker.FieldProfilePictureURL]
	return ok
}

// ResetProfilePictureURL resets all changes to the "profile_picture_url" field.
func (m *WorkerMutation) ResetProfilePictureURL() {
	m.profile_picture_url = nil
	delete(m.clearedFields, worker.FieldProfilePictureURL)
}

// SetWorkerType sets the "worker_type" field.
func (m *WorkerMutation) SetWorkerType(wt worker.WorkerType) {
	m.worker_type = &wt
}

// WorkerType returns the value of the "worker_type" field in the mutation.
func (m *WorkerMutation) WorkerType() (r worker.WorkerType, exists bool) {
	v := m.worker_type
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkerType returns the old "worker_type" field's value of the Worker entity.
// If the Worker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerMutation) OldWorkerType(ctx context.Context) (v worker.WorkerType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkerType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkerType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkerType: %w", err)
	}
	return oldValue.WorkerType, nil
}

// ResetWorkerType resets all changes to the "worker_type" field.
func (m *WorkerMutation) ResetWorkerType() {
	m.worker_type = nil
}

// SetFirstName sets the "first_name" field.
func (m *WorkerMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *WorkerMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the Worker entity.
// If the Worker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *WorkerMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *WorkerMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *WorkerMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the Worker entity.
// If the Worker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *WorkerMutation) ResetLastName() {
	m.last_name = nil
}

// SetAddressLine1 sets the "address_line_1" field.
func (m *WorkerMutation) SetAddressLine1(s string) {
	m.address_line_1 = &s
}

// AddressLine1 returns the value of the "address_line_1" field in the mutation.
func (m *WorkerMutation) AddressLine1() (r string, exists bool) {
	v := m.address_line_1
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressLine1 returns the old "address_line_1" field's value of the Worker entity.
// If the Worker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerMutation) OldAddressLine1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddressLine1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddressLine1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressLine1: %w", err)
	}
	return oldValue.AddressLine1, nil
}

// ClearAddressLine1 clears the value of the "address_line_1" field.
func (m *WorkerMutation) ClearAddressLine1() {
	m.address_line_1 = nil
	m.clearedFields[worker.FieldAddressLine1] = struct{}{}
}

// AddressLine1Cleared returns if the "address_line_1" field was cleared in this mutation.
func (m *WorkerMutation) AddressLine1Cleared() bool {
	_, ok := m.clearedFields[worker.FieldAddressLine1]
	return ok
}

// ResetAddressLine1 resets all changes to the "address_line_1" field.
func (m *WorkerMutation) ResetAddressLine1() {
	m.address_line_1 = nil
	delete(m.clearedFields, worker.FieldAddressLine1)
}

// SetAddressLine2 sets the "address_line_2" field.
func (m *WorkerMutation) SetAddressLine2(s string) {
	m.address_line_2 = &s
}

// AddressLine2 returns the value of the "address_line_2" field in the mutation.
func (m *WorkerMutation) AddressLine2() (r string, exists bool) {
	v := m.address_line_2
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressLine2 returns the old "address_line_2" field's value of the Worker entity.
// If the Worker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerMutation) OldAddressLine2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddressLine2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddressLine2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressLine2: %w", err)
	}
	return oldValue.AddressLine2, nil
}

// ClearAddressLine2 clears the value of the "address_line_2" field.
func (m *WorkerMutation) ClearAddressLine2() {
	m.address_line_2 = nil
	m.clearedFields[worker.FieldAddressLine2] = struct{}{}
}

// AddressLine2Cleared returns if the "address_line_2" field was cleared in this mutation.
func (m *WorkerMutation) AddressLine2Cleared() bool {
	_, ok := m.clearedFields[worker.FieldAddressLine2]
	return ok
}

// ResetAddressLine2 resets all changes to the "address_line_2" field.
func (m *WorkerMutation) ResetAddressLine2() {
	m.address_line_2 = nil
	delete(m.clearedFields, worker.FieldAddressLine2)
}

// SetCity sets the "city" field.
func (m *WorkerMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *WorkerMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Worker entity.
// If the Worker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ClearCity clears the value of the "city" field.
func (m *WorkerMutation) ClearCity() {
	m.city = nil
	m.clearedFields[worker.FieldCity] = struct{}{}
}

// CityCleared returns if the "city" field was cleared in this mutation.
func (m *WorkerMutation) CityCleared() bool {
	_, ok := m.clearedFields[worker.FieldCity]
	return ok
}

// ResetCity resets all changes to the "city" field.
func (m *WorkerMutation) ResetCity() {
	m.city = nil
	delete(m.clearedFields, worker.FieldCity)
}

// SetPostalCode sets the "postal_code" field.
func (m *WorkerMutation) SetPostalCode(s string) {
	m.postal_code = &s
}

// PostalCode returns the value of the "postal_code" field in the mutation.
func (m *WorkerMutation) PostalCode() (r string, exists bool) {
	v := m.postal_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPostalCode returns the old "postal_code" field's value of the Worker entity.
// If the Worker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerMutation) OldPostalCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostalCode: %w", err)
	}
	return oldValue.PostalCode, nil
}

// ClearPostalCode clears the value of the "postal_code" field.
func (m *WorkerMutation) ClearPostalCode() {
	m.postal_code = nil
	m.clearedFields[worker.FieldPostalCode] = struct{}{}
}

// PostalCodeCleared returns if the "postal_code" field was cleared in this mutation.
func (m *WorkerMutation) PostalCodeCleared() bool {
	_, ok := m.clearedFields[worker.FieldPostalCode]
	return ok
}

// ResetPostalCode resets all changes to the "postal_code" field.
func (m *WorkerMutation) ResetPostalCode() {
	m.postal_code = nil
	delete(m.clearedFields, worker.FieldPostalCode)
}

// SetStateID sets the "state_id" field.
func (m *WorkerMutation) SetStateID(u uuid.UUID) {
	m.state = &u
}

// StateID returns the value of the "state_id" field in the mutation.
func (m *WorkerMutation) StateID() (r uuid.UUID, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldStateID returns the old "state_id" field's value of the Worker entity.
// If the Worker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerMutation) OldStateID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStateID: %w", err)
	}
	return oldValue.StateID, nil
}

// ClearStateID clears the value of the "state_id" field.
func (m *WorkerMutation) ClearStateID() {
	m.state = nil
	m.clearedFields[worker.FieldStateID] = struct{}{}
}

// StateIDCleared returns if the "state_id" field was cleared in this mutation.
func (m *WorkerMutation) StateIDCleared() bool {
	_, ok := m.clearedFields[worker.FieldStateID]
	return ok
}

// ResetStateID resets all changes to the "state_id" field.
func (m *WorkerMutation) ResetStateID() {
	m.state = nil
	delete(m.clearedFields, worker.FieldStateID)
}

// SetFleetCodeID sets the "fleet_code_id" field.
func (m *WorkerMutation) SetFleetCodeID(u uuid.UUID) {
	m.fleet_code = &u
}

// FleetCodeID returns the value of the "fleet_code_id" field in the mutation.
func (m *WorkerMutation) FleetCodeID() (r uuid.UUID, exists bool) {
	v := m.fleet_code
	if v == nil {
		return
	}
	return *v, true
}

// OldFleetCodeID returns the old "fleet_code_id" field's value of the Worker entity.
// If the Worker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerMutation) OldFleetCodeID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFleetCodeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFleetCodeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFleetCodeID: %w", err)
	}
	return oldValue.FleetCodeID, nil
}

// ClearFleetCodeID clears the value of the "fleet_code_id" field.
func (m *WorkerMutation) ClearFleetCodeID() {
	m.fleet_code = nil
	m.clearedFields[worker.FieldFleetCodeID] = struct{}{}
}

// FleetCodeIDCleared returns if the "fleet_code_id" field was cleared in this mutation.
func (m *WorkerMutation) FleetCodeIDCleared() bool {
	_, ok := m.clearedFields[worker.FieldFleetCodeID]
	return ok
}

// ResetFleetCodeID resets all changes to the "fleet_code_id" field.
func (m *WorkerMutation) ResetFleetCodeID() {
	m.fleet_code = nil
	delete(m.clearedFields, worker.FieldFleetCodeID)
}

// SetManagerID sets the "manager_id" field.
func (m *WorkerMutation) SetManagerID(u uuid.UUID) {
	m.manager = &u
}

// ManagerID returns the value of the "manager_id" field in the mutation.
func (m *WorkerMutation) ManagerID() (r uuid.UUID, exists bool) {
	v := m.manager
	if v == nil {
		return
	}
	return *v, true
}

// OldManagerID returns the old "manager_id" field's value of the Worker entity.
// If the Worker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerMutation) OldManagerID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManagerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManagerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManagerID: %w", err)
	}
	return oldValue.ManagerID, nil
}

// ClearManagerID clears the value of the "manager_id" field.
func (m *WorkerMutation) ClearManagerID() {
	m.manager = nil
	m.clearedFields[worker.FieldManagerID] = struct{}{}
}

// ManagerIDCleared returns if the "manager_id" field was cleared in this mutation.
func (m *WorkerMutation) ManagerIDCleared() bool {
	_, ok := m.clearedFields[worker.FieldManagerID]
	return ok
}

// ResetManagerID resets all changes to the "manager_id" field.
func (m *WorkerMutation) ResetManagerID() {
	m.manager = nil
	delete(m.clearedFields, worker.FieldManagerID)
}

// SetExternalID sets the "external_id" field.
func (m *WorkerMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *WorkerMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the Worker entity.
// If the Worker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *WorkerMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[worker.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *WorkerMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[worker.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *WorkerMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, worker.FieldExternalID)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *WorkerMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[worker.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *WorkerMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *WorkerMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *WorkerMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *WorkerMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[worker.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *WorkerMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *WorkerMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *WorkerMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearState clears the "state" edge to the UsState entity.
func (m *WorkerMutation) ClearState() {
	m.clearedstate = true
	m.clearedFields[worker.FieldStateID] = struct{}{}
}

// StateCleared reports if the "state" edge to the UsState entity was cleared.
func (m *WorkerMutation) StateCleared() bool {
	return m.StateIDCleared() || m.clearedstate
}

// StateIDs returns the "state" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StateID instead. It exists only for internal usage by the builders.
func (m *WorkerMutation) StateIDs() (ids []uuid.UUID) {
	if id := m.state; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetState resets all changes to the "state" edge.
func (m *WorkerMutation) ResetState() {
	m.state = nil
	m.clearedstate = false
}

// ClearFleetCode clears the "fleet_code" edge to the FleetCode entity.
func (m *WorkerMutation) ClearFleetCode() {
	m.clearedfleet_code = true
	m.clearedFields[worker.FieldFleetCodeID] = struct{}{}
}

// FleetCodeCleared reports if the "fleet_code" edge to the FleetCode entity was cleared.
func (m *WorkerMutation) FleetCodeCleared() bool {
	return m.FleetCodeIDCleared() || m.clearedfleet_code
}

// FleetCodeIDs returns the "fleet_code" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FleetCodeID instead. It exists only for internal usage by the builders.
func (m *WorkerMutation) FleetCodeIDs() (ids []uuid.UUID) {
	if id := m.fleet_code; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFleetCode resets all changes to the "fleet_code" edge.
func (m *WorkerMutation) ResetFleetCode() {
	m.fleet_code = nil
	m.clearedfleet_code = false
}

// ClearManager clears the "manager" edge to the User entity.
func (m *WorkerMutation) ClearManager() {
	m.clearedmanager = true
	m.clearedFields[worker.FieldManagerID] = struct{}{}
}

// ManagerCleared reports if the "manager" edge to the User entity was cleared.
func (m *WorkerMutation) ManagerCleared() bool {
	return m.ManagerIDCleared() || m.clearedmanager
}

// ManagerIDs returns the "manager" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ManagerID instead. It exists only for internal usage by the builders.
func (m *WorkerMutation) ManagerIDs() (ids []uuid.UUID) {
	if id := m.manager; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetManager resets all changes to the "manager" edge.
func (m *WorkerMutation) ResetManager() {
	m.manager = nil
	m.clearedmanager = false
}

// SetPrimaryTractorID sets the "primary_tractor" edge to the Tractor entity by id.
func (m *WorkerMutation) SetPrimaryTractorID(id uuid.UUID) {
	m.primary_tractor = &id
}

// ClearPrimaryTractor clears the "primary_tractor" edge to the Tractor entity.
func (m *WorkerMutation) ClearPrimaryTractor() {
	m.clearedprimary_tractor = true
}

// PrimaryTractorCleared reports if the "primary_tractor" edge to the Tractor entity was cleared.
func (m *WorkerMutation) PrimaryTractorCleared() bool {
	return m.clearedprimary_tractor
}

// PrimaryTractorID returns the "primary_tractor" edge ID in the mutation.
func (m *WorkerMutation) PrimaryTractorID() (id uuid.UUID, exists bool) {
	if m.primary_tractor != nil {
		return *m.primary_tractor, true
	}
	return
}

// PrimaryTractorIDs returns the "primary_tractor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PrimaryTractorID instead. It exists only for internal usage by the builders.
func (m *WorkerMutation) PrimaryTractorIDs() (ids []uuid.UUID) {
	if id := m.primary_tractor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrimaryTractor resets all changes to the "primary_tractor" edge.
func (m *WorkerMutation) ResetPrimaryTractor() {
	m.primary_tractor = nil
	m.clearedprimary_tractor = false
}

// SetSecondaryTractorID sets the "secondary_tractor" edge to the Tractor entity by id.
func (m *WorkerMutation) SetSecondaryTractorID(id uuid.UUID) {
	m.secondary_tractor = &id
}

// ClearSecondaryTractor clears the "secondary_tractor" edge to the Tractor entity.
func (m *WorkerMutation) ClearSecondaryTractor() {
	m.clearedsecondary_tractor = true
}

// SecondaryTractorCleared reports if the "secondary_tractor" edge to the Tractor entity was cleared.
func (m *WorkerMutation) SecondaryTractorCleared() bool {
	return m.clearedsecondary_tractor
}

// SecondaryTractorID returns the "secondary_tractor" edge ID in the mutation.
func (m *WorkerMutation) SecondaryTractorID() (id uuid.UUID, exists bool) {
	if m.secondary_tractor != nil {
		return *m.secondary_tractor, true
	}
	return
}

// SecondaryTractorIDs returns the "secondary_tractor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SecondaryTractorID instead. It exists only for internal usage by the builders.
func (m *WorkerMutation) SecondaryTractorIDs() (ids []uuid.UUID) {
	if id := m.secondary_tractor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSecondaryTractor resets all changes to the "secondary_tractor" edge.
func (m *WorkerMutation) ResetSecondaryTractor() {
	m.secondary_tractor = nil
	m.clearedsecondary_tractor = false
}

// SetWorkerProfileID sets the "worker_profile" edge to the WorkerProfile entity by id.
func (m *WorkerMutation) SetWorkerProfileID(id uuid.UUID) {
	m.worker_profile = &id
}

// ClearWorkerProfile clears the "worker_profile" edge to the WorkerProfile entity.
func (m *WorkerMutation) ClearWorkerProfile() {
	m.clearedworker_profile = true
}

// WorkerProfileCleared reports if the "worker_profile" edge to the WorkerProfile entity was cleared.
func (m *WorkerMutation) WorkerProfileCleared() bool {
	return m.clearedworker_profile
}

// WorkerProfileID returns the "worker_profile" edge ID in the mutation.
func (m *WorkerMutation) WorkerProfileID() (id uuid.UUID, exists bool) {
	if m.worker_profile != nil {
		return *m.worker_profile, true
	}
	return
}

// WorkerProfileIDs returns the "worker_profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkerProfileID instead. It exists only for internal usage by the builders.
func (m *WorkerMutation) WorkerProfileIDs() (ids []uuid.UUID) {
	if id := m.worker_profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkerProfile resets all changes to the "worker_profile" edge.
func (m *WorkerMutation) ResetWorkerProfile() {
	m.worker_profile = nil
	m.clearedworker_profile = false
}

// AddWorkerCommentIDs adds the "worker_comments" edge to the WorkerComment entity by ids.
func (m *WorkerMutation) AddWorkerCommentIDs(ids ...uuid.UUID) {
	if m.worker_comments == nil {
		m.worker_comments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.worker_comments[ids[i]] = struct{}{}
	}
}

// ClearWorkerComments clears the "worker_comments" edge to the WorkerComment entity.
func (m *WorkerMutation) ClearWorkerComments() {
	m.clearedworker_comments = true
}

// WorkerCommentsCleared reports if the "worker_comments" edge to the WorkerComment entity was cleared.
func (m *WorkerMutation) WorkerCommentsCleared() bool {
	return m.clearedworker_comments
}

// RemoveWorkerCommentIDs removes the "worker_comments" edge to the WorkerComment entity by IDs.
func (m *WorkerMutation) RemoveWorkerCommentIDs(ids ...uuid.UUID) {
	if m.removedworker_comments == nil {
		m.removedworker_comments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.worker_comments, ids[i])
		m.removedworker_comments[ids[i]] = struct{}{}
	}
}

// RemovedWorkerComments returns the removed IDs of the "worker_comments" edge to the WorkerComment entity.
func (m *WorkerMutation) RemovedWorkerCommentsIDs() (ids []uuid.UUID) {
	for id := range m.removedworker_comments {
		ids = append(ids, id)
	}
	return
}

// WorkerCommentsIDs returns the "worker_comments" edge IDs in the mutation.
func (m *WorkerMutation) WorkerCommentsIDs() (ids []uuid.UUID) {
	for id := range m.worker_comments {
		ids = append(ids, id)
	}
	return
}

// ResetWorkerComments resets all changes to the "worker_comments" edge.
func (m *WorkerMutation) ResetWorkerComments() {
	m.worker_comments = nil
	m.clearedworker_comments = false
	m.removedworker_comments = nil
}

// AddWorkerContactIDs adds the "worker_contacts" edge to the WorkerContact entity by ids.
func (m *WorkerMutation) AddWorkerContactIDs(ids ...uuid.UUID) {
	if m.worker_contacts == nil {
		m.worker_contacts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.worker_contacts[ids[i]] = struct{}{}
	}
}

// ClearWorkerContacts clears the "worker_contacts" edge to the WorkerContact entity.
func (m *WorkerMutation) ClearWorkerContacts() {
	m.clearedworker_contacts = true
}

// WorkerContactsCleared reports if the "worker_contacts" edge to the WorkerContact entity was cleared.
func (m *WorkerMutation) WorkerContactsCleared() bool {
	return m.clearedworker_contacts
}

// RemoveWorkerContactIDs removes the "worker_contacts" edge to the WorkerContact entity by IDs.
func (m *WorkerMutation) RemoveWorkerContactIDs(ids ...uuid.UUID) {
	if m.removedworker_contacts == nil {
		m.removedworker_contacts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.worker_contacts, ids[i])
		m.removedworker_contacts[ids[i]] = struct{}{}
	}
}

// RemovedWorkerContacts returns the removed IDs of the "worker_contacts" edge to the WorkerContact entity.
func (m *WorkerMutation) RemovedWorkerContactsIDs() (ids []uuid.UUID) {
	for id := range m.removedworker_contacts {
		ids = append(ids, id)
	}
	return
}

// WorkerContactsIDs returns the "worker_contacts" edge IDs in the mutation.
func (m *WorkerMutation) WorkerContactsIDs() (ids []uuid.UUID) {
	for id := range m.worker_contacts {
		ids = append(ids, id)
	}
	return
}

// ResetWorkerContacts resets all changes to the "worker_contacts" edge.
func (m *WorkerMutation) ResetWorkerContacts() {
	m.worker_contacts = nil
	m.clearedworker_contacts = false
	m.removedworker_contacts = nil
}

// Where appends a list predicates to the WorkerMutation builder.
func (m *WorkerMutation) Where(ps ...predicate.Worker) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Worker, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Worker).
func (m *WorkerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkerMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.business_unit != nil {
		fields = append(fields, worker.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, worker.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, worker.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, worker.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, worker.FieldVersion)
	}
	if m.status != nil {
		fields = append(fields, worker.FieldStatus)
	}
	if m.code != nil {
		fields = append(fields, worker.FieldCode)
	}
	if m.profile_picture_url != nil {
		fields = append(fields, worker.FieldProfilePictureURL)
	}
	if m.worker_type != nil {
		fields = append(fields, worker.FieldWorkerType)
	}
	if m.first_name != nil {
		fields = append(fields, worker.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, worker.FieldLastName)
	}
	if m.address_line_1 != nil {
		fields = append(fields, worker.FieldAddressLine1)
	}
	if m.address_line_2 != nil {
		fields = append(fields, worker.FieldAddressLine2)
	}
	if m.city != nil {
		fields = append(fields, worker.FieldCity)
	}
	if m.postal_code != nil {
		fields = append(fields, worker.FieldPostalCode)
	}
	if m.state != nil {
		fields = append(fields, worker.FieldStateID)
	}
	if m.fleet_code != nil {
		fields = append(fields, worker.FieldFleetCodeID)
	}
	if m.manager != nil {
		fields = append(fields, worker.FieldManagerID)
	}
	if m.external_id != nil {
		fields = append(fields, worker.FieldExternalID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case worker.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case worker.FieldOrganizationID:
		return m.OrganizationID()
	case worker.FieldCreatedAt:
		return m.CreatedAt()
	case worker.FieldUpdatedAt:
		return m.UpdatedAt()
	case worker.FieldVersion:
		return m.Version()
	case worker.FieldStatus:
		return m.Status()
	case worker.FieldCode:
		return m.Code()
	case worker.FieldProfilePictureURL:
		return m.ProfilePictureURL()
	case worker.FieldWorkerType:
		return m.WorkerType()
	case worker.FieldFirstName:
		return m.FirstName()
	case worker.FieldLastName:
		return m.LastName()
	case worker.FieldAddressLine1:
		return m.AddressLine1()
	case worker.FieldAddressLine2:
		return m.AddressLine2()
	case worker.FieldCity:
		return m.City()
	case worker.FieldPostalCode:
		return m.PostalCode()
	case worker.FieldStateID:
		return m.StateID()
	case worker.FieldFleetCodeID:
		return m.FleetCodeID()
	case worker.FieldManagerID:
		return m.ManagerID()
	case worker.FieldExternalID:
		return m.ExternalID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case worker.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case worker.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case worker.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case worker.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case worker.FieldVersion:
		return m.OldVersion(ctx)
	case worker.FieldStatus:
		return m.OldStatus(ctx)
	case worker.FieldCode:
		return m.OldCode(ctx)
	case worker.FieldProfilePictureURL:
		return m.OldProfilePictureURL(ctx)
	case worker.FieldWorkerType:
		return m.OldWorkerType(ctx)
	case worker.FieldFirstName:
		return m.OldFirstName(ctx)
	case worker.FieldLastName:
		return m.OldLastName(ctx)
	case worker.FieldAddressLine1:
		return m.OldAddressLine1(ctx)
	case worker.FieldAddressLine2:
		return m.OldAddressLine2(ctx)
	case worker.FieldCity:
		return m.OldCity(ctx)
	case worker.FieldPostalCode:
		return m.OldPostalCode(ctx)
	case worker.FieldStateID:
		return m.OldStateID(ctx)
	case worker.FieldFleetCodeID:
		return m.OldFleetCodeID(ctx)
	case worker.FieldManagerID:
		return m.OldManagerID(ctx)
	case worker.FieldExternalID:
		return m.OldExternalID(ctx)
	}
	return nil, fmt.Errorf("unknown Worker field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case worker.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case worker.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case worker.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case worker.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case worker.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case worker.FieldStatus:
		v, ok := value.(worker.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case worker.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case worker.FieldProfilePictureURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfilePictureURL(v)
		return nil
	case worker.FieldWorkerType:
		v, ok := value.(worker.WorkerType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkerType(v)
		return nil
	case worker.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case worker.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case worker.FieldAddressLine1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressLine1(v)
		return nil
	case worker.FieldAddressLine2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressLine2(v)
		return nil
	case worker.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case worker.FieldPostalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostalCode(v)
		return nil
	case worker.FieldStateID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStateID(v)
		return nil
	case worker.FieldFleetCodeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFleetCodeID(v)
		return nil
	case worker.FieldManagerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManagerID(v)
		return nil
	case worker.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	}
	return fmt.Errorf("unknown Worker field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkerMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, worker.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case worker.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case worker.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Worker numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(worker.FieldProfilePictureURL) {
		fields = append(fields, worker.FieldProfilePictureURL)
	}
	if m.FieldCleared(worker.FieldAddressLine1) {
		fields = append(fields, worker.FieldAddressLine1)
	}
	if m.FieldCleared(worker.FieldAddressLine2) {
		fields = append(fields, worker.FieldAddressLine2)
	}
	if m.FieldCleared(worker.FieldCity) {
		fields = append(fields, worker.FieldCity)
	}
	if m.FieldCleared(worker.FieldPostalCode) {
		fields = append(fields, worker.FieldPostalCode)
	}
	if m.FieldCleared(worker.FieldStateID) {
		fields = append(fields, worker.FieldStateID)
	}
	if m.FieldCleared(worker.FieldFleetCodeID) {
		fields = append(fields, worker.FieldFleetCodeID)
	}
	if m.FieldCleared(worker.FieldManagerID) {
		fields = append(fields, worker.FieldManagerID)
	}
	if m.FieldCleared(worker.FieldExternalID) {
		fields = append(fields, worker.FieldExternalID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkerMutation) ClearField(name string) error {
	switch name {
	case worker.FieldProfilePictureURL:
		m.ClearProfilePictureURL()
		return nil
	case worker.FieldAddressLine1:
		m.ClearAddressLine1()
		return nil
	case worker.FieldAddressLine2:
		m.ClearAddressLine2()
		return nil
	case worker.FieldCity:
		m.ClearCity()
		return nil
	case worker.FieldPostalCode:
		m.ClearPostalCode()
		return nil
	case worker.FieldStateID:
		m.ClearStateID()
		return nil
	case worker.FieldFleetCodeID:
		m.ClearFleetCodeID()
		return nil
	case worker.FieldManagerID:
		m.ClearManagerID()
		return nil
	case worker.FieldExternalID:
		m.ClearExternalID()
		return nil
	}
	return fmt.Errorf("unknown Worker nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkerMutation) ResetField(name string) error {
	switch name {
	case worker.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case worker.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case worker.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case worker.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case worker.FieldVersion:
		m.ResetVersion()
		return nil
	case worker.FieldStatus:
		m.ResetStatus()
		return nil
	case worker.FieldCode:
		m.ResetCode()
		return nil
	case worker.FieldProfilePictureURL:
		m.ResetProfilePictureURL()
		return nil
	case worker.FieldWorkerType:
		m.ResetWorkerType()
		return nil
	case worker.FieldFirstName:
		m.ResetFirstName()
		return nil
	case worker.FieldLastName:
		m.ResetLastName()
		return nil
	case worker.FieldAddressLine1:
		m.ResetAddressLine1()
		return nil
	case worker.FieldAddressLine2:
		m.ResetAddressLine2()
		return nil
	case worker.FieldCity:
		m.ResetCity()
		return nil
	case worker.FieldPostalCode:
		m.ResetPostalCode()
		return nil
	case worker.FieldStateID:
		m.ResetStateID()
		return nil
	case worker.FieldFleetCodeID:
		m.ResetFleetCodeID()
		return nil
	case worker.FieldManagerID:
		m.ResetManagerID()
		return nil
	case worker.FieldExternalID:
		m.ResetExternalID()
		return nil
	}
	return fmt.Errorf("unknown Worker field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkerMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m.business_unit != nil {
		edges = append(edges, worker.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, worker.EdgeOrganization)
	}
	if m.state != nil {
		edges = append(edges, worker.EdgeState)
	}
	if m.fleet_code != nil {
		edges = append(edges, worker.EdgeFleetCode)
	}
	if m.manager != nil {
		edges = append(edges, worker.EdgeManager)
	}
	if m.primary_tractor != nil {
		edges = append(edges, worker.EdgePrimaryTractor)
	}
	if m.secondary_tractor != nil {
		edges = append(edges, worker.EdgeSecondaryTractor)
	}
	if m.worker_profile != nil {
		edges = append(edges, worker.EdgeWorkerProfile)
	}
	if m.worker_comments != nil {
		edges = append(edges, worker.EdgeWorkerComments)
	}
	if m.worker_contacts != nil {
		edges = append(edges, worker.EdgeWorkerContacts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case worker.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case worker.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case worker.EdgeState:
		if id := m.state; id != nil {
			return []ent.Value{*id}
		}
	case worker.EdgeFleetCode:
		if id := m.fleet_code; id != nil {
			return []ent.Value{*id}
		}
	case worker.EdgeManager:
		if id := m.manager; id != nil {
			return []ent.Value{*id}
		}
	case worker.EdgePrimaryTractor:
		if id := m.primary_tractor; id != nil {
			return []ent.Value{*id}
		}
	case worker.EdgeSecondaryTractor:
		if id := m.secondary_tractor; id != nil {
			return []ent.Value{*id}
		}
	case worker.EdgeWorkerProfile:
		if id := m.worker_profile; id != nil {
			return []ent.Value{*id}
		}
	case worker.EdgeWorkerComments:
		ids := make([]ent.Value, 0, len(m.worker_comments))
		for id := range m.worker_comments {
			ids = append(ids, id)
		}
		return ids
	case worker.EdgeWorkerContacts:
		ids := make([]ent.Value, 0, len(m.worker_contacts))
		for id := range m.worker_contacts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	if m.removedworker_comments != nil {
		edges = append(edges, worker.EdgeWorkerComments)
	}
	if m.removedworker_contacts != nil {
		edges = append(edges, worker.EdgeWorkerContacts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case worker.EdgeWorkerComments:
		ids := make([]ent.Value, 0, len(m.removedworker_comments))
		for id := range m.removedworker_comments {
			ids = append(ids, id)
		}
		return ids
	case worker.EdgeWorkerContacts:
		ids := make([]ent.Value, 0, len(m.removedworker_contacts))
		for id := range m.removedworker_contacts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.clearedbusiness_unit {
		edges = append(edges, worker.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, worker.EdgeOrganization)
	}
	if m.clearedstate {
		edges = append(edges, worker.EdgeState)
	}
	if m.clearedfleet_code {
		edges = append(edges, worker.EdgeFleetCode)
	}
	if m.clearedmanager {
		edges = append(edges, worker.EdgeManager)
	}
	if m.clearedprimary_tractor {
		edges = append(edges, worker.EdgePrimaryTractor)
	}
	if m.clearedsecondary_tractor {
		edges = append(edges, worker.EdgeSecondaryTractor)
	}
	if m.clearedworker_profile {
		edges = append(edges, worker.EdgeWorkerProfile)
	}
	if m.clearedworker_comments {
		edges = append(edges, worker.EdgeWorkerComments)
	}
	if m.clearedworker_contacts {
		edges = append(edges, worker.EdgeWorkerContacts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkerMutation) EdgeCleared(name string) bool {
	switch name {
	case worker.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case worker.EdgeOrganization:
		return m.clearedorganization
	case worker.EdgeState:
		return m.clearedstate
	case worker.EdgeFleetCode:
		return m.clearedfleet_code
	case worker.EdgeManager:
		return m.clearedmanager
	case worker.EdgePrimaryTractor:
		return m.clearedprimary_tractor
	case worker.EdgeSecondaryTractor:
		return m.clearedsecondary_tractor
	case worker.EdgeWorkerProfile:
		return m.clearedworker_profile
	case worker.EdgeWorkerComments:
		return m.clearedworker_comments
	case worker.EdgeWorkerContacts:
		return m.clearedworker_contacts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkerMutation) ClearEdge(name string) error {
	switch name {
	case worker.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case worker.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case worker.EdgeState:
		m.ClearState()
		return nil
	case worker.EdgeFleetCode:
		m.ClearFleetCode()
		return nil
	case worker.EdgeManager:
		m.ClearManager()
		return nil
	case worker.EdgePrimaryTractor:
		m.ClearPrimaryTractor()
		return nil
	case worker.EdgeSecondaryTractor:
		m.ClearSecondaryTractor()
		return nil
	case worker.EdgeWorkerProfile:
		m.ClearWorkerProfile()
		return nil
	}
	return fmt.Errorf("unknown Worker unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkerMutation) ResetEdge(name string) error {
	switch name {
	case worker.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case worker.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case worker.EdgeState:
		m.ResetState()
		return nil
	case worker.EdgeFleetCode:
		m.ResetFleetCode()
		return nil
	case worker.EdgeManager:
		m.ResetManager()
		return nil
	case worker.EdgePrimaryTractor:
		m.ResetPrimaryTractor()
		return nil
	case worker.EdgeSecondaryTractor:
		m.ResetSecondaryTractor()
		return nil
	case worker.EdgeWorkerProfile:
		m.ResetWorkerProfile()
		return nil
	case worker.EdgeWorkerComments:
		m.ResetWorkerComments()
		return nil
	case worker.EdgeWorkerContacts:
		m.ResetWorkerContacts()
		return nil
	}
	return fmt.Errorf("unknown Worker edge %s", name)
}

// WorkerCommentMutation represents an operation that mutates the WorkerComment nodes in the graph.
type WorkerCommentMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	version              *int
	addversion           *int
	comment              *string
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	worker               *uuid.UUID
	clearedworker        bool
	comment_type         *uuid.UUID
	clearedcomment_type  bool
	user                 *uuid.UUID
	cleareduser          bool
	done                 bool
	oldValue             func(context.Context) (*WorkerComment, error)
	predicates           []predicate.WorkerComment
}

var _ ent.Mutation = (*WorkerCommentMutation)(nil)

// workercommentOption allows management of the mutation configuration using functional options.
type workercommentOption func(*WorkerCommentMutation)

// newWorkerCommentMutation creates new mutation for the WorkerComment entity.
func newWorkerCommentMutation(c config, op Op, opts ...workercommentOption) *WorkerCommentMutation {
	m := &WorkerCommentMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkerComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkerCommentID sets the ID field of the mutation.
func withWorkerCommentID(id uuid.UUID) workercommentOption {
	return func(m *WorkerCommentMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkerComment
		)
		m.oldValue = func(ctx context.Context) (*WorkerComment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkerComment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkerComment sets the old WorkerComment of the mutation.
func withWorkerComment(node *WorkerComment) workercommentOption {
	return func(m *WorkerCommentMutation) {
		m.oldValue = func(context.Context) (*WorkerComment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkerCommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkerCommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkerComment entities.
func (m *WorkerCommentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkerCommentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkerCommentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkerComment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *WorkerCommentMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *WorkerCommentMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the WorkerComment entity.
// If the WorkerComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerCommentMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *WorkerCommentMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *WorkerCommentMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *WorkerCommentMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the WorkerComment entity.
// If the WorkerComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerCommentMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *WorkerCommentMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkerCommentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkerCommentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WorkerComment entity.
// If the WorkerComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerCommentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkerCommentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkerCommentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkerCommentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WorkerComment entity.
// If the WorkerComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerCommentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkerCommentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *WorkerCommentMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *WorkerCommentMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the WorkerComment entity.
// If the WorkerComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerCommentMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *WorkerCommentMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *WorkerCommentMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *WorkerCommentMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetWorkerID sets the "worker_id" field.
func (m *WorkerCommentMutation) SetWorkerID(u uuid.UUID) {
	m.worker = &u
}

// WorkerID returns the value of the "worker_id" field in the mutation.
func (m *WorkerCommentMutation) WorkerID() (r uuid.UUID, exists bool) {
	v := m.worker
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkerID returns the old "worker_id" field's value of the WorkerComment entity.
// If the WorkerComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerCommentMutation) OldWorkerID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkerID: %w", err)
	}
	return oldValue.WorkerID, nil
}

// ResetWorkerID resets all changes to the "worker_id" field.
func (m *WorkerCommentMutation) ResetWorkerID() {
	m.worker = nil
}

// SetCommentTypeID sets the "comment_type_id" field.
func (m *WorkerCommentMutation) SetCommentTypeID(u uuid.UUID) {
	m.comment_type = &u
}

// CommentTypeID returns the value of the "comment_type_id" field in the mutation.
func (m *WorkerCommentMutation) CommentTypeID() (r uuid.UUID, exists bool) {
	v := m.comment_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCommentTypeID returns the old "comment_type_id" field's value of the WorkerComment entity.
// If the WorkerComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerCommentMutation) OldCommentTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommentTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommentTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommentTypeID: %w", err)
	}
	return oldValue.CommentTypeID, nil
}

// ResetCommentTypeID resets all changes to the "comment_type_id" field.
func (m *WorkerCommentMutation) ResetCommentTypeID() {
	m.comment_type = nil
}

// SetUserID sets the "user_id" field.
func (m *WorkerCommentMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *WorkerCommentMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the WorkerComment entity.
// If the WorkerComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerCommentMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *WorkerCommentMutation) ResetUserID() {
	m.user = nil
}

// SetComment sets the "comment" field.
func (m *WorkerCommentMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *WorkerCommentMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the WorkerComment entity.
// If the WorkerComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerCommentMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ResetComment resets all changes to the "comment" field.
func (m *WorkerCommentMutation) ResetComment() {
	m.comment = nil
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *WorkerCommentMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[workercomment.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *WorkerCommentMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *WorkerCommentMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *WorkerCommentMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *WorkerCommentMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[workercomment.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *WorkerCommentMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *WorkerCommentMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *WorkerCommentMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearWorker clears the "worker" edge to the Worker entity.
func (m *WorkerCommentMutation) ClearWorker() {
	m.clearedworker = true
	m.clearedFields[workercomment.FieldWorkerID] = struct{}{}
}

// WorkerCleared reports if the "worker" edge to the Worker entity was cleared.
func (m *WorkerCommentMutation) WorkerCleared() bool {
	return m.clearedworker
}

// WorkerIDs returns the "worker" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkerID instead. It exists only for internal usage by the builders.
func (m *WorkerCommentMutation) WorkerIDs() (ids []uuid.UUID) {
	if id := m.worker; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorker resets all changes to the "worker" edge.
func (m *WorkerCommentMutation) ResetWorker() {
	m.worker = nil
	m.clearedworker = false
}

// ClearCommentType clears the "comment_type" edge to the CommentType entity.
func (m *WorkerCommentMutation) ClearCommentType() {
	m.clearedcomment_type = true
	m.clearedFields[workercomment.FieldCommentTypeID] = struct{}{}
}

// CommentTypeCleared reports if the "comment_type" edge to the CommentType entity was cleared.
func (m *WorkerCommentMutation) CommentTypeCleared() bool {
	return m.clearedcomment_type
}

// CommentTypeIDs returns the "comment_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CommentTypeID instead. It exists only for internal usage by the builders.
func (m *WorkerCommentMutation) CommentTypeIDs() (ids []uuid.UUID) {
	if id := m.comment_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCommentType resets all changes to the "comment_type" edge.
func (m *WorkerCommentMutation) ResetCommentType() {
	m.comment_type = nil
	m.clearedcomment_type = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *WorkerCommentMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[workercomment.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *WorkerCommentMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *WorkerCommentMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *WorkerCommentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the WorkerCommentMutation builder.
func (m *WorkerCommentMutation) Where(ps ...predicate.WorkerComment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkerCommentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkerCommentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkerComment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkerCommentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkerCommentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkerComment).
func (m *WorkerCommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkerCommentMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.business_unit != nil {
		fields = append(fields, workercomment.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, workercomment.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, workercomment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, workercomment.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, workercomment.FieldVersion)
	}
	if m.worker != nil {
		fields = append(fields, workercomment.FieldWorkerID)
	}
	if m.comment_type != nil {
		fields = append(fields, workercomment.FieldCommentTypeID)
	}
	if m.user != nil {
		fields = append(fields, workercomment.FieldUserID)
	}
	if m.comment != nil {
		fields = append(fields, workercomment.FieldComment)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkerCommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workercomment.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case workercomment.FieldOrganizationID:
		return m.OrganizationID()
	case workercomment.FieldCreatedAt:
		return m.CreatedAt()
	case workercomment.FieldUpdatedAt:
		return m.UpdatedAt()
	case workercomment.FieldVersion:
		return m.Version()
	case workercomment.FieldWorkerID:
		return m.WorkerID()
	case workercomment.FieldCommentTypeID:
		return m.CommentTypeID()
	case workercomment.FieldUserID:
		return m.UserID()
	case workercomment.FieldComment:
		return m.Comment()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkerCommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workercomment.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case workercomment.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case workercomment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workercomment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case workercomment.FieldVersion:
		return m.OldVersion(ctx)
	case workercomment.FieldWorkerID:
		return m.OldWorkerID(ctx)
	case workercomment.FieldCommentTypeID:
		return m.OldCommentTypeID(ctx)
	case workercomment.FieldUserID:
		return m.OldUserID(ctx)
	case workercomment.FieldComment:
		return m.OldComment(ctx)
	}
	return nil, fmt.Errorf("unknown WorkerComment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkerCommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workercomment.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case workercomment.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case workercomment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workercomment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case workercomment.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case workercomment.FieldWorkerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkerID(v)
		return nil
	case workercomment.FieldCommentTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentTypeID(v)
		return nil
	case workercomment.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case workercomment.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	}
	return fmt.Errorf("unknown WorkerComment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkerCommentMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, workercomment.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkerCommentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workercomment.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkerCommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workercomment.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown WorkerComment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkerCommentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkerCommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkerCommentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WorkerComment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkerCommentMutation) ResetField(name string) error {
	switch name {
	case workercomment.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case workercomment.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case workercomment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workercomment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case workercomment.FieldVersion:
		m.ResetVersion()
		return nil
	case workercomment.FieldWorkerID:
		m.ResetWorkerID()
		return nil
	case workercomment.FieldCommentTypeID:
		m.ResetCommentTypeID()
		return nil
	case workercomment.FieldUserID:
		m.ResetUserID()
		return nil
	case workercomment.FieldComment:
		m.ResetComment()
		return nil
	}
	return fmt.Errorf("unknown WorkerComment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkerCommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.business_unit != nil {
		edges = append(edges, workercomment.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, workercomment.EdgeOrganization)
	}
	if m.worker != nil {
		edges = append(edges, workercomment.EdgeWorker)
	}
	if m.comment_type != nil {
		edges = append(edges, workercomment.EdgeCommentType)
	}
	if m.user != nil {
		edges = append(edges, workercomment.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkerCommentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workercomment.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case workercomment.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case workercomment.EdgeWorker:
		if id := m.worker; id != nil {
			return []ent.Value{*id}
		}
	case workercomment.EdgeCommentType:
		if id := m.comment_type; id != nil {
			return []ent.Value{*id}
		}
	case workercomment.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkerCommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkerCommentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkerCommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedbusiness_unit {
		edges = append(edges, workercomment.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, workercomment.EdgeOrganization)
	}
	if m.clearedworker {
		edges = append(edges, workercomment.EdgeWorker)
	}
	if m.clearedcomment_type {
		edges = append(edges, workercomment.EdgeCommentType)
	}
	if m.cleareduser {
		edges = append(edges, workercomment.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkerCommentMutation) EdgeCleared(name string) bool {
	switch name {
	case workercomment.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case workercomment.EdgeOrganization:
		return m.clearedorganization
	case workercomment.EdgeWorker:
		return m.clearedworker
	case workercomment.EdgeCommentType:
		return m.clearedcomment_type
	case workercomment.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkerCommentMutation) ClearEdge(name string) error {
	switch name {
	case workercomment.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case workercomment.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case workercomment.EdgeWorker:
		m.ClearWorker()
		return nil
	case workercomment.EdgeCommentType:
		m.ClearCommentType()
		return nil
	case workercomment.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown WorkerComment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkerCommentMutation) ResetEdge(name string) error {
	switch name {
	case workercomment.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case workercomment.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case workercomment.EdgeWorker:
		m.ResetWorker()
		return nil
	case workercomment.EdgeCommentType:
		m.ResetCommentType()
		return nil
	case workercomment.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown WorkerComment edge %s", name)
}

// WorkerContactMutation represents an operation that mutates the WorkerContact nodes in the graph.
type WorkerContactMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	version              *int
	addversion           *int
	name                 *string
	email                *string
	phone                *string
	relationship         *string
	is_primary           *bool
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	worker               *uuid.UUID
	clearedworker        bool
	done                 bool
	oldValue             func(context.Context) (*WorkerContact, error)
	predicates           []predicate.WorkerContact
}

var _ ent.Mutation = (*WorkerContactMutation)(nil)

// workercontactOption allows management of the mutation configuration using functional options.
type workercontactOption func(*WorkerContactMutation)

// newWorkerContactMutation creates new mutation for the WorkerContact entity.
func newWorkerContactMutation(c config, op Op, opts ...workercontactOption) *WorkerContactMutation {
	m := &WorkerContactMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkerContact,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkerContactID sets the ID field of the mutation.
func withWorkerContactID(id uuid.UUID) workercontactOption {
	return func(m *WorkerContactMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkerContact
		)
		m.oldValue = func(ctx context.Context) (*WorkerContact, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkerContact.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkerContact sets the old WorkerContact of the mutation.
func withWorkerContact(node *WorkerContact) workercontactOption {
	return func(m *WorkerContactMutation) {
		m.oldValue = func(context.Context) (*WorkerContact, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkerContactMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkerContactMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkerContact entities.
func (m *WorkerContactMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkerContactMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkerContactMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkerContact.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *WorkerContactMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *WorkerContactMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the WorkerContact entity.
// If the WorkerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerContactMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *WorkerContactMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *WorkerContactMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *WorkerContactMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the WorkerContact entity.
// If the WorkerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerContactMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *WorkerContactMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkerContactMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkerContactMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WorkerContact entity.
// If the WorkerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerContactMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkerContactMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkerContactMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkerContactMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WorkerContact entity.
// If the WorkerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerContactMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkerContactMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *WorkerContactMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *WorkerContactMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the WorkerContact entity.
// If the WorkerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerContactMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *WorkerContactMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *WorkerContactMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *WorkerContactMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetWorkerID sets the "worker_id" field.
func (m *WorkerContactMutation) SetWorkerID(u uuid.UUID) {
	m.worker = &u
}

// WorkerID returns the value of the "worker_id" field in the mutation.
func (m *WorkerContactMutation) WorkerID() (r uuid.UUID, exists bool) {
	v := m.worker
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkerID returns the old "worker_id" field's value of the WorkerContact entity.
// If the WorkerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerContactMutation) OldWorkerID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkerID: %w", err)
	}
	return oldValue.WorkerID, nil
}

// ResetWorkerID resets all changes to the "worker_id" field.
func (m *WorkerContactMutation) ResetWorkerID() {
	m.worker = nil
}

// SetName sets the "name" field.
func (m *WorkerContactMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WorkerContactMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the WorkerContact entity.
// If the WorkerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerContactMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WorkerContactMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *WorkerContactMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *WorkerContactMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the WorkerContact entity.
// If the WorkerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerContactMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *WorkerContactMutation) ResetEmail() {
	m.email = nil
}

// SetPhone sets the "phone" field.
func (m *WorkerContactMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *WorkerContactMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the WorkerContact entity.
// If the WorkerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerContactMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *WorkerContactMutation) ResetPhone() {
	m.phone = nil
}

// SetRelationship sets the "relationship" field.
func (m *WorkerContactMutation) SetRelationship(s string) {
	m.relationship = &s
}

// Relationship returns the value of the "relationship" field in the mutation.
func (m *WorkerContactMutation) Relationship() (r string, exists bool) {
	v := m.relationship
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationship returns the old "relationship" field's value of the WorkerContact entity.
// If the WorkerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerContactMutation) OldRelationship(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationship is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationship requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationship: %w", err)
	}
	return oldValue.Relationship, nil
}

// ClearRelationship clears the value of the "relationship" field.
func (m *WorkerContactMutation) ClearRelationship() {
	m.relationship = nil
	m.clearedFields[workercontact.FieldRelationship] = struct{}{}
}

// RelationshipCleared returns if the "relationship" field was cleared in this mutation.
func (m *WorkerContactMutation) RelationshipCleared() bool {
	_, ok := m.clearedFields[workercontact.FieldRelationship]
	return ok
}

// ResetRelationship resets all changes to the "relationship" field.
func (m *WorkerContactMutation) ResetRelationship() {
	m.relationship = nil
	delete(m.clearedFields, workercontact.FieldRelationship)
}

// SetIsPrimary sets the "is_primary" field.
func (m *WorkerContactMutation) SetIsPrimary(b bool) {
	m.is_primary = &b
}

// IsPrimary returns the value of the "is_primary" field in the mutation.
func (m *WorkerContactMutation) IsPrimary() (r bool, exists bool) {
	v := m.is_primary
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPrimary returns the old "is_primary" field's value of the WorkerContact entity.
// If the WorkerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerContactMutation) OldIsPrimary(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPrimary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPrimary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPrimary: %w", err)
	}
	return oldValue.IsPrimary, nil
}

// ResetIsPrimary resets all changes to the "is_primary" field.
func (m *WorkerContactMutation) ResetIsPrimary() {
	m.is_primary = nil
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *WorkerContactMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[workercontact.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *WorkerContactMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *WorkerContactMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *WorkerContactMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *WorkerContactMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[workercontact.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *WorkerContactMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *WorkerContactMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *WorkerContactMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearWorker clears the "worker" edge to the Worker entity.
func (m *WorkerContactMutation) ClearWorker() {
	m.clearedworker = true
	m.clearedFields[workercontact.FieldWorkerID] = struct{}{}
}

// WorkerCleared reports if the "worker" edge to the Worker entity was cleared.
func (m *WorkerContactMutation) WorkerCleared() bool {
	return m.clearedworker
}

// WorkerIDs returns the "worker" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkerID instead. It exists only for internal usage by the builders.
func (m *WorkerContactMutation) WorkerIDs() (ids []uuid.UUID) {
	if id := m.worker; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorker resets all changes to the "worker" edge.
func (m *WorkerContactMutation) ResetWorker() {
	m.worker = nil
	m.clearedworker = false
}

// Where appends a list predicates to the WorkerContactMutation builder.
func (m *WorkerContactMutation) Where(ps ...predicate.WorkerContact) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkerContactMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkerContactMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkerContact, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkerContactMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkerContactMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkerContact).
func (m *WorkerContactMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkerContactMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.business_unit != nil {
		fields = append(fields, workercontact.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, workercontact.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, workercontact.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, workercontact.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, workercontact.FieldVersion)
	}
	if m.worker != nil {
		fields = append(fields, workercontact.FieldWorkerID)
	}
	if m.name != nil {
		fields = append(fields, workercontact.FieldName)
	}
	if m.email != nil {
		fields = append(fields, workercontact.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, workercontact.FieldPhone)
	}
	if m.relationship != nil {
		fields = append(fields, workercontact.FieldRelationship)
	}
	if m.is_primary != nil {
		fields = append(fields, workercontact.FieldIsPrimary)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkerContactMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workercontact.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case workercontact.FieldOrganizationID:
		return m.OrganizationID()
	case workercontact.FieldCreatedAt:
		return m.CreatedAt()
	case workercontact.FieldUpdatedAt:
		return m.UpdatedAt()
	case workercontact.FieldVersion:
		return m.Version()
	case workercontact.FieldWorkerID:
		return m.WorkerID()
	case workercontact.FieldName:
		return m.Name()
	case workercontact.FieldEmail:
		return m.Email()
	case workercontact.FieldPhone:
		return m.Phone()
	case workercontact.FieldRelationship:
		return m.Relationship()
	case workercontact.FieldIsPrimary:
		return m.IsPrimary()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkerContactMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workercontact.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case workercontact.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case workercontact.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workercontact.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case workercontact.FieldVersion:
		return m.OldVersion(ctx)
	case workercontact.FieldWorkerID:
		return m.OldWorkerID(ctx)
	case workercontact.FieldName:
		return m.OldName(ctx)
	case workercontact.FieldEmail:
		return m.OldEmail(ctx)
	case workercontact.FieldPhone:
		return m.OldPhone(ctx)
	case workercontact.FieldRelationship:
		return m.OldRelationship(ctx)
	case workercontact.FieldIsPrimary:
		return m.OldIsPrimary(ctx)
	}
	return nil, fmt.Errorf("unknown WorkerContact field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkerContactMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workercontact.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case workercontact.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case workercontact.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workercontact.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case workercontact.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case workercontact.FieldWorkerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkerID(v)
		return nil
	case workercontact.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case workercontact.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case workercontact.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case workercontact.FieldRelationship:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationship(v)
		return nil
	case workercontact.FieldIsPrimary:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPrimary(v)
		return nil
	}
	return fmt.Errorf("unknown WorkerContact field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkerContactMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, workercontact.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkerContactMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workercontact.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkerContactMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workercontact.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown WorkerContact numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkerContactMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workercontact.FieldRelationship) {
		fields = append(fields, workercontact.FieldRelationship)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkerContactMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkerContactMutation) ClearField(name string) error {
	switch name {
	case workercontact.FieldRelationship:
		m.ClearRelationship()
		return nil
	}
	return fmt.Errorf("unknown WorkerContact nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkerContactMutation) ResetField(name string) error {
	switch name {
	case workercontact.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case workercontact.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case workercontact.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workercontact.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case workercontact.FieldVersion:
		m.ResetVersion()
		return nil
	case workercontact.FieldWorkerID:
		m.ResetWorkerID()
		return nil
	case workercontact.FieldName:
		m.ResetName()
		return nil
	case workercontact.FieldEmail:
		m.ResetEmail()
		return nil
	case workercontact.FieldPhone:
		m.ResetPhone()
		return nil
	case workercontact.FieldRelationship:
		m.ResetRelationship()
		return nil
	case workercontact.FieldIsPrimary:
		m.ResetIsPrimary()
		return nil
	}
	return fmt.Errorf("unknown WorkerContact field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkerContactMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.business_unit != nil {
		edges = append(edges, workercontact.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, workercontact.EdgeOrganization)
	}
	if m.worker != nil {
		edges = append(edges, workercontact.EdgeWorker)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkerContactMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workercontact.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case workercontact.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case workercontact.EdgeWorker:
		if id := m.worker; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkerContactMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkerContactMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkerContactMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbusiness_unit {
		edges = append(edges, workercontact.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, workercontact.EdgeOrganization)
	}
	if m.clearedworker {
		edges = append(edges, workercontact.EdgeWorker)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkerContactMutation) EdgeCleared(name string) bool {
	switch name {
	case workercontact.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case workercontact.EdgeOrganization:
		return m.clearedorganization
	case workercontact.EdgeWorker:
		return m.clearedworker
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkerContactMutation) ClearEdge(name string) error {
	switch name {
	case workercontact.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case workercontact.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case workercontact.EdgeWorker:
		m.ClearWorker()
		return nil
	}
	return fmt.Errorf("unknown WorkerContact unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkerContactMutation) ResetEdge(name string) error {
	switch name {
	case workercontact.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case workercontact.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case workercontact.EdgeWorker:
		m.ResetWorker()
		return nil
	}
	return fmt.Errorf("unknown WorkerContact edge %s", name)
}

// WorkerProfileMutation represents an operation that mutates the WorkerProfile nodes in the graph.
type WorkerProfileMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	created_at              *time.Time
	updated_at              *time.Time
	version                 *int
	addversion              *int
	race                    *string
	sex                     *string
	date_of_birth           **pgtype.Date
	license_number          *string
	license_expiration_date **pgtype.Date
	endorsements            *workerprofile.Endorsements
	hazmat_expiration_date  **pgtype.Date
	hire_date               **pgtype.Date
	termination_date        **pgtype.Date
	physical_due_date       **pgtype.Date
	medical_cert_date       **pgtype.Date
	mvr_due_date            **pgtype.Date
	clearedFields           map[string]struct{}
	business_unit           *uuid.UUID
	clearedbusiness_unit    bool
	organization            *uuid.UUID
	clearedorganization     bool
	worker                  *uuid.UUID
	clearedworker           bool
	state                   *uuid.UUID
	clearedstate            bool
	done                    bool
	oldValue                func(context.Context) (*WorkerProfile, error)
	predicates              []predicate.WorkerProfile
}

var _ ent.Mutation = (*WorkerProfileMutation)(nil)

// workerprofileOption allows management of the mutation configuration using functional options.
type workerprofileOption func(*WorkerProfileMutation)

// newWorkerProfileMutation creates new mutation for the WorkerProfile entity.
func newWorkerProfileMutation(c config, op Op, opts ...workerprofileOption) *WorkerProfileMutation {
	m := &WorkerProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkerProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkerProfileID sets the ID field of the mutation.
func withWorkerProfileID(id uuid.UUID) workerprofileOption {
	return func(m *WorkerProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkerProfile
		)
		m.oldValue = func(ctx context.Context) (*WorkerProfile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkerProfile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkerProfile sets the old WorkerProfile of the mutation.
func withWorkerProfile(node *WorkerProfile) workerprofileOption {
	return func(m *WorkerProfileMutation) {
		m.oldValue = func(context.Context) (*WorkerProfile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkerProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkerProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkerProfile entities.
func (m *WorkerProfileMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkerProfileMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkerProfileMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkerProfile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *WorkerProfileMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *WorkerProfileMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the WorkerProfile entity.
// If the WorkerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerProfileMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *WorkerProfileMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *WorkerProfileMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *WorkerProfileMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the WorkerProfile entity.
// If the WorkerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerProfileMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *WorkerProfileMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkerProfileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkerProfileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WorkerProfile entity.
// If the WorkerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerProfileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkerProfileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkerProfileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkerProfileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WorkerProfile entity.
// If the WorkerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerProfileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkerProfileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *WorkerProfileMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *WorkerProfileMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the WorkerProfile entity.
// If the WorkerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerProfileMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *WorkerProfileMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *WorkerProfileMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *WorkerProfileMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetWorkerID sets the "worker_id" field.
func (m *WorkerProfileMutation) SetWorkerID(u uuid.UUID) {
	m.worker = &u
}

// WorkerID returns the value of the "worker_id" field in the mutation.
func (m *WorkerProfileMutation) WorkerID() (r uuid.UUID, exists bool) {
	v := m.worker
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkerID returns the old "worker_id" field's value of the WorkerProfile entity.
// If the WorkerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerProfileMutation) OldWorkerID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkerID: %w", err)
	}
	return oldValue.WorkerID, nil
}

// ResetWorkerID resets all changes to the "worker_id" field.
func (m *WorkerProfileMutation) ResetWorkerID() {
	m.worker = nil
}

// SetRace sets the "race" field.
func (m *WorkerProfileMutation) SetRace(s string) {
	m.race = &s
}

// Race returns the value of the "race" field in the mutation.
func (m *WorkerProfileMutation) Race() (r string, exists bool) {
	v := m.race
	if v == nil {
		return
	}
	return *v, true
}

// OldRace returns the old "race" field's value of the WorkerProfile entity.
// If the WorkerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerProfileMutation) OldRace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRace: %w", err)
	}
	return oldValue.Race, nil
}

// ClearRace clears the value of the "race" field.
func (m *WorkerProfileMutation) ClearRace() {
	m.race = nil
	m.clearedFields[workerprofile.FieldRace] = struct{}{}
}

// RaceCleared returns if the "race" field was cleared in this mutation.
func (m *WorkerProfileMutation) RaceCleared() bool {
	_, ok := m.clearedFields[workerprofile.FieldRace]
	return ok
}

// ResetRace resets all changes to the "race" field.
func (m *WorkerProfileMutation) ResetRace() {
	m.race = nil
	delete(m.clearedFields, workerprofile.FieldRace)
}

// SetSex sets the "sex" field.
func (m *WorkerProfileMutation) SetSex(s string) {
	m.sex = &s
}

// Sex returns the value of the "sex" field in the mutation.
func (m *WorkerProfileMutation) Sex() (r string, exists bool) {
	v := m.sex
	if v == nil {
		return
	}
	return *v, true
}

// OldSex returns the old "sex" field's value of the WorkerProfile entity.
// If the WorkerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerProfileMutation) OldSex(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSex: %w", err)
	}
	return oldValue.Sex, nil
}

// ClearSex clears the value of the "sex" field.
func (m *WorkerProfileMutation) ClearSex() {
	m.sex = nil
	m.clearedFields[workerprofile.FieldSex] = struct{}{}
}

// SexCleared returns if the "sex" field was cleared in this mutation.
func (m *WorkerProfileMutation) SexCleared() bool {
	_, ok := m.clearedFields[workerprofile.FieldSex]
	return ok
}

// ResetSex resets all changes to the "sex" field.
func (m *WorkerProfileMutation) ResetSex() {
	m.sex = nil
	delete(m.clearedFields, workerprofile.FieldSex)
}

// SetDateOfBirth sets the "date_of_birth" field.
func (m *WorkerProfileMutation) SetDateOfBirth(pg *pgtype.Date) {
	m.date_of_birth = &pg
}

// DateOfBirth returns the value of the "date_of_birth" field in the mutation.
func (m *WorkerProfileMutation) DateOfBirth() (r *pgtype.Date, exists bool) {
	v := m.date_of_birth
	if v == nil {
		return
	}
	return *v, true
}

// OldDateOfBirth returns the old "date_of_birth" field's value of the WorkerProfile entity.
// If the WorkerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerProfileMutation) OldDateOfBirth(ctx context.Context) (v *pgtype.Date, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDateOfBirth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDateOfBirth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateOfBirth: %w", err)
	}
	return oldValue.DateOfBirth, nil
}

// ClearDateOfBirth clears the value of the "date_of_birth" field.
func (m *WorkerProfileMutation) ClearDateOfBirth() {
	m.date_of_birth = nil
	m.clearedFields[workerprofile.FieldDateOfBirth] = struct{}{}
}

// DateOfBirthCleared returns if the "date_of_birth" field was cleared in this mutation.
func (m *WorkerProfileMutation) DateOfBirthCleared() bool {
	_, ok := m.clearedFields[workerprofile.FieldDateOfBirth]
	return ok
}

// ResetDateOfBirth resets all changes to the "date_of_birth" field.
func (m *WorkerProfileMutation) ResetDateOfBirth() {
	m.date_of_birth = nil
	delete(m.clearedFields, workerprofile.FieldDateOfBirth)
}

// SetLicenseNumber sets the "license_number" field.
func (m *WorkerProfileMutation) SetLicenseNumber(s string) {
	m.license_number = &s
}

// LicenseNumber returns the value of the "license_number" field in the mutation.
func (m *WorkerProfileMutation) LicenseNumber() (r string, exists bool) {
	v := m.license_number
	if v == nil {
		return
	}
	return *v, true
}

// OldLicenseNumber returns the old "license_number" field's value of the WorkerProfile entity.
// If the WorkerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerProfileMutation) OldLicenseNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLicenseNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLicenseNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicenseNumber: %w", err)
	}
	return oldValue.LicenseNumber, nil
}

// ResetLicenseNumber resets all changes to the "license_number" field.
func (m *WorkerProfileMutation) ResetLicenseNumber() {
	m.license_number = nil
}

// SetLicenseStateID sets the "license_state_id" field.
func (m *WorkerProfileMutation) SetLicenseStateID(u uuid.UUID) {
	m.state = &u
}

// LicenseStateID returns the value of the "license_state_id" field in the mutation.
func (m *WorkerProfileMutation) LicenseStateID() (r uuid.UUID, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldLicenseStateID returns the old "license_state_id" field's value of the WorkerProfile entity.
// If the WorkerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerProfileMutation) OldLicenseStateID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLicenseStateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLicenseStateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicenseStateID: %w", err)
	}
	return oldValue.LicenseStateID, nil
}

// ResetLicenseStateID resets all changes to the "license_state_id" field.
func (m *WorkerProfileMutation) ResetLicenseStateID() {
	m.state = nil
}

// SetLicenseExpirationDate sets the "license_expiration_date" field.
func (m *WorkerProfileMutation) SetLicenseExpirationDate(pg *pgtype.Date) {
	m.license_expiration_date = &pg
}

// LicenseExpirationDate returns the value of the "license_expiration_date" field in the mutation.
func (m *WorkerProfileMutation) LicenseExpirationDate() (r *pgtype.Date, exists bool) {
	v := m.license_expiration_date
	if v == nil {
		return
	}
	return *v, true
}

// OldLicenseExpirationDate returns the old "license_expiration_date" field's value of the WorkerProfile entity.
// If the WorkerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerProfileMutation) OldLicenseExpirationDate(ctx context.Context) (v *pgtype.Date, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLicenseExpirationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLicenseExpirationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicenseExpirationDate: %w", err)
	}
	return oldValue.LicenseExpirationDate, nil
}

// ClearLicenseExpirationDate clears the value of the "license_expiration_date" field.
func (m *WorkerProfileMutation) ClearLicenseExpirationDate() {
	m.license_expiration_date = nil
	m.clearedFields[workerprofile.FieldLicenseExpirationDate] = struct{}{}
}

// LicenseExpirationDateCleared returns if the "license_expiration_date" field was cleared in this mutation.
func (m *WorkerProfileMutation) LicenseExpirationDateCleared() bool {
	_, ok := m.clearedFields[workerprofile.FieldLicenseExpirationDate]
	return ok
}

// ResetLicenseExpirationDate resets all changes to the "license_expiration_date" field.
func (m *WorkerProfileMutation) ResetLicenseExpirationDate() {
	m.license_expiration_date = nil
	delete(m.clearedFields, workerprofile.FieldLicenseExpirationDate)
}

// SetEndorsements sets the "endorsements" field.
func (m *WorkerProfileMutation) SetEndorsements(w workerprofile.Endorsements) {
	m.endorsements = &w
}

// Endorsements returns the value of the "endorsements" field in the mutation.
func (m *WorkerProfileMutation) Endorsements() (r workerprofile.Endorsements, exists bool) {
	v := m.endorsements
	if v == nil {
		return
	}
	return *v, true
}

// OldEndorsements returns the old "endorsements" field's value of the WorkerProfile entity.
// If the WorkerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerProfileMutation) OldEndorsements(ctx context.Context) (v workerprofile.Endorsements, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndorsements is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndorsements requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndorsements: %w", err)
	}
	return oldValue.Endorsements, nil
}

// ClearEndorsements clears the value of the "endorsements" field.
func (m *WorkerProfileMutation) ClearEndorsements() {
	m.endorsements = nil
	m.clearedFields[workerprofile.FieldEndorsements] = struct{}{}
}

// EndorsementsCleared returns if the "endorsements" field was cleared in this mutation.
func (m *WorkerProfileMutation) EndorsementsCleared() bool {
	_, ok := m.clearedFields[workerprofile.FieldEndorsements]
	return ok
}

// ResetEndorsements resets all changes to the "endorsements" field.
func (m *WorkerProfileMutation) ResetEndorsements() {
	m.endorsements = nil
	delete(m.clearedFields, workerprofile.FieldEndorsements)
}

// SetHazmatExpirationDate sets the "hazmat_expiration_date" field.
func (m *WorkerProfileMutation) SetHazmatExpirationDate(pg *pgtype.Date) {
	m.hazmat_expiration_date = &pg
}

// HazmatExpirationDate returns the value of the "hazmat_expiration_date" field in the mutation.
func (m *WorkerProfileMutation) HazmatExpirationDate() (r *pgtype.Date, exists bool) {
	v := m.hazmat_expiration_date
	if v == nil {
		return
	}
	return *v, true
}

// OldHazmatExpirationDate returns the old "hazmat_expiration_date" field's value of the WorkerProfile entity.
// If the WorkerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerProfileMutation) OldHazmatExpirationDate(ctx context.Context) (v *pgtype.Date, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHazmatExpirationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHazmatExpirationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHazmatExpirationDate: %w", err)
	}
	return oldValue.HazmatExpirationDate, nil
}

// ClearHazmatExpirationDate clears the value of the "hazmat_expiration_date" field.
func (m *WorkerProfileMutation) ClearHazmatExpirationDate() {
	m.hazmat_expiration_date = nil
	m.clearedFields[workerprofile.FieldHazmatExpirationDate] = struct{}{}
}

// HazmatExpirationDateCleared returns if the "hazmat_expiration_date" field was cleared in this mutation.
func (m *WorkerProfileMutation) HazmatExpirationDateCleared() bool {
	_, ok := m.clearedFields[workerprofile.FieldHazmatExpirationDate]
	return ok
}

// ResetHazmatExpirationDate resets all changes to the "hazmat_expiration_date" field.
func (m *WorkerProfileMutation) ResetHazmatExpirationDate() {
	m.hazmat_expiration_date = nil
	delete(m.clearedFields, workerprofile.FieldHazmatExpirationDate)
}

// SetHireDate sets the "hire_date" field.
func (m *WorkerProfileMutation) SetHireDate(pg *pgtype.Date) {
	m.hire_date = &pg
}

// HireDate returns the value of the "hire_date" field in the mutation.
func (m *WorkerProfileMutation) HireDate() (r *pgtype.Date, exists bool) {
	v := m.hire_date
	if v == nil {
		return
	}
	return *v, true
}

// OldHireDate returns the old "hire_date" field's value of the WorkerProfile entity.
// If the WorkerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerProfileMutation) OldHireDate(ctx context.Context) (v *pgtype.Date, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHireDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHireDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHireDate: %w", err)
	}
	return oldValue.HireDate, nil
}

// ClearHireDate clears the value of the "hire_date" field.
func (m *WorkerProfileMutation) ClearHireDate() {
	m.hire_date = nil
	m.clearedFields[workerprofile.FieldHireDate] = struct{}{}
}

// HireDateCleared returns if the "hire_date" field was cleared in this mutation.
func (m *WorkerProfileMutation) HireDateCleared() bool {
	_, ok := m.clearedFields[workerprofile.FieldHireDate]
	return ok
}

// ResetHireDate resets all changes to the "hire_date" field.
func (m *WorkerProfileMutation) ResetHireDate() {
	m.hire_date = nil
	delete(m.clearedFields, workerprofile.FieldHireDate)
}

// SetTerminationDate sets the "termination_date" field.
func (m *WorkerProfileMutation) SetTerminationDate(pg *pgtype.Date) {
	m.termination_date = &pg
}

// TerminationDate returns the value of the "termination_date" field in the mutation.
func (m *WorkerProfileMutation) TerminationDate() (r *pgtype.Date, exists bool) {
	v := m.termination_date
	if v == nil {
		return
	}
	return *v, true
}

// OldTerminationDate returns the old "termination_date" field's value of the WorkerProfile entity.
// If the WorkerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerProfileMutation) OldTerminationDate(ctx context.Context) (v *pgtype.Date, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTerminationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTerminationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTerminationDate: %w", err)
	}
	return oldValue.TerminationDate, nil
}

// ClearTerminationDate clears the value of the "termination_date" field.
func (m *WorkerProfileMutation) ClearTerminationDate() {
	m.termination_date = nil
	m.clearedFields[workerprofile.FieldTerminationDate] = struct{}{}
}

// TerminationDateCleared returns if the "termination_date" field was cleared in this mutation.
func (m *WorkerProfileMutation) TerminationDateCleared() bool {
	_, ok := m.clearedFields[workerprofile.FieldTerminationDate]
	return ok
}

// ResetTerminationDate resets all changes to the "termination_date" field.
func (m *WorkerProfileMutation) ResetTerminationDate() {
	m.termination_date = nil
	delete(m.clearedFields, workerprofile.FieldTerminationDate)
}

// SetPhysicalDueDate sets the "physical_due_date" field.
func (m *WorkerProfileMutation) SetPhysicalDueDate(pg *pgtype.Date) {
	m.physical_due_date = &pg
}

// PhysicalDueDate returns the value of the "physical_due_date" field in the mutation.
func (m *WorkerProfileMutation) PhysicalDueDate() (r *pgtype.Date, exists bool) {
	v := m.physical_due_date
	if v == nil {
		return
	}
	return *v, true
}

// OldPhysicalDueDate returns the old "physical_due_date" field's value of the WorkerProfile entity.
// If the WorkerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerProfileMutation) OldPhysicalDueDate(ctx context.Context) (v *pgtype.Date, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhysicalDueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhysicalDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhysicalDueDate: %w", err)
	}
	return oldValue.PhysicalDueDate, nil
}

// ClearPhysicalDueDate clears the value of the "physical_due_date" field.
func (m *WorkerProfileMutation) ClearPhysicalDueDate() {
	m.physical_due_date = nil
	m.clearedFields[workerprofile.FieldPhysicalDueDate] = struct{}{}
}

// PhysicalDueDateCleared returns if the "physical_due_date" field was cleared in this mutation.
func (m *WorkerProfileMutation) PhysicalDueDateCleared() bool {
	_, ok := m.clearedFields[workerprofile.FieldPhysicalDueDate]
	return ok
}

// ResetPhysicalDueDate resets all changes to the "physical_due_date" field.
func (m *WorkerProfileMutation) ResetPhysicalDueDate() {
	m.physical_due_date = nil
	delete(m.clearedFields, workerprofile.FieldPhysicalDueDate)
}

// SetMedicalCertDate sets the "medical_cert_date" field.
func (m *WorkerProfileMutation) SetMedicalCertDate(pg *pgtype.Date) {
	m.medical_cert_date = &pg
}

// MedicalCertDate returns the value of the "medical_cert_date" field in the mutation.
func (m *WorkerProfileMutation) MedicalCertDate() (r *pgtype.Date, exists bool) {
	v := m.medical_cert_date
	if v == nil {
		return
	}
	return *v, true
}

// OldMedicalCertDate returns the old "medical_cert_date" field's value of the WorkerProfile entity.
// If the WorkerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerProfileMutation) OldMedicalCertDate(ctx context.Context) (v *pgtype.Date, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMedicalCertDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMedicalCertDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMedicalCertDate: %w", err)
	}
	return oldValue.MedicalCertDate, nil
}

// ClearMedicalCertDate clears the value of the "medical_cert_date" field.
func (m *WorkerProfileMutation) ClearMedicalCertDate() {
	m.medical_cert_date = nil
	m.clearedFields[workerprofile.FieldMedicalCertDate] = struct{}{}
}

// MedicalCertDateCleared returns if the "medical_cert_date" field was cleared in this mutation.
func (m *WorkerProfileMutation) MedicalCertDateCleared() bool {
	_, ok := m.clearedFields[workerprofile.FieldMedicalCertDate]
	return ok
}

// ResetMedicalCertDate resets all changes to the "medical_cert_date" field.
func (m *WorkerProfileMutation) ResetMedicalCertDate() {
	m.medical_cert_date = nil
	delete(m.clearedFields, workerprofile.FieldMedicalCertDate)
}

// SetMvrDueDate sets the "mvr_due_date" field.
func (m *WorkerProfileMutation) SetMvrDueDate(pg *pgtype.Date) {
	m.mvr_due_date = &pg
}

// MvrDueDate returns the value of the "mvr_due_date" field in the mutation.
func (m *WorkerProfileMutation) MvrDueDate() (r *pgtype.Date, exists bool) {
	v := m.mvr_due_date
	if v == nil {
		return
	}
	return *v, true
}

// OldMvrDueDate returns the old "mvr_due_date" field's value of the WorkerProfile entity.
// If the WorkerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerProfileMutation) OldMvrDueDate(ctx context.Context) (v *pgtype.Date, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMvrDueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMvrDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMvrDueDate: %w", err)
	}
	return oldValue.MvrDueDate, nil
}

// ClearMvrDueDate clears the value of the "mvr_due_date" field.
func (m *WorkerProfileMutation) ClearMvrDueDate() {
	m.mvr_due_date = nil
	m.clearedFields[workerprofile.FieldMvrDueDate] = struct{}{}
}

// MvrDueDateCleared returns if the "mvr_due_date" field was cleared in this mutation.
func (m *WorkerProfileMutation) MvrDueDateCleared() bool {
	_, ok := m.clearedFields[workerprofile.FieldMvrDueDate]
	return ok
}

// ResetMvrDueDate resets all changes to the "mvr_due_date" field.
func (m *WorkerProfileMutation) ResetMvrDueDate() {
	m.mvr_due_date = nil
	delete(m.clearedFields, workerprofile.FieldMvrDueDate)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *WorkerProfileMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[workerprofile.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *WorkerProfileMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *WorkerProfileMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *WorkerProfileMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *WorkerProfileMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[workerprofile.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *WorkerProfileMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *WorkerProfileMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *WorkerProfileMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearWorker clears the "worker" edge to the Worker entity.
func (m *WorkerProfileMutation) ClearWorker() {
	m.clearedworker = true
	m.clearedFields[workerprofile.FieldWorkerID] = struct{}{}
}

// WorkerCleared reports if the "worker" edge to the Worker entity was cleared.
func (m *WorkerProfileMutation) WorkerCleared() bool {
	return m.clearedworker
}

// WorkerIDs returns the "worker" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkerID instead. It exists only for internal usage by the builders.
func (m *WorkerProfileMutation) WorkerIDs() (ids []uuid.UUID) {
	if id := m.worker; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorker resets all changes to the "worker" edge.
func (m *WorkerProfileMutation) ResetWorker() {
	m.worker = nil
	m.clearedworker = false
}

// SetStateID sets the "state" edge to the UsState entity by id.
func (m *WorkerProfileMutation) SetStateID(id uuid.UUID) {
	m.state = &id
}

// ClearState clears the "state" edge to the UsState entity.
func (m *WorkerProfileMutation) ClearState() {
	m.clearedstate = true
	m.clearedFields[workerprofile.FieldLicenseStateID] = struct{}{}
}

// StateCleared reports if the "state" edge to the UsState entity was cleared.
func (m *WorkerProfileMutation) StateCleared() bool {
	return m.clearedstate
}

// StateID returns the "state" edge ID in the mutation.
func (m *WorkerProfileMutation) StateID() (id uuid.UUID, exists bool) {
	if m.state != nil {
		return *m.state, true
	}
	return
}

// StateIDs returns the "state" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StateID instead. It exists only for internal usage by the builders.
func (m *WorkerProfileMutation) StateIDs() (ids []uuid.UUID) {
	if id := m.state; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetState resets all changes to the "state" edge.
func (m *WorkerProfileMutation) ResetState() {
	m.state = nil
	m.clearedstate = false
}

// Where appends a list predicates to the WorkerProfileMutation builder.
func (m *WorkerProfileMutation) Where(ps ...predicate.WorkerProfile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkerProfileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkerProfileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkerProfile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkerProfileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkerProfileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkerProfile).
func (m *WorkerProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkerProfileMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.business_unit != nil {
		fields = append(fields, workerprofile.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, workerprofile.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, workerprofile.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, workerprofile.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, workerprofile.FieldVersion)
	}
	if m.worker != nil {
		fields = append(fields, workerprofile.FieldWorkerID)
	}
	if m.race != nil {
		fields = append(fields, workerprofile.FieldRace)
	}
	if m.sex != nil {
		fields = append(fields, workerprofile.FieldSex)
	}
	if m.date_of_birth != nil {
		fields = append(fields, workerprofile.FieldDateOfBirth)
	}
	if m.license_number != nil {
		fields = append(fields, workerprofile.FieldLicenseNumber)
	}
	if m.state != nil {
		fields = append(fields, workerprofile.FieldLicenseStateID)
	}
	if m.license_expiration_date != nil {
		fields = append(fields, workerprofile.FieldLicenseExpirationDate)
	}
	if m.endorsements != nil {
		fields = append(fields, workerprofile.FieldEndorsements)
	}
	if m.hazmat_expiration_date != nil {
		fields = append(fields, workerprofile.FieldHazmatExpirationDate)
	}
	if m.hire_date != nil {
		fields = append(fields, workerprofile.FieldHireDate)
	}
	if m.termination_date != nil {
		fields = append(fields, workerprofile.FieldTerminationDate)
	}
	if m.physical_due_date != nil {
		fields = append(fields, workerprofile.FieldPhysicalDueDate)
	}
	if m.medical_cert_date != nil {
		fields = append(fields, workerprofile.FieldMedicalCertDate)
	}
	if m.mvr_due_date != nil {
		fields = append(fields, workerprofile.FieldMvrDueDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkerProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workerprofile.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case workerprofile.FieldOrganizationID:
		return m.OrganizationID()
	case workerprofile.FieldCreatedAt:
		return m.CreatedAt()
	case workerprofile.FieldUpdatedAt:
		return m.UpdatedAt()
	case workerprofile.FieldVersion:
		return m.Version()
	case workerprofile.FieldWorkerID:
		return m.WorkerID()
	case workerprofile.FieldRace:
		return m.Race()
	case workerprofile.FieldSex:
		return m.Sex()
	case workerprofile.FieldDateOfBirth:
		return m.DateOfBirth()
	case workerprofile.FieldLicenseNumber:
		return m.LicenseNumber()
	case workerprofile.FieldLicenseStateID:
		return m.LicenseStateID()
	case workerprofile.FieldLicenseExpirationDate:
		return m.LicenseExpirationDate()
	case workerprofile.FieldEndorsements:
		return m.Endorsements()
	case workerprofile.FieldHazmatExpirationDate:
		return m.HazmatExpirationDate()
	case workerprofile.FieldHireDate:
		return m.HireDate()
	case workerprofile.FieldTerminationDate:
		return m.TerminationDate()
	case workerprofile.FieldPhysicalDueDate:
		return m.PhysicalDueDate()
	case workerprofile.FieldMedicalCertDate:
		return m.MedicalCertDate()
	case workerprofile.FieldMvrDueDate:
		return m.MvrDueDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkerProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workerprofile.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case workerprofile.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case workerprofile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workerprofile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case workerprofile.FieldVersion:
		return m.OldVersion(ctx)
	case workerprofile.FieldWorkerID:
		return m.OldWorkerID(ctx)
	case workerprofile.FieldRace:
		return m.OldRace(ctx)
	case workerprofile.FieldSex:
		return m.OldSex(ctx)
	case workerprofile.FieldDateOfBirth:
		return m.OldDateOfBirth(ctx)
	case workerprofile.FieldLicenseNumber:
		return m.OldLicenseNumber(ctx)
	case workerprofile.FieldLicenseStateID:
		return m.OldLicenseStateID(ctx)
	case workerprofile.FieldLicenseExpirationDate:
		return m.OldLicenseExpirationDate(ctx)
	case workerprofile.FieldEndorsements:
		return m.OldEndorsements(ctx)
	case workerprofile.FieldHazmatExpirationDate:
		return m.OldHazmatExpirationDate(ctx)
	case workerprofile.FieldHireDate:
		return m.OldHireDate(ctx)
	case workerprofile.FieldTerminationDate:
		return m.OldTerminationDate(ctx)
	case workerprofile.FieldPhysicalDueDate:
		return m.OldPhysicalDueDate(ctx)
	case workerprofile.FieldMedicalCertDate:
		return m.OldMedicalCertDate(ctx)
	case workerprofile.FieldMvrDueDate:
		return m.OldMvrDueDate(ctx)
	}
	return nil, fmt.Errorf("unknown WorkerProfile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkerProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workerprofile.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case workerprofile.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case workerprofile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workerprofile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case workerprofile.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case workerprofile.FieldWorkerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkerID(v)
		return nil
	case workerprofile.FieldRace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRace(v)
		return nil
	case workerprofile.FieldSex:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSex(v)
		return nil
	case workerprofile.FieldDateOfBirth:
		v, ok := value.(*pgtype.Date)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateOfBirth(v)
		return nil
	case workerprofile.FieldLicenseNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicenseNumber(v)
		return nil
	case workerprofile.FieldLicenseStateID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicenseStateID(v)
		return nil
	case workerprofile.FieldLicenseExpirationDate:
		v, ok := value.(*pgtype.Date)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicenseExpirationDate(v)
		return nil
	case workerprofile.FieldEndorsements:
		v, ok := value.(workerprofile.Endorsements)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndorsements(v)
		return nil
	case workerprofile.FieldHazmatExpirationDate:
		v, ok := value.(*pgtype.Date)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHazmatExpirationDate(v)
		return nil
	case workerprofile.FieldHireDate:
		v, ok := value.(*pgtype.Date)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHireDate(v)
		return nil
	case workerprofile.FieldTerminationDate:
		v, ok := value.(*pgtype.Date)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTerminationDate(v)
		return nil
	case workerprofile.FieldPhysicalDueDate:
		v, ok := value.(*pgtype.Date)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhysicalDueDate(v)
		return nil
	case workerprofile.FieldMedicalCertDate:
		v, ok := value.(*pgtype.Date)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMedicalCertDate(v)
		return nil
	case workerprofile.FieldMvrDueDate:
		v, ok := value.(*pgtype.Date)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMvrDueDate(v)
		return nil
	}
	return fmt.Errorf("unknown WorkerProfile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkerProfileMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, workerprofile.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkerProfileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workerprofile.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkerProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workerprofile.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown WorkerProfile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkerProfileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workerprofile.FieldRace) {
		fields = append(fields, workerprofile.FieldRace)
	}
	if m.FieldCleared(workerprofile.FieldSex) {
		fields = append(fields, workerprofile.FieldSex)
	}
	if m.FieldCleared(workerprofile.FieldDateOfBirth) {
		fields = append(fields, workerprofile.FieldDateOfBirth)
	}
	if m.FieldCleared(workerprofile.FieldLicenseExpirationDate) {
		fields = append(fields, workerprofile.FieldLicenseExpirationDate)
	}
	if m.FieldCleared(workerprofile.FieldEndorsements) {
		fields = append(fields, workerprofile.FieldEndorsements)
	}
	if m.FieldCleared(workerprofile.FieldHazmatExpirationDate) {
		fields = append(fields, workerprofile.FieldHazmatExpirationDate)
	}
	if m.FieldCleared(workerprofile.FieldHireDate) {
		fields = append(fields, workerprofile.FieldHireDate)
	}
	if m.FieldCleared(workerprofile.FieldTerminationDate) {
		fields = append(fields, workerprofile.FieldTerminationDate)
	}
	if m.FieldCleared(workerprofile.FieldPhysicalDueDate) {
		fields = append(fields, workerprofile.FieldPhysicalDueDate)
	}
	if m.FieldCleared(workerprofile.FieldMedicalCertDate) {
		fields = append(fields, workerprofile.FieldMedicalCertDate)
	}
	if m.FieldCleared(workerprofile.FieldMvrDueDate) {
		fields = append(fields, workerprofile.FieldMvrDueDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkerProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkerProfileMutation) ClearField(name string) error {
	switch name {
	case workerprofile.FieldRace:
		m.ClearRace()
		return nil
	case workerprofile.FieldSex:
		m.ClearSex()
		return nil
	case workerprofile.FieldDateOfBirth:
		m.ClearDateOfBirth()
		return nil
	case workerprofile.FieldLicenseExpirationDate:
		m.ClearLicenseExpirationDate()
		return nil
	case workerprofile.FieldEndorsements:
		m.ClearEndorsements()
		return nil
	case workerprofile.FieldHazmatExpirationDate:
		m.ClearHazmatExpirationDate()
		return nil
	case workerprofile.FieldHireDate:
		m.ClearHireDate()
		return nil
	case workerprofile.FieldTerminationDate:
		m.ClearTerminationDate()
		return nil
	case workerprofile.FieldPhysicalDueDate:
		m.ClearPhysicalDueDate()
		return nil
	case workerprofile.FieldMedicalCertDate:
		m.ClearMedicalCertDate()
		return nil
	case workerprofile.FieldMvrDueDate:
		m.ClearMvrDueDate()
		return nil
	}
	return fmt.Errorf("unknown WorkerProfile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkerProfileMutation) ResetField(name string) error {
	switch name {
	case workerprofile.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case workerprofile.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case workerprofile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workerprofile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case workerprofile.FieldVersion:
		m.ResetVersion()
		return nil
	case workerprofile.FieldWorkerID:
		m.ResetWorkerID()
		return nil
	case workerprofile.FieldRace:
		m.ResetRace()
		return nil
	case workerprofile.FieldSex:
		m.ResetSex()
		return nil
	case workerprofile.FieldDateOfBirth:
		m.ResetDateOfBirth()
		return nil
	case workerprofile.FieldLicenseNumber:
		m.ResetLicenseNumber()
		return nil
	case workerprofile.FieldLicenseStateID:
		m.ResetLicenseStateID()
		return nil
	case workerprofile.FieldLicenseExpirationDate:
		m.ResetLicenseExpirationDate()
		return nil
	case workerprofile.FieldEndorsements:
		m.ResetEndorsements()
		return nil
	case workerprofile.FieldHazmatExpirationDate:
		m.ResetHazmatExpirationDate()
		return nil
	case workerprofile.FieldHireDate:
		m.ResetHireDate()
		return nil
	case workerprofile.FieldTerminationDate:
		m.ResetTerminationDate()
		return nil
	case workerprofile.FieldPhysicalDueDate:
		m.ResetPhysicalDueDate()
		return nil
	case workerprofile.FieldMedicalCertDate:
		m.ResetMedicalCertDate()
		return nil
	case workerprofile.FieldMvrDueDate:
		m.ResetMvrDueDate()
		return nil
	}
	return fmt.Errorf("unknown WorkerProfile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkerProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.business_unit != nil {
		edges = append(edges, workerprofile.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, workerprofile.EdgeOrganization)
	}
	if m.worker != nil {
		edges = append(edges, workerprofile.EdgeWorker)
	}
	if m.state != nil {
		edges = append(edges, workerprofile.EdgeState)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkerProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workerprofile.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case workerprofile.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case workerprofile.EdgeWorker:
		if id := m.worker; id != nil {
			return []ent.Value{*id}
		}
	case workerprofile.EdgeState:
		if id := m.state; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkerProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkerProfileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkerProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedbusiness_unit {
		edges = append(edges, workerprofile.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, workerprofile.EdgeOrganization)
	}
	if m.clearedworker {
		edges = append(edges, workerprofile.EdgeWorker)
	}
	if m.clearedstate {
		edges = append(edges, workerprofile.EdgeState)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkerProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case workerprofile.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case workerprofile.EdgeOrganization:
		return m.clearedorganization
	case workerprofile.EdgeWorker:
		return m.clearedworker
	case workerprofile.EdgeState:
		return m.clearedstate
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkerProfileMutation) ClearEdge(name string) error {
	switch name {
	case workerprofile.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case workerprofile.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case workerprofile.EdgeWorker:
		m.ClearWorker()
		return nil
	case workerprofile.EdgeState:
		m.ClearState()
		return nil
	}
	return fmt.Errorf("unknown WorkerProfile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkerProfileMutation) ResetEdge(name string) error {
	switch name {
	case workerprofile.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case workerprofile.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case workerprofile.EdgeWorker:
		m.ResetWorker()
		return nil
	case workerprofile.EdgeState:
		m.ResetState()
		return nil
	}
	return fmt.Errorf("unknown WorkerProfile edge %s", name)
}
