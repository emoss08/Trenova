// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/emoss08/trenova/internal/ent/businessunit"
	"github.com/emoss08/trenova/internal/ent/organization"
	"github.com/emoss08/trenova/internal/ent/shipmentmove"
	"github.com/emoss08/trenova/internal/ent/stop"
	"github.com/google/uuid"
)

// Stop is the model entity for the Stop schema.
type Stop struct {
	config `json:"-" validate:"-"`
	// ID of the ent.
	ID uuid.UUID `json:"id,omitempty"`
	// BusinessUnitID holds the value of the "business_unit_id" field.
	BusinessUnitID uuid.UUID `json:"businessUnitId"`
	// OrganizationID holds the value of the "organization_id" field.
	OrganizationID uuid.UUID `json:"organizationId"`
	// The time that this entity was created.
	CreatedAt time.Time `json:"createdAt" validate:"omitempty"`
	// The last time that this entity was updated.
	UpdatedAt time.Time `json:"updatedAt" validate:"omitempty"`
	// The current version of this entity.
	Version int `json:"version" validate:"omitempty"`
	// Status holds the value of the "status" field.
	Status stop.Status `json:"status" validate:"required"`
	// ShipmentMoveID holds the value of the "shipment_move_id" field.
	ShipmentMoveID uuid.UUID `json:"shipmentMoveId"`
	// StopType holds the value of the "stop_type" field.
	StopType stop.StopType `json:"stopType" validate:"required"`
	// Current sequence of the stop within the movement.
	Sequence int `json:"sequence" validate:"required"`
	// LocationID holds the value of the "location_id" field.
	LocationID *uuid.UUID `json:"locationId" validate:"omitempty"`
	// Pieces holds the value of the "pieces" field.
	Pieces float64 `json:"pieces" validate:"omitempty"`
	// Weight holds the value of the "weight" field.
	Weight float64 `json:"weight" validate:"omitempty"`
	// AddressLine holds the value of the "address_line" field.
	AddressLine string `json:"addressLine" validate:"omitempty"`
	// AppointmentStart holds the value of the "appointment_start" field.
	AppointmentStart *time.Time `json:"appointmentStart" validate:"required"`
	// AppointmentEnd holds the value of the "appointment_end" field.
	AppointmentEnd *time.Time `json:"appointmentEnd" validate:"required"`
	// ArrivalTime holds the value of the "arrival_time" field.
	ArrivalTime *time.Time `json:"arrivaltime" validate:"omitempty"`
	// DepartureTime holds the value of the "departure_time" field.
	DepartureTime *time.Time `json:"departureTime" validate:"omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the StopQuery when eager-loading is set.
	Edges        StopEdges `json:"edges"`
	selectValues sql.SelectValues
}

// StopEdges holds the relations/edges for other nodes in the graph.
type StopEdges struct {
	// BusinessUnit holds the value of the business_unit edge.
	BusinessUnit *BusinessUnit `json:"business_unit,omitempty"`
	// Organization holds the value of the organization edge.
	Organization *Organization `json:"organization,omitempty"`
	// ShipmentMove holds the value of the shipment_move edge.
	ShipmentMove *ShipmentMove `json:"shipmentMove,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [3]bool
}

// BusinessUnitOrErr returns the BusinessUnit value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e StopEdges) BusinessUnitOrErr() (*BusinessUnit, error) {
	if e.BusinessUnit != nil {
		return e.BusinessUnit, nil
	} else if e.loadedTypes[0] {
		return nil, &NotFoundError{label: businessunit.Label}
	}
	return nil, &NotLoadedError{edge: "business_unit"}
}

// OrganizationOrErr returns the Organization value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e StopEdges) OrganizationOrErr() (*Organization, error) {
	if e.Organization != nil {
		return e.Organization, nil
	} else if e.loadedTypes[1] {
		return nil, &NotFoundError{label: organization.Label}
	}
	return nil, &NotLoadedError{edge: "organization"}
}

// ShipmentMoveOrErr returns the ShipmentMove value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e StopEdges) ShipmentMoveOrErr() (*ShipmentMove, error) {
	if e.ShipmentMove != nil {
		return e.ShipmentMove, nil
	} else if e.loadedTypes[2] {
		return nil, &NotFoundError{label: shipmentmove.Label}
	}
	return nil, &NotLoadedError{edge: "shipment_move"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Stop) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case stop.FieldLocationID:
			values[i] = &sql.NullScanner{S: new(uuid.UUID)}
		case stop.FieldPieces, stop.FieldWeight:
			values[i] = new(sql.NullFloat64)
		case stop.FieldVersion, stop.FieldSequence:
			values[i] = new(sql.NullInt64)
		case stop.FieldStatus, stop.FieldStopType, stop.FieldAddressLine:
			values[i] = new(sql.NullString)
		case stop.FieldCreatedAt, stop.FieldUpdatedAt, stop.FieldAppointmentStart, stop.FieldAppointmentEnd, stop.FieldArrivalTime, stop.FieldDepartureTime:
			values[i] = new(sql.NullTime)
		case stop.FieldID, stop.FieldBusinessUnitID, stop.FieldOrganizationID, stop.FieldShipmentMoveID:
			values[i] = new(uuid.UUID)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Stop fields.
func (s *Stop) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case stop.FieldID:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value != nil {
				s.ID = *value
			}
		case stop.FieldBusinessUnitID:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field business_unit_id", values[i])
			} else if value != nil {
				s.BusinessUnitID = *value
			}
		case stop.FieldOrganizationID:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field organization_id", values[i])
			} else if value != nil {
				s.OrganizationID = *value
			}
		case stop.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				s.CreatedAt = value.Time
			}
		case stop.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				s.UpdatedAt = value.Time
			}
		case stop.FieldVersion:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field version", values[i])
			} else if value.Valid {
				s.Version = int(value.Int64)
			}
		case stop.FieldStatus:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field status", values[i])
			} else if value.Valid {
				s.Status = stop.Status(value.String)
			}
		case stop.FieldShipmentMoveID:
			if value, ok := values[i].(*uuid.UUID); !ok {
				return fmt.Errorf("unexpected type %T for field shipment_move_id", values[i])
			} else if value != nil {
				s.ShipmentMoveID = *value
			}
		case stop.FieldStopType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field stop_type", values[i])
			} else if value.Valid {
				s.StopType = stop.StopType(value.String)
			}
		case stop.FieldSequence:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field sequence", values[i])
			} else if value.Valid {
				s.Sequence = int(value.Int64)
			}
		case stop.FieldLocationID:
			if value, ok := values[i].(*sql.NullScanner); !ok {
				return fmt.Errorf("unexpected type %T for field location_id", values[i])
			} else if value.Valid {
				s.LocationID = new(uuid.UUID)
				*s.LocationID = *value.S.(*uuid.UUID)
			}
		case stop.FieldPieces:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field pieces", values[i])
			} else if value.Valid {
				s.Pieces = value.Float64
			}
		case stop.FieldWeight:
			if value, ok := values[i].(*sql.NullFloat64); !ok {
				return fmt.Errorf("unexpected type %T for field weight", values[i])
			} else if value.Valid {
				s.Weight = value.Float64
			}
		case stop.FieldAddressLine:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field address_line", values[i])
			} else if value.Valid {
				s.AddressLine = value.String
			}
		case stop.FieldAppointmentStart:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field appointment_start", values[i])
			} else if value.Valid {
				s.AppointmentStart = new(time.Time)
				*s.AppointmentStart = value.Time
			}
		case stop.FieldAppointmentEnd:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field appointment_end", values[i])
			} else if value.Valid {
				s.AppointmentEnd = new(time.Time)
				*s.AppointmentEnd = value.Time
			}
		case stop.FieldArrivalTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field arrival_time", values[i])
			} else if value.Valid {
				s.ArrivalTime = new(time.Time)
				*s.ArrivalTime = value.Time
			}
		case stop.FieldDepartureTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field departure_time", values[i])
			} else if value.Valid {
				s.DepartureTime = new(time.Time)
				*s.DepartureTime = value.Time
			}
		default:
			s.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the Stop.
// This includes values selected through modifiers, order, etc.
func (s *Stop) Value(name string) (ent.Value, error) {
	return s.selectValues.Get(name)
}

// QueryBusinessUnit queries the "business_unit" edge of the Stop entity.
func (s *Stop) QueryBusinessUnit() *BusinessUnitQuery {
	return NewStopClient(s.config).QueryBusinessUnit(s)
}

// QueryOrganization queries the "organization" edge of the Stop entity.
func (s *Stop) QueryOrganization() *OrganizationQuery {
	return NewStopClient(s.config).QueryOrganization(s)
}

// QueryShipmentMove queries the "shipment_move" edge of the Stop entity.
func (s *Stop) QueryShipmentMove() *ShipmentMoveQuery {
	return NewStopClient(s.config).QueryShipmentMove(s)
}

// Update returns a builder for updating this Stop.
// Note that you need to call Stop.Unwrap() before calling this method if this Stop
// was returned from a transaction, and the transaction was committed or rolled back.
func (s *Stop) Update() *StopUpdateOne {
	return NewStopClient(s.config).UpdateOne(s)
}

// Unwrap unwraps the Stop entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (s *Stop) Unwrap() *Stop {
	_tx, ok := s.config.driver.(*txDriver)
	if !ok {
		panic("ent: Stop is not a transactional entity")
	}
	s.config.driver = _tx.drv
	return s
}

// String implements the fmt.Stringer.
func (s *Stop) String() string {
	var builder strings.Builder
	builder.WriteString("Stop(")
	builder.WriteString(fmt.Sprintf("id=%v, ", s.ID))
	builder.WriteString("business_unit_id=")
	builder.WriteString(fmt.Sprintf("%v", s.BusinessUnitID))
	builder.WriteString(", ")
	builder.WriteString("organization_id=")
	builder.WriteString(fmt.Sprintf("%v", s.OrganizationID))
	builder.WriteString(", ")
	builder.WriteString("created_at=")
	builder.WriteString(s.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("updated_at=")
	builder.WriteString(s.UpdatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("version=")
	builder.WriteString(fmt.Sprintf("%v", s.Version))
	builder.WriteString(", ")
	builder.WriteString("status=")
	builder.WriteString(fmt.Sprintf("%v", s.Status))
	builder.WriteString(", ")
	builder.WriteString("shipment_move_id=")
	builder.WriteString(fmt.Sprintf("%v", s.ShipmentMoveID))
	builder.WriteString(", ")
	builder.WriteString("stop_type=")
	builder.WriteString(fmt.Sprintf("%v", s.StopType))
	builder.WriteString(", ")
	builder.WriteString("sequence=")
	builder.WriteString(fmt.Sprintf("%v", s.Sequence))
	builder.WriteString(", ")
	if v := s.LocationID; v != nil {
		builder.WriteString("location_id=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteString(", ")
	builder.WriteString("pieces=")
	builder.WriteString(fmt.Sprintf("%v", s.Pieces))
	builder.WriteString(", ")
	builder.WriteString("weight=")
	builder.WriteString(fmt.Sprintf("%v", s.Weight))
	builder.WriteString(", ")
	builder.WriteString("address_line=")
	builder.WriteString(s.AddressLine)
	builder.WriteString(", ")
	if v := s.AppointmentStart; v != nil {
		builder.WriteString("appointment_start=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	if v := s.AppointmentEnd; v != nil {
		builder.WriteString("appointment_end=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	if v := s.ArrivalTime; v != nil {
		builder.WriteString("arrival_time=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	if v := s.DepartureTime; v != nil {
		builder.WriteString("departure_time=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteByte(')')
	return builder.String()
}

// Stops is a parsable slice of Stop.
type Stops []*Stop
