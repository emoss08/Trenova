// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/emoss08/trenova/internal/ent/predicate"
	"github.com/emoss08/trenova/internal/ent/usernotification"
)

// UserNotificationUpdate is the builder for updating UserNotification entities.
type UserNotificationUpdate struct {
	config
	hooks     []Hook
	mutation  *UserNotificationMutation
	modifiers []func(*sql.UpdateBuilder)
}

// Where appends a list predicates to the UserNotificationUpdate builder.
func (unu *UserNotificationUpdate) Where(ps ...predicate.UserNotification) *UserNotificationUpdate {
	unu.mutation.Where(ps...)
	return unu
}

// SetUpdatedAt sets the "updated_at" field.
func (unu *UserNotificationUpdate) SetUpdatedAt(t time.Time) *UserNotificationUpdate {
	unu.mutation.SetUpdatedAt(t)
	return unu
}

// SetVersion sets the "version" field.
func (unu *UserNotificationUpdate) SetVersion(i int) *UserNotificationUpdate {
	unu.mutation.ResetVersion()
	unu.mutation.SetVersion(i)
	return unu
}

// SetNillableVersion sets the "version" field if the given value is not nil.
func (unu *UserNotificationUpdate) SetNillableVersion(i *int) *UserNotificationUpdate {
	if i != nil {
		unu.SetVersion(*i)
	}
	return unu
}

// AddVersion adds i to the "version" field.
func (unu *UserNotificationUpdate) AddVersion(i int) *UserNotificationUpdate {
	unu.mutation.AddVersion(i)
	return unu
}

// SetIsRead sets the "is_read" field.
func (unu *UserNotificationUpdate) SetIsRead(b bool) *UserNotificationUpdate {
	unu.mutation.SetIsRead(b)
	return unu
}

// SetNillableIsRead sets the "is_read" field if the given value is not nil.
func (unu *UserNotificationUpdate) SetNillableIsRead(b *bool) *UserNotificationUpdate {
	if b != nil {
		unu.SetIsRead(*b)
	}
	return unu
}

// SetTitle sets the "title" field.
func (unu *UserNotificationUpdate) SetTitle(s string) *UserNotificationUpdate {
	unu.mutation.SetTitle(s)
	return unu
}

// SetNillableTitle sets the "title" field if the given value is not nil.
func (unu *UserNotificationUpdate) SetNillableTitle(s *string) *UserNotificationUpdate {
	if s != nil {
		unu.SetTitle(*s)
	}
	return unu
}

// SetDescription sets the "description" field.
func (unu *UserNotificationUpdate) SetDescription(s string) *UserNotificationUpdate {
	unu.mutation.SetDescription(s)
	return unu
}

// SetNillableDescription sets the "description" field if the given value is not nil.
func (unu *UserNotificationUpdate) SetNillableDescription(s *string) *UserNotificationUpdate {
	if s != nil {
		unu.SetDescription(*s)
	}
	return unu
}

// SetActionURL sets the "action_url" field.
func (unu *UserNotificationUpdate) SetActionURL(s string) *UserNotificationUpdate {
	unu.mutation.SetActionURL(s)
	return unu
}

// SetNillableActionURL sets the "action_url" field if the given value is not nil.
func (unu *UserNotificationUpdate) SetNillableActionURL(s *string) *UserNotificationUpdate {
	if s != nil {
		unu.SetActionURL(*s)
	}
	return unu
}

// ClearActionURL clears the value of the "action_url" field.
func (unu *UserNotificationUpdate) ClearActionURL() *UserNotificationUpdate {
	unu.mutation.ClearActionURL()
	return unu
}

// Mutation returns the UserNotificationMutation object of the builder.
func (unu *UserNotificationUpdate) Mutation() *UserNotificationMutation {
	return unu.mutation
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (unu *UserNotificationUpdate) Save(ctx context.Context) (int, error) {
	unu.defaults()
	return withHooks(ctx, unu.sqlSave, unu.mutation, unu.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (unu *UserNotificationUpdate) SaveX(ctx context.Context) int {
	affected, err := unu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (unu *UserNotificationUpdate) Exec(ctx context.Context) error {
	_, err := unu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (unu *UserNotificationUpdate) ExecX(ctx context.Context) {
	if err := unu.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (unu *UserNotificationUpdate) defaults() {
	if _, ok := unu.mutation.UpdatedAt(); !ok {
		v := usernotification.UpdateDefaultUpdatedAt()
		unu.mutation.SetUpdatedAt(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (unu *UserNotificationUpdate) check() error {
	if v, ok := unu.mutation.Title(); ok {
		if err := usernotification.TitleValidator(v); err != nil {
			return &ValidationError{Name: "title", err: fmt.Errorf(`ent: validator failed for field "UserNotification.title": %w`, err)}
		}
	}
	if v, ok := unu.mutation.Description(); ok {
		if err := usernotification.DescriptionValidator(v); err != nil {
			return &ValidationError{Name: "description", err: fmt.Errorf(`ent: validator failed for field "UserNotification.description": %w`, err)}
		}
	}
	if _, ok := unu.mutation.BusinessUnitID(); unu.mutation.BusinessUnitCleared() && !ok {
		return errors.New(`ent: clearing a required unique edge "UserNotification.business_unit"`)
	}
	if _, ok := unu.mutation.OrganizationID(); unu.mutation.OrganizationCleared() && !ok {
		return errors.New(`ent: clearing a required unique edge "UserNotification.organization"`)
	}
	if _, ok := unu.mutation.UserID(); unu.mutation.UserCleared() && !ok {
		return errors.New(`ent: clearing a required unique edge "UserNotification.user"`)
	}
	return nil
}

// Modify adds a statement modifier for attaching custom logic to the UPDATE statement.
func (unu *UserNotificationUpdate) Modify(modifiers ...func(u *sql.UpdateBuilder)) *UserNotificationUpdate {
	unu.modifiers = append(unu.modifiers, modifiers...)
	return unu
}

func (unu *UserNotificationUpdate) sqlSave(ctx context.Context) (n int, err error) {
	if err := unu.check(); err != nil {
		return n, err
	}
	_spec := sqlgraph.NewUpdateSpec(usernotification.Table, usernotification.Columns, sqlgraph.NewFieldSpec(usernotification.FieldID, field.TypeUUID))
	if ps := unu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := unu.mutation.UpdatedAt(); ok {
		_spec.SetField(usernotification.FieldUpdatedAt, field.TypeTime, value)
	}
	if value, ok := unu.mutation.Version(); ok {
		_spec.SetField(usernotification.FieldVersion, field.TypeInt, value)
	}
	if value, ok := unu.mutation.AddedVersion(); ok {
		_spec.AddField(usernotification.FieldVersion, field.TypeInt, value)
	}
	if value, ok := unu.mutation.IsRead(); ok {
		_spec.SetField(usernotification.FieldIsRead, field.TypeBool, value)
	}
	if value, ok := unu.mutation.Title(); ok {
		_spec.SetField(usernotification.FieldTitle, field.TypeString, value)
	}
	if value, ok := unu.mutation.Description(); ok {
		_spec.SetField(usernotification.FieldDescription, field.TypeString, value)
	}
	if value, ok := unu.mutation.ActionURL(); ok {
		_spec.SetField(usernotification.FieldActionURL, field.TypeString, value)
	}
	if unu.mutation.ActionURLCleared() {
		_spec.ClearField(usernotification.FieldActionURL, field.TypeString)
	}
	_spec.AddModifiers(unu.modifiers...)
	if n, err = sqlgraph.UpdateNodes(ctx, unu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{usernotification.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	unu.mutation.done = true
	return n, nil
}

// UserNotificationUpdateOne is the builder for updating a single UserNotification entity.
type UserNotificationUpdateOne struct {
	config
	fields    []string
	hooks     []Hook
	mutation  *UserNotificationMutation
	modifiers []func(*sql.UpdateBuilder)
}

// SetUpdatedAt sets the "updated_at" field.
func (unuo *UserNotificationUpdateOne) SetUpdatedAt(t time.Time) *UserNotificationUpdateOne {
	unuo.mutation.SetUpdatedAt(t)
	return unuo
}

// SetVersion sets the "version" field.
func (unuo *UserNotificationUpdateOne) SetVersion(i int) *UserNotificationUpdateOne {
	unuo.mutation.ResetVersion()
	unuo.mutation.SetVersion(i)
	return unuo
}

// SetNillableVersion sets the "version" field if the given value is not nil.
func (unuo *UserNotificationUpdateOne) SetNillableVersion(i *int) *UserNotificationUpdateOne {
	if i != nil {
		unuo.SetVersion(*i)
	}
	return unuo
}

// AddVersion adds i to the "version" field.
func (unuo *UserNotificationUpdateOne) AddVersion(i int) *UserNotificationUpdateOne {
	unuo.mutation.AddVersion(i)
	return unuo
}

// SetIsRead sets the "is_read" field.
func (unuo *UserNotificationUpdateOne) SetIsRead(b bool) *UserNotificationUpdateOne {
	unuo.mutation.SetIsRead(b)
	return unuo
}

// SetNillableIsRead sets the "is_read" field if the given value is not nil.
func (unuo *UserNotificationUpdateOne) SetNillableIsRead(b *bool) *UserNotificationUpdateOne {
	if b != nil {
		unuo.SetIsRead(*b)
	}
	return unuo
}

// SetTitle sets the "title" field.
func (unuo *UserNotificationUpdateOne) SetTitle(s string) *UserNotificationUpdateOne {
	unuo.mutation.SetTitle(s)
	return unuo
}

// SetNillableTitle sets the "title" field if the given value is not nil.
func (unuo *UserNotificationUpdateOne) SetNillableTitle(s *string) *UserNotificationUpdateOne {
	if s != nil {
		unuo.SetTitle(*s)
	}
	return unuo
}

// SetDescription sets the "description" field.
func (unuo *UserNotificationUpdateOne) SetDescription(s string) *UserNotificationUpdateOne {
	unuo.mutation.SetDescription(s)
	return unuo
}

// SetNillableDescription sets the "description" field if the given value is not nil.
func (unuo *UserNotificationUpdateOne) SetNillableDescription(s *string) *UserNotificationUpdateOne {
	if s != nil {
		unuo.SetDescription(*s)
	}
	return unuo
}

// SetActionURL sets the "action_url" field.
func (unuo *UserNotificationUpdateOne) SetActionURL(s string) *UserNotificationUpdateOne {
	unuo.mutation.SetActionURL(s)
	return unuo
}

// SetNillableActionURL sets the "action_url" field if the given value is not nil.
func (unuo *UserNotificationUpdateOne) SetNillableActionURL(s *string) *UserNotificationUpdateOne {
	if s != nil {
		unuo.SetActionURL(*s)
	}
	return unuo
}

// ClearActionURL clears the value of the "action_url" field.
func (unuo *UserNotificationUpdateOne) ClearActionURL() *UserNotificationUpdateOne {
	unuo.mutation.ClearActionURL()
	return unuo
}

// Mutation returns the UserNotificationMutation object of the builder.
func (unuo *UserNotificationUpdateOne) Mutation() *UserNotificationMutation {
	return unuo.mutation
}

// Where appends a list predicates to the UserNotificationUpdate builder.
func (unuo *UserNotificationUpdateOne) Where(ps ...predicate.UserNotification) *UserNotificationUpdateOne {
	unuo.mutation.Where(ps...)
	return unuo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (unuo *UserNotificationUpdateOne) Select(field string, fields ...string) *UserNotificationUpdateOne {
	unuo.fields = append([]string{field}, fields...)
	return unuo
}

// Save executes the query and returns the updated UserNotification entity.
func (unuo *UserNotificationUpdateOne) Save(ctx context.Context) (*UserNotification, error) {
	unuo.defaults()
	return withHooks(ctx, unuo.sqlSave, unuo.mutation, unuo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (unuo *UserNotificationUpdateOne) SaveX(ctx context.Context) *UserNotification {
	node, err := unuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (unuo *UserNotificationUpdateOne) Exec(ctx context.Context) error {
	_, err := unuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (unuo *UserNotificationUpdateOne) ExecX(ctx context.Context) {
	if err := unuo.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (unuo *UserNotificationUpdateOne) defaults() {
	if _, ok := unuo.mutation.UpdatedAt(); !ok {
		v := usernotification.UpdateDefaultUpdatedAt()
		unuo.mutation.SetUpdatedAt(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (unuo *UserNotificationUpdateOne) check() error {
	if v, ok := unuo.mutation.Title(); ok {
		if err := usernotification.TitleValidator(v); err != nil {
			return &ValidationError{Name: "title", err: fmt.Errorf(`ent: validator failed for field "UserNotification.title": %w`, err)}
		}
	}
	if v, ok := unuo.mutation.Description(); ok {
		if err := usernotification.DescriptionValidator(v); err != nil {
			return &ValidationError{Name: "description", err: fmt.Errorf(`ent: validator failed for field "UserNotification.description": %w`, err)}
		}
	}
	if _, ok := unuo.mutation.BusinessUnitID(); unuo.mutation.BusinessUnitCleared() && !ok {
		return errors.New(`ent: clearing a required unique edge "UserNotification.business_unit"`)
	}
	if _, ok := unuo.mutation.OrganizationID(); unuo.mutation.OrganizationCleared() && !ok {
		return errors.New(`ent: clearing a required unique edge "UserNotification.organization"`)
	}
	if _, ok := unuo.mutation.UserID(); unuo.mutation.UserCleared() && !ok {
		return errors.New(`ent: clearing a required unique edge "UserNotification.user"`)
	}
	return nil
}

// Modify adds a statement modifier for attaching custom logic to the UPDATE statement.
func (unuo *UserNotificationUpdateOne) Modify(modifiers ...func(u *sql.UpdateBuilder)) *UserNotificationUpdateOne {
	unuo.modifiers = append(unuo.modifiers, modifiers...)
	return unuo
}

func (unuo *UserNotificationUpdateOne) sqlSave(ctx context.Context) (_node *UserNotification, err error) {
	if err := unuo.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(usernotification.Table, usernotification.Columns, sqlgraph.NewFieldSpec(usernotification.FieldID, field.TypeUUID))
	id, ok := unuo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "UserNotification.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := unuo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, usernotification.FieldID)
		for _, f := range fields {
			if !usernotification.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != usernotification.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := unuo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := unuo.mutation.UpdatedAt(); ok {
		_spec.SetField(usernotification.FieldUpdatedAt, field.TypeTime, value)
	}
	if value, ok := unuo.mutation.Version(); ok {
		_spec.SetField(usernotification.FieldVersion, field.TypeInt, value)
	}
	if value, ok := unuo.mutation.AddedVersion(); ok {
		_spec.AddField(usernotification.FieldVersion, field.TypeInt, value)
	}
	if value, ok := unuo.mutation.IsRead(); ok {
		_spec.SetField(usernotification.FieldIsRead, field.TypeBool, value)
	}
	if value, ok := unuo.mutation.Title(); ok {
		_spec.SetField(usernotification.FieldTitle, field.TypeString, value)
	}
	if value, ok := unuo.mutation.Description(); ok {
		_spec.SetField(usernotification.FieldDescription, field.TypeString, value)
	}
	if value, ok := unuo.mutation.ActionURL(); ok {
		_spec.SetField(usernotification.FieldActionURL, field.TypeString, value)
	}
	if unuo.mutation.ActionURLCleared() {
		_spec.ClearField(usernotification.FieldActionURL, field.TypeString)
	}
	_spec.AddModifiers(unuo.modifiers...)
	_node = &UserNotification{config: unuo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, unuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{usernotification.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	unuo.mutation.done = true
	return _node, nil
}
