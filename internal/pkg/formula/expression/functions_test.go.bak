package expression

import (
	"context"
	"fmt"
	"math"
	"testing"
	"time"

	"github.com/emoss08/trenova/internal/pkg/formula/conversion"
)

func TestBuiltinFunctions(t *testing.T) {
	// Create a mock variable context
	mockVarCtx := &mockVariableContext{
		fields: map[string]any{
			"test_var": 42.0,
		},
	}

	// Create evaluation context
	evalCtx := NewEvaluationContext(context.Background(), mockVarCtx)
	registry := evalCtx.functions

	tests := []struct {
		name      string
		function  string
		args      []any
		want      any
		wantError bool
	}{
		// Math functions
		{
			name:     "abs positive",
			function: "abs",
			args:     []any{5.0},
			want:     5.0,
		},
		{
			name:     "abs negative",
			function: "abs",
			args:     []any{-5.0},
			want:     5.0,
		},
		{
			name:      "abs wrong args",
			function:  "abs",
			args:      []any{},
			wantError: true,
		},
		{
			name:     "min two args",
			function: "min",
			args:     []any{5.0, 3.0},
			want:     3.0,
		},
		{
			name:     "min multiple args",
			function: "min",
			args:     []any{5.0, 3.0, 7.0, 1.0},
			want:     1.0,
		},
		{
			name:      "min no args",
			function:  "min",
			args:      []any{},
			wantError: true,
		},
		{
			name:     "max two args",
			function: "max",
			args:     []any{5.0, 3.0},
			want:     5.0,
		},
		{
			name:     "max multiple args",
			function: "max",
			args:     []any{5.0, 3.0, 7.0, 1.0},
			want:     7.0,
		},
		{
			name:     "floor",
			function: "floor",
			args:     []any{3.7},
			want:     3.0,
		},
		{
			name:     "ceil",
			function: "ceil",
			args:     []any{3.2},
			want:     4.0,
		},
		{
			name:     "round half up",
			function: "round",
			args:     []any{3.5},
			want:     4.0,
		},
		{
			name:     "round half down",
			function: "round",
			args:     []any{3.4},
			want:     3.0,
		},
		{
			name:     "round with precision",
			function: "round",
			args:     []any{3.14159, 2.0},
			want:     3.14,
		},
		{
			name:     "sqrt",
			function: "sqrt",
			args:     []any{16.0},
			want:     4.0,
		},
		{
			name:      "sqrt negative",
			function:  "sqrt",
			args:      []any{-4.0},
			wantError: true,
		},
		{
			name:     "pow",
			function: "pow",
			args:     []any{2.0, 3.0},
			want:     8.0,
		},
		{
			name:     "exp",
			function: "exp",
			args:     []any{1.0},
			want:     math.E,
		},
		{
			name:     "ln",
			function: "ln",
			args:     []any{math.E},
			want:     1.0,
		},
		{
			name:      "ln zero",
			function:  "ln",
			args:      []any{0.0},
			wantError: true,
		},
		{
			name:     "log10",
			function: "log10",
			args:     []any{100.0},
			want:     2.0,
		},
		{
			name:     "sin",
			function: "sin",
			args:     []any{0.0},
			want:     0.0,
		},
		{
			name:     "cos",
			function: "cos",
			args:     []any{0.0},
			want:     1.0,
		},
		{
			name:     "tan",
			function: "tan",
			args:     []any{0.0},
			want:     0.0,
		},
		{
			name:     "radians",
			function: "radians",
			args:     []any{180.0},
			want:     math.Pi,
		},
		{
			name:     "degrees",
			function: "degrees",
			args:     []any{math.Pi},
			want:     180.0,
		},

		// String functions
		{
			name:     "len string",
			function: "len",
			args:     []any{"hello"},
			want:     5.0,
		},
		{
			name:     "len array",
			function: "len",
			args:     []any{[]any{1, 2, 3}},
			want:     3.0,
		},
		{
			name:     "upper",
			function: "upper",
			args:     []any{"hello"},
			want:     "HELLO",
		},
		{
			name:      "upper non-string",
			function:  "upper",
			args:      []any{123},
			wantError: true,
		},
		{
			name:     "lower",
			function: "lower",
			args:     []any{"HELLO"},
			want:     "hello",
		},
		{
			name:     "concat two",
			function: "concat",
			args:     []any{"hello", " ", "world"},
			want:     "hello world",
		},
		{
			name:     "concat mixed types",
			function: "concat",
			args:     []any{"value: ", 42},
			want:     "value: 42",
		},
		{
			name:     "substring",
			function: "substring",
			args:     []any{"hello world", 0.0, 5.0},
			want:     "hello",
		},
		{
			name:     "substring from middle",
			function: "substring",
			args:     []any{"hello world", 6.0, 11.0},
			want:     "world",
		},
		{
			name:      "substring invalid indices",
			function:  "substring",
			args:      []any{"hello", 10.0, 20.0},
			wantError: true,
		},
		{
			name:     "trim",
			function: "trim",
			args:     []any{"  hello  "},
			want:     "hello",
		},
		{
			name:     "contains true",
			function: "contains",
			args:     []any{"hello world", "world"},
			want:     true,
		},
		{
			name:     "contains false",
			function: "contains",
			args:     []any{"hello world", "xyz"},
			want:     false,
		},
		{
			name:     "replace",
			function: "replace",
			args:     []any{"hello world", "world", "universe"},
			want:     "hello universe",
		},
		{
			name:     "split",
			function: "split",
			args:     []any{"a,b,c", ","},
			want:     []any{"a", "b", "c"},
		},

		// Date/Time functions
		{
			name:     "date_diff days",
			function: "date_diff",
			args: []any{
				time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC),
				time.Date(2024, 1, 5, 0, 0, 0, 0, time.UTC),
				"days",
			},
			want: 4.0,
		},
		{
			name:     "date_diff hours",
			function: "date_diff",
			args: []any{
				time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC),
				time.Date(2024, 1, 1, 12, 0, 0, 0, time.UTC),
				"hours",
			},
			want: 12.0,
		},
		{
			name:      "date_diff invalid unit",
			function:  "date_diff",
			args:      []any{time.Now(), time.Now(), "invalid"},
			wantError: true,
		},

		// Logic functions
		{
			name:     "if true",
			function: "if",
			args:     []any{true, "yes", "no"},
			want:     "yes",
		},
		{
			name:     "if false",
			function: "if",
			args:     []any{false, "yes", "no"},
			want:     "no",
		},
		{
			name:     "if number condition",
			function: "if",
			args:     []any{1.0, "yes", "no"},
			want:     "yes",
		},
		{
			name:     "if_error no error",
			function: "if_error",
			args:     []any{42.0, -1.0},
			want:     42.0,
		},
		{
			name:     "coalesce first non-nil",
			function: "coalesce",
			args:     []any{nil, nil, "value", "other"},
			want:     "value",
		},
		{
			name:     "coalesce all nil",
			function: "coalesce",
			args:     []any{nil, nil, nil},
			want:     nil,
		},

		// Type functions
		{
			name:     "is_number true",
			function: "is_number",
			args:     []any{42.0},
			want:     true,
		},
		{
			name:     "is_number false",
			function: "is_number",
			args:     []any{"hello"},
			want:     false,
		},
		{
			name:     "is_string true",
			function: "is_string",
			args:     []any{"hello"},
			want:     true,
		},
		{
			name:     "is_bool true",
			function: "is_bool",
			args:     []any{true},
			want:     true,
		},
		{
			name:     "is_array true",
			function: "is_array",
			args:     []any{[]any{1, 2, 3}},
			want:     true,
		},
		{
			name:     "to_number from string",
			function: "to_number",
			args:     []any{"42"},
			want:     42.0,
		},
		{
			name:     "to_number from bool",
			function: "to_number",
			args:     []any{true},
			want:     1.0,
		},
		{
			name:      "to_number invalid",
			function:  "to_number",
			args:      []any{"not a number"},
			wantError: true,
		},
		{
			name:     "to_string number",
			function: "to_string",
			args:     []any{42.0},
			want:     "42",
		},
		{
			name:     "to_string bool",
			function: "to_string",
			args:     []any{true},
			want:     "true",
		},

		// Array functions
		{
			name:     "sum",
			function: "sum",
			args:     []any{[]any{1.0, 2.0, 3.0, 4.0}},
			want:     10.0,
		},
		{
			name:     "average",
			function: "average",
			args:     []any{[]any{1.0, 2.0, 3.0, 4.0}},
			want:     2.5,
		},
		{
			name:      "average empty array",
			function:  "average",
			args:      []any{[]any{}},
			wantError: true,
		},
		{
			name:     "count",
			function: "count",
			args:     []any{[]any{1, 2, 3, 4}},
			want:     4.0,
		},
		{
			name:     "first",
			function: "first",
			args:     []any{[]any{"a", "b", "c"}},
			want:     "a",
		},
		{
			name:      "first empty array",
			function:  "first",
			args:      []any{[]any{}},
			wantError: true,
		},
		{
			name:     "last",
			function: "last",
			args:     []any{[]any{"a", "b", "c"}},
			want:     "c",
		},
		{
			name:     "reverse",
			function: "reverse",
			args:     []any{[]any{1, 2, 3}},
			want:     []any{3, 2, 1},
		},
		{
			name:     "sort numbers",
			function: "sort",
			args:     []any{[]any{3.0, 1.0, 4.0, 2.0}},
			want:     []any{1.0, 2.0, 3.0, 4.0},
		},
		{
			name:     "sort strings",
			function: "sort",
			args:     []any{[]any{"c", "a", "b"}},
			want:     []any{"a", "b", "c"},
		},
		{
			name:     "unique",
			function: "unique",
			args:     []any{[]any{1.0, 2.0, 2.0, 3.0, 3.0, 3.0}},
			want:     []any{1.0, 2.0, 3.0},
		},
		{
			name:     "filter",
			function: "filter",
			args: []any{[]any{1.0, 2.0, 3.0, 4.0, 5.0}, func(v any) (any, error) {
				val, ok := conversion.ToFloat64(v)
				if !ok {
					return false, nil
				}
				return val > 3, nil
			}},
			want: []any{4.0, 5.0},
		},
		{
			name:     "map",
			function: "map",
			args: []any{[]any{1.0, 2.0, 3.0}, func(v any) (any, error) {
				val, ok := conversion.ToFloat64(v)
				if !ok {
					return nil, fmt.Errorf("not a number")
				}
				return val * 2, nil
			}},
			want: []any{2.0, 4.0, 6.0},
		},

		// Business logic functions
		{
			name:     "percent",
			function: "percent",
			args:     []any{25.0, 200.0},
			want:     50.0,
		},
		{
			name:     "percent_of",
			function: "percent_of",
			args:     []any{50.0, 200.0},
			want:     25.0,
		},
		{
			name:     "clamp within range",
			function: "clamp",
			args:     []any{5.0, 0.0, 10.0},
			want:     5.0,
		},
		{
			name:     "clamp below min",
			function: "clamp",
			args:     []any{-5.0, 0.0, 10.0},
			want:     0.0,
		},
		{
			name:     "clamp above max",
			function: "clamp",
			args:     []any{15.0, 0.0, 10.0},
			want:     10.0,
		},
		{
			name:     "lerp start",
			function: "lerp",
			args:     []any{0.0, 10.0, 0.0},
			want:     0.0,
		},
		{
			name:     "lerp middle",
			function: "lerp",
			args:     []any{0.0, 10.0, 0.5},
			want:     5.0,
		},
		{
			name:     "lerp end",
			function: "lerp",
			args:     []any{0.0, 10.0, 1.0},
			want:     10.0,
		},
		{
			name:     "step_function below",
			function: "step_function",
			args: []any{
				5.0,
				[]any{0.0, 10.0, 20.0},
				[]any{100.0, 200.0, 300.0},
			},
			want: 100.0,
		},
		{
			name:     "step_function middle",
			function: "step_function",
			args: []any{
				15.0,
				[]any{0.0, 10.0, 20.0},
				[]any{100.0, 200.0, 300.0},
			},
			want: 200.0,
		},
		{
			name:     "step_function above",
			function: "step_function",
			args: []any{
				25.0,
				[]any{0.0, 10.0, 20.0},
				[]any{100.0, 200.0, 300.0},
			},
			want: 300.0,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			fn, exists := registry[tt.function]
			if !exists {
				t.Fatalf("function %q not found", tt.function)
			}

			got, err := fn.Call(evalCtx, tt.args...)
			if (err != nil) != tt.wantError {
				t.Errorf("Execute() error = %v, wantError %v", err, tt.wantError)
				return
			}

			if tt.wantError {
				return
			}

			// Special handling for float comparisons
			switch want := tt.want.(type) {
			case float64:
				got, ok := got.(float64)
				if !ok {
					t.Errorf("Execute() = %T, want float64", got)
					return
				}
				if math.Abs(got-want) > 1e-9 {
					t.Errorf("Execute() = %v, want %v", got, want)
				}
			case []any:
				gotSlice, ok := got.([]any)
				if !ok {
					t.Errorf("Execute() = %T, want []any", got)
					return
				}
				if len(gotSlice) != len(want) {
					t.Errorf("Execute() len = %d, want %d", len(gotSlice), len(want))
					return
				}
				for i := range want {
					if !equalValues(gotSlice[i], want[i]) {
						t.Errorf("Execute()[%d] = %v, want %v", i, gotSlice[i], want[i])
					}
				}
			default:
				if !equalValues(got, tt.want) {
					t.Errorf("Execute() = %v, want %v", got, tt.want)
				}
			}
		})
	}
}

func TestFunctionRegistry(t *testing.T) {
	// Create evaluation context to get registry
	mockVarCtx := &mockVariableContext{
		fields: map[string]any{},
	}
	evalCtx := NewEvaluationContext(context.Background(), mockVarCtx)
	registry := evalCtx.functions

	// Test getting a built-in function
	fn, exists := registry["abs"]
	if !exists {
		t.Error("Get abs() returned false, want true")
	}
	if fn == nil {
		t.Error("Get abs() returned nil function")
	}

	// Test getting non-existent function
	_, exists = registry["nonexistent"]
	if exists {
		t.Error("Get() returned true for non-existent function")
	}

	// Test that we have the expected number of built-in functions
	expectedFunctions := []string{
		"abs", "min", "max", "round", "floor", "ceil", "sqrt", "pow",
		"number", "string", "bool",
		"len", "sum", "avg",
		"if", "coalesce",
	}

	for _, name := range expectedFunctions {
		if _, exists := registry[name]; !exists {
			t.Errorf("Expected function %q not found in registry", name)
		}
	}
}

func TestValidateArgs(t *testing.T) {
	// Create a simple test function that implements the Function interface
	type testFunction struct {
		name    string
		minArgs int
		maxArgs int
	}

	tests := []struct {
		name      string
		fn        *testFunction
		args      []any
		wantError bool
	}{
		{
			name:      "too few args",
			fn:        &testFunction{minArgs: 2, maxArgs: 4},
			args:      []any{1},
			wantError: true,
		},
		{
			name:      "min args",
			fn:        &testFunction{minArgs: 2, maxArgs: 4},
			args:      []any{1, 2},
			wantError: false,
		},
		{
			name:      "between min and max",
			fn:        &testFunction{minArgs: 2, maxArgs: 4},
			args:      []any{1, 2, 3},
			wantError: false,
		},
		{
			name:      "max args",
			fn:        &testFunction{minArgs: 2, maxArgs: 4},
			args:      []any{1, 2, 3, 4},
			wantError: false,
		},
		{
			name:      "too many args",
			fn:        &testFunction{minArgs: 2, maxArgs: 4},
			args:      []any{1, 2, 3, 4, 5},
			wantError: true,
		},
		{
			name:      "unlimited args",
			fn:        &testFunction{minArgs: 1, maxArgs: -1},
			args:      []any{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},
			wantError: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Validate args based on min/max rules
			numArgs := len(tt.args)
			var err error

			if numArgs < tt.fn.minArgs {
				err = fmt.Errorf(
					"too few arguments: got %d, need at least %d",
					numArgs,
					tt.fn.minArgs,
				)
			} else if tt.fn.maxArgs != -1 && numArgs > tt.fn.maxArgs {
				err = fmt.Errorf("too many arguments: got %d, max %d", numArgs, tt.fn.maxArgs)
			}

			if (err != nil) != tt.wantError {
				t.Errorf("ValidateArgs() error = %v, wantError %v", err, tt.wantError)
			}
		})
	}
}

// Test filter and map functions with actual function arguments
func TestFilterMapFunctions(t *testing.T) {
	// Create evaluation context
	mockVarCtx := &mockVariableContext{
		fields: map[string]any{},
	}
	evalCtx := NewEvaluationContext(context.Background(), mockVarCtx)
	_ = evalCtx // Mark as used

	// Note: The built-in functions don't include filter and map in the current implementation
	// This test would need those functions to be added to the registry first
	// For now, we'll skip this test or implement a simpler version

	t.Skip("filter and map functions not implemented in current function registry")
}
