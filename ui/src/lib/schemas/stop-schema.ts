import { StopStatus, StopType } from "@/types/stop";
import { z } from "zod";
import { locationSchema } from "./location-schema";

export const stopSchema = z
  .object({
    id: z.string().optional(),
    version: z.number().optional(),
    createdAt: z.number().optional(),
    updatedAt: z.number().optional(),

    // * Core Fields
    locationId: z.string().min(1, "Location is required"),
    shipmentMoveId: z.string().optional(), // Generated by the system on create
    status: z.nativeEnum(StopStatus, {
      message: "Status is required",
    }),
    type: z.nativeEnum(StopType, {
      message: "Type is required",
    }),
    sequence: z.number().min(1, "Sequence is required"),
    pieces: z.preprocess((val) => {
      if (val === null || val === undefined) {
        return undefined;
      }
      const parsed = parseInt(String(val), 10);
      return isNaN(parsed) ? undefined : parsed;
    }, z.number().min(0, "Pieces cannot be negative").optional()),
    weight: z.preprocess((val) => {
      if (val === null || val === undefined) {
        return undefined;
      }
      const parsed = parseInt(String(val), 10);
      return isNaN(parsed) ? undefined : parsed;
    }, z.number().min(0, "Weight cannot be negative").optional()),
    plannedArrival: z.number().min(1, "Planned arrival is required"),
    plannedDeparture: z.number().min(1, "Planned departure is required"),
    actualArrival: z.preprocess((val) => {
      if (val === null || val === undefined) {
        return undefined;
      }
      const parsed = parseInt(String(val), 10);
      return isNaN(parsed) ? undefined : parsed;
    }, z.number().optional().nullable()),
    actualDeparture: z.preprocess((val) => {
      if (val === null || val === undefined) {
        return undefined;
      }
      const parsed = parseInt(String(val), 10);
      return isNaN(parsed) ? undefined : parsed;
    }, z.number().optional().nullable()),
    addressLine: z.string().min(1, "Address line is required"),
    location: locationSchema.optional(),
  })
  .refine(
    (data) => {
      if (
        data.plannedArrival &&
        data.plannedDeparture &&
        data.plannedArrival > data.plannedDeparture
      ) {
        return false;
      }
      return true;
    },
    {
      message: "Planned arrival must be before departure",
      path: ["plannedArrival"],
    },
  )
  .refine(
    (data) => {
      if (
        data.actualDeparture &&
        data.actualArrival &&
        data.actualDeparture < data.actualArrival
      ) {
        return false;
      }
      return true;
    },
    {
      message: "Actual departure must be after arrival",
      path: ["actualDeparture"],
    },
  );

export type StopSchema = z.infer<typeof stopSchema>;
