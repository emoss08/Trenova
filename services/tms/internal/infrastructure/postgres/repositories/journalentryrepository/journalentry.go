package journalentryrepository

import (
	"context"
	"fmt"

	"github.com/emoss08/trenova/internal/core/domain/accounting"
	"github.com/emoss08/trenova/internal/core/ports/repositories"
	"github.com/emoss08/trenova/internal/infrastructure/postgres"
	"github.com/emoss08/trenova/internal/infrastructure/postgres/repositories/dberror"
	"github.com/emoss08/trenova/pkg/pagination"
	"github.com/emoss08/trenova/pkg/pulid"
	"github.com/emoss08/trenova/pkg/utils"
	"github.com/emoss08/trenova/pkg/utils/querybuilder"
	"github.com/uptrace/bun"
	"go.uber.org/fx"
	"go.uber.org/zap"
)

type Params struct {
	fx.In

	DB     *postgres.Connection
	Logger *zap.Logger
}

type repository struct {
	db *postgres.Connection
	l  *zap.Logger
}

func NewRepository(p Params) repositories.JournalEntryRepository {
	return &repository{
		db: p.DB,
		l:  p.Logger.Named("postgres.journalentry-repository"),
	}
}

func (r *repository) addOptions(
	q *bun.SelectQuery,
	opts repositories.JournalEntryFilterOptions,
) *bun.SelectQuery {
	if opts.IncludeFiscalYear {
		q = q.Relation("FiscalYear")
	}
	if opts.IncludeFiscalPeriod {
		q = q.Relation("FiscalPeriod")
	}
	if opts.IncludeLines {
		q = q.Relation("Lines", func(sq *bun.SelectQuery) *bun.SelectQuery {
			return sq.Order("line_number ASC")
		})
	}
	if opts.IncludePostedBy {
		q = q.Relation("PostedBy")
	}
	if opts.IncludeApprovedBy {
		q = q.Relation("ApprovedBy")
	}
	if opts.Status != "" {
		q = q.Where("je.status = ?", opts.Status)
	}
	if opts.EntryType != "" {
		q = q.Where("je.entry_type = ?", opts.EntryType)
	}
	if opts.FiscalYearID != "" {
		q = q.Where("je.fiscal_year_id = ?", opts.FiscalYearID)
	}
	if opts.FiscalPeriodID != "" {
		q = q.Where("je.fiscal_period_id = ?", opts.FiscalPeriodID)
	}
	if opts.ReferenceType != "" {
		q = q.Where("je.reference_type = ?", opts.ReferenceType)
	}
	if opts.ReferenceID != "" {
		q = q.Where("je.reference_id = ?", opts.ReferenceID)
	}
	if opts.IsPosted != nil {
		q = q.Where("je.is_posted = ?", *opts.IsPosted)
	}
	if opts.IsApproved != nil {
		q = q.Where("je.is_approved = ?", *opts.IsApproved)
	}
	if opts.IsReversal != nil {
		q = q.Where("je.is_reversal = ?", *opts.IsReversal)
	}
	if opts.IsAutoGenerated != nil {
		q = q.Where("je.is_auto_generated = ?", *opts.IsAutoGenerated)
	}
	if opts.StartDate > 0 {
		q = q.Where("je.entry_date >= ?", opts.StartDate)
	}
	if opts.EndDate > 0 {
		q = q.Where("je.entry_date <= ?", opts.EndDate)
	}
	return q
}

func (r *repository) filterQuery(
	q *bun.SelectQuery,
	req *repositories.ListJournalEntryRequest,
) *bun.SelectQuery {
	q = querybuilder.ApplyFilters(
		q,
		"je",
		req.Filter,
		(*accounting.JournalEntry)(nil),
	)
	q = q.Apply(func(sq *bun.SelectQuery) *bun.SelectQuery {
		return r.addOptions(sq, req.FilterOptions)
	})
	return q.Limit(req.Filter.Limit).Offset(req.Filter.Offset)
}

func (r *repository) List(
	ctx context.Context,
	req *repositories.ListJournalEntryRequest,
) (*pagination.ListResult[*accounting.JournalEntry], error) {
	log := r.l.With(
		zap.String("operation", "List"),
		zap.String("orgId", req.Filter.TenantOpts.OrgID.String()),
		zap.String("buId", req.Filter.TenantOpts.BuID.String()),
	)

	db, err := r.db.DB(ctx)
	if err != nil {
		log.Error("failed to get database connection", zap.Error(err))
		return nil, err
	}

	entities := make([]*accounting.JournalEntry, 0, req.Filter.Limit)
	total, err := db.NewSelect().Model(&entities).Apply(func(sq *bun.SelectQuery) *bun.SelectQuery {
		return r.filterQuery(sq, req)
	}).ScanAndCount(ctx)
	if err != nil {
		log.Error("failed to scan journal entries", zap.Error(err))
		return nil, err
	}

	return &pagination.ListResult[*accounting.JournalEntry]{
		Items: entities,
		Total: total,
	}, nil
}

func (r *repository) GetByID(
	ctx context.Context,
	req *repositories.GetJournalEntryByIDRequest,
) (*accounting.JournalEntry, error) {
	log := r.l.With(
		zap.String("operation", "GetByID"),
		zap.String("entityID", req.JournalEntryID.String()),
	)

	db, err := r.db.DB(ctx)
	if err != nil {
		log.Error("failed to get database connection", zap.Error(err))
		return nil, err
	}

	entity := new(accounting.JournalEntry)
	err = db.NewSelect().Model(entity).
		WhereGroup(" AND ", func(sq *bun.SelectQuery) *bun.SelectQuery {
			return sq.
				Where("je.id = ?", req.JournalEntryID).
				Where("je.organization_id = ?", req.OrgID).
				Where("je.business_unit_id = ?", req.BuID)
		}).
		Apply(func(sq *bun.SelectQuery) *bun.SelectQuery {
			return r.addOptions(sq, req.FilterOptions)
		}).
		Scan(ctx)
	if err != nil {
		return nil, dberror.HandleNotFoundError(err, "JournalEntry")
	}

	return entity, nil
}

func (r *repository) GetByNumber(
	ctx context.Context,
	req *repositories.GetJournalEntryByNumberRequest,
) (*accounting.JournalEntry, error) {
	log := r.l.With(
		zap.String("operation", "GetByNumber"),
		zap.String("entryNumber", req.EntryNumber),
	)

	db, err := r.db.DB(ctx)
	if err != nil {
		log.Error("failed to get database connection", zap.Error(err))
		return nil, err
	}

	entity := new(accounting.JournalEntry)
	err = db.NewSelect().Model(entity).
		WhereGroup(" AND ", func(sq *bun.SelectQuery) *bun.SelectQuery {
			return sq.
				Where("je.entry_number = ?", req.EntryNumber).
				Where("je.organization_id = ?", req.OrgID).
				Where("je.business_unit_id = ?", req.BuID)
		}).
		Apply(func(sq *bun.SelectQuery) *bun.SelectQuery {
			return r.addOptions(sq, req.FilterOptions)
		}).
		Scan(ctx)
	if err != nil {
		return nil, dberror.HandleNotFoundError(err, "JournalEntry")
	}

	return entity, nil
}

func (r *repository) GetByReference(
	ctx context.Context,
	req *repositories.GetJournalEntriesByReferenceRequest,
) ([]*accounting.JournalEntry, error) {
	log := r.l.With(
		zap.String("operation", "GetByReference"),
		zap.String("referenceType", req.ReferenceType),
		zap.String("referenceId", req.ReferenceID.String()),
	)

	db, err := r.db.DB(ctx)
	if err != nil {
		log.Error("failed to get database connection", zap.Error(err))
		return nil, err
	}

	entities := make([]*accounting.JournalEntry, 0)
	err = db.NewSelect().Model(&entities).
		WhereGroup(" AND ", func(sq *bun.SelectQuery) *bun.SelectQuery {
			return sq.
				Where("je.reference_type = ?", req.ReferenceType).
				Where("je.reference_id = ?", req.ReferenceID).
				Where("je.organization_id = ?", req.OrgID).
				Where("je.business_unit_id = ?", req.BuID)
		}).
		Apply(func(sq *bun.SelectQuery) *bun.SelectQuery {
			return r.addOptions(sq, req.FilterOptions)
		}).
		Scan(ctx)
	if err != nil {
		return nil, dberror.HandleNotFoundError(err, "JournalEntry")
	}

	return entities, nil
}

func (r *repository) GetByPeriod(
	ctx context.Context,
	req *repositories.GetJournalEntriesByPeriodRequest,
) ([]*accounting.JournalEntry, error) {
	log := r.l.With(
		zap.String("operation", "GetByPeriod"),
		zap.String("fiscalPeriodId", req.FiscalPeriodID.String()),
	)

	db, err := r.db.DB(ctx)
	if err != nil {
		log.Error("failed to get database connection", zap.Error(err))
		return nil, err
	}

	entities := make([]*accounting.JournalEntry, 0)
	err = db.NewSelect().Model(&entities).
		WhereGroup(" AND ", func(sq *bun.SelectQuery) *bun.SelectQuery {
			return sq.
				Where("je.fiscal_period_id = ?", req.FiscalPeriodID).
				Where("je.organization_id = ?", req.OrgID).
				Where("je.business_unit_id = ?", req.BuID)
		}).
		Apply(func(sq *bun.SelectQuery) *bun.SelectQuery {
			return r.addOptions(sq, req.FilterOptions)
		}).
		Scan(ctx)
	if err != nil {
		return nil, dberror.HandleNotFoundError(err, "JournalEntry")
	}

	return entities, nil
}

func (r *repository) Create(
	ctx context.Context,
	req *repositories.CreateJournalEntryRequest,
) (*accounting.JournalEntry, error) {
	log := r.l.With(
		zap.String("operation", "Create"),
		zap.String("orgId", req.Entry.OrganizationID.String()),
		zap.String("buId", req.Entry.BusinessUnitID.String()),
	)

	db, err := r.db.DB(ctx)
	if err != nil {
		log.Error("failed to get database connection", zap.Error(err))
		return nil, err
	}

	_, err = db.NewInsert().Model(req.Entry).Exec(ctx)
	if err != nil {
		log.Error("failed to create journal entry", zap.Error(err))
		return nil, err
	}

	return req.Entry, nil
}

func (r *repository) Update(
	ctx context.Context,
	req *repositories.UpdateJournalEntryRequest,
) (*accounting.JournalEntry, error) {
	log := r.l.With(
		zap.String("operation", "Update"),
		zap.String("entityID", req.Entry.ID.String()),
	)

	db, err := r.db.DB(ctx)
	if err != nil {
		log.Error("failed to get database connection", zap.Error(err))
		return nil, err
	}

	_, err = db.NewUpdate().
		Model(req.Entry).
		WherePK().
		Exec(ctx)
	if err != nil {
		log.Error("failed to update journal entry", zap.Error(err))
		return nil, err
	}

	return req.Entry, nil
}

func (r *repository) Delete(
	ctx context.Context,
	req *repositories.DeleteJournalEntryRequest,
) error {
	log := r.l.With(
		zap.String("operation", "Delete"),
		zap.String("journalEntryId", req.JournalEntryID.String()),
	)

	db, err := r.db.DB(ctx)
	if err != nil {
		log.Error("failed to get database connection", zap.Error(err))
		return err
	}

	_, err = db.NewDelete().
		Model((*accounting.JournalEntry)(nil)).
		WhereGroup(" AND ", func(sq *bun.DeleteQuery) *bun.DeleteQuery {
			return sq.
				Where("je.id = ?", req.JournalEntryID).
				Where("je.organization_id = ?", req.OrgID).
				Where("je.business_unit_id = ?", req.BuID)
		}).
		Exec(ctx)
	if err != nil {
		log.Error("failed to delete journal entry", zap.Error(err))
		return err
	}

	return nil
}

func (r *repository) Post(
	ctx context.Context,
	req *repositories.PostJournalEntryRequest,
) (*accounting.JournalEntry, error) {
	log := r.l.With(
		zap.String("operation", "Post"),
		zap.String("journalEntryId", req.JournalEntryID.String()),
	)

	db, err := r.db.DB(ctx)
	if err != nil {
		log.Error("failed to get database connection", zap.Error(err))
		return nil, err
	}

	entity := new(accounting.JournalEntry)
	_, err = db.NewUpdate().
		Model(entity).
		Set("is_posted = ?", true).
		Set("posted_at = ?", req.PostedAt).
		Set("posted_by_id = ?", req.UserID).
		Set("status = ?", accounting.JournalEntryStatusPosted).
		Set("updated_at = ?", utils.NowUnix()).
		WhereGroup(" AND ", func(sq *bun.UpdateQuery) *bun.UpdateQuery {
			return sq.
				Where("je.id = ?", req.JournalEntryID).
				Where("je.organization_id = ?", req.OrgID).
				Where("je.business_unit_id = ?", req.BuID)
		}).
		Returning("*").
		Exec(ctx)
	if err != nil {
		log.Error("failed to post journal entry", zap.Error(err))
		return nil, err
	}

	return entity, nil
}

func (r *repository) Approve(
	ctx context.Context,
	req *repositories.ApproveJournalEntryRequest,
) (*accounting.JournalEntry, error) {
	log := r.l.With(
		zap.String("operation", "Approve"),
		zap.String("journalEntryId", req.JournalEntryID.String()),
	)

	db, err := r.db.DB(ctx)
	if err != nil {
		log.Error("failed to get database connection", zap.Error(err))
		return nil, err
	}

	entity := new(accounting.JournalEntry)
	_, err = db.NewUpdate().
		Model(entity).
		Set("is_approved = ?", true).
		Set("approved_at = ?", req.ApprovedAt).
		Set("approved_by_id = ?", req.UserID).
		Set("approval_notes = ?", req.ApprovalNotes).
		Set("status = ?", accounting.JournalEntryStatusApproved).
		Set("updated_at = ?", utils.NowUnix()).
		WhereGroup(" AND ", func(sq *bun.UpdateQuery) *bun.UpdateQuery {
			return sq.
				Where("je.id = ?", req.JournalEntryID).
				Where("je.organization_id = ?", req.OrgID).
				Where("je.business_unit_id = ?", req.BuID)
		}).
		Returning("*").
		Exec(ctx)
	if err != nil {
		log.Error("failed to approve journal entry", zap.Error(err))
		return nil, err
	}

	return entity, nil
}

func (r *repository) Reject(
	ctx context.Context,
	req *repositories.RejectJournalEntryRequest,
) (*accounting.JournalEntry, error) {
	log := r.l.With(
		zap.String("operation", "Reject"),
		zap.String("journalEntryId", req.JournalEntryID.String()),
	)

	db, err := r.db.DB(ctx)
	if err != nil {
		log.Error("failed to get database connection", zap.Error(err))
		return nil, err
	}

	entity := new(accounting.JournalEntry)
	_, err = db.NewUpdate().
		Model(entity).
		Set("status = ?", accounting.JournalEntryStatusRejected).
		Set("approval_notes = ?", req.RejectionNotes).
		Set("updated_at = ?", utils.NowUnix()).
		WhereGroup(" AND ", func(sq *bun.UpdateQuery) *bun.UpdateQuery {
			return sq.
				Where("je.id = ?", req.JournalEntryID).
				Where("je.organization_id = ?", req.OrgID).
				Where("je.business_unit_id = ?", req.BuID)
		}).
		Returning("*").
		Exec(ctx)
	if err != nil {
		log.Error("failed to reject journal entry", zap.Error(err))
		return nil, err
	}

	return entity, nil
}

func (r *repository) Reverse(
	ctx context.Context,
	req *repositories.ReverseJournalEntryRequest,
) (*accounting.JournalEntry, error) {
	log := r.l.With(
		zap.String("operation", "Reverse"),
		zap.String("journalEntryId", req.JournalEntryID.String()),
	)

	db, err := r.db.DB(ctx)
	if err != nil {
		log.Error("failed to get database connection", zap.Error(err))
		return nil, err
	}

	// Get original entry with lines
	original := new(accounting.JournalEntry)
	err = db.NewSelect().
		Model(original).
		Relation("Lines").
		WhereGroup(" AND ", func(sq *bun.SelectQuery) *bun.SelectQuery {
			return sq.
				Where("je.id = ?", req.JournalEntryID).
				Where("je.organization_id = ?", req.OrgID).
				Where("je.business_unit_id = ?", req.BuID)
		}).
		Scan(ctx)
	if err != nil {
		return nil, dberror.HandleNotFoundError(err, "JournalEntry")
	}

	// Create reversal entry
	reversal := &accounting.JournalEntry{
		OrganizationID: original.OrganizationID,
		BusinessUnitID: original.BusinessUnitID,
		FiscalYearID:   original.FiscalYearID,
		FiscalPeriodID: original.FiscalPeriodID,
		EntryNumber:    fmt.Sprintf("%s-REV", original.EntryNumber),
		EntryDate:      req.ReversalDate,
		EntryType:      accounting.JournalEntryTypeReversal,
		Status:         accounting.JournalEntryStatusDraft,
		Description: fmt.Sprintf(
			"Reversal of %s: %s",
			original.EntryNumber,
			req.ReversalReason,
		),
		TotalDebit:       original.TotalDebit,
		TotalCredit:      original.TotalCredit,
		IsReversal:       true,
		ReversalOfID:     &original.ID,
		ReversalReason:   req.ReversalReason,
		RequiresApproval: original.RequiresApproval,
	}

	// Generate ID
	reversal.ID = pulid.MustNew("je_")

	// Create reversal lines (swap debits and credits)
	reversalLines := make([]*accounting.JournalEntryLine, len(original.Lines))
	for i, line := range original.Lines {
		reversalLines[i] = &accounting.JournalEntryLine{
			ID:             pulid.MustNew("jel_"),
			OrganizationID: line.OrganizationID,
			BusinessUnitID: line.BusinessUnitID,
			JournalEntryID: reversal.ID,
			GLAccountID:    line.GLAccountID,
			LineNumber:     line.LineNumber,
			Description:    fmt.Sprintf("Reversal: %s", line.Description),
			DebitAmount:    line.CreditAmount, // Swap
			CreditAmount:   line.DebitAmount,  // Swap
			DepartmentID:   line.DepartmentID,
			ProjectID:      line.ProjectID,
			LocationID:     line.LocationID,
			CustomerID:     line.CustomerID,
		}
	}

	// Insert reversal entry and lines in a transaction
	err = db.RunInTx(ctx, nil, func(ctx context.Context, tx bun.Tx) error {
		// Insert reversal entry
		_, err := tx.NewInsert().Model(reversal).Exec(ctx)
		if err != nil {
			return err
		}

		// Insert reversal lines
		if len(reversalLines) > 0 {
			_, err = tx.NewInsert().Model(&reversalLines).Exec(ctx)
			if err != nil {
				return err
			}
		}

		// Update original entry status
		_, err = tx.NewUpdate().
			Model((*accounting.JournalEntry)(nil)).
			Set("status = ?", accounting.JournalEntryStatusReversed).
			Set("reversed_by_id = ?", reversal.ID).
			Set("updated_at = ?", utils.NowUnix()).
			Where("id = ?", original.ID).
			Where("organization_id = ?", original.OrganizationID).
			Where("business_unit_id = ?", original.BusinessUnitID).
			Exec(ctx)
		return err
	})
	if err != nil {
		log.Error("failed to reverse journal entry", zap.Error(err))
		return nil, err
	}

	// Load reversal with lines
	reversal.Lines = reversalLines

	return reversal, nil
}

func (r *repository) CreateWithLines(
	ctx context.Context,
	entry *accounting.JournalEntry,
	lines []*accounting.JournalEntryLine,
) (*accounting.JournalEntry, error) {
	log := r.l.With(
		zap.String("operation", "CreateWithLines"),
		zap.String("orgId", entry.OrganizationID.String()),
		zap.String("buId", entry.BusinessUnitID.String()),
	)

	db, err := r.db.DB(ctx)
	if err != nil {
		log.Error("failed to get database connection", zap.Error(err))
		return nil, err
	}

	err = db.RunInTx(ctx, nil, func(ctx context.Context, tx bun.Tx) error {
		// Insert entry
		_, err := tx.NewInsert().Model(entry).Exec(ctx)
		if err != nil {
			return err
		}

		// Insert lines
		if len(lines) > 0 {
			// Set journal entry ID on all lines
			for i := range lines {
				lines[i].JournalEntryID = entry.ID
				lines[i].OrganizationID = entry.OrganizationID
				lines[i].BusinessUnitID = entry.BusinessUnitID
			}

			_, err = tx.NewInsert().Model(&lines).Exec(ctx)
			if err != nil {
				return err
			}
		}

		return nil
	})
	if err != nil {
		log.Error("failed to create journal entry with lines", zap.Error(err))
		return nil, err
	}

	entry.Lines = lines
	return entry, nil
}

func (r *repository) UpdateWithLines(
	ctx context.Context,
	entry *accounting.JournalEntry,
	lines []*accounting.JournalEntryLine,
) (*accounting.JournalEntry, error) {
	log := r.l.With(
		zap.String("operation", "UpdateWithLines"),
		zap.String("entityID", entry.ID.String()),
	)

	db, err := r.db.DB(ctx)
	if err != nil {
		log.Error("failed to get database connection", zap.Error(err))
		return nil, err
	}

	err = db.RunInTx(ctx, nil, func(ctx context.Context, tx bun.Tx) error {
		// Update entry
		_, err := tx.NewUpdate().Model(entry).WherePK().Exec(ctx)
		if err != nil {
			return err
		}

		// Delete existing lines
		_, err = tx.NewDelete().
			Model((*accounting.JournalEntryLine)(nil)).
			Where("journal_entry_id = ?", entry.ID).
			Where("organization_id = ?", entry.OrganizationID).
			Where("business_unit_id = ?", entry.BusinessUnitID).
			Exec(ctx)
		if err != nil {
			return err
		}

		// Insert new lines
		if len(lines) > 0 {
			// Set journal entry ID on all lines
			for i := range lines {
				lines[i].JournalEntryID = entry.ID
				lines[i].OrganizationID = entry.OrganizationID
				lines[i].BusinessUnitID = entry.BusinessUnitID
			}

			_, err = tx.NewInsert().Model(&lines).Exec(ctx)
			if err != nil {
				return err
			}
		}

		return nil
	})
	if err != nil {
		log.Error("failed to update journal entry with lines", zap.Error(err))
		return nil, err
	}

	entry.Lines = lines
	return entry, nil
}
