//go:build ignore
// +build ignore

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io/fs"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"
)

// This file generates the seed registry based on discovered seed files
// Run with: go run registry.go

type SeedFile struct {
	Package    string
	StructName string
	FileName   string
	Order      int
	IsBase     bool
}

func main() {
	var seeds []SeedFile

	baseSeeds := discoverSeeds("base", true)
	seeds = append(seeds, baseSeeds...)

	devSeeds := discoverSeeds("development", false)
	seeds = append(seeds, devSeeds...)

	testSeeds := discoverSeeds("test", false)
	seeds = append(seeds, testSeeds...)

	sort.Slice(seeds, func(i, j int) bool {
		if seeds[i].IsBase != seeds[j].IsBase {
			return seeds[i].IsBase
		}
		return seeds[i].Order < seeds[j].Order
	})

	if err := generateRegistry(seeds); err != nil {
		panic(err)
	}

	fmt.Println("âœ“ Generated seed_registry.go")
}

func discoverSeeds(dir string, isBase bool) []SeedFile {
	var seeds []SeedFile

	dirPath := filepath.Join("..", "seeds", dir)

	err := filepath.WalkDir(dirPath, func(path string, d fs.DirEntry, err error) error {
		if err != nil || d.IsDir() || !strings.HasSuffix(d.Name(), ".go") {
			return nil
		}

		if strings.HasSuffix(d.Name(), "_test.go") || d.Name() == "seed_registry.go" {
			return nil
		}

		content, err := os.ReadFile(path)
		if err != nil {
			return nil
		}

		structName := findSeedStruct(string(content))
		if structName == "" {
			return nil
		}

		order := 999
		parts := strings.Split(d.Name(), "_")
		if len(parts) > 0 {
			fmt.Sscanf(parts[0], "%d", &order)
		}

		seeds = append(seeds, SeedFile{
			Package:    dir,
			StructName: structName,
			FileName:   d.Name(),
			Order:      order,
			IsBase:     isBase,
		})

		return nil
	})
	if err != nil {
		fmt.Printf("Warning: error discovering %s seeds: %v\n", dir, err)
	}

	return seeds
}

func findSeedStruct(content string) string {
	lines := strings.Split(content, "\n")
	for _, line := range lines {
		if strings.Contains(line, "type ") && strings.Contains(line, "Seed struct") {
			parts := strings.Fields(line)
			if len(parts) >= 2 {
				return parts[1]
			}
		}
	}
	return ""
}

func generateRegistry(seeds []SeedFile) error {
	tmpl := `// Code generated by go run registry.go; DO NOT EDIT.

package seeder

import (
	"github.com/emoss08/trenova/internal/infrastructure/database/common"
	"github.com/emoss08/trenova/internal/infrastructure/database/seeds/base"
	{{- if .HasDev }}
	"github.com/emoss08/trenova/internal/infrastructure/database/seeds/development"
	{{- end }}
	{{- if .HasTest }}
	"github.com/emoss08/trenova/internal/infrastructure/database/seeds/test"
	{{- end }}
)

// RegisterAll registers all seed runners based on environment
func RegisterAll(s *Seeder, env common.Environment) {
	// Base seeds (all environments)
	{{- range .Seeds }}
	{{- if .IsBase }}
	s.RegisterRunner({{ .Package }}.New{{ .StructName }}())
	{{- end }}
	{{- end }}

	// Development seeds
	if env == common.EnvDevelopment || env == common.EnvTest {
		{{- range .Seeds }}
		{{- if and (not .IsBase) (eq .Package "development") }}
		s.RegisterRunner(development.New{{ .StructName }}())
		{{- end }}
		{{- end }}
	}

	// Test-only seeds
	if env == common.EnvTest {
		{{- range .Seeds }}
		{{- if and (not .IsBase) (eq .Package "test") }}
		s.RegisterRunner(test.New{{ .StructName }}())
		{{- end }}
		{{- end }}
	}
}
`

	t, err := template.New("registry").Parse(tmpl)
	if err != nil {
		return err
	}

	var buf bytes.Buffer

	hasDev := false
	hasTest := false
	for _, s := range seeds {
		if s.Package == "development" {
			hasDev = true
		}
		if s.Package == "test" {
			hasTest = true
		}
	}

	err = t.Execute(&buf, struct {
		Seeds   []SeedFile
		HasDev  bool
		HasTest bool
	}{
		Seeds:   seeds,
		HasDev:  hasDev,
		HasTest: hasTest,
	})
	if err != nil {
		return err
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return err
	}

	return os.WriteFile("seed_registry.go", formatted, 0644)
}
