package codegen

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"github.com/emoss08/trenova/pkg/domainregistry"
	permregistry "github.com/emoss08/trenova/pkg/permissionregistry"
	"github.com/emoss08/trenova/pkg/utils"
)

const resourceEnumTemplate = `// Code generated by 'trenova codegen enum'. DO NOT EDIT.

package permission

// Resource represents a resource type in the permission system
type Resource string

const (
{{- range .Resources}}
	Resource{{ .ConstName }} Resource = "{{ .Name }}"
{{- end}}
)

// String returns the string representation of the Resource
func (r Resource) String() string {
	return string(r)
}

// IsValid checks if the Resource value is valid
func (r Resource) IsValid() bool {
	switch r {
	case {{ range $i, $res := .Resources }}{{if $i}}, {{end}}Resource{{ $res.ConstName }}{{end}}:
		return true
	default:
		return false
	}
}

// AllResources returns all valid Resource values
func AllResources() []Resource {
	return []Resource{
{{- range .Resources}}
		Resource{{ .ConstName }},
{{- end}}
	}
}
`

type resourceEnumData struct {
	Resources []resourceInfo
}

type resourceInfo struct {
	Name      string
	ConstName string
}

func GenerateResourceEnum(outputDir string) error {
	fmt.Println("ðŸ”§ Generating Resource enum from permission registry...")

	registry := createRegistry()

	resources := registry.GetAllResources()
	if len(resources) == 0 {
		return fmt.Errorf("no resources found in registry")
	}

	var resourceList []resourceInfo
	for name := range resources {
		constName := utils.ToConstName(name)

		resourceList = append(resourceList, resourceInfo{
			Name:      name,
			ConstName: constName,
		})
	}

	sort.Slice(resourceList, func(i, j int) bool {
		return resourceList[i].Name < resourceList[j].Name
	})

	tmpl, err := template.New("enum").Parse(resourceEnumTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, resourceEnumData{Resources: resourceList}); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("failed to format generated code: %w", err)
	}

	outputPath := filepath.Join(outputDir, "internal/core/domain/permission/resource_gen.go")
	if err := os.MkdirAll(filepath.Dir(outputPath), 0o755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	if err := os.WriteFile(outputPath, formatted, 0o644); err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	fmt.Printf("âœ… Generated Resource enum: %s\n", outputPath)
	fmt.Printf("   Resources: %d\n", len(resourceList))
	for _, res := range resourceList {
		fmt.Printf("   - %s (%s)\n", res.ConstName, res.Name)
	}

	return nil
}

func createRegistry() *permregistry.Registry {
	registry := permregistry.NewRegistry(permregistry.RegistryParams{
		Entities: domainregistry.RegisterPermissionAwareEntities(),
	})

	return registry
}

func escapeString(s string) string {
	s = strings.ReplaceAll(s, `\`, `\\`)
	s = strings.ReplaceAll(s, `"`, `\"`)
	s = strings.ReplaceAll(s, "\n", " ")
	s = strings.ReplaceAll(s, "\r", "")
	return s
}
