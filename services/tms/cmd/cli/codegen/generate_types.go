package codegen

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"github.com/emoss08/trenova/internal/core/domain/permission"
	"github.com/emoss08/trenova/pkg/utils"
)

const typeScriptTemplate = `// Code generated by 'trenova codegen types'. DO NOT EDIT.

import { usePermissions } from "@/hooks/use-permission";

/**
 * Permission Registry Metadata
 * Auto-generated from Go permission definitions
 *
 * Note: This file does NOT generate TypeScript types for entities.
 * Use Zod schemas (e.g., hazardous-material-schema.ts) for type generation.
 * This file only contains permission metadata and hooks.
 */

// ============================================================================
// Permission Operations
// ============================================================================

export const PermissionOperations = {
{{- range .Operations}}
  {{ .ConstName }}: {{ .Code }},  // {{ .DisplayName }}
{{- end}}
} as const;

export type PermissionOperation = typeof PermissionOperations[keyof typeof PermissionOperations];

// ============================================================================
// Resource Metadata
// ============================================================================

{{- range .Resources}}

/**
 * Permission metadata for {{ .TypeName }}
 */
export const {{ .TypeName }}Metadata = {
  resourceName: '{{ .ResourceName }}',
  operations: [
{{- range .Operations}}
    {
      code: {{ .Code }},
      name: '{{ .Name }}',
      displayName: '{{ .DisplayName }}',
      description: '{{ .Description }}',
    },
{{- end}}
  ],
  compositeOperations: {
{{- range $key, $value := .CompositeOperations}}
    {{ $key }}: {{ $value }},
{{- end}}
  },
} as const;

{{- end}}

// ============================================================================
// Permission Hooks (React)
// ============================================================================

{{- range .Resources}}
{{- $resourceName := .ResourceName }}

/**
 * React hook for {{ .TypeName }} permissions
 * @example
 * const perms = use{{ .TypeName }}Permissions();
 * if (perms.canCreate) { ... }
 */
export const use{{ .TypeName }}Permissions = () => {
  const { can } = usePermissions();

  return {
{{- range .Operations}}
    can{{ .MethodName }}: can('{{ $resourceName }}', '{{ .Name }}'),
{{- end}}
{{- range $key, $value := .CompositeOperations}}
    has{{ toMethodName $key }}: can('{{ $resourceName }}', '{{ $key }}'),
{{- end}}
  };
};

{{- end}}

// ============================================================================
// Type Guards
// ============================================================================

export const isValidResource = (resource: string): boolean => {
  return [
{{- range .Resources}}
    '{{ .ResourceName }}',
{{- end}}
  ].includes(resource);
};

export const isValidOperation = (operation: PermissionOperation): boolean => {
  return Object.values(PermissionOperations).includes(operation);
};
`

type typeScriptData struct {
	Operations []operationInfo
	Resources  []resourceTypeInfo
}

type operationInfo struct {
	Code        permission.Operation
	Name        string
	ConstName   string
	MethodName  string
	DisplayName string
	Description string
}

type resourceTypeInfo struct {
	ResourceName        string
	TypeName            string
	Operations          []operationInfo
	CompositeOperations map[string]permission.Operation
}

func GenerateTypeScriptTypes(outputDir string) error {
	fmt.Println("ðŸ”§ Generating TypeScript types from permission registry...")

	registry := createRegistry()
	resources := registry.GetAllResources()

	if len(resources) == 0 {
		return fmt.Errorf("no resources found in registry")
	}

	operationsMap := make(map[permission.Operation]operationInfo)
	var resourceTypes []resourceTypeInfo

	var resourceNames []string
	for name := range resources {
		resourceNames = append(resourceNames, name)
	}
	sort.Strings(resourceNames)

	for _, name := range resourceNames {
		res := resources[name]
		typeName := utils.ToConstName(name)

		var ops []operationInfo
		for _, op := range res.GetSupportedOperations() {
			opInfo := operationInfo{
				Code:        op.Code,
				Name:        op.Name,
				ConstName:   strings.ToUpper(op.Name),
				MethodName:  utils.ToConstName(op.Name),
				DisplayName: op.DisplayName,
				Description: escapeString(op.Description),
			}
			ops = append(ops, opInfo)
			operationsMap[op.Code] = opInfo
		}

		resourceTypes = append(resourceTypes, resourceTypeInfo{
			ResourceName:        name,
			TypeName:            typeName,
			Operations:          ops,
			CompositeOperations: res.GetCompositeOperations(),
		})
	}

	var allOperations []operationInfo
	for _, op := range operationsMap {
		allOperations = append(allOperations, op)
	}
	sort.Slice(allOperations, func(i, j int) bool {
		return allOperations[i].Code < allOperations[j].Code
	})

	funcMap := template.FuncMap{
		"toMethodName": func(s string) string {
			return utils.ToConstName(s)
		},
	}

	tmpl, err := template.New("typescript").Funcs(funcMap).Parse(typeScriptTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse template: %w", err)
	}

	var buf bytes.Buffer
	data := typeScriptData{
		Operations: allOperations,
		Resources:  resourceTypes,
	}
	if err := tmpl.Execute(&buf, data); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	outputPath := filepath.Join(outputDir, "../../ui/src/types/_gen/permissions.ts")
	if err := os.MkdirAll(filepath.Dir(outputPath), 0o755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	if err := os.WriteFile(outputPath, buf.Bytes(), 0o644); err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	fmt.Printf("âœ… Generated TypeScript types: %s\n", outputPath)
	fmt.Printf("   Resources: %d\n", len(resourceTypes))
	fmt.Printf("   Operations: %d\n", len(allOperations))

	return nil
}
