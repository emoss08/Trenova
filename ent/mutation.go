// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/emoss08/trenova/ent/accountingcontrol"
	"github.com/emoss08/trenova/ent/billingcontrol"
	"github.com/emoss08/trenova/ent/businessunit"
	"github.com/emoss08/trenova/ent/dispatchcontrol"
	"github.com/emoss08/trenova/ent/feasibilitytoolcontrol"
	"github.com/emoss08/trenova/ent/generalledgeraccount"
	"github.com/emoss08/trenova/ent/invoicecontrol"
	"github.com/emoss08/trenova/ent/organization"
	"github.com/emoss08/trenova/ent/predicate"
	"github.com/emoss08/trenova/ent/routecontrol"
	"github.com/emoss08/trenova/ent/schema"
	"github.com/emoss08/trenova/ent/shipmentcontrol"
	"github.com/emoss08/trenova/ent/tablechangealert"
	"github.com/emoss08/trenova/ent/tag"
	"github.com/emoss08/trenova/ent/user"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccountingControl      = "AccountingControl"
	TypeBillingControl         = "BillingControl"
	TypeBusinessUnit           = "BusinessUnit"
	TypeDispatchControl        = "DispatchControl"
	TypeFeasibilityToolControl = "FeasibilityToolControl"
	TypeGeneralLedgerAccount   = "GeneralLedgerAccount"
	TypeInvoiceControl         = "InvoiceControl"
	TypeOrganization           = "Organization"
	TypeRouteControl           = "RouteControl"
	TypeShipmentControl        = "ShipmentControl"
	TypeTableChangeAlert       = "TableChangeAlert"
	TypeTag                    = "Tag"
	TypeUser                   = "User"
)

// AccountingControlMutation represents an operation that mutates the AccountingControl nodes in the graph.
type AccountingControlMutation struct {
	config
	op                              Op
	typ                             string
	id                              *uuid.UUID
	created_at                      *time.Time
	updated_at                      *time.Time
	rec_threshold                   *int64
	addrec_threshold                *int64
	rec_threshold_action            *accountingcontrol.RecThresholdAction
	auto_create_journal_entries     *bool
	restrict_manual_journal_entries *bool
	require_journal_entry_approval  *bool
	enable_rec_notifications        *bool
	halt_on_pending_rec             *bool
	critical_processes              *string
	clearedFields                   map[string]struct{}
	organization                    *uuid.UUID
	clearedorganization             bool
	business_unit                   *uuid.UUID
	clearedbusiness_unit            bool
	default_rev_account             *uuid.UUID
	cleareddefault_rev_account      bool
	default_exp_account             *uuid.UUID
	cleareddefault_exp_account      bool
	done                            bool
	oldValue                        func(context.Context) (*AccountingControl, error)
	predicates                      []predicate.AccountingControl
}

var _ ent.Mutation = (*AccountingControlMutation)(nil)

// accountingcontrolOption allows management of the mutation configuration using functional options.
type accountingcontrolOption func(*AccountingControlMutation)

// newAccountingControlMutation creates new mutation for the AccountingControl entity.
func newAccountingControlMutation(c config, op Op, opts ...accountingcontrolOption) *AccountingControlMutation {
	m := &AccountingControlMutation{
		config:        c,
		op:            op,
		typ:           TypeAccountingControl,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountingControlID sets the ID field of the mutation.
func withAccountingControlID(id uuid.UUID) accountingcontrolOption {
	return func(m *AccountingControlMutation) {
		var (
			err   error
			once  sync.Once
			value *AccountingControl
		)
		m.oldValue = func(ctx context.Context) (*AccountingControl, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AccountingControl.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccountingControl sets the old AccountingControl of the mutation.
func withAccountingControl(node *AccountingControl) accountingcontrolOption {
	return func(m *AccountingControlMutation) {
		m.oldValue = func(context.Context) (*AccountingControl, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountingControlMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountingControlMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AccountingControl entities.
func (m *AccountingControlMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountingControlMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountingControlMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AccountingControl.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountingControlMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountingControlMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AccountingControl entity.
// If the AccountingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingControlMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountingControlMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AccountingControlMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AccountingControlMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AccountingControl entity.
// If the AccountingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingControlMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AccountingControlMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetRecThreshold sets the "rec_threshold" field.
func (m *AccountingControlMutation) SetRecThreshold(i int64) {
	m.rec_threshold = &i
	m.addrec_threshold = nil
}

// RecThreshold returns the value of the "rec_threshold" field in the mutation.
func (m *AccountingControlMutation) RecThreshold() (r int64, exists bool) {
	v := m.rec_threshold
	if v == nil {
		return
	}
	return *v, true
}

// OldRecThreshold returns the old "rec_threshold" field's value of the AccountingControl entity.
// If the AccountingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingControlMutation) OldRecThreshold(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecThreshold is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecThreshold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecThreshold: %w", err)
	}
	return oldValue.RecThreshold, nil
}

// AddRecThreshold adds i to the "rec_threshold" field.
func (m *AccountingControlMutation) AddRecThreshold(i int64) {
	if m.addrec_threshold != nil {
		*m.addrec_threshold += i
	} else {
		m.addrec_threshold = &i
	}
}

// AddedRecThreshold returns the value that was added to the "rec_threshold" field in this mutation.
func (m *AccountingControlMutation) AddedRecThreshold() (r int64, exists bool) {
	v := m.addrec_threshold
	if v == nil {
		return
	}
	return *v, true
}

// ResetRecThreshold resets all changes to the "rec_threshold" field.
func (m *AccountingControlMutation) ResetRecThreshold() {
	m.rec_threshold = nil
	m.addrec_threshold = nil
}

// SetRecThresholdAction sets the "rec_threshold_action" field.
func (m *AccountingControlMutation) SetRecThresholdAction(ata accountingcontrol.RecThresholdAction) {
	m.rec_threshold_action = &ata
}

// RecThresholdAction returns the value of the "rec_threshold_action" field in the mutation.
func (m *AccountingControlMutation) RecThresholdAction() (r accountingcontrol.RecThresholdAction, exists bool) {
	v := m.rec_threshold_action
	if v == nil {
		return
	}
	return *v, true
}

// OldRecThresholdAction returns the old "rec_threshold_action" field's value of the AccountingControl entity.
// If the AccountingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingControlMutation) OldRecThresholdAction(ctx context.Context) (v accountingcontrol.RecThresholdAction, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecThresholdAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecThresholdAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecThresholdAction: %w", err)
	}
	return oldValue.RecThresholdAction, nil
}

// ResetRecThresholdAction resets all changes to the "rec_threshold_action" field.
func (m *AccountingControlMutation) ResetRecThresholdAction() {
	m.rec_threshold_action = nil
}

// SetAutoCreateJournalEntries sets the "auto_create_journal_entries" field.
func (m *AccountingControlMutation) SetAutoCreateJournalEntries(b bool) {
	m.auto_create_journal_entries = &b
}

// AutoCreateJournalEntries returns the value of the "auto_create_journal_entries" field in the mutation.
func (m *AccountingControlMutation) AutoCreateJournalEntries() (r bool, exists bool) {
	v := m.auto_create_journal_entries
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoCreateJournalEntries returns the old "auto_create_journal_entries" field's value of the AccountingControl entity.
// If the AccountingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingControlMutation) OldAutoCreateJournalEntries(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoCreateJournalEntries is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoCreateJournalEntries requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoCreateJournalEntries: %w", err)
	}
	return oldValue.AutoCreateJournalEntries, nil
}

// ResetAutoCreateJournalEntries resets all changes to the "auto_create_journal_entries" field.
func (m *AccountingControlMutation) ResetAutoCreateJournalEntries() {
	m.auto_create_journal_entries = nil
}

// SetRestrictManualJournalEntries sets the "restrict_manual_journal_entries" field.
func (m *AccountingControlMutation) SetRestrictManualJournalEntries(b bool) {
	m.restrict_manual_journal_entries = &b
}

// RestrictManualJournalEntries returns the value of the "restrict_manual_journal_entries" field in the mutation.
func (m *AccountingControlMutation) RestrictManualJournalEntries() (r bool, exists bool) {
	v := m.restrict_manual_journal_entries
	if v == nil {
		return
	}
	return *v, true
}

// OldRestrictManualJournalEntries returns the old "restrict_manual_journal_entries" field's value of the AccountingControl entity.
// If the AccountingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingControlMutation) OldRestrictManualJournalEntries(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRestrictManualJournalEntries is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRestrictManualJournalEntries requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRestrictManualJournalEntries: %w", err)
	}
	return oldValue.RestrictManualJournalEntries, nil
}

// ResetRestrictManualJournalEntries resets all changes to the "restrict_manual_journal_entries" field.
func (m *AccountingControlMutation) ResetRestrictManualJournalEntries() {
	m.restrict_manual_journal_entries = nil
}

// SetRequireJournalEntryApproval sets the "require_journal_entry_approval" field.
func (m *AccountingControlMutation) SetRequireJournalEntryApproval(b bool) {
	m.require_journal_entry_approval = &b
}

// RequireJournalEntryApproval returns the value of the "require_journal_entry_approval" field in the mutation.
func (m *AccountingControlMutation) RequireJournalEntryApproval() (r bool, exists bool) {
	v := m.require_journal_entry_approval
	if v == nil {
		return
	}
	return *v, true
}

// OldRequireJournalEntryApproval returns the old "require_journal_entry_approval" field's value of the AccountingControl entity.
// If the AccountingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingControlMutation) OldRequireJournalEntryApproval(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequireJournalEntryApproval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequireJournalEntryApproval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequireJournalEntryApproval: %w", err)
	}
	return oldValue.RequireJournalEntryApproval, nil
}

// ResetRequireJournalEntryApproval resets all changes to the "require_journal_entry_approval" field.
func (m *AccountingControlMutation) ResetRequireJournalEntryApproval() {
	m.require_journal_entry_approval = nil
}

// SetEnableRecNotifications sets the "enable_rec_notifications" field.
func (m *AccountingControlMutation) SetEnableRecNotifications(b bool) {
	m.enable_rec_notifications = &b
}

// EnableRecNotifications returns the value of the "enable_rec_notifications" field in the mutation.
func (m *AccountingControlMutation) EnableRecNotifications() (r bool, exists bool) {
	v := m.enable_rec_notifications
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableRecNotifications returns the old "enable_rec_notifications" field's value of the AccountingControl entity.
// If the AccountingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingControlMutation) OldEnableRecNotifications(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnableRecNotifications is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnableRecNotifications requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableRecNotifications: %w", err)
	}
	return oldValue.EnableRecNotifications, nil
}

// ResetEnableRecNotifications resets all changes to the "enable_rec_notifications" field.
func (m *AccountingControlMutation) ResetEnableRecNotifications() {
	m.enable_rec_notifications = nil
}

// SetHaltOnPendingRec sets the "halt_on_pending_rec" field.
func (m *AccountingControlMutation) SetHaltOnPendingRec(b bool) {
	m.halt_on_pending_rec = &b
}

// HaltOnPendingRec returns the value of the "halt_on_pending_rec" field in the mutation.
func (m *AccountingControlMutation) HaltOnPendingRec() (r bool, exists bool) {
	v := m.halt_on_pending_rec
	if v == nil {
		return
	}
	return *v, true
}

// OldHaltOnPendingRec returns the old "halt_on_pending_rec" field's value of the AccountingControl entity.
// If the AccountingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingControlMutation) OldHaltOnPendingRec(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHaltOnPendingRec is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHaltOnPendingRec requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHaltOnPendingRec: %w", err)
	}
	return oldValue.HaltOnPendingRec, nil
}

// ResetHaltOnPendingRec resets all changes to the "halt_on_pending_rec" field.
func (m *AccountingControlMutation) ResetHaltOnPendingRec() {
	m.halt_on_pending_rec = nil
}

// SetCriticalProcesses sets the "critical_processes" field.
func (m *AccountingControlMutation) SetCriticalProcesses(s string) {
	m.critical_processes = &s
}

// CriticalProcesses returns the value of the "critical_processes" field in the mutation.
func (m *AccountingControlMutation) CriticalProcesses() (r string, exists bool) {
	v := m.critical_processes
	if v == nil {
		return
	}
	return *v, true
}

// OldCriticalProcesses returns the old "critical_processes" field's value of the AccountingControl entity.
// If the AccountingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingControlMutation) OldCriticalProcesses(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCriticalProcesses is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCriticalProcesses requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCriticalProcesses: %w", err)
	}
	return oldValue.CriticalProcesses, nil
}

// ClearCriticalProcesses clears the value of the "critical_processes" field.
func (m *AccountingControlMutation) ClearCriticalProcesses() {
	m.critical_processes = nil
	m.clearedFields[accountingcontrol.FieldCriticalProcesses] = struct{}{}
}

// CriticalProcessesCleared returns if the "critical_processes" field was cleared in this mutation.
func (m *AccountingControlMutation) CriticalProcessesCleared() bool {
	_, ok := m.clearedFields[accountingcontrol.FieldCriticalProcesses]
	return ok
}

// ResetCriticalProcesses resets all changes to the "critical_processes" field.
func (m *AccountingControlMutation) ResetCriticalProcesses() {
	m.critical_processes = nil
	delete(m.clearedFields, accountingcontrol.FieldCriticalProcesses)
}

// SetDefaultRevAccountID sets the "default_rev_account_id" field.
func (m *AccountingControlMutation) SetDefaultRevAccountID(u uuid.UUID) {
	m.default_rev_account = &u
}

// DefaultRevAccountID returns the value of the "default_rev_account_id" field in the mutation.
func (m *AccountingControlMutation) DefaultRevAccountID() (r uuid.UUID, exists bool) {
	v := m.default_rev_account
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultRevAccountID returns the old "default_rev_account_id" field's value of the AccountingControl entity.
// If the AccountingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingControlMutation) OldDefaultRevAccountID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultRevAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultRevAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultRevAccountID: %w", err)
	}
	return oldValue.DefaultRevAccountID, nil
}

// ClearDefaultRevAccountID clears the value of the "default_rev_account_id" field.
func (m *AccountingControlMutation) ClearDefaultRevAccountID() {
	m.default_rev_account = nil
	m.clearedFields[accountingcontrol.FieldDefaultRevAccountID] = struct{}{}
}

// DefaultRevAccountIDCleared returns if the "default_rev_account_id" field was cleared in this mutation.
func (m *AccountingControlMutation) DefaultRevAccountIDCleared() bool {
	_, ok := m.clearedFields[accountingcontrol.FieldDefaultRevAccountID]
	return ok
}

// ResetDefaultRevAccountID resets all changes to the "default_rev_account_id" field.
func (m *AccountingControlMutation) ResetDefaultRevAccountID() {
	m.default_rev_account = nil
	delete(m.clearedFields, accountingcontrol.FieldDefaultRevAccountID)
}

// SetDefaultExpAccountID sets the "default_exp_account_id" field.
func (m *AccountingControlMutation) SetDefaultExpAccountID(u uuid.UUID) {
	m.default_exp_account = &u
}

// DefaultExpAccountID returns the value of the "default_exp_account_id" field in the mutation.
func (m *AccountingControlMutation) DefaultExpAccountID() (r uuid.UUID, exists bool) {
	v := m.default_exp_account
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultExpAccountID returns the old "default_exp_account_id" field's value of the AccountingControl entity.
// If the AccountingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingControlMutation) OldDefaultExpAccountID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultExpAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultExpAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultExpAccountID: %w", err)
	}
	return oldValue.DefaultExpAccountID, nil
}

// ClearDefaultExpAccountID clears the value of the "default_exp_account_id" field.
func (m *AccountingControlMutation) ClearDefaultExpAccountID() {
	m.default_exp_account = nil
	m.clearedFields[accountingcontrol.FieldDefaultExpAccountID] = struct{}{}
}

// DefaultExpAccountIDCleared returns if the "default_exp_account_id" field was cleared in this mutation.
func (m *AccountingControlMutation) DefaultExpAccountIDCleared() bool {
	_, ok := m.clearedFields[accountingcontrol.FieldDefaultExpAccountID]
	return ok
}

// ResetDefaultExpAccountID resets all changes to the "default_exp_account_id" field.
func (m *AccountingControlMutation) ResetDefaultExpAccountID() {
	m.default_exp_account = nil
	delete(m.clearedFields, accountingcontrol.FieldDefaultExpAccountID)
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *AccountingControlMutation) SetOrganizationID(id uuid.UUID) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *AccountingControlMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *AccountingControlMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *AccountingControlMutation) OrganizationID() (id uuid.UUID, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *AccountingControlMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *AccountingControlMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// SetBusinessUnitID sets the "business_unit" edge to the BusinessUnit entity by id.
func (m *AccountingControlMutation) SetBusinessUnitID(id uuid.UUID) {
	m.business_unit = &id
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *AccountingControlMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *AccountingControlMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitID returns the "business_unit" edge ID in the mutation.
func (m *AccountingControlMutation) BusinessUnitID() (id uuid.UUID, exists bool) {
	if m.business_unit != nil {
		return *m.business_unit, true
	}
	return
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *AccountingControlMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *AccountingControlMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearDefaultRevAccount clears the "default_rev_account" edge to the GeneralLedgerAccount entity.
func (m *AccountingControlMutation) ClearDefaultRevAccount() {
	m.cleareddefault_rev_account = true
	m.clearedFields[accountingcontrol.FieldDefaultRevAccountID] = struct{}{}
}

// DefaultRevAccountCleared reports if the "default_rev_account" edge to the GeneralLedgerAccount entity was cleared.
func (m *AccountingControlMutation) DefaultRevAccountCleared() bool {
	return m.DefaultRevAccountIDCleared() || m.cleareddefault_rev_account
}

// DefaultRevAccountIDs returns the "default_rev_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DefaultRevAccountID instead. It exists only for internal usage by the builders.
func (m *AccountingControlMutation) DefaultRevAccountIDs() (ids []uuid.UUID) {
	if id := m.default_rev_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDefaultRevAccount resets all changes to the "default_rev_account" edge.
func (m *AccountingControlMutation) ResetDefaultRevAccount() {
	m.default_rev_account = nil
	m.cleareddefault_rev_account = false
}

// ClearDefaultExpAccount clears the "default_exp_account" edge to the GeneralLedgerAccount entity.
func (m *AccountingControlMutation) ClearDefaultExpAccount() {
	m.cleareddefault_exp_account = true
	m.clearedFields[accountingcontrol.FieldDefaultExpAccountID] = struct{}{}
}

// DefaultExpAccountCleared reports if the "default_exp_account" edge to the GeneralLedgerAccount entity was cleared.
func (m *AccountingControlMutation) DefaultExpAccountCleared() bool {
	return m.DefaultExpAccountIDCleared() || m.cleareddefault_exp_account
}

// DefaultExpAccountIDs returns the "default_exp_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DefaultExpAccountID instead. It exists only for internal usage by the builders.
func (m *AccountingControlMutation) DefaultExpAccountIDs() (ids []uuid.UUID) {
	if id := m.default_exp_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDefaultExpAccount resets all changes to the "default_exp_account" edge.
func (m *AccountingControlMutation) ResetDefaultExpAccount() {
	m.default_exp_account = nil
	m.cleareddefault_exp_account = false
}

// Where appends a list predicates to the AccountingControlMutation builder.
func (m *AccountingControlMutation) Where(ps ...predicate.AccountingControl) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountingControlMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountingControlMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AccountingControl, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountingControlMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountingControlMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AccountingControl).
func (m *AccountingControlMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountingControlMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, accountingcontrol.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, accountingcontrol.FieldUpdatedAt)
	}
	if m.rec_threshold != nil {
		fields = append(fields, accountingcontrol.FieldRecThreshold)
	}
	if m.rec_threshold_action != nil {
		fields = append(fields, accountingcontrol.FieldRecThresholdAction)
	}
	if m.auto_create_journal_entries != nil {
		fields = append(fields, accountingcontrol.FieldAutoCreateJournalEntries)
	}
	if m.restrict_manual_journal_entries != nil {
		fields = append(fields, accountingcontrol.FieldRestrictManualJournalEntries)
	}
	if m.require_journal_entry_approval != nil {
		fields = append(fields, accountingcontrol.FieldRequireJournalEntryApproval)
	}
	if m.enable_rec_notifications != nil {
		fields = append(fields, accountingcontrol.FieldEnableRecNotifications)
	}
	if m.halt_on_pending_rec != nil {
		fields = append(fields, accountingcontrol.FieldHaltOnPendingRec)
	}
	if m.critical_processes != nil {
		fields = append(fields, accountingcontrol.FieldCriticalProcesses)
	}
	if m.default_rev_account != nil {
		fields = append(fields, accountingcontrol.FieldDefaultRevAccountID)
	}
	if m.default_exp_account != nil {
		fields = append(fields, accountingcontrol.FieldDefaultExpAccountID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountingControlMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case accountingcontrol.FieldCreatedAt:
		return m.CreatedAt()
	case accountingcontrol.FieldUpdatedAt:
		return m.UpdatedAt()
	case accountingcontrol.FieldRecThreshold:
		return m.RecThreshold()
	case accountingcontrol.FieldRecThresholdAction:
		return m.RecThresholdAction()
	case accountingcontrol.FieldAutoCreateJournalEntries:
		return m.AutoCreateJournalEntries()
	case accountingcontrol.FieldRestrictManualJournalEntries:
		return m.RestrictManualJournalEntries()
	case accountingcontrol.FieldRequireJournalEntryApproval:
		return m.RequireJournalEntryApproval()
	case accountingcontrol.FieldEnableRecNotifications:
		return m.EnableRecNotifications()
	case accountingcontrol.FieldHaltOnPendingRec:
		return m.HaltOnPendingRec()
	case accountingcontrol.FieldCriticalProcesses:
		return m.CriticalProcesses()
	case accountingcontrol.FieldDefaultRevAccountID:
		return m.DefaultRevAccountID()
	case accountingcontrol.FieldDefaultExpAccountID:
		return m.DefaultExpAccountID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountingControlMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case accountingcontrol.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case accountingcontrol.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case accountingcontrol.FieldRecThreshold:
		return m.OldRecThreshold(ctx)
	case accountingcontrol.FieldRecThresholdAction:
		return m.OldRecThresholdAction(ctx)
	case accountingcontrol.FieldAutoCreateJournalEntries:
		return m.OldAutoCreateJournalEntries(ctx)
	case accountingcontrol.FieldRestrictManualJournalEntries:
		return m.OldRestrictManualJournalEntries(ctx)
	case accountingcontrol.FieldRequireJournalEntryApproval:
		return m.OldRequireJournalEntryApproval(ctx)
	case accountingcontrol.FieldEnableRecNotifications:
		return m.OldEnableRecNotifications(ctx)
	case accountingcontrol.FieldHaltOnPendingRec:
		return m.OldHaltOnPendingRec(ctx)
	case accountingcontrol.FieldCriticalProcesses:
		return m.OldCriticalProcesses(ctx)
	case accountingcontrol.FieldDefaultRevAccountID:
		return m.OldDefaultRevAccountID(ctx)
	case accountingcontrol.FieldDefaultExpAccountID:
		return m.OldDefaultExpAccountID(ctx)
	}
	return nil, fmt.Errorf("unknown AccountingControl field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountingControlMutation) SetField(name string, value ent.Value) error {
	switch name {
	case accountingcontrol.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case accountingcontrol.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case accountingcontrol.FieldRecThreshold:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecThreshold(v)
		return nil
	case accountingcontrol.FieldRecThresholdAction:
		v, ok := value.(accountingcontrol.RecThresholdAction)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecThresholdAction(v)
		return nil
	case accountingcontrol.FieldAutoCreateJournalEntries:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoCreateJournalEntries(v)
		return nil
	case accountingcontrol.FieldRestrictManualJournalEntries:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRestrictManualJournalEntries(v)
		return nil
	case accountingcontrol.FieldRequireJournalEntryApproval:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequireJournalEntryApproval(v)
		return nil
	case accountingcontrol.FieldEnableRecNotifications:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableRecNotifications(v)
		return nil
	case accountingcontrol.FieldHaltOnPendingRec:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHaltOnPendingRec(v)
		return nil
	case accountingcontrol.FieldCriticalProcesses:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCriticalProcesses(v)
		return nil
	case accountingcontrol.FieldDefaultRevAccountID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultRevAccountID(v)
		return nil
	case accountingcontrol.FieldDefaultExpAccountID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultExpAccountID(v)
		return nil
	}
	return fmt.Errorf("unknown AccountingControl field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountingControlMutation) AddedFields() []string {
	var fields []string
	if m.addrec_threshold != nil {
		fields = append(fields, accountingcontrol.FieldRecThreshold)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountingControlMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case accountingcontrol.FieldRecThreshold:
		return m.AddedRecThreshold()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountingControlMutation) AddField(name string, value ent.Value) error {
	switch name {
	case accountingcontrol.FieldRecThreshold:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRecThreshold(v)
		return nil
	}
	return fmt.Errorf("unknown AccountingControl numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountingControlMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(accountingcontrol.FieldCriticalProcesses) {
		fields = append(fields, accountingcontrol.FieldCriticalProcesses)
	}
	if m.FieldCleared(accountingcontrol.FieldDefaultRevAccountID) {
		fields = append(fields, accountingcontrol.FieldDefaultRevAccountID)
	}
	if m.FieldCleared(accountingcontrol.FieldDefaultExpAccountID) {
		fields = append(fields, accountingcontrol.FieldDefaultExpAccountID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountingControlMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountingControlMutation) ClearField(name string) error {
	switch name {
	case accountingcontrol.FieldCriticalProcesses:
		m.ClearCriticalProcesses()
		return nil
	case accountingcontrol.FieldDefaultRevAccountID:
		m.ClearDefaultRevAccountID()
		return nil
	case accountingcontrol.FieldDefaultExpAccountID:
		m.ClearDefaultExpAccountID()
		return nil
	}
	return fmt.Errorf("unknown AccountingControl nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountingControlMutation) ResetField(name string) error {
	switch name {
	case accountingcontrol.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case accountingcontrol.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case accountingcontrol.FieldRecThreshold:
		m.ResetRecThreshold()
		return nil
	case accountingcontrol.FieldRecThresholdAction:
		m.ResetRecThresholdAction()
		return nil
	case accountingcontrol.FieldAutoCreateJournalEntries:
		m.ResetAutoCreateJournalEntries()
		return nil
	case accountingcontrol.FieldRestrictManualJournalEntries:
		m.ResetRestrictManualJournalEntries()
		return nil
	case accountingcontrol.FieldRequireJournalEntryApproval:
		m.ResetRequireJournalEntryApproval()
		return nil
	case accountingcontrol.FieldEnableRecNotifications:
		m.ResetEnableRecNotifications()
		return nil
	case accountingcontrol.FieldHaltOnPendingRec:
		m.ResetHaltOnPendingRec()
		return nil
	case accountingcontrol.FieldCriticalProcesses:
		m.ResetCriticalProcesses()
		return nil
	case accountingcontrol.FieldDefaultRevAccountID:
		m.ResetDefaultRevAccountID()
		return nil
	case accountingcontrol.FieldDefaultExpAccountID:
		m.ResetDefaultExpAccountID()
		return nil
	}
	return fmt.Errorf("unknown AccountingControl field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountingControlMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.organization != nil {
		edges = append(edges, accountingcontrol.EdgeOrganization)
	}
	if m.business_unit != nil {
		edges = append(edges, accountingcontrol.EdgeBusinessUnit)
	}
	if m.default_rev_account != nil {
		edges = append(edges, accountingcontrol.EdgeDefaultRevAccount)
	}
	if m.default_exp_account != nil {
		edges = append(edges, accountingcontrol.EdgeDefaultExpAccount)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountingControlMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case accountingcontrol.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case accountingcontrol.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case accountingcontrol.EdgeDefaultRevAccount:
		if id := m.default_rev_account; id != nil {
			return []ent.Value{*id}
		}
	case accountingcontrol.EdgeDefaultExpAccount:
		if id := m.default_exp_account; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountingControlMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountingControlMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountingControlMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedorganization {
		edges = append(edges, accountingcontrol.EdgeOrganization)
	}
	if m.clearedbusiness_unit {
		edges = append(edges, accountingcontrol.EdgeBusinessUnit)
	}
	if m.cleareddefault_rev_account {
		edges = append(edges, accountingcontrol.EdgeDefaultRevAccount)
	}
	if m.cleareddefault_exp_account {
		edges = append(edges, accountingcontrol.EdgeDefaultExpAccount)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountingControlMutation) EdgeCleared(name string) bool {
	switch name {
	case accountingcontrol.EdgeOrganization:
		return m.clearedorganization
	case accountingcontrol.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case accountingcontrol.EdgeDefaultRevAccount:
		return m.cleareddefault_rev_account
	case accountingcontrol.EdgeDefaultExpAccount:
		return m.cleareddefault_exp_account
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountingControlMutation) ClearEdge(name string) error {
	switch name {
	case accountingcontrol.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case accountingcontrol.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case accountingcontrol.EdgeDefaultRevAccount:
		m.ClearDefaultRevAccount()
		return nil
	case accountingcontrol.EdgeDefaultExpAccount:
		m.ClearDefaultExpAccount()
		return nil
	}
	return fmt.Errorf("unknown AccountingControl unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountingControlMutation) ResetEdge(name string) error {
	switch name {
	case accountingcontrol.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case accountingcontrol.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case accountingcontrol.EdgeDefaultRevAccount:
		m.ResetDefaultRevAccount()
		return nil
	case accountingcontrol.EdgeDefaultExpAccount:
		m.ResetDefaultExpAccount()
		return nil
	}
	return fmt.Errorf("unknown AccountingControl edge %s", name)
}

// BillingControlMutation represents an operation that mutates the BillingControl nodes in the graph.
type BillingControlMutation struct {
	config
	op                         Op
	typ                        string
	id                         *uuid.UUID
	created_at                 *time.Time
	updated_at                 *time.Time
	remove_billing_history     *bool
	auto_bill_shipment         *bool
	auto_mark_ready_to_bill    *bool
	validate_customer_rates    *bool
	auto_bill_criteria         *billingcontrol.AutoBillCriteria
	shipment_transfer_criteria *billingcontrol.ShipmentTransferCriteria
	clearedFields              map[string]struct{}
	organization               *uuid.UUID
	clearedorganization        bool
	business_unit              *uuid.UUID
	clearedbusiness_unit       bool
	done                       bool
	oldValue                   func(context.Context) (*BillingControl, error)
	predicates                 []predicate.BillingControl
}

var _ ent.Mutation = (*BillingControlMutation)(nil)

// billingcontrolOption allows management of the mutation configuration using functional options.
type billingcontrolOption func(*BillingControlMutation)

// newBillingControlMutation creates new mutation for the BillingControl entity.
func newBillingControlMutation(c config, op Op, opts ...billingcontrolOption) *BillingControlMutation {
	m := &BillingControlMutation{
		config:        c,
		op:            op,
		typ:           TypeBillingControl,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillingControlID sets the ID field of the mutation.
func withBillingControlID(id uuid.UUID) billingcontrolOption {
	return func(m *BillingControlMutation) {
		var (
			err   error
			once  sync.Once
			value *BillingControl
		)
		m.oldValue = func(ctx context.Context) (*BillingControl, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BillingControl.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBillingControl sets the old BillingControl of the mutation.
func withBillingControl(node *BillingControl) billingcontrolOption {
	return func(m *BillingControlMutation) {
		m.oldValue = func(context.Context) (*BillingControl, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillingControlMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillingControlMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BillingControl entities.
func (m *BillingControlMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BillingControlMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BillingControlMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BillingControl.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BillingControlMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BillingControlMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BillingControl entity.
// If the BillingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingControlMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BillingControlMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BillingControlMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BillingControlMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BillingControl entity.
// If the BillingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingControlMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BillingControlMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetRemoveBillingHistory sets the "remove_billing_history" field.
func (m *BillingControlMutation) SetRemoveBillingHistory(b bool) {
	m.remove_billing_history = &b
}

// RemoveBillingHistory returns the value of the "remove_billing_history" field in the mutation.
func (m *BillingControlMutation) RemoveBillingHistory() (r bool, exists bool) {
	v := m.remove_billing_history
	if v == nil {
		return
	}
	return *v, true
}

// OldRemoveBillingHistory returns the old "remove_billing_history" field's value of the BillingControl entity.
// If the BillingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingControlMutation) OldRemoveBillingHistory(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemoveBillingHistory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemoveBillingHistory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemoveBillingHistory: %w", err)
	}
	return oldValue.RemoveBillingHistory, nil
}

// ResetRemoveBillingHistory resets all changes to the "remove_billing_history" field.
func (m *BillingControlMutation) ResetRemoveBillingHistory() {
	m.remove_billing_history = nil
}

// SetAutoBillShipment sets the "auto_bill_shipment" field.
func (m *BillingControlMutation) SetAutoBillShipment(b bool) {
	m.auto_bill_shipment = &b
}

// AutoBillShipment returns the value of the "auto_bill_shipment" field in the mutation.
func (m *BillingControlMutation) AutoBillShipment() (r bool, exists bool) {
	v := m.auto_bill_shipment
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoBillShipment returns the old "auto_bill_shipment" field's value of the BillingControl entity.
// If the BillingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingControlMutation) OldAutoBillShipment(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoBillShipment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoBillShipment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoBillShipment: %w", err)
	}
	return oldValue.AutoBillShipment, nil
}

// ResetAutoBillShipment resets all changes to the "auto_bill_shipment" field.
func (m *BillingControlMutation) ResetAutoBillShipment() {
	m.auto_bill_shipment = nil
}

// SetAutoMarkReadyToBill sets the "auto_mark_ready_to_bill" field.
func (m *BillingControlMutation) SetAutoMarkReadyToBill(b bool) {
	m.auto_mark_ready_to_bill = &b
}

// AutoMarkReadyToBill returns the value of the "auto_mark_ready_to_bill" field in the mutation.
func (m *BillingControlMutation) AutoMarkReadyToBill() (r bool, exists bool) {
	v := m.auto_mark_ready_to_bill
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoMarkReadyToBill returns the old "auto_mark_ready_to_bill" field's value of the BillingControl entity.
// If the BillingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingControlMutation) OldAutoMarkReadyToBill(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoMarkReadyToBill is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoMarkReadyToBill requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoMarkReadyToBill: %w", err)
	}
	return oldValue.AutoMarkReadyToBill, nil
}

// ResetAutoMarkReadyToBill resets all changes to the "auto_mark_ready_to_bill" field.
func (m *BillingControlMutation) ResetAutoMarkReadyToBill() {
	m.auto_mark_ready_to_bill = nil
}

// SetValidateCustomerRates sets the "validate_customer_rates" field.
func (m *BillingControlMutation) SetValidateCustomerRates(b bool) {
	m.validate_customer_rates = &b
}

// ValidateCustomerRates returns the value of the "validate_customer_rates" field in the mutation.
func (m *BillingControlMutation) ValidateCustomerRates() (r bool, exists bool) {
	v := m.validate_customer_rates
	if v == nil {
		return
	}
	return *v, true
}

// OldValidateCustomerRates returns the old "validate_customer_rates" field's value of the BillingControl entity.
// If the BillingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingControlMutation) OldValidateCustomerRates(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidateCustomerRates is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidateCustomerRates requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidateCustomerRates: %w", err)
	}
	return oldValue.ValidateCustomerRates, nil
}

// ResetValidateCustomerRates resets all changes to the "validate_customer_rates" field.
func (m *BillingControlMutation) ResetValidateCustomerRates() {
	m.validate_customer_rates = nil
}

// SetAutoBillCriteria sets the "auto_bill_criteria" field.
func (m *BillingControlMutation) SetAutoBillCriteria(bbc billingcontrol.AutoBillCriteria) {
	m.auto_bill_criteria = &bbc
}

// AutoBillCriteria returns the value of the "auto_bill_criteria" field in the mutation.
func (m *BillingControlMutation) AutoBillCriteria() (r billingcontrol.AutoBillCriteria, exists bool) {
	v := m.auto_bill_criteria
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoBillCriteria returns the old "auto_bill_criteria" field's value of the BillingControl entity.
// If the BillingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingControlMutation) OldAutoBillCriteria(ctx context.Context) (v billingcontrol.AutoBillCriteria, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoBillCriteria is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoBillCriteria requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoBillCriteria: %w", err)
	}
	return oldValue.AutoBillCriteria, nil
}

// ResetAutoBillCriteria resets all changes to the "auto_bill_criteria" field.
func (m *BillingControlMutation) ResetAutoBillCriteria() {
	m.auto_bill_criteria = nil
}

// SetShipmentTransferCriteria sets the "shipment_transfer_criteria" field.
func (m *BillingControlMutation) SetShipmentTransferCriteria(btc billingcontrol.ShipmentTransferCriteria) {
	m.shipment_transfer_criteria = &btc
}

// ShipmentTransferCriteria returns the value of the "shipment_transfer_criteria" field in the mutation.
func (m *BillingControlMutation) ShipmentTransferCriteria() (r billingcontrol.ShipmentTransferCriteria, exists bool) {
	v := m.shipment_transfer_criteria
	if v == nil {
		return
	}
	return *v, true
}

// OldShipmentTransferCriteria returns the old "shipment_transfer_criteria" field's value of the BillingControl entity.
// If the BillingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingControlMutation) OldShipmentTransferCriteria(ctx context.Context) (v billingcontrol.ShipmentTransferCriteria, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShipmentTransferCriteria is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShipmentTransferCriteria requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipmentTransferCriteria: %w", err)
	}
	return oldValue.ShipmentTransferCriteria, nil
}

// ResetShipmentTransferCriteria resets all changes to the "shipment_transfer_criteria" field.
func (m *BillingControlMutation) ResetShipmentTransferCriteria() {
	m.shipment_transfer_criteria = nil
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *BillingControlMutation) SetOrganizationID(id uuid.UUID) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *BillingControlMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *BillingControlMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *BillingControlMutation) OrganizationID() (id uuid.UUID, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *BillingControlMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *BillingControlMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// SetBusinessUnitID sets the "business_unit" edge to the BusinessUnit entity by id.
func (m *BillingControlMutation) SetBusinessUnitID(id uuid.UUID) {
	m.business_unit = &id
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *BillingControlMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *BillingControlMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitID returns the "business_unit" edge ID in the mutation.
func (m *BillingControlMutation) BusinessUnitID() (id uuid.UUID, exists bool) {
	if m.business_unit != nil {
		return *m.business_unit, true
	}
	return
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *BillingControlMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *BillingControlMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// Where appends a list predicates to the BillingControlMutation builder.
func (m *BillingControlMutation) Where(ps ...predicate.BillingControl) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BillingControlMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BillingControlMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BillingControl, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BillingControlMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BillingControlMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BillingControl).
func (m *BillingControlMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BillingControlMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, billingcontrol.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, billingcontrol.FieldUpdatedAt)
	}
	if m.remove_billing_history != nil {
		fields = append(fields, billingcontrol.FieldRemoveBillingHistory)
	}
	if m.auto_bill_shipment != nil {
		fields = append(fields, billingcontrol.FieldAutoBillShipment)
	}
	if m.auto_mark_ready_to_bill != nil {
		fields = append(fields, billingcontrol.FieldAutoMarkReadyToBill)
	}
	if m.validate_customer_rates != nil {
		fields = append(fields, billingcontrol.FieldValidateCustomerRates)
	}
	if m.auto_bill_criteria != nil {
		fields = append(fields, billingcontrol.FieldAutoBillCriteria)
	}
	if m.shipment_transfer_criteria != nil {
		fields = append(fields, billingcontrol.FieldShipmentTransferCriteria)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BillingControlMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case billingcontrol.FieldCreatedAt:
		return m.CreatedAt()
	case billingcontrol.FieldUpdatedAt:
		return m.UpdatedAt()
	case billingcontrol.FieldRemoveBillingHistory:
		return m.RemoveBillingHistory()
	case billingcontrol.FieldAutoBillShipment:
		return m.AutoBillShipment()
	case billingcontrol.FieldAutoMarkReadyToBill:
		return m.AutoMarkReadyToBill()
	case billingcontrol.FieldValidateCustomerRates:
		return m.ValidateCustomerRates()
	case billingcontrol.FieldAutoBillCriteria:
		return m.AutoBillCriteria()
	case billingcontrol.FieldShipmentTransferCriteria:
		return m.ShipmentTransferCriteria()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BillingControlMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case billingcontrol.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case billingcontrol.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case billingcontrol.FieldRemoveBillingHistory:
		return m.OldRemoveBillingHistory(ctx)
	case billingcontrol.FieldAutoBillShipment:
		return m.OldAutoBillShipment(ctx)
	case billingcontrol.FieldAutoMarkReadyToBill:
		return m.OldAutoMarkReadyToBill(ctx)
	case billingcontrol.FieldValidateCustomerRates:
		return m.OldValidateCustomerRates(ctx)
	case billingcontrol.FieldAutoBillCriteria:
		return m.OldAutoBillCriteria(ctx)
	case billingcontrol.FieldShipmentTransferCriteria:
		return m.OldShipmentTransferCriteria(ctx)
	}
	return nil, fmt.Errorf("unknown BillingControl field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingControlMutation) SetField(name string, value ent.Value) error {
	switch name {
	case billingcontrol.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case billingcontrol.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case billingcontrol.FieldRemoveBillingHistory:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemoveBillingHistory(v)
		return nil
	case billingcontrol.FieldAutoBillShipment:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoBillShipment(v)
		return nil
	case billingcontrol.FieldAutoMarkReadyToBill:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoMarkReadyToBill(v)
		return nil
	case billingcontrol.FieldValidateCustomerRates:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidateCustomerRates(v)
		return nil
	case billingcontrol.FieldAutoBillCriteria:
		v, ok := value.(billingcontrol.AutoBillCriteria)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoBillCriteria(v)
		return nil
	case billingcontrol.FieldShipmentTransferCriteria:
		v, ok := value.(billingcontrol.ShipmentTransferCriteria)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipmentTransferCriteria(v)
		return nil
	}
	return fmt.Errorf("unknown BillingControl field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BillingControlMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BillingControlMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingControlMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BillingControl numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BillingControlMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BillingControlMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillingControlMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BillingControl nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BillingControlMutation) ResetField(name string) error {
	switch name {
	case billingcontrol.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case billingcontrol.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case billingcontrol.FieldRemoveBillingHistory:
		m.ResetRemoveBillingHistory()
		return nil
	case billingcontrol.FieldAutoBillShipment:
		m.ResetAutoBillShipment()
		return nil
	case billingcontrol.FieldAutoMarkReadyToBill:
		m.ResetAutoMarkReadyToBill()
		return nil
	case billingcontrol.FieldValidateCustomerRates:
		m.ResetValidateCustomerRates()
		return nil
	case billingcontrol.FieldAutoBillCriteria:
		m.ResetAutoBillCriteria()
		return nil
	case billingcontrol.FieldShipmentTransferCriteria:
		m.ResetShipmentTransferCriteria()
		return nil
	}
	return fmt.Errorf("unknown BillingControl field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BillingControlMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.organization != nil {
		edges = append(edges, billingcontrol.EdgeOrganization)
	}
	if m.business_unit != nil {
		edges = append(edges, billingcontrol.EdgeBusinessUnit)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BillingControlMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case billingcontrol.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case billingcontrol.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BillingControlMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BillingControlMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BillingControlMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorganization {
		edges = append(edges, billingcontrol.EdgeOrganization)
	}
	if m.clearedbusiness_unit {
		edges = append(edges, billingcontrol.EdgeBusinessUnit)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BillingControlMutation) EdgeCleared(name string) bool {
	switch name {
	case billingcontrol.EdgeOrganization:
		return m.clearedorganization
	case billingcontrol.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BillingControlMutation) ClearEdge(name string) error {
	switch name {
	case billingcontrol.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case billingcontrol.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	}
	return fmt.Errorf("unknown BillingControl unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BillingControlMutation) ResetEdge(name string) error {
	switch name {
	case billingcontrol.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case billingcontrol.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	}
	return fmt.Errorf("unknown BillingControl edge %s", name)
}

// BusinessUnitMutation represents an operation that mutates the BusinessUnit nodes in the graph.
type BusinessUnitMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	status               *businessunit.Status
	name                 *string
	entity_key           *string
	phone_number         *string
	address              *string
	city                 *string
	state                *string
	country              *string
	postal_code          *string
	tax_id               *string
	subscription_plan    *string
	description          *string
	legal_name           *string
	contact_name         *string
	contact_email        *string
	paid_until           *time.Time
	settings             *map[string]interface{}
	free_trial           *bool
	clearedFields        map[string]struct{}
	prev                 *uuid.UUID
	clearedprev          bool
	next                 *uuid.UUID
	clearednext          bool
	organizations        map[uuid.UUID]struct{}
	removedorganizations map[uuid.UUID]struct{}
	clearedorganizations bool
	done                 bool
	oldValue             func(context.Context) (*BusinessUnit, error)
	predicates           []predicate.BusinessUnit
}

var _ ent.Mutation = (*BusinessUnitMutation)(nil)

// businessunitOption allows management of the mutation configuration using functional options.
type businessunitOption func(*BusinessUnitMutation)

// newBusinessUnitMutation creates new mutation for the BusinessUnit entity.
func newBusinessUnitMutation(c config, op Op, opts ...businessunitOption) *BusinessUnitMutation {
	m := &BusinessUnitMutation{
		config:        c,
		op:            op,
		typ:           TypeBusinessUnit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBusinessUnitID sets the ID field of the mutation.
func withBusinessUnitID(id uuid.UUID) businessunitOption {
	return func(m *BusinessUnitMutation) {
		var (
			err   error
			once  sync.Once
			value *BusinessUnit
		)
		m.oldValue = func(ctx context.Context) (*BusinessUnit, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BusinessUnit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBusinessUnit sets the old BusinessUnit of the mutation.
func withBusinessUnit(node *BusinessUnit) businessunitOption {
	return func(m *BusinessUnitMutation) {
		m.oldValue = func(context.Context) (*BusinessUnit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BusinessUnitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BusinessUnitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BusinessUnit entities.
func (m *BusinessUnitMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BusinessUnitMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BusinessUnitMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BusinessUnit.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BusinessUnitMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BusinessUnitMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BusinessUnitMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BusinessUnitMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BusinessUnitMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BusinessUnitMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *BusinessUnitMutation) SetStatus(b businessunit.Status) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *BusinessUnitMutation) Status() (r businessunit.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldStatus(ctx context.Context) (v businessunit.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BusinessUnitMutation) ResetStatus() {
	m.status = nil
}

// SetName sets the "name" field.
func (m *BusinessUnitMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BusinessUnitMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BusinessUnitMutation) ResetName() {
	m.name = nil
}

// SetEntityKey sets the "entity_key" field.
func (m *BusinessUnitMutation) SetEntityKey(s string) {
	m.entity_key = &s
}

// EntityKey returns the value of the "entity_key" field in the mutation.
func (m *BusinessUnitMutation) EntityKey() (r string, exists bool) {
	v := m.entity_key
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityKey returns the old "entity_key" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldEntityKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityKey: %w", err)
	}
	return oldValue.EntityKey, nil
}

// ResetEntityKey resets all changes to the "entity_key" field.
func (m *BusinessUnitMutation) ResetEntityKey() {
	m.entity_key = nil
}

// SetPhoneNumber sets the "phone_number" field.
func (m *BusinessUnitMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *BusinessUnitMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *BusinessUnitMutation) ResetPhoneNumber() {
	m.phone_number = nil
}

// SetAddress sets the "address" field.
func (m *BusinessUnitMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *BusinessUnitMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *BusinessUnitMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[businessunit.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *BusinessUnitMutation) AddressCleared() bool {
	_, ok := m.clearedFields[businessunit.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *BusinessUnitMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, businessunit.FieldAddress)
}

// SetCity sets the "city" field.
func (m *BusinessUnitMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *BusinessUnitMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ClearCity clears the value of the "city" field.
func (m *BusinessUnitMutation) ClearCity() {
	m.city = nil
	m.clearedFields[businessunit.FieldCity] = struct{}{}
}

// CityCleared returns if the "city" field was cleared in this mutation.
func (m *BusinessUnitMutation) CityCleared() bool {
	_, ok := m.clearedFields[businessunit.FieldCity]
	return ok
}

// ResetCity resets all changes to the "city" field.
func (m *BusinessUnitMutation) ResetCity() {
	m.city = nil
	delete(m.clearedFields, businessunit.FieldCity)
}

// SetState sets the "state" field.
func (m *BusinessUnitMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *BusinessUnitMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *BusinessUnitMutation) ClearState() {
	m.state = nil
	m.clearedFields[businessunit.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *BusinessUnitMutation) StateCleared() bool {
	_, ok := m.clearedFields[businessunit.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *BusinessUnitMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, businessunit.FieldState)
}

// SetCountry sets the "country" field.
func (m *BusinessUnitMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *BusinessUnitMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ClearCountry clears the value of the "country" field.
func (m *BusinessUnitMutation) ClearCountry() {
	m.country = nil
	m.clearedFields[businessunit.FieldCountry] = struct{}{}
}

// CountryCleared returns if the "country" field was cleared in this mutation.
func (m *BusinessUnitMutation) CountryCleared() bool {
	_, ok := m.clearedFields[businessunit.FieldCountry]
	return ok
}

// ResetCountry resets all changes to the "country" field.
func (m *BusinessUnitMutation) ResetCountry() {
	m.country = nil
	delete(m.clearedFields, businessunit.FieldCountry)
}

// SetPostalCode sets the "postal_code" field.
func (m *BusinessUnitMutation) SetPostalCode(s string) {
	m.postal_code = &s
}

// PostalCode returns the value of the "postal_code" field in the mutation.
func (m *BusinessUnitMutation) PostalCode() (r string, exists bool) {
	v := m.postal_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPostalCode returns the old "postal_code" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldPostalCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostalCode: %w", err)
	}
	return oldValue.PostalCode, nil
}

// ClearPostalCode clears the value of the "postal_code" field.
func (m *BusinessUnitMutation) ClearPostalCode() {
	m.postal_code = nil
	m.clearedFields[businessunit.FieldPostalCode] = struct{}{}
}

// PostalCodeCleared returns if the "postal_code" field was cleared in this mutation.
func (m *BusinessUnitMutation) PostalCodeCleared() bool {
	_, ok := m.clearedFields[businessunit.FieldPostalCode]
	return ok
}

// ResetPostalCode resets all changes to the "postal_code" field.
func (m *BusinessUnitMutation) ResetPostalCode() {
	m.postal_code = nil
	delete(m.clearedFields, businessunit.FieldPostalCode)
}

// SetTaxID sets the "tax_id" field.
func (m *BusinessUnitMutation) SetTaxID(s string) {
	m.tax_id = &s
}

// TaxID returns the value of the "tax_id" field in the mutation.
func (m *BusinessUnitMutation) TaxID() (r string, exists bool) {
	v := m.tax_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxID returns the old "tax_id" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldTaxID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxID: %w", err)
	}
	return oldValue.TaxID, nil
}

// ClearTaxID clears the value of the "tax_id" field.
func (m *BusinessUnitMutation) ClearTaxID() {
	m.tax_id = nil
	m.clearedFields[businessunit.FieldTaxID] = struct{}{}
}

// TaxIDCleared returns if the "tax_id" field was cleared in this mutation.
func (m *BusinessUnitMutation) TaxIDCleared() bool {
	_, ok := m.clearedFields[businessunit.FieldTaxID]
	return ok
}

// ResetTaxID resets all changes to the "tax_id" field.
func (m *BusinessUnitMutation) ResetTaxID() {
	m.tax_id = nil
	delete(m.clearedFields, businessunit.FieldTaxID)
}

// SetSubscriptionPlan sets the "subscription_plan" field.
func (m *BusinessUnitMutation) SetSubscriptionPlan(s string) {
	m.subscription_plan = &s
}

// SubscriptionPlan returns the value of the "subscription_plan" field in the mutation.
func (m *BusinessUnitMutation) SubscriptionPlan() (r string, exists bool) {
	v := m.subscription_plan
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionPlan returns the old "subscription_plan" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldSubscriptionPlan(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscriptionPlan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscriptionPlan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionPlan: %w", err)
	}
	return oldValue.SubscriptionPlan, nil
}

// ClearSubscriptionPlan clears the value of the "subscription_plan" field.
func (m *BusinessUnitMutation) ClearSubscriptionPlan() {
	m.subscription_plan = nil
	m.clearedFields[businessunit.FieldSubscriptionPlan] = struct{}{}
}

// SubscriptionPlanCleared returns if the "subscription_plan" field was cleared in this mutation.
func (m *BusinessUnitMutation) SubscriptionPlanCleared() bool {
	_, ok := m.clearedFields[businessunit.FieldSubscriptionPlan]
	return ok
}

// ResetSubscriptionPlan resets all changes to the "subscription_plan" field.
func (m *BusinessUnitMutation) ResetSubscriptionPlan() {
	m.subscription_plan = nil
	delete(m.clearedFields, businessunit.FieldSubscriptionPlan)
}

// SetDescription sets the "description" field.
func (m *BusinessUnitMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BusinessUnitMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BusinessUnitMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[businessunit.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BusinessUnitMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[businessunit.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BusinessUnitMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, businessunit.FieldDescription)
}

// SetLegalName sets the "legal_name" field.
func (m *BusinessUnitMutation) SetLegalName(s string) {
	m.legal_name = &s
}

// LegalName returns the value of the "legal_name" field in the mutation.
func (m *BusinessUnitMutation) LegalName() (r string, exists bool) {
	v := m.legal_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLegalName returns the old "legal_name" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldLegalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLegalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLegalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLegalName: %w", err)
	}
	return oldValue.LegalName, nil
}

// ClearLegalName clears the value of the "legal_name" field.
func (m *BusinessUnitMutation) ClearLegalName() {
	m.legal_name = nil
	m.clearedFields[businessunit.FieldLegalName] = struct{}{}
}

// LegalNameCleared returns if the "legal_name" field was cleared in this mutation.
func (m *BusinessUnitMutation) LegalNameCleared() bool {
	_, ok := m.clearedFields[businessunit.FieldLegalName]
	return ok
}

// ResetLegalName resets all changes to the "legal_name" field.
func (m *BusinessUnitMutation) ResetLegalName() {
	m.legal_name = nil
	delete(m.clearedFields, businessunit.FieldLegalName)
}

// SetContactName sets the "contact_name" field.
func (m *BusinessUnitMutation) SetContactName(s string) {
	m.contact_name = &s
}

// ContactName returns the value of the "contact_name" field in the mutation.
func (m *BusinessUnitMutation) ContactName() (r string, exists bool) {
	v := m.contact_name
	if v == nil {
		return
	}
	return *v, true
}

// OldContactName returns the old "contact_name" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldContactName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactName: %w", err)
	}
	return oldValue.ContactName, nil
}

// ClearContactName clears the value of the "contact_name" field.
func (m *BusinessUnitMutation) ClearContactName() {
	m.contact_name = nil
	m.clearedFields[businessunit.FieldContactName] = struct{}{}
}

// ContactNameCleared returns if the "contact_name" field was cleared in this mutation.
func (m *BusinessUnitMutation) ContactNameCleared() bool {
	_, ok := m.clearedFields[businessunit.FieldContactName]
	return ok
}

// ResetContactName resets all changes to the "contact_name" field.
func (m *BusinessUnitMutation) ResetContactName() {
	m.contact_name = nil
	delete(m.clearedFields, businessunit.FieldContactName)
}

// SetContactEmail sets the "contact_email" field.
func (m *BusinessUnitMutation) SetContactEmail(s string) {
	m.contact_email = &s
}

// ContactEmail returns the value of the "contact_email" field in the mutation.
func (m *BusinessUnitMutation) ContactEmail() (r string, exists bool) {
	v := m.contact_email
	if v == nil {
		return
	}
	return *v, true
}

// OldContactEmail returns the old "contact_email" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldContactEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactEmail: %w", err)
	}
	return oldValue.ContactEmail, nil
}

// ClearContactEmail clears the value of the "contact_email" field.
func (m *BusinessUnitMutation) ClearContactEmail() {
	m.contact_email = nil
	m.clearedFields[businessunit.FieldContactEmail] = struct{}{}
}

// ContactEmailCleared returns if the "contact_email" field was cleared in this mutation.
func (m *BusinessUnitMutation) ContactEmailCleared() bool {
	_, ok := m.clearedFields[businessunit.FieldContactEmail]
	return ok
}

// ResetContactEmail resets all changes to the "contact_email" field.
func (m *BusinessUnitMutation) ResetContactEmail() {
	m.contact_email = nil
	delete(m.clearedFields, businessunit.FieldContactEmail)
}

// SetPaidUntil sets the "paid_until" field.
func (m *BusinessUnitMutation) SetPaidUntil(t time.Time) {
	m.paid_until = &t
}

// PaidUntil returns the value of the "paid_until" field in the mutation.
func (m *BusinessUnitMutation) PaidUntil() (r time.Time, exists bool) {
	v := m.paid_until
	if v == nil {
		return
	}
	return *v, true
}

// OldPaidUntil returns the old "paid_until" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldPaidUntil(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaidUntil is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaidUntil requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaidUntil: %w", err)
	}
	return oldValue.PaidUntil, nil
}

// ClearPaidUntil clears the value of the "paid_until" field.
func (m *BusinessUnitMutation) ClearPaidUntil() {
	m.paid_until = nil
	m.clearedFields[businessunit.FieldPaidUntil] = struct{}{}
}

// PaidUntilCleared returns if the "paid_until" field was cleared in this mutation.
func (m *BusinessUnitMutation) PaidUntilCleared() bool {
	_, ok := m.clearedFields[businessunit.FieldPaidUntil]
	return ok
}

// ResetPaidUntil resets all changes to the "paid_until" field.
func (m *BusinessUnitMutation) ResetPaidUntil() {
	m.paid_until = nil
	delete(m.clearedFields, businessunit.FieldPaidUntil)
}

// SetSettings sets the "settings" field.
func (m *BusinessUnitMutation) SetSettings(value map[string]interface{}) {
	m.settings = &value
}

// Settings returns the value of the "settings" field in the mutation.
func (m *BusinessUnitMutation) Settings() (r map[string]interface{}, exists bool) {
	v := m.settings
	if v == nil {
		return
	}
	return *v, true
}

// OldSettings returns the old "settings" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldSettings(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettings: %w", err)
	}
	return oldValue.Settings, nil
}

// ClearSettings clears the value of the "settings" field.
func (m *BusinessUnitMutation) ClearSettings() {
	m.settings = nil
	m.clearedFields[businessunit.FieldSettings] = struct{}{}
}

// SettingsCleared returns if the "settings" field was cleared in this mutation.
func (m *BusinessUnitMutation) SettingsCleared() bool {
	_, ok := m.clearedFields[businessunit.FieldSettings]
	return ok
}

// ResetSettings resets all changes to the "settings" field.
func (m *BusinessUnitMutation) ResetSettings() {
	m.settings = nil
	delete(m.clearedFields, businessunit.FieldSettings)
}

// SetFreeTrial sets the "free_trial" field.
func (m *BusinessUnitMutation) SetFreeTrial(b bool) {
	m.free_trial = &b
}

// FreeTrial returns the value of the "free_trial" field in the mutation.
func (m *BusinessUnitMutation) FreeTrial() (r bool, exists bool) {
	v := m.free_trial
	if v == nil {
		return
	}
	return *v, true
}

// OldFreeTrial returns the old "free_trial" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldFreeTrial(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFreeTrial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFreeTrial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFreeTrial: %w", err)
	}
	return oldValue.FreeTrial, nil
}

// ResetFreeTrial resets all changes to the "free_trial" field.
func (m *BusinessUnitMutation) ResetFreeTrial() {
	m.free_trial = nil
}

// SetParentID sets the "parent_id" field.
func (m *BusinessUnitMutation) SetParentID(u uuid.UUID) {
	m.prev = &u
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *BusinessUnitMutation) ParentID() (r uuid.UUID, exists bool) {
	v := m.prev
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldParentID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *BusinessUnitMutation) ClearParentID() {
	m.prev = nil
	m.clearedFields[businessunit.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *BusinessUnitMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[businessunit.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *BusinessUnitMutation) ResetParentID() {
	m.prev = nil
	delete(m.clearedFields, businessunit.FieldParentID)
}

// SetPrevID sets the "prev" edge to the BusinessUnit entity by id.
func (m *BusinessUnitMutation) SetPrevID(id uuid.UUID) {
	m.prev = &id
}

// ClearPrev clears the "prev" edge to the BusinessUnit entity.
func (m *BusinessUnitMutation) ClearPrev() {
	m.clearedprev = true
	m.clearedFields[businessunit.FieldParentID] = struct{}{}
}

// PrevCleared reports if the "prev" edge to the BusinessUnit entity was cleared.
func (m *BusinessUnitMutation) PrevCleared() bool {
	return m.ParentIDCleared() || m.clearedprev
}

// PrevID returns the "prev" edge ID in the mutation.
func (m *BusinessUnitMutation) PrevID() (id uuid.UUID, exists bool) {
	if m.prev != nil {
		return *m.prev, true
	}
	return
}

// PrevIDs returns the "prev" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PrevID instead. It exists only for internal usage by the builders.
func (m *BusinessUnitMutation) PrevIDs() (ids []uuid.UUID) {
	if id := m.prev; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrev resets all changes to the "prev" edge.
func (m *BusinessUnitMutation) ResetPrev() {
	m.prev = nil
	m.clearedprev = false
}

// SetNextID sets the "next" edge to the BusinessUnit entity by id.
func (m *BusinessUnitMutation) SetNextID(id uuid.UUID) {
	m.next = &id
}

// ClearNext clears the "next" edge to the BusinessUnit entity.
func (m *BusinessUnitMutation) ClearNext() {
	m.clearednext = true
}

// NextCleared reports if the "next" edge to the BusinessUnit entity was cleared.
func (m *BusinessUnitMutation) NextCleared() bool {
	return m.clearednext
}

// NextID returns the "next" edge ID in the mutation.
func (m *BusinessUnitMutation) NextID() (id uuid.UUID, exists bool) {
	if m.next != nil {
		return *m.next, true
	}
	return
}

// NextIDs returns the "next" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NextID instead. It exists only for internal usage by the builders.
func (m *BusinessUnitMutation) NextIDs() (ids []uuid.UUID) {
	if id := m.next; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNext resets all changes to the "next" edge.
func (m *BusinessUnitMutation) ResetNext() {
	m.next = nil
	m.clearednext = false
}

// AddOrganizationIDs adds the "organizations" edge to the Organization entity by ids.
func (m *BusinessUnitMutation) AddOrganizationIDs(ids ...uuid.UUID) {
	if m.organizations == nil {
		m.organizations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.organizations[ids[i]] = struct{}{}
	}
}

// ClearOrganizations clears the "organizations" edge to the Organization entity.
func (m *BusinessUnitMutation) ClearOrganizations() {
	m.clearedorganizations = true
}

// OrganizationsCleared reports if the "organizations" edge to the Organization entity was cleared.
func (m *BusinessUnitMutation) OrganizationsCleared() bool {
	return m.clearedorganizations
}

// RemoveOrganizationIDs removes the "organizations" edge to the Organization entity by IDs.
func (m *BusinessUnitMutation) RemoveOrganizationIDs(ids ...uuid.UUID) {
	if m.removedorganizations == nil {
		m.removedorganizations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.organizations, ids[i])
		m.removedorganizations[ids[i]] = struct{}{}
	}
}

// RemovedOrganizations returns the removed IDs of the "organizations" edge to the Organization entity.
func (m *BusinessUnitMutation) RemovedOrganizationsIDs() (ids []uuid.UUID) {
	for id := range m.removedorganizations {
		ids = append(ids, id)
	}
	return
}

// OrganizationsIDs returns the "organizations" edge IDs in the mutation.
func (m *BusinessUnitMutation) OrganizationsIDs() (ids []uuid.UUID) {
	for id := range m.organizations {
		ids = append(ids, id)
	}
	return
}

// ResetOrganizations resets all changes to the "organizations" edge.
func (m *BusinessUnitMutation) ResetOrganizations() {
	m.organizations = nil
	m.clearedorganizations = false
	m.removedorganizations = nil
}

// Where appends a list predicates to the BusinessUnitMutation builder.
func (m *BusinessUnitMutation) Where(ps ...predicate.BusinessUnit) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BusinessUnitMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BusinessUnitMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BusinessUnit, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BusinessUnitMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BusinessUnitMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BusinessUnit).
func (m *BusinessUnitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BusinessUnitMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.created_at != nil {
		fields = append(fields, businessunit.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, businessunit.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, businessunit.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, businessunit.FieldName)
	}
	if m.entity_key != nil {
		fields = append(fields, businessunit.FieldEntityKey)
	}
	if m.phone_number != nil {
		fields = append(fields, businessunit.FieldPhoneNumber)
	}
	if m.address != nil {
		fields = append(fields, businessunit.FieldAddress)
	}
	if m.city != nil {
		fields = append(fields, businessunit.FieldCity)
	}
	if m.state != nil {
		fields = append(fields, businessunit.FieldState)
	}
	if m.country != nil {
		fields = append(fields, businessunit.FieldCountry)
	}
	if m.postal_code != nil {
		fields = append(fields, businessunit.FieldPostalCode)
	}
	if m.tax_id != nil {
		fields = append(fields, businessunit.FieldTaxID)
	}
	if m.subscription_plan != nil {
		fields = append(fields, businessunit.FieldSubscriptionPlan)
	}
	if m.description != nil {
		fields = append(fields, businessunit.FieldDescription)
	}
	if m.legal_name != nil {
		fields = append(fields, businessunit.FieldLegalName)
	}
	if m.contact_name != nil {
		fields = append(fields, businessunit.FieldContactName)
	}
	if m.contact_email != nil {
		fields = append(fields, businessunit.FieldContactEmail)
	}
	if m.paid_until != nil {
		fields = append(fields, businessunit.FieldPaidUntil)
	}
	if m.settings != nil {
		fields = append(fields, businessunit.FieldSettings)
	}
	if m.free_trial != nil {
		fields = append(fields, businessunit.FieldFreeTrial)
	}
	if m.prev != nil {
		fields = append(fields, businessunit.FieldParentID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BusinessUnitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case businessunit.FieldCreatedAt:
		return m.CreatedAt()
	case businessunit.FieldUpdatedAt:
		return m.UpdatedAt()
	case businessunit.FieldStatus:
		return m.Status()
	case businessunit.FieldName:
		return m.Name()
	case businessunit.FieldEntityKey:
		return m.EntityKey()
	case businessunit.FieldPhoneNumber:
		return m.PhoneNumber()
	case businessunit.FieldAddress:
		return m.Address()
	case businessunit.FieldCity:
		return m.City()
	case businessunit.FieldState:
		return m.State()
	case businessunit.FieldCountry:
		return m.Country()
	case businessunit.FieldPostalCode:
		return m.PostalCode()
	case businessunit.FieldTaxID:
		return m.TaxID()
	case businessunit.FieldSubscriptionPlan:
		return m.SubscriptionPlan()
	case businessunit.FieldDescription:
		return m.Description()
	case businessunit.FieldLegalName:
		return m.LegalName()
	case businessunit.FieldContactName:
		return m.ContactName()
	case businessunit.FieldContactEmail:
		return m.ContactEmail()
	case businessunit.FieldPaidUntil:
		return m.PaidUntil()
	case businessunit.FieldSettings:
		return m.Settings()
	case businessunit.FieldFreeTrial:
		return m.FreeTrial()
	case businessunit.FieldParentID:
		return m.ParentID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BusinessUnitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case businessunit.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case businessunit.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case businessunit.FieldStatus:
		return m.OldStatus(ctx)
	case businessunit.FieldName:
		return m.OldName(ctx)
	case businessunit.FieldEntityKey:
		return m.OldEntityKey(ctx)
	case businessunit.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case businessunit.FieldAddress:
		return m.OldAddress(ctx)
	case businessunit.FieldCity:
		return m.OldCity(ctx)
	case businessunit.FieldState:
		return m.OldState(ctx)
	case businessunit.FieldCountry:
		return m.OldCountry(ctx)
	case businessunit.FieldPostalCode:
		return m.OldPostalCode(ctx)
	case businessunit.FieldTaxID:
		return m.OldTaxID(ctx)
	case businessunit.FieldSubscriptionPlan:
		return m.OldSubscriptionPlan(ctx)
	case businessunit.FieldDescription:
		return m.OldDescription(ctx)
	case businessunit.FieldLegalName:
		return m.OldLegalName(ctx)
	case businessunit.FieldContactName:
		return m.OldContactName(ctx)
	case businessunit.FieldContactEmail:
		return m.OldContactEmail(ctx)
	case businessunit.FieldPaidUntil:
		return m.OldPaidUntil(ctx)
	case businessunit.FieldSettings:
		return m.OldSettings(ctx)
	case businessunit.FieldFreeTrial:
		return m.OldFreeTrial(ctx)
	case businessunit.FieldParentID:
		return m.OldParentID(ctx)
	}
	return nil, fmt.Errorf("unknown BusinessUnit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BusinessUnitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case businessunit.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case businessunit.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case businessunit.FieldStatus:
		v, ok := value.(businessunit.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case businessunit.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case businessunit.FieldEntityKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityKey(v)
		return nil
	case businessunit.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case businessunit.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case businessunit.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case businessunit.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case businessunit.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case businessunit.FieldPostalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostalCode(v)
		return nil
	case businessunit.FieldTaxID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxID(v)
		return nil
	case businessunit.FieldSubscriptionPlan:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionPlan(v)
		return nil
	case businessunit.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case businessunit.FieldLegalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLegalName(v)
		return nil
	case businessunit.FieldContactName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactName(v)
		return nil
	case businessunit.FieldContactEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactEmail(v)
		return nil
	case businessunit.FieldPaidUntil:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaidUntil(v)
		return nil
	case businessunit.FieldSettings:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettings(v)
		return nil
	case businessunit.FieldFreeTrial:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFreeTrial(v)
		return nil
	case businessunit.FieldParentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	}
	return fmt.Errorf("unknown BusinessUnit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BusinessUnitMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BusinessUnitMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BusinessUnitMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BusinessUnit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BusinessUnitMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(businessunit.FieldAddress) {
		fields = append(fields, businessunit.FieldAddress)
	}
	if m.FieldCleared(businessunit.FieldCity) {
		fields = append(fields, businessunit.FieldCity)
	}
	if m.FieldCleared(businessunit.FieldState) {
		fields = append(fields, businessunit.FieldState)
	}
	if m.FieldCleared(businessunit.FieldCountry) {
		fields = append(fields, businessunit.FieldCountry)
	}
	if m.FieldCleared(businessunit.FieldPostalCode) {
		fields = append(fields, businessunit.FieldPostalCode)
	}
	if m.FieldCleared(businessunit.FieldTaxID) {
		fields = append(fields, businessunit.FieldTaxID)
	}
	if m.FieldCleared(businessunit.FieldSubscriptionPlan) {
		fields = append(fields, businessunit.FieldSubscriptionPlan)
	}
	if m.FieldCleared(businessunit.FieldDescription) {
		fields = append(fields, businessunit.FieldDescription)
	}
	if m.FieldCleared(businessunit.FieldLegalName) {
		fields = append(fields, businessunit.FieldLegalName)
	}
	if m.FieldCleared(businessunit.FieldContactName) {
		fields = append(fields, businessunit.FieldContactName)
	}
	if m.FieldCleared(businessunit.FieldContactEmail) {
		fields = append(fields, businessunit.FieldContactEmail)
	}
	if m.FieldCleared(businessunit.FieldPaidUntil) {
		fields = append(fields, businessunit.FieldPaidUntil)
	}
	if m.FieldCleared(businessunit.FieldSettings) {
		fields = append(fields, businessunit.FieldSettings)
	}
	if m.FieldCleared(businessunit.FieldParentID) {
		fields = append(fields, businessunit.FieldParentID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BusinessUnitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BusinessUnitMutation) ClearField(name string) error {
	switch name {
	case businessunit.FieldAddress:
		m.ClearAddress()
		return nil
	case businessunit.FieldCity:
		m.ClearCity()
		return nil
	case businessunit.FieldState:
		m.ClearState()
		return nil
	case businessunit.FieldCountry:
		m.ClearCountry()
		return nil
	case businessunit.FieldPostalCode:
		m.ClearPostalCode()
		return nil
	case businessunit.FieldTaxID:
		m.ClearTaxID()
		return nil
	case businessunit.FieldSubscriptionPlan:
		m.ClearSubscriptionPlan()
		return nil
	case businessunit.FieldDescription:
		m.ClearDescription()
		return nil
	case businessunit.FieldLegalName:
		m.ClearLegalName()
		return nil
	case businessunit.FieldContactName:
		m.ClearContactName()
		return nil
	case businessunit.FieldContactEmail:
		m.ClearContactEmail()
		return nil
	case businessunit.FieldPaidUntil:
		m.ClearPaidUntil()
		return nil
	case businessunit.FieldSettings:
		m.ClearSettings()
		return nil
	case businessunit.FieldParentID:
		m.ClearParentID()
		return nil
	}
	return fmt.Errorf("unknown BusinessUnit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BusinessUnitMutation) ResetField(name string) error {
	switch name {
	case businessunit.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case businessunit.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case businessunit.FieldStatus:
		m.ResetStatus()
		return nil
	case businessunit.FieldName:
		m.ResetName()
		return nil
	case businessunit.FieldEntityKey:
		m.ResetEntityKey()
		return nil
	case businessunit.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case businessunit.FieldAddress:
		m.ResetAddress()
		return nil
	case businessunit.FieldCity:
		m.ResetCity()
		return nil
	case businessunit.FieldState:
		m.ResetState()
		return nil
	case businessunit.FieldCountry:
		m.ResetCountry()
		return nil
	case businessunit.FieldPostalCode:
		m.ResetPostalCode()
		return nil
	case businessunit.FieldTaxID:
		m.ResetTaxID()
		return nil
	case businessunit.FieldSubscriptionPlan:
		m.ResetSubscriptionPlan()
		return nil
	case businessunit.FieldDescription:
		m.ResetDescription()
		return nil
	case businessunit.FieldLegalName:
		m.ResetLegalName()
		return nil
	case businessunit.FieldContactName:
		m.ResetContactName()
		return nil
	case businessunit.FieldContactEmail:
		m.ResetContactEmail()
		return nil
	case businessunit.FieldPaidUntil:
		m.ResetPaidUntil()
		return nil
	case businessunit.FieldSettings:
		m.ResetSettings()
		return nil
	case businessunit.FieldFreeTrial:
		m.ResetFreeTrial()
		return nil
	case businessunit.FieldParentID:
		m.ResetParentID()
		return nil
	}
	return fmt.Errorf("unknown BusinessUnit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BusinessUnitMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.prev != nil {
		edges = append(edges, businessunit.EdgePrev)
	}
	if m.next != nil {
		edges = append(edges, businessunit.EdgeNext)
	}
	if m.organizations != nil {
		edges = append(edges, businessunit.EdgeOrganizations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BusinessUnitMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case businessunit.EdgePrev:
		if id := m.prev; id != nil {
			return []ent.Value{*id}
		}
	case businessunit.EdgeNext:
		if id := m.next; id != nil {
			return []ent.Value{*id}
		}
	case businessunit.EdgeOrganizations:
		ids := make([]ent.Value, 0, len(m.organizations))
		for id := range m.organizations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BusinessUnitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedorganizations != nil {
		edges = append(edges, businessunit.EdgeOrganizations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BusinessUnitMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case businessunit.EdgeOrganizations:
		ids := make([]ent.Value, 0, len(m.removedorganizations))
		for id := range m.removedorganizations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BusinessUnitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedprev {
		edges = append(edges, businessunit.EdgePrev)
	}
	if m.clearednext {
		edges = append(edges, businessunit.EdgeNext)
	}
	if m.clearedorganizations {
		edges = append(edges, businessunit.EdgeOrganizations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BusinessUnitMutation) EdgeCleared(name string) bool {
	switch name {
	case businessunit.EdgePrev:
		return m.clearedprev
	case businessunit.EdgeNext:
		return m.clearednext
	case businessunit.EdgeOrganizations:
		return m.clearedorganizations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BusinessUnitMutation) ClearEdge(name string) error {
	switch name {
	case businessunit.EdgePrev:
		m.ClearPrev()
		return nil
	case businessunit.EdgeNext:
		m.ClearNext()
		return nil
	}
	return fmt.Errorf("unknown BusinessUnit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BusinessUnitMutation) ResetEdge(name string) error {
	switch name {
	case businessunit.EdgePrev:
		m.ResetPrev()
		return nil
	case businessunit.EdgeNext:
		m.ResetNext()
		return nil
	case businessunit.EdgeOrganizations:
		m.ResetOrganizations()
		return nil
	}
	return fmt.Errorf("unknown BusinessUnit edge %s", name)
}

// DispatchControlMutation represents an operation that mutates the DispatchControl nodes in the graph.
type DispatchControlMutation struct {
	config
	op                              Op
	typ                             string
	id                              *uuid.UUID
	created_at                      *time.Time
	updated_at                      *time.Time
	record_service_incident         *dispatchcontrol.RecordServiceIncident
	deadhead_target                 *float64
	adddeadhead_target              *float64
	max_shipment_weight_limit       *int
	addmax_shipment_weight_limit    *int
	grace_period                    *uint8
	addgrace_period                 *int8
	enforce_worker_assign           *bool
	trailer_continuity              *bool
	dupe_trailer_check              *bool
	maintenance_compliance          *bool
	regulatory_check                *bool
	prev_shipment_on_hold           *bool
	worker_time_away_restriction    *bool
	tractor_worker_fleet_constraint *bool
	clearedFields                   map[string]struct{}
	organization                    *uuid.UUID
	clearedorganization             bool
	business_unit                   *uuid.UUID
	clearedbusiness_unit            bool
	done                            bool
	oldValue                        func(context.Context) (*DispatchControl, error)
	predicates                      []predicate.DispatchControl
}

var _ ent.Mutation = (*DispatchControlMutation)(nil)

// dispatchcontrolOption allows management of the mutation configuration using functional options.
type dispatchcontrolOption func(*DispatchControlMutation)

// newDispatchControlMutation creates new mutation for the DispatchControl entity.
func newDispatchControlMutation(c config, op Op, opts ...dispatchcontrolOption) *DispatchControlMutation {
	m := &DispatchControlMutation{
		config:        c,
		op:            op,
		typ:           TypeDispatchControl,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDispatchControlID sets the ID field of the mutation.
func withDispatchControlID(id uuid.UUID) dispatchcontrolOption {
	return func(m *DispatchControlMutation) {
		var (
			err   error
			once  sync.Once
			value *DispatchControl
		)
		m.oldValue = func(ctx context.Context) (*DispatchControl, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DispatchControl.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDispatchControl sets the old DispatchControl of the mutation.
func withDispatchControl(node *DispatchControl) dispatchcontrolOption {
	return func(m *DispatchControlMutation) {
		m.oldValue = func(context.Context) (*DispatchControl, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DispatchControlMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DispatchControlMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DispatchControl entities.
func (m *DispatchControlMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DispatchControlMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DispatchControlMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DispatchControl.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DispatchControlMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DispatchControlMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DispatchControl entity.
// If the DispatchControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DispatchControlMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DispatchControlMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DispatchControlMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DispatchControlMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DispatchControl entity.
// If the DispatchControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DispatchControlMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DispatchControlMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetRecordServiceIncident sets the "record_service_incident" field.
func (m *DispatchControlMutation) SetRecordServiceIncident(dsi dispatchcontrol.RecordServiceIncident) {
	m.record_service_incident = &dsi
}

// RecordServiceIncident returns the value of the "record_service_incident" field in the mutation.
func (m *DispatchControlMutation) RecordServiceIncident() (r dispatchcontrol.RecordServiceIncident, exists bool) {
	v := m.record_service_incident
	if v == nil {
		return
	}
	return *v, true
}

// OldRecordServiceIncident returns the old "record_service_incident" field's value of the DispatchControl entity.
// If the DispatchControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DispatchControlMutation) OldRecordServiceIncident(ctx context.Context) (v dispatchcontrol.RecordServiceIncident, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecordServiceIncident is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecordServiceIncident requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecordServiceIncident: %w", err)
	}
	return oldValue.RecordServiceIncident, nil
}

// ResetRecordServiceIncident resets all changes to the "record_service_incident" field.
func (m *DispatchControlMutation) ResetRecordServiceIncident() {
	m.record_service_incident = nil
}

// SetDeadheadTarget sets the "deadhead_target" field.
func (m *DispatchControlMutation) SetDeadheadTarget(f float64) {
	m.deadhead_target = &f
	m.adddeadhead_target = nil
}

// DeadheadTarget returns the value of the "deadhead_target" field in the mutation.
func (m *DispatchControlMutation) DeadheadTarget() (r float64, exists bool) {
	v := m.deadhead_target
	if v == nil {
		return
	}
	return *v, true
}

// OldDeadheadTarget returns the old "deadhead_target" field's value of the DispatchControl entity.
// If the DispatchControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DispatchControlMutation) OldDeadheadTarget(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeadheadTarget is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeadheadTarget requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeadheadTarget: %w", err)
	}
	return oldValue.DeadheadTarget, nil
}

// AddDeadheadTarget adds f to the "deadhead_target" field.
func (m *DispatchControlMutation) AddDeadheadTarget(f float64) {
	if m.adddeadhead_target != nil {
		*m.adddeadhead_target += f
	} else {
		m.adddeadhead_target = &f
	}
}

// AddedDeadheadTarget returns the value that was added to the "deadhead_target" field in this mutation.
func (m *DispatchControlMutation) AddedDeadheadTarget() (r float64, exists bool) {
	v := m.adddeadhead_target
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeadheadTarget resets all changes to the "deadhead_target" field.
func (m *DispatchControlMutation) ResetDeadheadTarget() {
	m.deadhead_target = nil
	m.adddeadhead_target = nil
}

// SetMaxShipmentWeightLimit sets the "max_shipment_weight_limit" field.
func (m *DispatchControlMutation) SetMaxShipmentWeightLimit(i int) {
	m.max_shipment_weight_limit = &i
	m.addmax_shipment_weight_limit = nil
}

// MaxShipmentWeightLimit returns the value of the "max_shipment_weight_limit" field in the mutation.
func (m *DispatchControlMutation) MaxShipmentWeightLimit() (r int, exists bool) {
	v := m.max_shipment_weight_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxShipmentWeightLimit returns the old "max_shipment_weight_limit" field's value of the DispatchControl entity.
// If the DispatchControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DispatchControlMutation) OldMaxShipmentWeightLimit(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxShipmentWeightLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxShipmentWeightLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxShipmentWeightLimit: %w", err)
	}
	return oldValue.MaxShipmentWeightLimit, nil
}

// AddMaxShipmentWeightLimit adds i to the "max_shipment_weight_limit" field.
func (m *DispatchControlMutation) AddMaxShipmentWeightLimit(i int) {
	if m.addmax_shipment_weight_limit != nil {
		*m.addmax_shipment_weight_limit += i
	} else {
		m.addmax_shipment_weight_limit = &i
	}
}

// AddedMaxShipmentWeightLimit returns the value that was added to the "max_shipment_weight_limit" field in this mutation.
func (m *DispatchControlMutation) AddedMaxShipmentWeightLimit() (r int, exists bool) {
	v := m.addmax_shipment_weight_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxShipmentWeightLimit resets all changes to the "max_shipment_weight_limit" field.
func (m *DispatchControlMutation) ResetMaxShipmentWeightLimit() {
	m.max_shipment_weight_limit = nil
	m.addmax_shipment_weight_limit = nil
}

// SetGracePeriod sets the "grace_period" field.
func (m *DispatchControlMutation) SetGracePeriod(u uint8) {
	m.grace_period = &u
	m.addgrace_period = nil
}

// GracePeriod returns the value of the "grace_period" field in the mutation.
func (m *DispatchControlMutation) GracePeriod() (r uint8, exists bool) {
	v := m.grace_period
	if v == nil {
		return
	}
	return *v, true
}

// OldGracePeriod returns the old "grace_period" field's value of the DispatchControl entity.
// If the DispatchControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DispatchControlMutation) OldGracePeriod(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGracePeriod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGracePeriod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGracePeriod: %w", err)
	}
	return oldValue.GracePeriod, nil
}

// AddGracePeriod adds u to the "grace_period" field.
func (m *DispatchControlMutation) AddGracePeriod(u int8) {
	if m.addgrace_period != nil {
		*m.addgrace_period += u
	} else {
		m.addgrace_period = &u
	}
}

// AddedGracePeriod returns the value that was added to the "grace_period" field in this mutation.
func (m *DispatchControlMutation) AddedGracePeriod() (r int8, exists bool) {
	v := m.addgrace_period
	if v == nil {
		return
	}
	return *v, true
}

// ResetGracePeriod resets all changes to the "grace_period" field.
func (m *DispatchControlMutation) ResetGracePeriod() {
	m.grace_period = nil
	m.addgrace_period = nil
}

// SetEnforceWorkerAssign sets the "enforce_worker_assign" field.
func (m *DispatchControlMutation) SetEnforceWorkerAssign(b bool) {
	m.enforce_worker_assign = &b
}

// EnforceWorkerAssign returns the value of the "enforce_worker_assign" field in the mutation.
func (m *DispatchControlMutation) EnforceWorkerAssign() (r bool, exists bool) {
	v := m.enforce_worker_assign
	if v == nil {
		return
	}
	return *v, true
}

// OldEnforceWorkerAssign returns the old "enforce_worker_assign" field's value of the DispatchControl entity.
// If the DispatchControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DispatchControlMutation) OldEnforceWorkerAssign(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnforceWorkerAssign is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnforceWorkerAssign requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnforceWorkerAssign: %w", err)
	}
	return oldValue.EnforceWorkerAssign, nil
}

// ResetEnforceWorkerAssign resets all changes to the "enforce_worker_assign" field.
func (m *DispatchControlMutation) ResetEnforceWorkerAssign() {
	m.enforce_worker_assign = nil
}

// SetTrailerContinuity sets the "trailer_continuity" field.
func (m *DispatchControlMutation) SetTrailerContinuity(b bool) {
	m.trailer_continuity = &b
}

// TrailerContinuity returns the value of the "trailer_continuity" field in the mutation.
func (m *DispatchControlMutation) TrailerContinuity() (r bool, exists bool) {
	v := m.trailer_continuity
	if v == nil {
		return
	}
	return *v, true
}

// OldTrailerContinuity returns the old "trailer_continuity" field's value of the DispatchControl entity.
// If the DispatchControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DispatchControlMutation) OldTrailerContinuity(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrailerContinuity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrailerContinuity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrailerContinuity: %w", err)
	}
	return oldValue.TrailerContinuity, nil
}

// ResetTrailerContinuity resets all changes to the "trailer_continuity" field.
func (m *DispatchControlMutation) ResetTrailerContinuity() {
	m.trailer_continuity = nil
}

// SetDupeTrailerCheck sets the "dupe_trailer_check" field.
func (m *DispatchControlMutation) SetDupeTrailerCheck(b bool) {
	m.dupe_trailer_check = &b
}

// DupeTrailerCheck returns the value of the "dupe_trailer_check" field in the mutation.
func (m *DispatchControlMutation) DupeTrailerCheck() (r bool, exists bool) {
	v := m.dupe_trailer_check
	if v == nil {
		return
	}
	return *v, true
}

// OldDupeTrailerCheck returns the old "dupe_trailer_check" field's value of the DispatchControl entity.
// If the DispatchControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DispatchControlMutation) OldDupeTrailerCheck(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDupeTrailerCheck is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDupeTrailerCheck requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDupeTrailerCheck: %w", err)
	}
	return oldValue.DupeTrailerCheck, nil
}

// ResetDupeTrailerCheck resets all changes to the "dupe_trailer_check" field.
func (m *DispatchControlMutation) ResetDupeTrailerCheck() {
	m.dupe_trailer_check = nil
}

// SetMaintenanceCompliance sets the "maintenance_compliance" field.
func (m *DispatchControlMutation) SetMaintenanceCompliance(b bool) {
	m.maintenance_compliance = &b
}

// MaintenanceCompliance returns the value of the "maintenance_compliance" field in the mutation.
func (m *DispatchControlMutation) MaintenanceCompliance() (r bool, exists bool) {
	v := m.maintenance_compliance
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintenanceCompliance returns the old "maintenance_compliance" field's value of the DispatchControl entity.
// If the DispatchControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DispatchControlMutation) OldMaintenanceCompliance(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintenanceCompliance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintenanceCompliance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintenanceCompliance: %w", err)
	}
	return oldValue.MaintenanceCompliance, nil
}

// ResetMaintenanceCompliance resets all changes to the "maintenance_compliance" field.
func (m *DispatchControlMutation) ResetMaintenanceCompliance() {
	m.maintenance_compliance = nil
}

// SetRegulatoryCheck sets the "regulatory_check" field.
func (m *DispatchControlMutation) SetRegulatoryCheck(b bool) {
	m.regulatory_check = &b
}

// RegulatoryCheck returns the value of the "regulatory_check" field in the mutation.
func (m *DispatchControlMutation) RegulatoryCheck() (r bool, exists bool) {
	v := m.regulatory_check
	if v == nil {
		return
	}
	return *v, true
}

// OldRegulatoryCheck returns the old "regulatory_check" field's value of the DispatchControl entity.
// If the DispatchControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DispatchControlMutation) OldRegulatoryCheck(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegulatoryCheck is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegulatoryCheck requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegulatoryCheck: %w", err)
	}
	return oldValue.RegulatoryCheck, nil
}

// ResetRegulatoryCheck resets all changes to the "regulatory_check" field.
func (m *DispatchControlMutation) ResetRegulatoryCheck() {
	m.regulatory_check = nil
}

// SetPrevShipmentOnHold sets the "prev_shipment_on_hold" field.
func (m *DispatchControlMutation) SetPrevShipmentOnHold(b bool) {
	m.prev_shipment_on_hold = &b
}

// PrevShipmentOnHold returns the value of the "prev_shipment_on_hold" field in the mutation.
func (m *DispatchControlMutation) PrevShipmentOnHold() (r bool, exists bool) {
	v := m.prev_shipment_on_hold
	if v == nil {
		return
	}
	return *v, true
}

// OldPrevShipmentOnHold returns the old "prev_shipment_on_hold" field's value of the DispatchControl entity.
// If the DispatchControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DispatchControlMutation) OldPrevShipmentOnHold(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrevShipmentOnHold is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrevShipmentOnHold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrevShipmentOnHold: %w", err)
	}
	return oldValue.PrevShipmentOnHold, nil
}

// ResetPrevShipmentOnHold resets all changes to the "prev_shipment_on_hold" field.
func (m *DispatchControlMutation) ResetPrevShipmentOnHold() {
	m.prev_shipment_on_hold = nil
}

// SetWorkerTimeAwayRestriction sets the "worker_time_away_restriction" field.
func (m *DispatchControlMutation) SetWorkerTimeAwayRestriction(b bool) {
	m.worker_time_away_restriction = &b
}

// WorkerTimeAwayRestriction returns the value of the "worker_time_away_restriction" field in the mutation.
func (m *DispatchControlMutation) WorkerTimeAwayRestriction() (r bool, exists bool) {
	v := m.worker_time_away_restriction
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkerTimeAwayRestriction returns the old "worker_time_away_restriction" field's value of the DispatchControl entity.
// If the DispatchControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DispatchControlMutation) OldWorkerTimeAwayRestriction(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkerTimeAwayRestriction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkerTimeAwayRestriction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkerTimeAwayRestriction: %w", err)
	}
	return oldValue.WorkerTimeAwayRestriction, nil
}

// ResetWorkerTimeAwayRestriction resets all changes to the "worker_time_away_restriction" field.
func (m *DispatchControlMutation) ResetWorkerTimeAwayRestriction() {
	m.worker_time_away_restriction = nil
}

// SetTractorWorkerFleetConstraint sets the "tractor_worker_fleet_constraint" field.
func (m *DispatchControlMutation) SetTractorWorkerFleetConstraint(b bool) {
	m.tractor_worker_fleet_constraint = &b
}

// TractorWorkerFleetConstraint returns the value of the "tractor_worker_fleet_constraint" field in the mutation.
func (m *DispatchControlMutation) TractorWorkerFleetConstraint() (r bool, exists bool) {
	v := m.tractor_worker_fleet_constraint
	if v == nil {
		return
	}
	return *v, true
}

// OldTractorWorkerFleetConstraint returns the old "tractor_worker_fleet_constraint" field's value of the DispatchControl entity.
// If the DispatchControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DispatchControlMutation) OldTractorWorkerFleetConstraint(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTractorWorkerFleetConstraint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTractorWorkerFleetConstraint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTractorWorkerFleetConstraint: %w", err)
	}
	return oldValue.TractorWorkerFleetConstraint, nil
}

// ResetTractorWorkerFleetConstraint resets all changes to the "tractor_worker_fleet_constraint" field.
func (m *DispatchControlMutation) ResetTractorWorkerFleetConstraint() {
	m.tractor_worker_fleet_constraint = nil
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *DispatchControlMutation) SetOrganizationID(id uuid.UUID) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *DispatchControlMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *DispatchControlMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *DispatchControlMutation) OrganizationID() (id uuid.UUID, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *DispatchControlMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *DispatchControlMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// SetBusinessUnitID sets the "business_unit" edge to the BusinessUnit entity by id.
func (m *DispatchControlMutation) SetBusinessUnitID(id uuid.UUID) {
	m.business_unit = &id
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *DispatchControlMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *DispatchControlMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitID returns the "business_unit" edge ID in the mutation.
func (m *DispatchControlMutation) BusinessUnitID() (id uuid.UUID, exists bool) {
	if m.business_unit != nil {
		return *m.business_unit, true
	}
	return
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *DispatchControlMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *DispatchControlMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// Where appends a list predicates to the DispatchControlMutation builder.
func (m *DispatchControlMutation) Where(ps ...predicate.DispatchControl) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DispatchControlMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DispatchControlMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DispatchControl, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DispatchControlMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DispatchControlMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DispatchControl).
func (m *DispatchControlMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DispatchControlMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, dispatchcontrol.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dispatchcontrol.FieldUpdatedAt)
	}
	if m.record_service_incident != nil {
		fields = append(fields, dispatchcontrol.FieldRecordServiceIncident)
	}
	if m.deadhead_target != nil {
		fields = append(fields, dispatchcontrol.FieldDeadheadTarget)
	}
	if m.max_shipment_weight_limit != nil {
		fields = append(fields, dispatchcontrol.FieldMaxShipmentWeightLimit)
	}
	if m.grace_period != nil {
		fields = append(fields, dispatchcontrol.FieldGracePeriod)
	}
	if m.enforce_worker_assign != nil {
		fields = append(fields, dispatchcontrol.FieldEnforceWorkerAssign)
	}
	if m.trailer_continuity != nil {
		fields = append(fields, dispatchcontrol.FieldTrailerContinuity)
	}
	if m.dupe_trailer_check != nil {
		fields = append(fields, dispatchcontrol.FieldDupeTrailerCheck)
	}
	if m.maintenance_compliance != nil {
		fields = append(fields, dispatchcontrol.FieldMaintenanceCompliance)
	}
	if m.regulatory_check != nil {
		fields = append(fields, dispatchcontrol.FieldRegulatoryCheck)
	}
	if m.prev_shipment_on_hold != nil {
		fields = append(fields, dispatchcontrol.FieldPrevShipmentOnHold)
	}
	if m.worker_time_away_restriction != nil {
		fields = append(fields, dispatchcontrol.FieldWorkerTimeAwayRestriction)
	}
	if m.tractor_worker_fleet_constraint != nil {
		fields = append(fields, dispatchcontrol.FieldTractorWorkerFleetConstraint)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DispatchControlMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dispatchcontrol.FieldCreatedAt:
		return m.CreatedAt()
	case dispatchcontrol.FieldUpdatedAt:
		return m.UpdatedAt()
	case dispatchcontrol.FieldRecordServiceIncident:
		return m.RecordServiceIncident()
	case dispatchcontrol.FieldDeadheadTarget:
		return m.DeadheadTarget()
	case dispatchcontrol.FieldMaxShipmentWeightLimit:
		return m.MaxShipmentWeightLimit()
	case dispatchcontrol.FieldGracePeriod:
		return m.GracePeriod()
	case dispatchcontrol.FieldEnforceWorkerAssign:
		return m.EnforceWorkerAssign()
	case dispatchcontrol.FieldTrailerContinuity:
		return m.TrailerContinuity()
	case dispatchcontrol.FieldDupeTrailerCheck:
		return m.DupeTrailerCheck()
	case dispatchcontrol.FieldMaintenanceCompliance:
		return m.MaintenanceCompliance()
	case dispatchcontrol.FieldRegulatoryCheck:
		return m.RegulatoryCheck()
	case dispatchcontrol.FieldPrevShipmentOnHold:
		return m.PrevShipmentOnHold()
	case dispatchcontrol.FieldWorkerTimeAwayRestriction:
		return m.WorkerTimeAwayRestriction()
	case dispatchcontrol.FieldTractorWorkerFleetConstraint:
		return m.TractorWorkerFleetConstraint()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DispatchControlMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dispatchcontrol.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dispatchcontrol.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dispatchcontrol.FieldRecordServiceIncident:
		return m.OldRecordServiceIncident(ctx)
	case dispatchcontrol.FieldDeadheadTarget:
		return m.OldDeadheadTarget(ctx)
	case dispatchcontrol.FieldMaxShipmentWeightLimit:
		return m.OldMaxShipmentWeightLimit(ctx)
	case dispatchcontrol.FieldGracePeriod:
		return m.OldGracePeriod(ctx)
	case dispatchcontrol.FieldEnforceWorkerAssign:
		return m.OldEnforceWorkerAssign(ctx)
	case dispatchcontrol.FieldTrailerContinuity:
		return m.OldTrailerContinuity(ctx)
	case dispatchcontrol.FieldDupeTrailerCheck:
		return m.OldDupeTrailerCheck(ctx)
	case dispatchcontrol.FieldMaintenanceCompliance:
		return m.OldMaintenanceCompliance(ctx)
	case dispatchcontrol.FieldRegulatoryCheck:
		return m.OldRegulatoryCheck(ctx)
	case dispatchcontrol.FieldPrevShipmentOnHold:
		return m.OldPrevShipmentOnHold(ctx)
	case dispatchcontrol.FieldWorkerTimeAwayRestriction:
		return m.OldWorkerTimeAwayRestriction(ctx)
	case dispatchcontrol.FieldTractorWorkerFleetConstraint:
		return m.OldTractorWorkerFleetConstraint(ctx)
	}
	return nil, fmt.Errorf("unknown DispatchControl field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DispatchControlMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dispatchcontrol.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dispatchcontrol.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dispatchcontrol.FieldRecordServiceIncident:
		v, ok := value.(dispatchcontrol.RecordServiceIncident)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecordServiceIncident(v)
		return nil
	case dispatchcontrol.FieldDeadheadTarget:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeadheadTarget(v)
		return nil
	case dispatchcontrol.FieldMaxShipmentWeightLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxShipmentWeightLimit(v)
		return nil
	case dispatchcontrol.FieldGracePeriod:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGracePeriod(v)
		return nil
	case dispatchcontrol.FieldEnforceWorkerAssign:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnforceWorkerAssign(v)
		return nil
	case dispatchcontrol.FieldTrailerContinuity:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrailerContinuity(v)
		return nil
	case dispatchcontrol.FieldDupeTrailerCheck:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDupeTrailerCheck(v)
		return nil
	case dispatchcontrol.FieldMaintenanceCompliance:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintenanceCompliance(v)
		return nil
	case dispatchcontrol.FieldRegulatoryCheck:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegulatoryCheck(v)
		return nil
	case dispatchcontrol.FieldPrevShipmentOnHold:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrevShipmentOnHold(v)
		return nil
	case dispatchcontrol.FieldWorkerTimeAwayRestriction:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkerTimeAwayRestriction(v)
		return nil
	case dispatchcontrol.FieldTractorWorkerFleetConstraint:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTractorWorkerFleetConstraint(v)
		return nil
	}
	return fmt.Errorf("unknown DispatchControl field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DispatchControlMutation) AddedFields() []string {
	var fields []string
	if m.adddeadhead_target != nil {
		fields = append(fields, dispatchcontrol.FieldDeadheadTarget)
	}
	if m.addmax_shipment_weight_limit != nil {
		fields = append(fields, dispatchcontrol.FieldMaxShipmentWeightLimit)
	}
	if m.addgrace_period != nil {
		fields = append(fields, dispatchcontrol.FieldGracePeriod)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DispatchControlMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dispatchcontrol.FieldDeadheadTarget:
		return m.AddedDeadheadTarget()
	case dispatchcontrol.FieldMaxShipmentWeightLimit:
		return m.AddedMaxShipmentWeightLimit()
	case dispatchcontrol.FieldGracePeriod:
		return m.AddedGracePeriod()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DispatchControlMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dispatchcontrol.FieldDeadheadTarget:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeadheadTarget(v)
		return nil
	case dispatchcontrol.FieldMaxShipmentWeightLimit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxShipmentWeightLimit(v)
		return nil
	case dispatchcontrol.FieldGracePeriod:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGracePeriod(v)
		return nil
	}
	return fmt.Errorf("unknown DispatchControl numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DispatchControlMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DispatchControlMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DispatchControlMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DispatchControl nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DispatchControlMutation) ResetField(name string) error {
	switch name {
	case dispatchcontrol.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dispatchcontrol.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dispatchcontrol.FieldRecordServiceIncident:
		m.ResetRecordServiceIncident()
		return nil
	case dispatchcontrol.FieldDeadheadTarget:
		m.ResetDeadheadTarget()
		return nil
	case dispatchcontrol.FieldMaxShipmentWeightLimit:
		m.ResetMaxShipmentWeightLimit()
		return nil
	case dispatchcontrol.FieldGracePeriod:
		m.ResetGracePeriod()
		return nil
	case dispatchcontrol.FieldEnforceWorkerAssign:
		m.ResetEnforceWorkerAssign()
		return nil
	case dispatchcontrol.FieldTrailerContinuity:
		m.ResetTrailerContinuity()
		return nil
	case dispatchcontrol.FieldDupeTrailerCheck:
		m.ResetDupeTrailerCheck()
		return nil
	case dispatchcontrol.FieldMaintenanceCompliance:
		m.ResetMaintenanceCompliance()
		return nil
	case dispatchcontrol.FieldRegulatoryCheck:
		m.ResetRegulatoryCheck()
		return nil
	case dispatchcontrol.FieldPrevShipmentOnHold:
		m.ResetPrevShipmentOnHold()
		return nil
	case dispatchcontrol.FieldWorkerTimeAwayRestriction:
		m.ResetWorkerTimeAwayRestriction()
		return nil
	case dispatchcontrol.FieldTractorWorkerFleetConstraint:
		m.ResetTractorWorkerFleetConstraint()
		return nil
	}
	return fmt.Errorf("unknown DispatchControl field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DispatchControlMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.organization != nil {
		edges = append(edges, dispatchcontrol.EdgeOrganization)
	}
	if m.business_unit != nil {
		edges = append(edges, dispatchcontrol.EdgeBusinessUnit)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DispatchControlMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dispatchcontrol.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case dispatchcontrol.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DispatchControlMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DispatchControlMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DispatchControlMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorganization {
		edges = append(edges, dispatchcontrol.EdgeOrganization)
	}
	if m.clearedbusiness_unit {
		edges = append(edges, dispatchcontrol.EdgeBusinessUnit)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DispatchControlMutation) EdgeCleared(name string) bool {
	switch name {
	case dispatchcontrol.EdgeOrganization:
		return m.clearedorganization
	case dispatchcontrol.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DispatchControlMutation) ClearEdge(name string) error {
	switch name {
	case dispatchcontrol.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case dispatchcontrol.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	}
	return fmt.Errorf("unknown DispatchControl unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DispatchControlMutation) ResetEdge(name string) error {
	switch name {
	case dispatchcontrol.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case dispatchcontrol.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	}
	return fmt.Errorf("unknown DispatchControl edge %s", name)
}

// FeasibilityToolControlMutation represents an operation that mutates the FeasibilityToolControl nodes in the graph.
type FeasibilityToolControlMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	otp_operator         *feasibilitytoolcontrol.OtpOperator
	otp_value            *float64
	addotp_value         *float64
	mpw_operator         *feasibilitytoolcontrol.MpwOperator
	mpw_value            *float64
	addmpw_value         *float64
	mpd_operator         *feasibilitytoolcontrol.MpdOperator
	mpd_value            *float64
	addmpd_value         *float64
	mpg_operator         *feasibilitytoolcontrol.MpgOperator
	mpg_value            *float64
	addmpg_value         *float64
	clearedFields        map[string]struct{}
	organization         *uuid.UUID
	clearedorganization  bool
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	done                 bool
	oldValue             func(context.Context) (*FeasibilityToolControl, error)
	predicates           []predicate.FeasibilityToolControl
}

var _ ent.Mutation = (*FeasibilityToolControlMutation)(nil)

// feasibilitytoolcontrolOption allows management of the mutation configuration using functional options.
type feasibilitytoolcontrolOption func(*FeasibilityToolControlMutation)

// newFeasibilityToolControlMutation creates new mutation for the FeasibilityToolControl entity.
func newFeasibilityToolControlMutation(c config, op Op, opts ...feasibilitytoolcontrolOption) *FeasibilityToolControlMutation {
	m := &FeasibilityToolControlMutation{
		config:        c,
		op:            op,
		typ:           TypeFeasibilityToolControl,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeasibilityToolControlID sets the ID field of the mutation.
func withFeasibilityToolControlID(id uuid.UUID) feasibilitytoolcontrolOption {
	return func(m *FeasibilityToolControlMutation) {
		var (
			err   error
			once  sync.Once
			value *FeasibilityToolControl
		)
		m.oldValue = func(ctx context.Context) (*FeasibilityToolControl, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FeasibilityToolControl.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeasibilityToolControl sets the old FeasibilityToolControl of the mutation.
func withFeasibilityToolControl(node *FeasibilityToolControl) feasibilitytoolcontrolOption {
	return func(m *FeasibilityToolControlMutation) {
		m.oldValue = func(context.Context) (*FeasibilityToolControl, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeasibilityToolControlMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeasibilityToolControlMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FeasibilityToolControl entities.
func (m *FeasibilityToolControlMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeasibilityToolControlMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeasibilityToolControlMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FeasibilityToolControl.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FeasibilityToolControlMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FeasibilityToolControlMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FeasibilityToolControl entity.
// If the FeasibilityToolControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeasibilityToolControlMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FeasibilityToolControlMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FeasibilityToolControlMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FeasibilityToolControlMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FeasibilityToolControl entity.
// If the FeasibilityToolControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeasibilityToolControlMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FeasibilityToolControlMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOtpOperator sets the "otp_operator" field.
func (m *FeasibilityToolControlMutation) SetOtpOperator(fo feasibilitytoolcontrol.OtpOperator) {
	m.otp_operator = &fo
}

// OtpOperator returns the value of the "otp_operator" field in the mutation.
func (m *FeasibilityToolControlMutation) OtpOperator() (r feasibilitytoolcontrol.OtpOperator, exists bool) {
	v := m.otp_operator
	if v == nil {
		return
	}
	return *v, true
}

// OldOtpOperator returns the old "otp_operator" field's value of the FeasibilityToolControl entity.
// If the FeasibilityToolControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeasibilityToolControlMutation) OldOtpOperator(ctx context.Context) (v feasibilitytoolcontrol.OtpOperator, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtpOperator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtpOperator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtpOperator: %w", err)
	}
	return oldValue.OtpOperator, nil
}

// ResetOtpOperator resets all changes to the "otp_operator" field.
func (m *FeasibilityToolControlMutation) ResetOtpOperator() {
	m.otp_operator = nil
}

// SetOtpValue sets the "otp_value" field.
func (m *FeasibilityToolControlMutation) SetOtpValue(f float64) {
	m.otp_value = &f
	m.addotp_value = nil
}

// OtpValue returns the value of the "otp_value" field in the mutation.
func (m *FeasibilityToolControlMutation) OtpValue() (r float64, exists bool) {
	v := m.otp_value
	if v == nil {
		return
	}
	return *v, true
}

// OldOtpValue returns the old "otp_value" field's value of the FeasibilityToolControl entity.
// If the FeasibilityToolControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeasibilityToolControlMutation) OldOtpValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtpValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtpValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtpValue: %w", err)
	}
	return oldValue.OtpValue, nil
}

// AddOtpValue adds f to the "otp_value" field.
func (m *FeasibilityToolControlMutation) AddOtpValue(f float64) {
	if m.addotp_value != nil {
		*m.addotp_value += f
	} else {
		m.addotp_value = &f
	}
}

// AddedOtpValue returns the value that was added to the "otp_value" field in this mutation.
func (m *FeasibilityToolControlMutation) AddedOtpValue() (r float64, exists bool) {
	v := m.addotp_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetOtpValue resets all changes to the "otp_value" field.
func (m *FeasibilityToolControlMutation) ResetOtpValue() {
	m.otp_value = nil
	m.addotp_value = nil
}

// SetMpwOperator sets the "mpw_operator" field.
func (m *FeasibilityToolControlMutation) SetMpwOperator(fo feasibilitytoolcontrol.MpwOperator) {
	m.mpw_operator = &fo
}

// MpwOperator returns the value of the "mpw_operator" field in the mutation.
func (m *FeasibilityToolControlMutation) MpwOperator() (r feasibilitytoolcontrol.MpwOperator, exists bool) {
	v := m.mpw_operator
	if v == nil {
		return
	}
	return *v, true
}

// OldMpwOperator returns the old "mpw_operator" field's value of the FeasibilityToolControl entity.
// If the FeasibilityToolControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeasibilityToolControlMutation) OldMpwOperator(ctx context.Context) (v feasibilitytoolcontrol.MpwOperator, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMpwOperator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMpwOperator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMpwOperator: %w", err)
	}
	return oldValue.MpwOperator, nil
}

// ResetMpwOperator resets all changes to the "mpw_operator" field.
func (m *FeasibilityToolControlMutation) ResetMpwOperator() {
	m.mpw_operator = nil
}

// SetMpwValue sets the "mpw_value" field.
func (m *FeasibilityToolControlMutation) SetMpwValue(f float64) {
	m.mpw_value = &f
	m.addmpw_value = nil
}

// MpwValue returns the value of the "mpw_value" field in the mutation.
func (m *FeasibilityToolControlMutation) MpwValue() (r float64, exists bool) {
	v := m.mpw_value
	if v == nil {
		return
	}
	return *v, true
}

// OldMpwValue returns the old "mpw_value" field's value of the FeasibilityToolControl entity.
// If the FeasibilityToolControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeasibilityToolControlMutation) OldMpwValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMpwValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMpwValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMpwValue: %w", err)
	}
	return oldValue.MpwValue, nil
}

// AddMpwValue adds f to the "mpw_value" field.
func (m *FeasibilityToolControlMutation) AddMpwValue(f float64) {
	if m.addmpw_value != nil {
		*m.addmpw_value += f
	} else {
		m.addmpw_value = &f
	}
}

// AddedMpwValue returns the value that was added to the "mpw_value" field in this mutation.
func (m *FeasibilityToolControlMutation) AddedMpwValue() (r float64, exists bool) {
	v := m.addmpw_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetMpwValue resets all changes to the "mpw_value" field.
func (m *FeasibilityToolControlMutation) ResetMpwValue() {
	m.mpw_value = nil
	m.addmpw_value = nil
}

// SetMpdOperator sets the "mpd_operator" field.
func (m *FeasibilityToolControlMutation) SetMpdOperator(fo feasibilitytoolcontrol.MpdOperator) {
	m.mpd_operator = &fo
}

// MpdOperator returns the value of the "mpd_operator" field in the mutation.
func (m *FeasibilityToolControlMutation) MpdOperator() (r feasibilitytoolcontrol.MpdOperator, exists bool) {
	v := m.mpd_operator
	if v == nil {
		return
	}
	return *v, true
}

// OldMpdOperator returns the old "mpd_operator" field's value of the FeasibilityToolControl entity.
// If the FeasibilityToolControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeasibilityToolControlMutation) OldMpdOperator(ctx context.Context) (v feasibilitytoolcontrol.MpdOperator, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMpdOperator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMpdOperator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMpdOperator: %w", err)
	}
	return oldValue.MpdOperator, nil
}

// ResetMpdOperator resets all changes to the "mpd_operator" field.
func (m *FeasibilityToolControlMutation) ResetMpdOperator() {
	m.mpd_operator = nil
}

// SetMpdValue sets the "mpd_value" field.
func (m *FeasibilityToolControlMutation) SetMpdValue(f float64) {
	m.mpd_value = &f
	m.addmpd_value = nil
}

// MpdValue returns the value of the "mpd_value" field in the mutation.
func (m *FeasibilityToolControlMutation) MpdValue() (r float64, exists bool) {
	v := m.mpd_value
	if v == nil {
		return
	}
	return *v, true
}

// OldMpdValue returns the old "mpd_value" field's value of the FeasibilityToolControl entity.
// If the FeasibilityToolControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeasibilityToolControlMutation) OldMpdValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMpdValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMpdValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMpdValue: %w", err)
	}
	return oldValue.MpdValue, nil
}

// AddMpdValue adds f to the "mpd_value" field.
func (m *FeasibilityToolControlMutation) AddMpdValue(f float64) {
	if m.addmpd_value != nil {
		*m.addmpd_value += f
	} else {
		m.addmpd_value = &f
	}
}

// AddedMpdValue returns the value that was added to the "mpd_value" field in this mutation.
func (m *FeasibilityToolControlMutation) AddedMpdValue() (r float64, exists bool) {
	v := m.addmpd_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetMpdValue resets all changes to the "mpd_value" field.
func (m *FeasibilityToolControlMutation) ResetMpdValue() {
	m.mpd_value = nil
	m.addmpd_value = nil
}

// SetMpgOperator sets the "mpg_operator" field.
func (m *FeasibilityToolControlMutation) SetMpgOperator(fo feasibilitytoolcontrol.MpgOperator) {
	m.mpg_operator = &fo
}

// MpgOperator returns the value of the "mpg_operator" field in the mutation.
func (m *FeasibilityToolControlMutation) MpgOperator() (r feasibilitytoolcontrol.MpgOperator, exists bool) {
	v := m.mpg_operator
	if v == nil {
		return
	}
	return *v, true
}

// OldMpgOperator returns the old "mpg_operator" field's value of the FeasibilityToolControl entity.
// If the FeasibilityToolControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeasibilityToolControlMutation) OldMpgOperator(ctx context.Context) (v feasibilitytoolcontrol.MpgOperator, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMpgOperator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMpgOperator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMpgOperator: %w", err)
	}
	return oldValue.MpgOperator, nil
}

// ResetMpgOperator resets all changes to the "mpg_operator" field.
func (m *FeasibilityToolControlMutation) ResetMpgOperator() {
	m.mpg_operator = nil
}

// SetMpgValue sets the "mpg_value" field.
func (m *FeasibilityToolControlMutation) SetMpgValue(f float64) {
	m.mpg_value = &f
	m.addmpg_value = nil
}

// MpgValue returns the value of the "mpg_value" field in the mutation.
func (m *FeasibilityToolControlMutation) MpgValue() (r float64, exists bool) {
	v := m.mpg_value
	if v == nil {
		return
	}
	return *v, true
}

// OldMpgValue returns the old "mpg_value" field's value of the FeasibilityToolControl entity.
// If the FeasibilityToolControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeasibilityToolControlMutation) OldMpgValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMpgValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMpgValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMpgValue: %w", err)
	}
	return oldValue.MpgValue, nil
}

// AddMpgValue adds f to the "mpg_value" field.
func (m *FeasibilityToolControlMutation) AddMpgValue(f float64) {
	if m.addmpg_value != nil {
		*m.addmpg_value += f
	} else {
		m.addmpg_value = &f
	}
}

// AddedMpgValue returns the value that was added to the "mpg_value" field in this mutation.
func (m *FeasibilityToolControlMutation) AddedMpgValue() (r float64, exists bool) {
	v := m.addmpg_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetMpgValue resets all changes to the "mpg_value" field.
func (m *FeasibilityToolControlMutation) ResetMpgValue() {
	m.mpg_value = nil
	m.addmpg_value = nil
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *FeasibilityToolControlMutation) SetOrganizationID(id uuid.UUID) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *FeasibilityToolControlMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *FeasibilityToolControlMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *FeasibilityToolControlMutation) OrganizationID() (id uuid.UUID, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *FeasibilityToolControlMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *FeasibilityToolControlMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// SetBusinessUnitID sets the "business_unit" edge to the BusinessUnit entity by id.
func (m *FeasibilityToolControlMutation) SetBusinessUnitID(id uuid.UUID) {
	m.business_unit = &id
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *FeasibilityToolControlMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *FeasibilityToolControlMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitID returns the "business_unit" edge ID in the mutation.
func (m *FeasibilityToolControlMutation) BusinessUnitID() (id uuid.UUID, exists bool) {
	if m.business_unit != nil {
		return *m.business_unit, true
	}
	return
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *FeasibilityToolControlMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *FeasibilityToolControlMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// Where appends a list predicates to the FeasibilityToolControlMutation builder.
func (m *FeasibilityToolControlMutation) Where(ps ...predicate.FeasibilityToolControl) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeasibilityToolControlMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeasibilityToolControlMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FeasibilityToolControl, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeasibilityToolControlMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeasibilityToolControlMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FeasibilityToolControl).
func (m *FeasibilityToolControlMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeasibilityToolControlMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, feasibilitytoolcontrol.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, feasibilitytoolcontrol.FieldUpdatedAt)
	}
	if m.otp_operator != nil {
		fields = append(fields, feasibilitytoolcontrol.FieldOtpOperator)
	}
	if m.otp_value != nil {
		fields = append(fields, feasibilitytoolcontrol.FieldOtpValue)
	}
	if m.mpw_operator != nil {
		fields = append(fields, feasibilitytoolcontrol.FieldMpwOperator)
	}
	if m.mpw_value != nil {
		fields = append(fields, feasibilitytoolcontrol.FieldMpwValue)
	}
	if m.mpd_operator != nil {
		fields = append(fields, feasibilitytoolcontrol.FieldMpdOperator)
	}
	if m.mpd_value != nil {
		fields = append(fields, feasibilitytoolcontrol.FieldMpdValue)
	}
	if m.mpg_operator != nil {
		fields = append(fields, feasibilitytoolcontrol.FieldMpgOperator)
	}
	if m.mpg_value != nil {
		fields = append(fields, feasibilitytoolcontrol.FieldMpgValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeasibilityToolControlMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case feasibilitytoolcontrol.FieldCreatedAt:
		return m.CreatedAt()
	case feasibilitytoolcontrol.FieldUpdatedAt:
		return m.UpdatedAt()
	case feasibilitytoolcontrol.FieldOtpOperator:
		return m.OtpOperator()
	case feasibilitytoolcontrol.FieldOtpValue:
		return m.OtpValue()
	case feasibilitytoolcontrol.FieldMpwOperator:
		return m.MpwOperator()
	case feasibilitytoolcontrol.FieldMpwValue:
		return m.MpwValue()
	case feasibilitytoolcontrol.FieldMpdOperator:
		return m.MpdOperator()
	case feasibilitytoolcontrol.FieldMpdValue:
		return m.MpdValue()
	case feasibilitytoolcontrol.FieldMpgOperator:
		return m.MpgOperator()
	case feasibilitytoolcontrol.FieldMpgValue:
		return m.MpgValue()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeasibilityToolControlMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case feasibilitytoolcontrol.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case feasibilitytoolcontrol.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case feasibilitytoolcontrol.FieldOtpOperator:
		return m.OldOtpOperator(ctx)
	case feasibilitytoolcontrol.FieldOtpValue:
		return m.OldOtpValue(ctx)
	case feasibilitytoolcontrol.FieldMpwOperator:
		return m.OldMpwOperator(ctx)
	case feasibilitytoolcontrol.FieldMpwValue:
		return m.OldMpwValue(ctx)
	case feasibilitytoolcontrol.FieldMpdOperator:
		return m.OldMpdOperator(ctx)
	case feasibilitytoolcontrol.FieldMpdValue:
		return m.OldMpdValue(ctx)
	case feasibilitytoolcontrol.FieldMpgOperator:
		return m.OldMpgOperator(ctx)
	case feasibilitytoolcontrol.FieldMpgValue:
		return m.OldMpgValue(ctx)
	}
	return nil, fmt.Errorf("unknown FeasibilityToolControl field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeasibilityToolControlMutation) SetField(name string, value ent.Value) error {
	switch name {
	case feasibilitytoolcontrol.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case feasibilitytoolcontrol.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case feasibilitytoolcontrol.FieldOtpOperator:
		v, ok := value.(feasibilitytoolcontrol.OtpOperator)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtpOperator(v)
		return nil
	case feasibilitytoolcontrol.FieldOtpValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtpValue(v)
		return nil
	case feasibilitytoolcontrol.FieldMpwOperator:
		v, ok := value.(feasibilitytoolcontrol.MpwOperator)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMpwOperator(v)
		return nil
	case feasibilitytoolcontrol.FieldMpwValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMpwValue(v)
		return nil
	case feasibilitytoolcontrol.FieldMpdOperator:
		v, ok := value.(feasibilitytoolcontrol.MpdOperator)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMpdOperator(v)
		return nil
	case feasibilitytoolcontrol.FieldMpdValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMpdValue(v)
		return nil
	case feasibilitytoolcontrol.FieldMpgOperator:
		v, ok := value.(feasibilitytoolcontrol.MpgOperator)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMpgOperator(v)
		return nil
	case feasibilitytoolcontrol.FieldMpgValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMpgValue(v)
		return nil
	}
	return fmt.Errorf("unknown FeasibilityToolControl field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeasibilityToolControlMutation) AddedFields() []string {
	var fields []string
	if m.addotp_value != nil {
		fields = append(fields, feasibilitytoolcontrol.FieldOtpValue)
	}
	if m.addmpw_value != nil {
		fields = append(fields, feasibilitytoolcontrol.FieldMpwValue)
	}
	if m.addmpd_value != nil {
		fields = append(fields, feasibilitytoolcontrol.FieldMpdValue)
	}
	if m.addmpg_value != nil {
		fields = append(fields, feasibilitytoolcontrol.FieldMpgValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeasibilityToolControlMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case feasibilitytoolcontrol.FieldOtpValue:
		return m.AddedOtpValue()
	case feasibilitytoolcontrol.FieldMpwValue:
		return m.AddedMpwValue()
	case feasibilitytoolcontrol.FieldMpdValue:
		return m.AddedMpdValue()
	case feasibilitytoolcontrol.FieldMpgValue:
		return m.AddedMpgValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeasibilityToolControlMutation) AddField(name string, value ent.Value) error {
	switch name {
	case feasibilitytoolcontrol.FieldOtpValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOtpValue(v)
		return nil
	case feasibilitytoolcontrol.FieldMpwValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMpwValue(v)
		return nil
	case feasibilitytoolcontrol.FieldMpdValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMpdValue(v)
		return nil
	case feasibilitytoolcontrol.FieldMpgValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMpgValue(v)
		return nil
	}
	return fmt.Errorf("unknown FeasibilityToolControl numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeasibilityToolControlMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeasibilityToolControlMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeasibilityToolControlMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FeasibilityToolControl nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeasibilityToolControlMutation) ResetField(name string) error {
	switch name {
	case feasibilitytoolcontrol.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case feasibilitytoolcontrol.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case feasibilitytoolcontrol.FieldOtpOperator:
		m.ResetOtpOperator()
		return nil
	case feasibilitytoolcontrol.FieldOtpValue:
		m.ResetOtpValue()
		return nil
	case feasibilitytoolcontrol.FieldMpwOperator:
		m.ResetMpwOperator()
		return nil
	case feasibilitytoolcontrol.FieldMpwValue:
		m.ResetMpwValue()
		return nil
	case feasibilitytoolcontrol.FieldMpdOperator:
		m.ResetMpdOperator()
		return nil
	case feasibilitytoolcontrol.FieldMpdValue:
		m.ResetMpdValue()
		return nil
	case feasibilitytoolcontrol.FieldMpgOperator:
		m.ResetMpgOperator()
		return nil
	case feasibilitytoolcontrol.FieldMpgValue:
		m.ResetMpgValue()
		return nil
	}
	return fmt.Errorf("unknown FeasibilityToolControl field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeasibilityToolControlMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.organization != nil {
		edges = append(edges, feasibilitytoolcontrol.EdgeOrganization)
	}
	if m.business_unit != nil {
		edges = append(edges, feasibilitytoolcontrol.EdgeBusinessUnit)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeasibilityToolControlMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case feasibilitytoolcontrol.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case feasibilitytoolcontrol.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeasibilityToolControlMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeasibilityToolControlMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeasibilityToolControlMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorganization {
		edges = append(edges, feasibilitytoolcontrol.EdgeOrganization)
	}
	if m.clearedbusiness_unit {
		edges = append(edges, feasibilitytoolcontrol.EdgeBusinessUnit)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeasibilityToolControlMutation) EdgeCleared(name string) bool {
	switch name {
	case feasibilitytoolcontrol.EdgeOrganization:
		return m.clearedorganization
	case feasibilitytoolcontrol.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeasibilityToolControlMutation) ClearEdge(name string) error {
	switch name {
	case feasibilitytoolcontrol.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case feasibilitytoolcontrol.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	}
	return fmt.Errorf("unknown FeasibilityToolControl unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeasibilityToolControlMutation) ResetEdge(name string) error {
	switch name {
	case feasibilitytoolcontrol.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case feasibilitytoolcontrol.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	}
	return fmt.Errorf("unknown FeasibilityToolControl edge %s", name)
}

// GeneralLedgerAccountMutation represents an operation that mutates the GeneralLedgerAccount nodes in the graph.
type GeneralLedgerAccountMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	status               *generalledgeraccount.Status
	account_number       *string
	account_type         *generalledgeraccount.AccountType
	cash_flow_type       *generalledgeraccount.CashFlowType
	account_sub_type     *generalledgeraccount.AccountSubType
	account_class        *generalledgeraccount.AccountClass
	balance              *float64
	addbalance           *float64
	interest_rate        *float64
	addinterest_rate     *float64
	date_opened          *time.Time
	date_closed          *time.Time
	notes                *string
	is_tax_relevant      *bool
	is_reconciled        *bool
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	tags                 map[uuid.UUID]struct{}
	removedtags          map[uuid.UUID]struct{}
	clearedtags          bool
	done                 bool
	oldValue             func(context.Context) (*GeneralLedgerAccount, error)
	predicates           []predicate.GeneralLedgerAccount
}

var _ ent.Mutation = (*GeneralLedgerAccountMutation)(nil)

// generalledgeraccountOption allows management of the mutation configuration using functional options.
type generalledgeraccountOption func(*GeneralLedgerAccountMutation)

// newGeneralLedgerAccountMutation creates new mutation for the GeneralLedgerAccount entity.
func newGeneralLedgerAccountMutation(c config, op Op, opts ...generalledgeraccountOption) *GeneralLedgerAccountMutation {
	m := &GeneralLedgerAccountMutation{
		config:        c,
		op:            op,
		typ:           TypeGeneralLedgerAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGeneralLedgerAccountID sets the ID field of the mutation.
func withGeneralLedgerAccountID(id uuid.UUID) generalledgeraccountOption {
	return func(m *GeneralLedgerAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *GeneralLedgerAccount
		)
		m.oldValue = func(ctx context.Context) (*GeneralLedgerAccount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GeneralLedgerAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGeneralLedgerAccount sets the old GeneralLedgerAccount of the mutation.
func withGeneralLedgerAccount(node *GeneralLedgerAccount) generalledgeraccountOption {
	return func(m *GeneralLedgerAccountMutation) {
		m.oldValue = func(context.Context) (*GeneralLedgerAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GeneralLedgerAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GeneralLedgerAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GeneralLedgerAccount entities.
func (m *GeneralLedgerAccountMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GeneralLedgerAccountMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GeneralLedgerAccountMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GeneralLedgerAccount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *GeneralLedgerAccountMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *GeneralLedgerAccountMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *GeneralLedgerAccountMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *GeneralLedgerAccountMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *GeneralLedgerAccountMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *GeneralLedgerAccountMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GeneralLedgerAccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GeneralLedgerAccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GeneralLedgerAccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GeneralLedgerAccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GeneralLedgerAccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GeneralLedgerAccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *GeneralLedgerAccountMutation) SetStatus(ge generalledgeraccount.Status) {
	m.status = &ge
}

// Status returns the value of the "status" field in the mutation.
func (m *GeneralLedgerAccountMutation) Status() (r generalledgeraccount.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldStatus(ctx context.Context) (v generalledgeraccount.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *GeneralLedgerAccountMutation) ResetStatus() {
	m.status = nil
}

// SetAccountNumber sets the "account_number" field.
func (m *GeneralLedgerAccountMutation) SetAccountNumber(s string) {
	m.account_number = &s
}

// AccountNumber returns the value of the "account_number" field in the mutation.
func (m *GeneralLedgerAccountMutation) AccountNumber() (r string, exists bool) {
	v := m.account_number
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountNumber returns the old "account_number" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldAccountNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountNumber: %w", err)
	}
	return oldValue.AccountNumber, nil
}

// ResetAccountNumber resets all changes to the "account_number" field.
func (m *GeneralLedgerAccountMutation) ResetAccountNumber() {
	m.account_number = nil
}

// SetAccountType sets the "account_type" field.
func (m *GeneralLedgerAccountMutation) SetAccountType(gt generalledgeraccount.AccountType) {
	m.account_type = &gt
}

// AccountType returns the value of the "account_type" field in the mutation.
func (m *GeneralLedgerAccountMutation) AccountType() (r generalledgeraccount.AccountType, exists bool) {
	v := m.account_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountType returns the old "account_type" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldAccountType(ctx context.Context) (v generalledgeraccount.AccountType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountType: %w", err)
	}
	return oldValue.AccountType, nil
}

// ResetAccountType resets all changes to the "account_type" field.
func (m *GeneralLedgerAccountMutation) ResetAccountType() {
	m.account_type = nil
}

// SetCashFlowType sets the "cash_flow_type" field.
func (m *GeneralLedgerAccountMutation) SetCashFlowType(gft generalledgeraccount.CashFlowType) {
	m.cash_flow_type = &gft
}

// CashFlowType returns the value of the "cash_flow_type" field in the mutation.
func (m *GeneralLedgerAccountMutation) CashFlowType() (r generalledgeraccount.CashFlowType, exists bool) {
	v := m.cash_flow_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCashFlowType returns the old "cash_flow_type" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldCashFlowType(ctx context.Context) (v generalledgeraccount.CashFlowType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCashFlowType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCashFlowType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCashFlowType: %w", err)
	}
	return oldValue.CashFlowType, nil
}

// ClearCashFlowType clears the value of the "cash_flow_type" field.
func (m *GeneralLedgerAccountMutation) ClearCashFlowType() {
	m.cash_flow_type = nil
	m.clearedFields[generalledgeraccount.FieldCashFlowType] = struct{}{}
}

// CashFlowTypeCleared returns if the "cash_flow_type" field was cleared in this mutation.
func (m *GeneralLedgerAccountMutation) CashFlowTypeCleared() bool {
	_, ok := m.clearedFields[generalledgeraccount.FieldCashFlowType]
	return ok
}

// ResetCashFlowType resets all changes to the "cash_flow_type" field.
func (m *GeneralLedgerAccountMutation) ResetCashFlowType() {
	m.cash_flow_type = nil
	delete(m.clearedFields, generalledgeraccount.FieldCashFlowType)
}

// SetAccountSubType sets the "account_sub_type" field.
func (m *GeneralLedgerAccountMutation) SetAccountSubType(gst generalledgeraccount.AccountSubType) {
	m.account_sub_type = &gst
}

// AccountSubType returns the value of the "account_sub_type" field in the mutation.
func (m *GeneralLedgerAccountMutation) AccountSubType() (r generalledgeraccount.AccountSubType, exists bool) {
	v := m.account_sub_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountSubType returns the old "account_sub_type" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldAccountSubType(ctx context.Context) (v generalledgeraccount.AccountSubType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountSubType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountSubType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountSubType: %w", err)
	}
	return oldValue.AccountSubType, nil
}

// ClearAccountSubType clears the value of the "account_sub_type" field.
func (m *GeneralLedgerAccountMutation) ClearAccountSubType() {
	m.account_sub_type = nil
	m.clearedFields[generalledgeraccount.FieldAccountSubType] = struct{}{}
}

// AccountSubTypeCleared returns if the "account_sub_type" field was cleared in this mutation.
func (m *GeneralLedgerAccountMutation) AccountSubTypeCleared() bool {
	_, ok := m.clearedFields[generalledgeraccount.FieldAccountSubType]
	return ok
}

// ResetAccountSubType resets all changes to the "account_sub_type" field.
func (m *GeneralLedgerAccountMutation) ResetAccountSubType() {
	m.account_sub_type = nil
	delete(m.clearedFields, generalledgeraccount.FieldAccountSubType)
}

// SetAccountClass sets the "account_class" field.
func (m *GeneralLedgerAccountMutation) SetAccountClass(gc generalledgeraccount.AccountClass) {
	m.account_class = &gc
}

// AccountClass returns the value of the "account_class" field in the mutation.
func (m *GeneralLedgerAccountMutation) AccountClass() (r generalledgeraccount.AccountClass, exists bool) {
	v := m.account_class
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountClass returns the old "account_class" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldAccountClass(ctx context.Context) (v generalledgeraccount.AccountClass, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountClass is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountClass requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountClass: %w", err)
	}
	return oldValue.AccountClass, nil
}

// ClearAccountClass clears the value of the "account_class" field.
func (m *GeneralLedgerAccountMutation) ClearAccountClass() {
	m.account_class = nil
	m.clearedFields[generalledgeraccount.FieldAccountClass] = struct{}{}
}

// AccountClassCleared returns if the "account_class" field was cleared in this mutation.
func (m *GeneralLedgerAccountMutation) AccountClassCleared() bool {
	_, ok := m.clearedFields[generalledgeraccount.FieldAccountClass]
	return ok
}

// ResetAccountClass resets all changes to the "account_class" field.
func (m *GeneralLedgerAccountMutation) ResetAccountClass() {
	m.account_class = nil
	delete(m.clearedFields, generalledgeraccount.FieldAccountClass)
}

// SetBalance sets the "balance" field.
func (m *GeneralLedgerAccountMutation) SetBalance(f float64) {
	m.balance = &f
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *GeneralLedgerAccountMutation) Balance() (r float64, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldBalance(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds f to the "balance" field.
func (m *GeneralLedgerAccountMutation) AddBalance(f float64) {
	if m.addbalance != nil {
		*m.addbalance += f
	} else {
		m.addbalance = &f
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *GeneralLedgerAccountMutation) AddedBalance() (r float64, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ClearBalance clears the value of the "balance" field.
func (m *GeneralLedgerAccountMutation) ClearBalance() {
	m.balance = nil
	m.addbalance = nil
	m.clearedFields[generalledgeraccount.FieldBalance] = struct{}{}
}

// BalanceCleared returns if the "balance" field was cleared in this mutation.
func (m *GeneralLedgerAccountMutation) BalanceCleared() bool {
	_, ok := m.clearedFields[generalledgeraccount.FieldBalance]
	return ok
}

// ResetBalance resets all changes to the "balance" field.
func (m *GeneralLedgerAccountMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
	delete(m.clearedFields, generalledgeraccount.FieldBalance)
}

// SetInterestRate sets the "interest_rate" field.
func (m *GeneralLedgerAccountMutation) SetInterestRate(f float64) {
	m.interest_rate = &f
	m.addinterest_rate = nil
}

// InterestRate returns the value of the "interest_rate" field in the mutation.
func (m *GeneralLedgerAccountMutation) InterestRate() (r float64, exists bool) {
	v := m.interest_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldInterestRate returns the old "interest_rate" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldInterestRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInterestRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInterestRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterestRate: %w", err)
	}
	return oldValue.InterestRate, nil
}

// AddInterestRate adds f to the "interest_rate" field.
func (m *GeneralLedgerAccountMutation) AddInterestRate(f float64) {
	if m.addinterest_rate != nil {
		*m.addinterest_rate += f
	} else {
		m.addinterest_rate = &f
	}
}

// AddedInterestRate returns the value that was added to the "interest_rate" field in this mutation.
func (m *GeneralLedgerAccountMutation) AddedInterestRate() (r float64, exists bool) {
	v := m.addinterest_rate
	if v == nil {
		return
	}
	return *v, true
}

// ClearInterestRate clears the value of the "interest_rate" field.
func (m *GeneralLedgerAccountMutation) ClearInterestRate() {
	m.interest_rate = nil
	m.addinterest_rate = nil
	m.clearedFields[generalledgeraccount.FieldInterestRate] = struct{}{}
}

// InterestRateCleared returns if the "interest_rate" field was cleared in this mutation.
func (m *GeneralLedgerAccountMutation) InterestRateCleared() bool {
	_, ok := m.clearedFields[generalledgeraccount.FieldInterestRate]
	return ok
}

// ResetInterestRate resets all changes to the "interest_rate" field.
func (m *GeneralLedgerAccountMutation) ResetInterestRate() {
	m.interest_rate = nil
	m.addinterest_rate = nil
	delete(m.clearedFields, generalledgeraccount.FieldInterestRate)
}

// SetDateOpened sets the "date_opened" field.
func (m *GeneralLedgerAccountMutation) SetDateOpened(t time.Time) {
	m.date_opened = &t
}

// DateOpened returns the value of the "date_opened" field in the mutation.
func (m *GeneralLedgerAccountMutation) DateOpened() (r time.Time, exists bool) {
	v := m.date_opened
	if v == nil {
		return
	}
	return *v, true
}

// OldDateOpened returns the old "date_opened" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldDateOpened(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDateOpened is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDateOpened requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateOpened: %w", err)
	}
	return oldValue.DateOpened, nil
}

// ResetDateOpened resets all changes to the "date_opened" field.
func (m *GeneralLedgerAccountMutation) ResetDateOpened() {
	m.date_opened = nil
}

// SetDateClosed sets the "date_closed" field.
func (m *GeneralLedgerAccountMutation) SetDateClosed(t time.Time) {
	m.date_closed = &t
}

// DateClosed returns the value of the "date_closed" field in the mutation.
func (m *GeneralLedgerAccountMutation) DateClosed() (r time.Time, exists bool) {
	v := m.date_closed
	if v == nil {
		return
	}
	return *v, true
}

// OldDateClosed returns the old "date_closed" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldDateClosed(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDateClosed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDateClosed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateClosed: %w", err)
	}
	return oldValue.DateClosed, nil
}

// ClearDateClosed clears the value of the "date_closed" field.
func (m *GeneralLedgerAccountMutation) ClearDateClosed() {
	m.date_closed = nil
	m.clearedFields[generalledgeraccount.FieldDateClosed] = struct{}{}
}

// DateClosedCleared returns if the "date_closed" field was cleared in this mutation.
func (m *GeneralLedgerAccountMutation) DateClosedCleared() bool {
	_, ok := m.clearedFields[generalledgeraccount.FieldDateClosed]
	return ok
}

// ResetDateClosed resets all changes to the "date_closed" field.
func (m *GeneralLedgerAccountMutation) ResetDateClosed() {
	m.date_closed = nil
	delete(m.clearedFields, generalledgeraccount.FieldDateClosed)
}

// SetNotes sets the "notes" field.
func (m *GeneralLedgerAccountMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *GeneralLedgerAccountMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *GeneralLedgerAccountMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[generalledgeraccount.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *GeneralLedgerAccountMutation) NotesCleared() bool {
	_, ok := m.clearedFields[generalledgeraccount.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *GeneralLedgerAccountMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, generalledgeraccount.FieldNotes)
}

// SetIsTaxRelevant sets the "is_tax_relevant" field.
func (m *GeneralLedgerAccountMutation) SetIsTaxRelevant(b bool) {
	m.is_tax_relevant = &b
}

// IsTaxRelevant returns the value of the "is_tax_relevant" field in the mutation.
func (m *GeneralLedgerAccountMutation) IsTaxRelevant() (r bool, exists bool) {
	v := m.is_tax_relevant
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTaxRelevant returns the old "is_tax_relevant" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldIsTaxRelevant(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTaxRelevant is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTaxRelevant requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTaxRelevant: %w", err)
	}
	return oldValue.IsTaxRelevant, nil
}

// ResetIsTaxRelevant resets all changes to the "is_tax_relevant" field.
func (m *GeneralLedgerAccountMutation) ResetIsTaxRelevant() {
	m.is_tax_relevant = nil
}

// SetIsReconciled sets the "is_reconciled" field.
func (m *GeneralLedgerAccountMutation) SetIsReconciled(b bool) {
	m.is_reconciled = &b
}

// IsReconciled returns the value of the "is_reconciled" field in the mutation.
func (m *GeneralLedgerAccountMutation) IsReconciled() (r bool, exists bool) {
	v := m.is_reconciled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsReconciled returns the old "is_reconciled" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldIsReconciled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsReconciled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsReconciled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsReconciled: %w", err)
	}
	return oldValue.IsReconciled, nil
}

// ResetIsReconciled resets all changes to the "is_reconciled" field.
func (m *GeneralLedgerAccountMutation) ResetIsReconciled() {
	m.is_reconciled = nil
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *GeneralLedgerAccountMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[generalledgeraccount.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *GeneralLedgerAccountMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *GeneralLedgerAccountMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *GeneralLedgerAccountMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *GeneralLedgerAccountMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[generalledgeraccount.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *GeneralLedgerAccountMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *GeneralLedgerAccountMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *GeneralLedgerAccountMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *GeneralLedgerAccountMutation) AddTagIDs(ids ...uuid.UUID) {
	if m.tags == nil {
		m.tags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *GeneralLedgerAccountMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *GeneralLedgerAccountMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *GeneralLedgerAccountMutation) RemoveTagIDs(ids ...uuid.UUID) {
	if m.removedtags == nil {
		m.removedtags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *GeneralLedgerAccountMutation) RemovedTagsIDs() (ids []uuid.UUID) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *GeneralLedgerAccountMutation) TagsIDs() (ids []uuid.UUID) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *GeneralLedgerAccountMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// Where appends a list predicates to the GeneralLedgerAccountMutation builder.
func (m *GeneralLedgerAccountMutation) Where(ps ...predicate.GeneralLedgerAccount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GeneralLedgerAccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GeneralLedgerAccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GeneralLedgerAccount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GeneralLedgerAccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GeneralLedgerAccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GeneralLedgerAccount).
func (m *GeneralLedgerAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GeneralLedgerAccountMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.business_unit != nil {
		fields = append(fields, generalledgeraccount.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, generalledgeraccount.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, generalledgeraccount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, generalledgeraccount.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, generalledgeraccount.FieldStatus)
	}
	if m.account_number != nil {
		fields = append(fields, generalledgeraccount.FieldAccountNumber)
	}
	if m.account_type != nil {
		fields = append(fields, generalledgeraccount.FieldAccountType)
	}
	if m.cash_flow_type != nil {
		fields = append(fields, generalledgeraccount.FieldCashFlowType)
	}
	if m.account_sub_type != nil {
		fields = append(fields, generalledgeraccount.FieldAccountSubType)
	}
	if m.account_class != nil {
		fields = append(fields, generalledgeraccount.FieldAccountClass)
	}
	if m.balance != nil {
		fields = append(fields, generalledgeraccount.FieldBalance)
	}
	if m.interest_rate != nil {
		fields = append(fields, generalledgeraccount.FieldInterestRate)
	}
	if m.date_opened != nil {
		fields = append(fields, generalledgeraccount.FieldDateOpened)
	}
	if m.date_closed != nil {
		fields = append(fields, generalledgeraccount.FieldDateClosed)
	}
	if m.notes != nil {
		fields = append(fields, generalledgeraccount.FieldNotes)
	}
	if m.is_tax_relevant != nil {
		fields = append(fields, generalledgeraccount.FieldIsTaxRelevant)
	}
	if m.is_reconciled != nil {
		fields = append(fields, generalledgeraccount.FieldIsReconciled)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GeneralLedgerAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case generalledgeraccount.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case generalledgeraccount.FieldOrganizationID:
		return m.OrganizationID()
	case generalledgeraccount.FieldCreatedAt:
		return m.CreatedAt()
	case generalledgeraccount.FieldUpdatedAt:
		return m.UpdatedAt()
	case generalledgeraccount.FieldStatus:
		return m.Status()
	case generalledgeraccount.FieldAccountNumber:
		return m.AccountNumber()
	case generalledgeraccount.FieldAccountType:
		return m.AccountType()
	case generalledgeraccount.FieldCashFlowType:
		return m.CashFlowType()
	case generalledgeraccount.FieldAccountSubType:
		return m.AccountSubType()
	case generalledgeraccount.FieldAccountClass:
		return m.AccountClass()
	case generalledgeraccount.FieldBalance:
		return m.Balance()
	case generalledgeraccount.FieldInterestRate:
		return m.InterestRate()
	case generalledgeraccount.FieldDateOpened:
		return m.DateOpened()
	case generalledgeraccount.FieldDateClosed:
		return m.DateClosed()
	case generalledgeraccount.FieldNotes:
		return m.Notes()
	case generalledgeraccount.FieldIsTaxRelevant:
		return m.IsTaxRelevant()
	case generalledgeraccount.FieldIsReconciled:
		return m.IsReconciled()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GeneralLedgerAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case generalledgeraccount.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case generalledgeraccount.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case generalledgeraccount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case generalledgeraccount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case generalledgeraccount.FieldStatus:
		return m.OldStatus(ctx)
	case generalledgeraccount.FieldAccountNumber:
		return m.OldAccountNumber(ctx)
	case generalledgeraccount.FieldAccountType:
		return m.OldAccountType(ctx)
	case generalledgeraccount.FieldCashFlowType:
		return m.OldCashFlowType(ctx)
	case generalledgeraccount.FieldAccountSubType:
		return m.OldAccountSubType(ctx)
	case generalledgeraccount.FieldAccountClass:
		return m.OldAccountClass(ctx)
	case generalledgeraccount.FieldBalance:
		return m.OldBalance(ctx)
	case generalledgeraccount.FieldInterestRate:
		return m.OldInterestRate(ctx)
	case generalledgeraccount.FieldDateOpened:
		return m.OldDateOpened(ctx)
	case generalledgeraccount.FieldDateClosed:
		return m.OldDateClosed(ctx)
	case generalledgeraccount.FieldNotes:
		return m.OldNotes(ctx)
	case generalledgeraccount.FieldIsTaxRelevant:
		return m.OldIsTaxRelevant(ctx)
	case generalledgeraccount.FieldIsReconciled:
		return m.OldIsReconciled(ctx)
	}
	return nil, fmt.Errorf("unknown GeneralLedgerAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GeneralLedgerAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case generalledgeraccount.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case generalledgeraccount.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case generalledgeraccount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case generalledgeraccount.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case generalledgeraccount.FieldStatus:
		v, ok := value.(generalledgeraccount.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case generalledgeraccount.FieldAccountNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountNumber(v)
		return nil
	case generalledgeraccount.FieldAccountType:
		v, ok := value.(generalledgeraccount.AccountType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountType(v)
		return nil
	case generalledgeraccount.FieldCashFlowType:
		v, ok := value.(generalledgeraccount.CashFlowType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCashFlowType(v)
		return nil
	case generalledgeraccount.FieldAccountSubType:
		v, ok := value.(generalledgeraccount.AccountSubType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountSubType(v)
		return nil
	case generalledgeraccount.FieldAccountClass:
		v, ok := value.(generalledgeraccount.AccountClass)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountClass(v)
		return nil
	case generalledgeraccount.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	case generalledgeraccount.FieldInterestRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterestRate(v)
		return nil
	case generalledgeraccount.FieldDateOpened:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateOpened(v)
		return nil
	case generalledgeraccount.FieldDateClosed:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateClosed(v)
		return nil
	case generalledgeraccount.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case generalledgeraccount.FieldIsTaxRelevant:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTaxRelevant(v)
		return nil
	case generalledgeraccount.FieldIsReconciled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsReconciled(v)
		return nil
	}
	return fmt.Errorf("unknown GeneralLedgerAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GeneralLedgerAccountMutation) AddedFields() []string {
	var fields []string
	if m.addbalance != nil {
		fields = append(fields, generalledgeraccount.FieldBalance)
	}
	if m.addinterest_rate != nil {
		fields = append(fields, generalledgeraccount.FieldInterestRate)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GeneralLedgerAccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case generalledgeraccount.FieldBalance:
		return m.AddedBalance()
	case generalledgeraccount.FieldInterestRate:
		return m.AddedInterestRate()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GeneralLedgerAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case generalledgeraccount.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	case generalledgeraccount.FieldInterestRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInterestRate(v)
		return nil
	}
	return fmt.Errorf("unknown GeneralLedgerAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GeneralLedgerAccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(generalledgeraccount.FieldCashFlowType) {
		fields = append(fields, generalledgeraccount.FieldCashFlowType)
	}
	if m.FieldCleared(generalledgeraccount.FieldAccountSubType) {
		fields = append(fields, generalledgeraccount.FieldAccountSubType)
	}
	if m.FieldCleared(generalledgeraccount.FieldAccountClass) {
		fields = append(fields, generalledgeraccount.FieldAccountClass)
	}
	if m.FieldCleared(generalledgeraccount.FieldBalance) {
		fields = append(fields, generalledgeraccount.FieldBalance)
	}
	if m.FieldCleared(generalledgeraccount.FieldInterestRate) {
		fields = append(fields, generalledgeraccount.FieldInterestRate)
	}
	if m.FieldCleared(generalledgeraccount.FieldDateClosed) {
		fields = append(fields, generalledgeraccount.FieldDateClosed)
	}
	if m.FieldCleared(generalledgeraccount.FieldNotes) {
		fields = append(fields, generalledgeraccount.FieldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GeneralLedgerAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GeneralLedgerAccountMutation) ClearField(name string) error {
	switch name {
	case generalledgeraccount.FieldCashFlowType:
		m.ClearCashFlowType()
		return nil
	case generalledgeraccount.FieldAccountSubType:
		m.ClearAccountSubType()
		return nil
	case generalledgeraccount.FieldAccountClass:
		m.ClearAccountClass()
		return nil
	case generalledgeraccount.FieldBalance:
		m.ClearBalance()
		return nil
	case generalledgeraccount.FieldInterestRate:
		m.ClearInterestRate()
		return nil
	case generalledgeraccount.FieldDateClosed:
		m.ClearDateClosed()
		return nil
	case generalledgeraccount.FieldNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown GeneralLedgerAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GeneralLedgerAccountMutation) ResetField(name string) error {
	switch name {
	case generalledgeraccount.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case generalledgeraccount.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case generalledgeraccount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case generalledgeraccount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case generalledgeraccount.FieldStatus:
		m.ResetStatus()
		return nil
	case generalledgeraccount.FieldAccountNumber:
		m.ResetAccountNumber()
		return nil
	case generalledgeraccount.FieldAccountType:
		m.ResetAccountType()
		return nil
	case generalledgeraccount.FieldCashFlowType:
		m.ResetCashFlowType()
		return nil
	case generalledgeraccount.FieldAccountSubType:
		m.ResetAccountSubType()
		return nil
	case generalledgeraccount.FieldAccountClass:
		m.ResetAccountClass()
		return nil
	case generalledgeraccount.FieldBalance:
		m.ResetBalance()
		return nil
	case generalledgeraccount.FieldInterestRate:
		m.ResetInterestRate()
		return nil
	case generalledgeraccount.FieldDateOpened:
		m.ResetDateOpened()
		return nil
	case generalledgeraccount.FieldDateClosed:
		m.ResetDateClosed()
		return nil
	case generalledgeraccount.FieldNotes:
		m.ResetNotes()
		return nil
	case generalledgeraccount.FieldIsTaxRelevant:
		m.ResetIsTaxRelevant()
		return nil
	case generalledgeraccount.FieldIsReconciled:
		m.ResetIsReconciled()
		return nil
	}
	return fmt.Errorf("unknown GeneralLedgerAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GeneralLedgerAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.business_unit != nil {
		edges = append(edges, generalledgeraccount.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, generalledgeraccount.EdgeOrganization)
	}
	if m.tags != nil {
		edges = append(edges, generalledgeraccount.EdgeTags)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GeneralLedgerAccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case generalledgeraccount.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case generalledgeraccount.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case generalledgeraccount.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GeneralLedgerAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedtags != nil {
		edges = append(edges, generalledgeraccount.EdgeTags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GeneralLedgerAccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case generalledgeraccount.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GeneralLedgerAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbusiness_unit {
		edges = append(edges, generalledgeraccount.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, generalledgeraccount.EdgeOrganization)
	}
	if m.clearedtags {
		edges = append(edges, generalledgeraccount.EdgeTags)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GeneralLedgerAccountMutation) EdgeCleared(name string) bool {
	switch name {
	case generalledgeraccount.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case generalledgeraccount.EdgeOrganization:
		return m.clearedorganization
	case generalledgeraccount.EdgeTags:
		return m.clearedtags
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GeneralLedgerAccountMutation) ClearEdge(name string) error {
	switch name {
	case generalledgeraccount.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case generalledgeraccount.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown GeneralLedgerAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GeneralLedgerAccountMutation) ResetEdge(name string) error {
	switch name {
	case generalledgeraccount.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case generalledgeraccount.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case generalledgeraccount.EdgeTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown GeneralLedgerAccount edge %s", name)
}

// InvoiceControlMutation represents an operation that mutates the InvoiceControl nodes in the graph.
type InvoiceControlMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	created_at                *time.Time
	updated_at                *time.Time
	invoice_number_prefix     *string
	credit_memo_number_prefix *string
	invoice_terms             *string
	invoice_footer            *string
	invoice_logo_url          *string
	invoice_date_format       *invoicecontrol.InvoiceDateFormat
	invoice_due_after_days    *uint8
	addinvoice_due_after_days *int8
	invoice_logo_width        *uint16
	addinvoice_logo_width     *int16
	show_amount_due           *bool
	attach_pdf                *bool
	show_invoice_due_date     *bool
	clearedFields             map[string]struct{}
	organization              *uuid.UUID
	clearedorganization       bool
	business_unit             *uuid.UUID
	clearedbusiness_unit      bool
	done                      bool
	oldValue                  func(context.Context) (*InvoiceControl, error)
	predicates                []predicate.InvoiceControl
}

var _ ent.Mutation = (*InvoiceControlMutation)(nil)

// invoicecontrolOption allows management of the mutation configuration using functional options.
type invoicecontrolOption func(*InvoiceControlMutation)

// newInvoiceControlMutation creates new mutation for the InvoiceControl entity.
func newInvoiceControlMutation(c config, op Op, opts ...invoicecontrolOption) *InvoiceControlMutation {
	m := &InvoiceControlMutation{
		config:        c,
		op:            op,
		typ:           TypeInvoiceControl,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvoiceControlID sets the ID field of the mutation.
func withInvoiceControlID(id uuid.UUID) invoicecontrolOption {
	return func(m *InvoiceControlMutation) {
		var (
			err   error
			once  sync.Once
			value *InvoiceControl
		)
		m.oldValue = func(ctx context.Context) (*InvoiceControl, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InvoiceControl.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvoiceControl sets the old InvoiceControl of the mutation.
func withInvoiceControl(node *InvoiceControl) invoicecontrolOption {
	return func(m *InvoiceControlMutation) {
		m.oldValue = func(context.Context) (*InvoiceControl, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InvoiceControlMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InvoiceControlMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InvoiceControl entities.
func (m *InvoiceControlMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InvoiceControlMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InvoiceControlMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InvoiceControl.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InvoiceControlMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InvoiceControlMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InvoiceControl entity.
// If the InvoiceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceControlMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InvoiceControlMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InvoiceControlMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InvoiceControlMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the InvoiceControl entity.
// If the InvoiceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceControlMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InvoiceControlMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetInvoiceNumberPrefix sets the "invoice_number_prefix" field.
func (m *InvoiceControlMutation) SetInvoiceNumberPrefix(s string) {
	m.invoice_number_prefix = &s
}

// InvoiceNumberPrefix returns the value of the "invoice_number_prefix" field in the mutation.
func (m *InvoiceControlMutation) InvoiceNumberPrefix() (r string, exists bool) {
	v := m.invoice_number_prefix
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceNumberPrefix returns the old "invoice_number_prefix" field's value of the InvoiceControl entity.
// If the InvoiceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceControlMutation) OldInvoiceNumberPrefix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceNumberPrefix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceNumberPrefix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceNumberPrefix: %w", err)
	}
	return oldValue.InvoiceNumberPrefix, nil
}

// ResetInvoiceNumberPrefix resets all changes to the "invoice_number_prefix" field.
func (m *InvoiceControlMutation) ResetInvoiceNumberPrefix() {
	m.invoice_number_prefix = nil
}

// SetCreditMemoNumberPrefix sets the "credit_memo_number_prefix" field.
func (m *InvoiceControlMutation) SetCreditMemoNumberPrefix(s string) {
	m.credit_memo_number_prefix = &s
}

// CreditMemoNumberPrefix returns the value of the "credit_memo_number_prefix" field in the mutation.
func (m *InvoiceControlMutation) CreditMemoNumberPrefix() (r string, exists bool) {
	v := m.credit_memo_number_prefix
	if v == nil {
		return
	}
	return *v, true
}

// OldCreditMemoNumberPrefix returns the old "credit_memo_number_prefix" field's value of the InvoiceControl entity.
// If the InvoiceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceControlMutation) OldCreditMemoNumberPrefix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreditMemoNumberPrefix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreditMemoNumberPrefix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreditMemoNumberPrefix: %w", err)
	}
	return oldValue.CreditMemoNumberPrefix, nil
}

// ResetCreditMemoNumberPrefix resets all changes to the "credit_memo_number_prefix" field.
func (m *InvoiceControlMutation) ResetCreditMemoNumberPrefix() {
	m.credit_memo_number_prefix = nil
}

// SetInvoiceTerms sets the "invoice_terms" field.
func (m *InvoiceControlMutation) SetInvoiceTerms(s string) {
	m.invoice_terms = &s
}

// InvoiceTerms returns the value of the "invoice_terms" field in the mutation.
func (m *InvoiceControlMutation) InvoiceTerms() (r string, exists bool) {
	v := m.invoice_terms
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceTerms returns the old "invoice_terms" field's value of the InvoiceControl entity.
// If the InvoiceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceControlMutation) OldInvoiceTerms(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceTerms is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceTerms requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceTerms: %w", err)
	}
	return oldValue.InvoiceTerms, nil
}

// ClearInvoiceTerms clears the value of the "invoice_terms" field.
func (m *InvoiceControlMutation) ClearInvoiceTerms() {
	m.invoice_terms = nil
	m.clearedFields[invoicecontrol.FieldInvoiceTerms] = struct{}{}
}

// InvoiceTermsCleared returns if the "invoice_terms" field was cleared in this mutation.
func (m *InvoiceControlMutation) InvoiceTermsCleared() bool {
	_, ok := m.clearedFields[invoicecontrol.FieldInvoiceTerms]
	return ok
}

// ResetInvoiceTerms resets all changes to the "invoice_terms" field.
func (m *InvoiceControlMutation) ResetInvoiceTerms() {
	m.invoice_terms = nil
	delete(m.clearedFields, invoicecontrol.FieldInvoiceTerms)
}

// SetInvoiceFooter sets the "invoice_footer" field.
func (m *InvoiceControlMutation) SetInvoiceFooter(s string) {
	m.invoice_footer = &s
}

// InvoiceFooter returns the value of the "invoice_footer" field in the mutation.
func (m *InvoiceControlMutation) InvoiceFooter() (r string, exists bool) {
	v := m.invoice_footer
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceFooter returns the old "invoice_footer" field's value of the InvoiceControl entity.
// If the InvoiceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceControlMutation) OldInvoiceFooter(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceFooter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceFooter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceFooter: %w", err)
	}
	return oldValue.InvoiceFooter, nil
}

// ClearInvoiceFooter clears the value of the "invoice_footer" field.
func (m *InvoiceControlMutation) ClearInvoiceFooter() {
	m.invoice_footer = nil
	m.clearedFields[invoicecontrol.FieldInvoiceFooter] = struct{}{}
}

// InvoiceFooterCleared returns if the "invoice_footer" field was cleared in this mutation.
func (m *InvoiceControlMutation) InvoiceFooterCleared() bool {
	_, ok := m.clearedFields[invoicecontrol.FieldInvoiceFooter]
	return ok
}

// ResetInvoiceFooter resets all changes to the "invoice_footer" field.
func (m *InvoiceControlMutation) ResetInvoiceFooter() {
	m.invoice_footer = nil
	delete(m.clearedFields, invoicecontrol.FieldInvoiceFooter)
}

// SetInvoiceLogoURL sets the "invoice_logo_url" field.
func (m *InvoiceControlMutation) SetInvoiceLogoURL(s string) {
	m.invoice_logo_url = &s
}

// InvoiceLogoURL returns the value of the "invoice_logo_url" field in the mutation.
func (m *InvoiceControlMutation) InvoiceLogoURL() (r string, exists bool) {
	v := m.invoice_logo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceLogoURL returns the old "invoice_logo_url" field's value of the InvoiceControl entity.
// If the InvoiceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceControlMutation) OldInvoiceLogoURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceLogoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceLogoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceLogoURL: %w", err)
	}
	return oldValue.InvoiceLogoURL, nil
}

// ClearInvoiceLogoURL clears the value of the "invoice_logo_url" field.
func (m *InvoiceControlMutation) ClearInvoiceLogoURL() {
	m.invoice_logo_url = nil
	m.clearedFields[invoicecontrol.FieldInvoiceLogoURL] = struct{}{}
}

// InvoiceLogoURLCleared returns if the "invoice_logo_url" field was cleared in this mutation.
func (m *InvoiceControlMutation) InvoiceLogoURLCleared() bool {
	_, ok := m.clearedFields[invoicecontrol.FieldInvoiceLogoURL]
	return ok
}

// ResetInvoiceLogoURL resets all changes to the "invoice_logo_url" field.
func (m *InvoiceControlMutation) ResetInvoiceLogoURL() {
	m.invoice_logo_url = nil
	delete(m.clearedFields, invoicecontrol.FieldInvoiceLogoURL)
}

// SetInvoiceDateFormat sets the "invoice_date_format" field.
func (m *InvoiceControlMutation) SetInvoiceDateFormat(idf invoicecontrol.InvoiceDateFormat) {
	m.invoice_date_format = &idf
}

// InvoiceDateFormat returns the value of the "invoice_date_format" field in the mutation.
func (m *InvoiceControlMutation) InvoiceDateFormat() (r invoicecontrol.InvoiceDateFormat, exists bool) {
	v := m.invoice_date_format
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceDateFormat returns the old "invoice_date_format" field's value of the InvoiceControl entity.
// If the InvoiceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceControlMutation) OldInvoiceDateFormat(ctx context.Context) (v invoicecontrol.InvoiceDateFormat, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceDateFormat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceDateFormat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceDateFormat: %w", err)
	}
	return oldValue.InvoiceDateFormat, nil
}

// ResetInvoiceDateFormat resets all changes to the "invoice_date_format" field.
func (m *InvoiceControlMutation) ResetInvoiceDateFormat() {
	m.invoice_date_format = nil
}

// SetInvoiceDueAfterDays sets the "invoice_due_after_days" field.
func (m *InvoiceControlMutation) SetInvoiceDueAfterDays(u uint8) {
	m.invoice_due_after_days = &u
	m.addinvoice_due_after_days = nil
}

// InvoiceDueAfterDays returns the value of the "invoice_due_after_days" field in the mutation.
func (m *InvoiceControlMutation) InvoiceDueAfterDays() (r uint8, exists bool) {
	v := m.invoice_due_after_days
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceDueAfterDays returns the old "invoice_due_after_days" field's value of the InvoiceControl entity.
// If the InvoiceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceControlMutation) OldInvoiceDueAfterDays(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceDueAfterDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceDueAfterDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceDueAfterDays: %w", err)
	}
	return oldValue.InvoiceDueAfterDays, nil
}

// AddInvoiceDueAfterDays adds u to the "invoice_due_after_days" field.
func (m *InvoiceControlMutation) AddInvoiceDueAfterDays(u int8) {
	if m.addinvoice_due_after_days != nil {
		*m.addinvoice_due_after_days += u
	} else {
		m.addinvoice_due_after_days = &u
	}
}

// AddedInvoiceDueAfterDays returns the value that was added to the "invoice_due_after_days" field in this mutation.
func (m *InvoiceControlMutation) AddedInvoiceDueAfterDays() (r int8, exists bool) {
	v := m.addinvoice_due_after_days
	if v == nil {
		return
	}
	return *v, true
}

// ResetInvoiceDueAfterDays resets all changes to the "invoice_due_after_days" field.
func (m *InvoiceControlMutation) ResetInvoiceDueAfterDays() {
	m.invoice_due_after_days = nil
	m.addinvoice_due_after_days = nil
}

// SetInvoiceLogoWidth sets the "invoice_logo_width" field.
func (m *InvoiceControlMutation) SetInvoiceLogoWidth(u uint16) {
	m.invoice_logo_width = &u
	m.addinvoice_logo_width = nil
}

// InvoiceLogoWidth returns the value of the "invoice_logo_width" field in the mutation.
func (m *InvoiceControlMutation) InvoiceLogoWidth() (r uint16, exists bool) {
	v := m.invoice_logo_width
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceLogoWidth returns the old "invoice_logo_width" field's value of the InvoiceControl entity.
// If the InvoiceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceControlMutation) OldInvoiceLogoWidth(ctx context.Context) (v uint16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceLogoWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceLogoWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceLogoWidth: %w", err)
	}
	return oldValue.InvoiceLogoWidth, nil
}

// AddInvoiceLogoWidth adds u to the "invoice_logo_width" field.
func (m *InvoiceControlMutation) AddInvoiceLogoWidth(u int16) {
	if m.addinvoice_logo_width != nil {
		*m.addinvoice_logo_width += u
	} else {
		m.addinvoice_logo_width = &u
	}
}

// AddedInvoiceLogoWidth returns the value that was added to the "invoice_logo_width" field in this mutation.
func (m *InvoiceControlMutation) AddedInvoiceLogoWidth() (r int16, exists bool) {
	v := m.addinvoice_logo_width
	if v == nil {
		return
	}
	return *v, true
}

// ResetInvoiceLogoWidth resets all changes to the "invoice_logo_width" field.
func (m *InvoiceControlMutation) ResetInvoiceLogoWidth() {
	m.invoice_logo_width = nil
	m.addinvoice_logo_width = nil
}

// SetShowAmountDue sets the "show_amount_due" field.
func (m *InvoiceControlMutation) SetShowAmountDue(b bool) {
	m.show_amount_due = &b
}

// ShowAmountDue returns the value of the "show_amount_due" field in the mutation.
func (m *InvoiceControlMutation) ShowAmountDue() (r bool, exists bool) {
	v := m.show_amount_due
	if v == nil {
		return
	}
	return *v, true
}

// OldShowAmountDue returns the old "show_amount_due" field's value of the InvoiceControl entity.
// If the InvoiceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceControlMutation) OldShowAmountDue(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShowAmountDue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShowAmountDue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShowAmountDue: %w", err)
	}
	return oldValue.ShowAmountDue, nil
}

// ResetShowAmountDue resets all changes to the "show_amount_due" field.
func (m *InvoiceControlMutation) ResetShowAmountDue() {
	m.show_amount_due = nil
}

// SetAttachPdf sets the "attach_pdf" field.
func (m *InvoiceControlMutation) SetAttachPdf(b bool) {
	m.attach_pdf = &b
}

// AttachPdf returns the value of the "attach_pdf" field in the mutation.
func (m *InvoiceControlMutation) AttachPdf() (r bool, exists bool) {
	v := m.attach_pdf
	if v == nil {
		return
	}
	return *v, true
}

// OldAttachPdf returns the old "attach_pdf" field's value of the InvoiceControl entity.
// If the InvoiceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceControlMutation) OldAttachPdf(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttachPdf is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttachPdf requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttachPdf: %w", err)
	}
	return oldValue.AttachPdf, nil
}

// ResetAttachPdf resets all changes to the "attach_pdf" field.
func (m *InvoiceControlMutation) ResetAttachPdf() {
	m.attach_pdf = nil
}

// SetShowInvoiceDueDate sets the "show_invoice_due_date" field.
func (m *InvoiceControlMutation) SetShowInvoiceDueDate(b bool) {
	m.show_invoice_due_date = &b
}

// ShowInvoiceDueDate returns the value of the "show_invoice_due_date" field in the mutation.
func (m *InvoiceControlMutation) ShowInvoiceDueDate() (r bool, exists bool) {
	v := m.show_invoice_due_date
	if v == nil {
		return
	}
	return *v, true
}

// OldShowInvoiceDueDate returns the old "show_invoice_due_date" field's value of the InvoiceControl entity.
// If the InvoiceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceControlMutation) OldShowInvoiceDueDate(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShowInvoiceDueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShowInvoiceDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShowInvoiceDueDate: %w", err)
	}
	return oldValue.ShowInvoiceDueDate, nil
}

// ResetShowInvoiceDueDate resets all changes to the "show_invoice_due_date" field.
func (m *InvoiceControlMutation) ResetShowInvoiceDueDate() {
	m.show_invoice_due_date = nil
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *InvoiceControlMutation) SetOrganizationID(id uuid.UUID) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *InvoiceControlMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *InvoiceControlMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *InvoiceControlMutation) OrganizationID() (id uuid.UUID, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *InvoiceControlMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *InvoiceControlMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// SetBusinessUnitID sets the "business_unit" edge to the BusinessUnit entity by id.
func (m *InvoiceControlMutation) SetBusinessUnitID(id uuid.UUID) {
	m.business_unit = &id
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *InvoiceControlMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *InvoiceControlMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitID returns the "business_unit" edge ID in the mutation.
func (m *InvoiceControlMutation) BusinessUnitID() (id uuid.UUID, exists bool) {
	if m.business_unit != nil {
		return *m.business_unit, true
	}
	return
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *InvoiceControlMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *InvoiceControlMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// Where appends a list predicates to the InvoiceControlMutation builder.
func (m *InvoiceControlMutation) Where(ps ...predicate.InvoiceControl) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InvoiceControlMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InvoiceControlMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InvoiceControl, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InvoiceControlMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InvoiceControlMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InvoiceControl).
func (m *InvoiceControlMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InvoiceControlMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, invoicecontrol.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, invoicecontrol.FieldUpdatedAt)
	}
	if m.invoice_number_prefix != nil {
		fields = append(fields, invoicecontrol.FieldInvoiceNumberPrefix)
	}
	if m.credit_memo_number_prefix != nil {
		fields = append(fields, invoicecontrol.FieldCreditMemoNumberPrefix)
	}
	if m.invoice_terms != nil {
		fields = append(fields, invoicecontrol.FieldInvoiceTerms)
	}
	if m.invoice_footer != nil {
		fields = append(fields, invoicecontrol.FieldInvoiceFooter)
	}
	if m.invoice_logo_url != nil {
		fields = append(fields, invoicecontrol.FieldInvoiceLogoURL)
	}
	if m.invoice_date_format != nil {
		fields = append(fields, invoicecontrol.FieldInvoiceDateFormat)
	}
	if m.invoice_due_after_days != nil {
		fields = append(fields, invoicecontrol.FieldInvoiceDueAfterDays)
	}
	if m.invoice_logo_width != nil {
		fields = append(fields, invoicecontrol.FieldInvoiceLogoWidth)
	}
	if m.show_amount_due != nil {
		fields = append(fields, invoicecontrol.FieldShowAmountDue)
	}
	if m.attach_pdf != nil {
		fields = append(fields, invoicecontrol.FieldAttachPdf)
	}
	if m.show_invoice_due_date != nil {
		fields = append(fields, invoicecontrol.FieldShowInvoiceDueDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InvoiceControlMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case invoicecontrol.FieldCreatedAt:
		return m.CreatedAt()
	case invoicecontrol.FieldUpdatedAt:
		return m.UpdatedAt()
	case invoicecontrol.FieldInvoiceNumberPrefix:
		return m.InvoiceNumberPrefix()
	case invoicecontrol.FieldCreditMemoNumberPrefix:
		return m.CreditMemoNumberPrefix()
	case invoicecontrol.FieldInvoiceTerms:
		return m.InvoiceTerms()
	case invoicecontrol.FieldInvoiceFooter:
		return m.InvoiceFooter()
	case invoicecontrol.FieldInvoiceLogoURL:
		return m.InvoiceLogoURL()
	case invoicecontrol.FieldInvoiceDateFormat:
		return m.InvoiceDateFormat()
	case invoicecontrol.FieldInvoiceDueAfterDays:
		return m.InvoiceDueAfterDays()
	case invoicecontrol.FieldInvoiceLogoWidth:
		return m.InvoiceLogoWidth()
	case invoicecontrol.FieldShowAmountDue:
		return m.ShowAmountDue()
	case invoicecontrol.FieldAttachPdf:
		return m.AttachPdf()
	case invoicecontrol.FieldShowInvoiceDueDate:
		return m.ShowInvoiceDueDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InvoiceControlMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case invoicecontrol.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case invoicecontrol.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case invoicecontrol.FieldInvoiceNumberPrefix:
		return m.OldInvoiceNumberPrefix(ctx)
	case invoicecontrol.FieldCreditMemoNumberPrefix:
		return m.OldCreditMemoNumberPrefix(ctx)
	case invoicecontrol.FieldInvoiceTerms:
		return m.OldInvoiceTerms(ctx)
	case invoicecontrol.FieldInvoiceFooter:
		return m.OldInvoiceFooter(ctx)
	case invoicecontrol.FieldInvoiceLogoURL:
		return m.OldInvoiceLogoURL(ctx)
	case invoicecontrol.FieldInvoiceDateFormat:
		return m.OldInvoiceDateFormat(ctx)
	case invoicecontrol.FieldInvoiceDueAfterDays:
		return m.OldInvoiceDueAfterDays(ctx)
	case invoicecontrol.FieldInvoiceLogoWidth:
		return m.OldInvoiceLogoWidth(ctx)
	case invoicecontrol.FieldShowAmountDue:
		return m.OldShowAmountDue(ctx)
	case invoicecontrol.FieldAttachPdf:
		return m.OldAttachPdf(ctx)
	case invoicecontrol.FieldShowInvoiceDueDate:
		return m.OldShowInvoiceDueDate(ctx)
	}
	return nil, fmt.Errorf("unknown InvoiceControl field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvoiceControlMutation) SetField(name string, value ent.Value) error {
	switch name {
	case invoicecontrol.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case invoicecontrol.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case invoicecontrol.FieldInvoiceNumberPrefix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceNumberPrefix(v)
		return nil
	case invoicecontrol.FieldCreditMemoNumberPrefix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreditMemoNumberPrefix(v)
		return nil
	case invoicecontrol.FieldInvoiceTerms:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceTerms(v)
		return nil
	case invoicecontrol.FieldInvoiceFooter:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceFooter(v)
		return nil
	case invoicecontrol.FieldInvoiceLogoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceLogoURL(v)
		return nil
	case invoicecontrol.FieldInvoiceDateFormat:
		v, ok := value.(invoicecontrol.InvoiceDateFormat)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceDateFormat(v)
		return nil
	case invoicecontrol.FieldInvoiceDueAfterDays:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceDueAfterDays(v)
		return nil
	case invoicecontrol.FieldInvoiceLogoWidth:
		v, ok := value.(uint16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceLogoWidth(v)
		return nil
	case invoicecontrol.FieldShowAmountDue:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShowAmountDue(v)
		return nil
	case invoicecontrol.FieldAttachPdf:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttachPdf(v)
		return nil
	case invoicecontrol.FieldShowInvoiceDueDate:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShowInvoiceDueDate(v)
		return nil
	}
	return fmt.Errorf("unknown InvoiceControl field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InvoiceControlMutation) AddedFields() []string {
	var fields []string
	if m.addinvoice_due_after_days != nil {
		fields = append(fields, invoicecontrol.FieldInvoiceDueAfterDays)
	}
	if m.addinvoice_logo_width != nil {
		fields = append(fields, invoicecontrol.FieldInvoiceLogoWidth)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InvoiceControlMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case invoicecontrol.FieldInvoiceDueAfterDays:
		return m.AddedInvoiceDueAfterDays()
	case invoicecontrol.FieldInvoiceLogoWidth:
		return m.AddedInvoiceLogoWidth()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvoiceControlMutation) AddField(name string, value ent.Value) error {
	switch name {
	case invoicecontrol.FieldInvoiceDueAfterDays:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInvoiceDueAfterDays(v)
		return nil
	case invoicecontrol.FieldInvoiceLogoWidth:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInvoiceLogoWidth(v)
		return nil
	}
	return fmt.Errorf("unknown InvoiceControl numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InvoiceControlMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(invoicecontrol.FieldInvoiceTerms) {
		fields = append(fields, invoicecontrol.FieldInvoiceTerms)
	}
	if m.FieldCleared(invoicecontrol.FieldInvoiceFooter) {
		fields = append(fields, invoicecontrol.FieldInvoiceFooter)
	}
	if m.FieldCleared(invoicecontrol.FieldInvoiceLogoURL) {
		fields = append(fields, invoicecontrol.FieldInvoiceLogoURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InvoiceControlMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InvoiceControlMutation) ClearField(name string) error {
	switch name {
	case invoicecontrol.FieldInvoiceTerms:
		m.ClearInvoiceTerms()
		return nil
	case invoicecontrol.FieldInvoiceFooter:
		m.ClearInvoiceFooter()
		return nil
	case invoicecontrol.FieldInvoiceLogoURL:
		m.ClearInvoiceLogoURL()
		return nil
	}
	return fmt.Errorf("unknown InvoiceControl nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InvoiceControlMutation) ResetField(name string) error {
	switch name {
	case invoicecontrol.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case invoicecontrol.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case invoicecontrol.FieldInvoiceNumberPrefix:
		m.ResetInvoiceNumberPrefix()
		return nil
	case invoicecontrol.FieldCreditMemoNumberPrefix:
		m.ResetCreditMemoNumberPrefix()
		return nil
	case invoicecontrol.FieldInvoiceTerms:
		m.ResetInvoiceTerms()
		return nil
	case invoicecontrol.FieldInvoiceFooter:
		m.ResetInvoiceFooter()
		return nil
	case invoicecontrol.FieldInvoiceLogoURL:
		m.ResetInvoiceLogoURL()
		return nil
	case invoicecontrol.FieldInvoiceDateFormat:
		m.ResetInvoiceDateFormat()
		return nil
	case invoicecontrol.FieldInvoiceDueAfterDays:
		m.ResetInvoiceDueAfterDays()
		return nil
	case invoicecontrol.FieldInvoiceLogoWidth:
		m.ResetInvoiceLogoWidth()
		return nil
	case invoicecontrol.FieldShowAmountDue:
		m.ResetShowAmountDue()
		return nil
	case invoicecontrol.FieldAttachPdf:
		m.ResetAttachPdf()
		return nil
	case invoicecontrol.FieldShowInvoiceDueDate:
		m.ResetShowInvoiceDueDate()
		return nil
	}
	return fmt.Errorf("unknown InvoiceControl field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InvoiceControlMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.organization != nil {
		edges = append(edges, invoicecontrol.EdgeOrganization)
	}
	if m.business_unit != nil {
		edges = append(edges, invoicecontrol.EdgeBusinessUnit)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InvoiceControlMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case invoicecontrol.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case invoicecontrol.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InvoiceControlMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InvoiceControlMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InvoiceControlMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorganization {
		edges = append(edges, invoicecontrol.EdgeOrganization)
	}
	if m.clearedbusiness_unit {
		edges = append(edges, invoicecontrol.EdgeBusinessUnit)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InvoiceControlMutation) EdgeCleared(name string) bool {
	switch name {
	case invoicecontrol.EdgeOrganization:
		return m.clearedorganization
	case invoicecontrol.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InvoiceControlMutation) ClearEdge(name string) error {
	switch name {
	case invoicecontrol.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case invoicecontrol.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	}
	return fmt.Errorf("unknown InvoiceControl unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InvoiceControlMutation) ResetEdge(name string) error {
	switch name {
	case invoicecontrol.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case invoicecontrol.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	}
	return fmt.Errorf("unknown InvoiceControl edge %s", name)
}

// OrganizationMutation represents an operation that mutates the Organization nodes in the graph.
type OrganizationMutation struct {
	config
	op                              Op
	typ                             string
	id                              *uuid.UUID
	created_at                      *time.Time
	updated_at                      *time.Time
	name                            *string
	scac_code                       *string
	dot_number                      *string
	logo_url                        *string
	org_type                        *organization.OrgType
	timezone                        *organization.Timezone
	clearedFields                   map[string]struct{}
	business_unit                   *uuid.UUID
	clearedbusiness_unit            bool
	accounting_control              *uuid.UUID
	clearedaccounting_control       bool
	billing_control                 *uuid.UUID
	clearedbilling_control          bool
	dispatch_control                *uuid.UUID
	cleareddispatch_control         bool
	feasibility_tool_control        *uuid.UUID
	clearedfeasibility_tool_control bool
	invoice_control                 *uuid.UUID
	clearedinvoice_control          bool
	route_control                   *uuid.UUID
	clearedroute_control            bool
	shipment_control                *uuid.UUID
	clearedshipment_control         bool
	done                            bool
	oldValue                        func(context.Context) (*Organization, error)
	predicates                      []predicate.Organization
}

var _ ent.Mutation = (*OrganizationMutation)(nil)

// organizationOption allows management of the mutation configuration using functional options.
type organizationOption func(*OrganizationMutation)

// newOrganizationMutation creates new mutation for the Organization entity.
func newOrganizationMutation(c config, op Op, opts ...organizationOption) *OrganizationMutation {
	m := &OrganizationMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganization,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationID sets the ID field of the mutation.
func withOrganizationID(id uuid.UUID) organizationOption {
	return func(m *OrganizationMutation) {
		var (
			err   error
			once  sync.Once
			value *Organization
		)
		m.oldValue = func(ctx context.Context) (*Organization, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Organization.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganization sets the old Organization of the mutation.
func withOrganization(node *Organization) organizationOption {
	return func(m *OrganizationMutation) {
		m.oldValue = func(context.Context) (*Organization, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Organization entities.
func (m *OrganizationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Organization.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrganizationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrganizationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrganizationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *OrganizationMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *OrganizationMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *OrganizationMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetName sets the "name" field.
func (m *OrganizationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrganizationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrganizationMutation) ResetName() {
	m.name = nil
}

// SetScacCode sets the "scac_code" field.
func (m *OrganizationMutation) SetScacCode(s string) {
	m.scac_code = &s
}

// ScacCode returns the value of the "scac_code" field in the mutation.
func (m *OrganizationMutation) ScacCode() (r string, exists bool) {
	v := m.scac_code
	if v == nil {
		return
	}
	return *v, true
}

// OldScacCode returns the old "scac_code" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldScacCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScacCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScacCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScacCode: %w", err)
	}
	return oldValue.ScacCode, nil
}

// ResetScacCode resets all changes to the "scac_code" field.
func (m *OrganizationMutation) ResetScacCode() {
	m.scac_code = nil
}

// SetDotNumber sets the "dot_number" field.
func (m *OrganizationMutation) SetDotNumber(s string) {
	m.dot_number = &s
}

// DotNumber returns the value of the "dot_number" field in the mutation.
func (m *OrganizationMutation) DotNumber() (r string, exists bool) {
	v := m.dot_number
	if v == nil {
		return
	}
	return *v, true
}

// OldDotNumber returns the old "dot_number" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldDotNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDotNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDotNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDotNumber: %w", err)
	}
	return oldValue.DotNumber, nil
}

// ResetDotNumber resets all changes to the "dot_number" field.
func (m *OrganizationMutation) ResetDotNumber() {
	m.dot_number = nil
}

// SetLogoURL sets the "logo_url" field.
func (m *OrganizationMutation) SetLogoURL(s string) {
	m.logo_url = &s
}

// LogoURL returns the value of the "logo_url" field in the mutation.
func (m *OrganizationMutation) LogoURL() (r string, exists bool) {
	v := m.logo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldLogoURL returns the old "logo_url" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldLogoURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogoURL: %w", err)
	}
	return oldValue.LogoURL, nil
}

// ClearLogoURL clears the value of the "logo_url" field.
func (m *OrganizationMutation) ClearLogoURL() {
	m.logo_url = nil
	m.clearedFields[organization.FieldLogoURL] = struct{}{}
}

// LogoURLCleared returns if the "logo_url" field was cleared in this mutation.
func (m *OrganizationMutation) LogoURLCleared() bool {
	_, ok := m.clearedFields[organization.FieldLogoURL]
	return ok
}

// ResetLogoURL resets all changes to the "logo_url" field.
func (m *OrganizationMutation) ResetLogoURL() {
	m.logo_url = nil
	delete(m.clearedFields, organization.FieldLogoURL)
}

// SetOrgType sets the "org_type" field.
func (m *OrganizationMutation) SetOrgType(ot organization.OrgType) {
	m.org_type = &ot
}

// OrgType returns the value of the "org_type" field in the mutation.
func (m *OrganizationMutation) OrgType() (r organization.OrgType, exists bool) {
	v := m.org_type
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgType returns the old "org_type" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldOrgType(ctx context.Context) (v organization.OrgType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrgType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrgType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgType: %w", err)
	}
	return oldValue.OrgType, nil
}

// ResetOrgType resets all changes to the "org_type" field.
func (m *OrganizationMutation) ResetOrgType() {
	m.org_type = nil
}

// SetTimezone sets the "timezone" field.
func (m *OrganizationMutation) SetTimezone(o organization.Timezone) {
	m.timezone = &o
}

// Timezone returns the value of the "timezone" field in the mutation.
func (m *OrganizationMutation) Timezone() (r organization.Timezone, exists bool) {
	v := m.timezone
	if v == nil {
		return
	}
	return *v, true
}

// OldTimezone returns the old "timezone" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldTimezone(ctx context.Context) (v organization.Timezone, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimezone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimezone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimezone: %w", err)
	}
	return oldValue.Timezone, nil
}

// ResetTimezone resets all changes to the "timezone" field.
func (m *OrganizationMutation) ResetTimezone() {
	m.timezone = nil
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *OrganizationMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[organization.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *OrganizationMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *OrganizationMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// SetAccountingControlID sets the "accounting_control" edge to the AccountingControl entity by id.
func (m *OrganizationMutation) SetAccountingControlID(id uuid.UUID) {
	m.accounting_control = &id
}

// ClearAccountingControl clears the "accounting_control" edge to the AccountingControl entity.
func (m *OrganizationMutation) ClearAccountingControl() {
	m.clearedaccounting_control = true
}

// AccountingControlCleared reports if the "accounting_control" edge to the AccountingControl entity was cleared.
func (m *OrganizationMutation) AccountingControlCleared() bool {
	return m.clearedaccounting_control
}

// AccountingControlID returns the "accounting_control" edge ID in the mutation.
func (m *OrganizationMutation) AccountingControlID() (id uuid.UUID, exists bool) {
	if m.accounting_control != nil {
		return *m.accounting_control, true
	}
	return
}

// AccountingControlIDs returns the "accounting_control" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountingControlID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) AccountingControlIDs() (ids []uuid.UUID) {
	if id := m.accounting_control; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccountingControl resets all changes to the "accounting_control" edge.
func (m *OrganizationMutation) ResetAccountingControl() {
	m.accounting_control = nil
	m.clearedaccounting_control = false
}

// SetBillingControlID sets the "billing_control" edge to the BillingControl entity by id.
func (m *OrganizationMutation) SetBillingControlID(id uuid.UUID) {
	m.billing_control = &id
}

// ClearBillingControl clears the "billing_control" edge to the BillingControl entity.
func (m *OrganizationMutation) ClearBillingControl() {
	m.clearedbilling_control = true
}

// BillingControlCleared reports if the "billing_control" edge to the BillingControl entity was cleared.
func (m *OrganizationMutation) BillingControlCleared() bool {
	return m.clearedbilling_control
}

// BillingControlID returns the "billing_control" edge ID in the mutation.
func (m *OrganizationMutation) BillingControlID() (id uuid.UUID, exists bool) {
	if m.billing_control != nil {
		return *m.billing_control, true
	}
	return
}

// BillingControlIDs returns the "billing_control" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BillingControlID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) BillingControlIDs() (ids []uuid.UUID) {
	if id := m.billing_control; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBillingControl resets all changes to the "billing_control" edge.
func (m *OrganizationMutation) ResetBillingControl() {
	m.billing_control = nil
	m.clearedbilling_control = false
}

// SetDispatchControlID sets the "dispatch_control" edge to the DispatchControl entity by id.
func (m *OrganizationMutation) SetDispatchControlID(id uuid.UUID) {
	m.dispatch_control = &id
}

// ClearDispatchControl clears the "dispatch_control" edge to the DispatchControl entity.
func (m *OrganizationMutation) ClearDispatchControl() {
	m.cleareddispatch_control = true
}

// DispatchControlCleared reports if the "dispatch_control" edge to the DispatchControl entity was cleared.
func (m *OrganizationMutation) DispatchControlCleared() bool {
	return m.cleareddispatch_control
}

// DispatchControlID returns the "dispatch_control" edge ID in the mutation.
func (m *OrganizationMutation) DispatchControlID() (id uuid.UUID, exists bool) {
	if m.dispatch_control != nil {
		return *m.dispatch_control, true
	}
	return
}

// DispatchControlIDs returns the "dispatch_control" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DispatchControlID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) DispatchControlIDs() (ids []uuid.UUID) {
	if id := m.dispatch_control; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDispatchControl resets all changes to the "dispatch_control" edge.
func (m *OrganizationMutation) ResetDispatchControl() {
	m.dispatch_control = nil
	m.cleareddispatch_control = false
}

// SetFeasibilityToolControlID sets the "feasibility_tool_control" edge to the FeasibilityToolControl entity by id.
func (m *OrganizationMutation) SetFeasibilityToolControlID(id uuid.UUID) {
	m.feasibility_tool_control = &id
}

// ClearFeasibilityToolControl clears the "feasibility_tool_control" edge to the FeasibilityToolControl entity.
func (m *OrganizationMutation) ClearFeasibilityToolControl() {
	m.clearedfeasibility_tool_control = true
}

// FeasibilityToolControlCleared reports if the "feasibility_tool_control" edge to the FeasibilityToolControl entity was cleared.
func (m *OrganizationMutation) FeasibilityToolControlCleared() bool {
	return m.clearedfeasibility_tool_control
}

// FeasibilityToolControlID returns the "feasibility_tool_control" edge ID in the mutation.
func (m *OrganizationMutation) FeasibilityToolControlID() (id uuid.UUID, exists bool) {
	if m.feasibility_tool_control != nil {
		return *m.feasibility_tool_control, true
	}
	return
}

// FeasibilityToolControlIDs returns the "feasibility_tool_control" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FeasibilityToolControlID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) FeasibilityToolControlIDs() (ids []uuid.UUID) {
	if id := m.feasibility_tool_control; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFeasibilityToolControl resets all changes to the "feasibility_tool_control" edge.
func (m *OrganizationMutation) ResetFeasibilityToolControl() {
	m.feasibility_tool_control = nil
	m.clearedfeasibility_tool_control = false
}

// SetInvoiceControlID sets the "invoice_control" edge to the InvoiceControl entity by id.
func (m *OrganizationMutation) SetInvoiceControlID(id uuid.UUID) {
	m.invoice_control = &id
}

// ClearInvoiceControl clears the "invoice_control" edge to the InvoiceControl entity.
func (m *OrganizationMutation) ClearInvoiceControl() {
	m.clearedinvoice_control = true
}

// InvoiceControlCleared reports if the "invoice_control" edge to the InvoiceControl entity was cleared.
func (m *OrganizationMutation) InvoiceControlCleared() bool {
	return m.clearedinvoice_control
}

// InvoiceControlID returns the "invoice_control" edge ID in the mutation.
func (m *OrganizationMutation) InvoiceControlID() (id uuid.UUID, exists bool) {
	if m.invoice_control != nil {
		return *m.invoice_control, true
	}
	return
}

// InvoiceControlIDs returns the "invoice_control" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InvoiceControlID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) InvoiceControlIDs() (ids []uuid.UUID) {
	if id := m.invoice_control; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInvoiceControl resets all changes to the "invoice_control" edge.
func (m *OrganizationMutation) ResetInvoiceControl() {
	m.invoice_control = nil
	m.clearedinvoice_control = false
}

// SetRouteControlID sets the "route_control" edge to the RouteControl entity by id.
func (m *OrganizationMutation) SetRouteControlID(id uuid.UUID) {
	m.route_control = &id
}

// ClearRouteControl clears the "route_control" edge to the RouteControl entity.
func (m *OrganizationMutation) ClearRouteControl() {
	m.clearedroute_control = true
}

// RouteControlCleared reports if the "route_control" edge to the RouteControl entity was cleared.
func (m *OrganizationMutation) RouteControlCleared() bool {
	return m.clearedroute_control
}

// RouteControlID returns the "route_control" edge ID in the mutation.
func (m *OrganizationMutation) RouteControlID() (id uuid.UUID, exists bool) {
	if m.route_control != nil {
		return *m.route_control, true
	}
	return
}

// RouteControlIDs returns the "route_control" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RouteControlID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) RouteControlIDs() (ids []uuid.UUID) {
	if id := m.route_control; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRouteControl resets all changes to the "route_control" edge.
func (m *OrganizationMutation) ResetRouteControl() {
	m.route_control = nil
	m.clearedroute_control = false
}

// SetShipmentControlID sets the "shipment_control" edge to the ShipmentControl entity by id.
func (m *OrganizationMutation) SetShipmentControlID(id uuid.UUID) {
	m.shipment_control = &id
}

// ClearShipmentControl clears the "shipment_control" edge to the ShipmentControl entity.
func (m *OrganizationMutation) ClearShipmentControl() {
	m.clearedshipment_control = true
}

// ShipmentControlCleared reports if the "shipment_control" edge to the ShipmentControl entity was cleared.
func (m *OrganizationMutation) ShipmentControlCleared() bool {
	return m.clearedshipment_control
}

// ShipmentControlID returns the "shipment_control" edge ID in the mutation.
func (m *OrganizationMutation) ShipmentControlID() (id uuid.UUID, exists bool) {
	if m.shipment_control != nil {
		return *m.shipment_control, true
	}
	return
}

// ShipmentControlIDs returns the "shipment_control" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentControlID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) ShipmentControlIDs() (ids []uuid.UUID) {
	if id := m.shipment_control; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipmentControl resets all changes to the "shipment_control" edge.
func (m *OrganizationMutation) ResetShipmentControl() {
	m.shipment_control = nil
	m.clearedshipment_control = false
}

// Where appends a list predicates to the OrganizationMutation builder.
func (m *OrganizationMutation) Where(ps ...predicate.Organization) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Organization, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Organization).
func (m *OrganizationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, organization.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, organization.FieldUpdatedAt)
	}
	if m.business_unit != nil {
		fields = append(fields, organization.FieldBusinessUnitID)
	}
	if m.name != nil {
		fields = append(fields, organization.FieldName)
	}
	if m.scac_code != nil {
		fields = append(fields, organization.FieldScacCode)
	}
	if m.dot_number != nil {
		fields = append(fields, organization.FieldDotNumber)
	}
	if m.logo_url != nil {
		fields = append(fields, organization.FieldLogoURL)
	}
	if m.org_type != nil {
		fields = append(fields, organization.FieldOrgType)
	}
	if m.timezone != nil {
		fields = append(fields, organization.FieldTimezone)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organization.FieldCreatedAt:
		return m.CreatedAt()
	case organization.FieldUpdatedAt:
		return m.UpdatedAt()
	case organization.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case organization.FieldName:
		return m.Name()
	case organization.FieldScacCode:
		return m.ScacCode()
	case organization.FieldDotNumber:
		return m.DotNumber()
	case organization.FieldLogoURL:
		return m.LogoURL()
	case organization.FieldOrgType:
		return m.OrgType()
	case organization.FieldTimezone:
		return m.Timezone()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organization.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case organization.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case organization.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case organization.FieldName:
		return m.OldName(ctx)
	case organization.FieldScacCode:
		return m.OldScacCode(ctx)
	case organization.FieldDotNumber:
		return m.OldDotNumber(ctx)
	case organization.FieldLogoURL:
		return m.OldLogoURL(ctx)
	case organization.FieldOrgType:
		return m.OldOrgType(ctx)
	case organization.FieldTimezone:
		return m.OldTimezone(ctx)
	}
	return nil, fmt.Errorf("unknown Organization field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organization.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organization.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case organization.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case organization.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case organization.FieldScacCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScacCode(v)
		return nil
	case organization.FieldDotNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDotNumber(v)
		return nil
	case organization.FieldLogoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogoURL(v)
		return nil
	case organization.FieldOrgType:
		v, ok := value.(organization.OrgType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgType(v)
		return nil
	case organization.FieldTimezone:
		v, ok := value.(organization.Timezone)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimezone(v)
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Organization numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organization.FieldLogoURL) {
		fields = append(fields, organization.FieldLogoURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationMutation) ClearField(name string) error {
	switch name {
	case organization.FieldLogoURL:
		m.ClearLogoURL()
		return nil
	}
	return fmt.Errorf("unknown Organization nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationMutation) ResetField(name string) error {
	switch name {
	case organization.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organization.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case organization.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case organization.FieldName:
		m.ResetName()
		return nil
	case organization.FieldScacCode:
		m.ResetScacCode()
		return nil
	case organization.FieldDotNumber:
		m.ResetDotNumber()
		return nil
	case organization.FieldLogoURL:
		m.ResetLogoURL()
		return nil
	case organization.FieldOrgType:
		m.ResetOrgType()
		return nil
	case organization.FieldTimezone:
		m.ResetTimezone()
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.business_unit != nil {
		edges = append(edges, organization.EdgeBusinessUnit)
	}
	if m.accounting_control != nil {
		edges = append(edges, organization.EdgeAccountingControl)
	}
	if m.billing_control != nil {
		edges = append(edges, organization.EdgeBillingControl)
	}
	if m.dispatch_control != nil {
		edges = append(edges, organization.EdgeDispatchControl)
	}
	if m.feasibility_tool_control != nil {
		edges = append(edges, organization.EdgeFeasibilityToolControl)
	}
	if m.invoice_control != nil {
		edges = append(edges, organization.EdgeInvoiceControl)
	}
	if m.route_control != nil {
		edges = append(edges, organization.EdgeRouteControl)
	}
	if m.shipment_control != nil {
		edges = append(edges, organization.EdgeShipmentControl)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case organization.EdgeAccountingControl:
		if id := m.accounting_control; id != nil {
			return []ent.Value{*id}
		}
	case organization.EdgeBillingControl:
		if id := m.billing_control; id != nil {
			return []ent.Value{*id}
		}
	case organization.EdgeDispatchControl:
		if id := m.dispatch_control; id != nil {
			return []ent.Value{*id}
		}
	case organization.EdgeFeasibilityToolControl:
		if id := m.feasibility_tool_control; id != nil {
			return []ent.Value{*id}
		}
	case organization.EdgeInvoiceControl:
		if id := m.invoice_control; id != nil {
			return []ent.Value{*id}
		}
	case organization.EdgeRouteControl:
		if id := m.route_control; id != nil {
			return []ent.Value{*id}
		}
	case organization.EdgeShipmentControl:
		if id := m.shipment_control; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedbusiness_unit {
		edges = append(edges, organization.EdgeBusinessUnit)
	}
	if m.clearedaccounting_control {
		edges = append(edges, organization.EdgeAccountingControl)
	}
	if m.clearedbilling_control {
		edges = append(edges, organization.EdgeBillingControl)
	}
	if m.cleareddispatch_control {
		edges = append(edges, organization.EdgeDispatchControl)
	}
	if m.clearedfeasibility_tool_control {
		edges = append(edges, organization.EdgeFeasibilityToolControl)
	}
	if m.clearedinvoice_control {
		edges = append(edges, organization.EdgeInvoiceControl)
	}
	if m.clearedroute_control {
		edges = append(edges, organization.EdgeRouteControl)
	}
	if m.clearedshipment_control {
		edges = append(edges, organization.EdgeShipmentControl)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationMutation) EdgeCleared(name string) bool {
	switch name {
	case organization.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case organization.EdgeAccountingControl:
		return m.clearedaccounting_control
	case organization.EdgeBillingControl:
		return m.clearedbilling_control
	case organization.EdgeDispatchControl:
		return m.cleareddispatch_control
	case organization.EdgeFeasibilityToolControl:
		return m.clearedfeasibility_tool_control
	case organization.EdgeInvoiceControl:
		return m.clearedinvoice_control
	case organization.EdgeRouteControl:
		return m.clearedroute_control
	case organization.EdgeShipmentControl:
		return m.clearedshipment_control
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationMutation) ClearEdge(name string) error {
	switch name {
	case organization.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case organization.EdgeAccountingControl:
		m.ClearAccountingControl()
		return nil
	case organization.EdgeBillingControl:
		m.ClearBillingControl()
		return nil
	case organization.EdgeDispatchControl:
		m.ClearDispatchControl()
		return nil
	case organization.EdgeFeasibilityToolControl:
		m.ClearFeasibilityToolControl()
		return nil
	case organization.EdgeInvoiceControl:
		m.ClearInvoiceControl()
		return nil
	case organization.EdgeRouteControl:
		m.ClearRouteControl()
		return nil
	case organization.EdgeShipmentControl:
		m.ClearShipmentControl()
		return nil
	}
	return fmt.Errorf("unknown Organization unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationMutation) ResetEdge(name string) error {
	switch name {
	case organization.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case organization.EdgeAccountingControl:
		m.ResetAccountingControl()
		return nil
	case organization.EdgeBillingControl:
		m.ResetBillingControl()
		return nil
	case organization.EdgeDispatchControl:
		m.ResetDispatchControl()
		return nil
	case organization.EdgeFeasibilityToolControl:
		m.ResetFeasibilityToolControl()
		return nil
	case organization.EdgeInvoiceControl:
		m.ResetInvoiceControl()
		return nil
	case organization.EdgeRouteControl:
		m.ResetRouteControl()
		return nil
	case organization.EdgeShipmentControl:
		m.ResetShipmentControl()
		return nil
	}
	return fmt.Errorf("unknown Organization edge %s", name)
}

// RouteControlMutation represents an operation that mutates the RouteControl nodes in the graph.
type RouteControlMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	distance_method      *routecontrol.DistanceMethod
	mileage_unit         *routecontrol.MileageUnit
	generate_routes      *bool
	clearedFields        map[string]struct{}
	organization         *uuid.UUID
	clearedorganization  bool
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	done                 bool
	oldValue             func(context.Context) (*RouteControl, error)
	predicates           []predicate.RouteControl
}

var _ ent.Mutation = (*RouteControlMutation)(nil)

// routecontrolOption allows management of the mutation configuration using functional options.
type routecontrolOption func(*RouteControlMutation)

// newRouteControlMutation creates new mutation for the RouteControl entity.
func newRouteControlMutation(c config, op Op, opts ...routecontrolOption) *RouteControlMutation {
	m := &RouteControlMutation{
		config:        c,
		op:            op,
		typ:           TypeRouteControl,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRouteControlID sets the ID field of the mutation.
func withRouteControlID(id uuid.UUID) routecontrolOption {
	return func(m *RouteControlMutation) {
		var (
			err   error
			once  sync.Once
			value *RouteControl
		)
		m.oldValue = func(ctx context.Context) (*RouteControl, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RouteControl.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRouteControl sets the old RouteControl of the mutation.
func withRouteControl(node *RouteControl) routecontrolOption {
	return func(m *RouteControlMutation) {
		m.oldValue = func(context.Context) (*RouteControl, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RouteControlMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RouteControlMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RouteControl entities.
func (m *RouteControlMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RouteControlMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RouteControlMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RouteControl.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RouteControlMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RouteControlMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RouteControl entity.
// If the RouteControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteControlMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RouteControlMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RouteControlMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RouteControlMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RouteControl entity.
// If the RouteControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteControlMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RouteControlMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDistanceMethod sets the "distance_method" field.
func (m *RouteControlMutation) SetDistanceMethod(rm routecontrol.DistanceMethod) {
	m.distance_method = &rm
}

// DistanceMethod returns the value of the "distance_method" field in the mutation.
func (m *RouteControlMutation) DistanceMethod() (r routecontrol.DistanceMethod, exists bool) {
	v := m.distance_method
	if v == nil {
		return
	}
	return *v, true
}

// OldDistanceMethod returns the old "distance_method" field's value of the RouteControl entity.
// If the RouteControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteControlMutation) OldDistanceMethod(ctx context.Context) (v routecontrol.DistanceMethod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDistanceMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDistanceMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistanceMethod: %w", err)
	}
	return oldValue.DistanceMethod, nil
}

// ResetDistanceMethod resets all changes to the "distance_method" field.
func (m *RouteControlMutation) ResetDistanceMethod() {
	m.distance_method = nil
}

// SetMileageUnit sets the "mileage_unit" field.
func (m *RouteControlMutation) SetMileageUnit(ru routecontrol.MileageUnit) {
	m.mileage_unit = &ru
}

// MileageUnit returns the value of the "mileage_unit" field in the mutation.
func (m *RouteControlMutation) MileageUnit() (r routecontrol.MileageUnit, exists bool) {
	v := m.mileage_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldMileageUnit returns the old "mileage_unit" field's value of the RouteControl entity.
// If the RouteControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteControlMutation) OldMileageUnit(ctx context.Context) (v routecontrol.MileageUnit, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMileageUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMileageUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMileageUnit: %w", err)
	}
	return oldValue.MileageUnit, nil
}

// ResetMileageUnit resets all changes to the "mileage_unit" field.
func (m *RouteControlMutation) ResetMileageUnit() {
	m.mileage_unit = nil
}

// SetGenerateRoutes sets the "generate_routes" field.
func (m *RouteControlMutation) SetGenerateRoutes(b bool) {
	m.generate_routes = &b
}

// GenerateRoutes returns the value of the "generate_routes" field in the mutation.
func (m *RouteControlMutation) GenerateRoutes() (r bool, exists bool) {
	v := m.generate_routes
	if v == nil {
		return
	}
	return *v, true
}

// OldGenerateRoutes returns the old "generate_routes" field's value of the RouteControl entity.
// If the RouteControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteControlMutation) OldGenerateRoutes(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGenerateRoutes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGenerateRoutes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenerateRoutes: %w", err)
	}
	return oldValue.GenerateRoutes, nil
}

// ResetGenerateRoutes resets all changes to the "generate_routes" field.
func (m *RouteControlMutation) ResetGenerateRoutes() {
	m.generate_routes = nil
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *RouteControlMutation) SetOrganizationID(id uuid.UUID) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *RouteControlMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *RouteControlMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *RouteControlMutation) OrganizationID() (id uuid.UUID, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *RouteControlMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *RouteControlMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// SetBusinessUnitID sets the "business_unit" edge to the BusinessUnit entity by id.
func (m *RouteControlMutation) SetBusinessUnitID(id uuid.UUID) {
	m.business_unit = &id
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *RouteControlMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *RouteControlMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitID returns the "business_unit" edge ID in the mutation.
func (m *RouteControlMutation) BusinessUnitID() (id uuid.UUID, exists bool) {
	if m.business_unit != nil {
		return *m.business_unit, true
	}
	return
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *RouteControlMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *RouteControlMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// Where appends a list predicates to the RouteControlMutation builder.
func (m *RouteControlMutation) Where(ps ...predicate.RouteControl) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RouteControlMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RouteControlMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RouteControl, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RouteControlMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RouteControlMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RouteControl).
func (m *RouteControlMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RouteControlMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, routecontrol.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, routecontrol.FieldUpdatedAt)
	}
	if m.distance_method != nil {
		fields = append(fields, routecontrol.FieldDistanceMethod)
	}
	if m.mileage_unit != nil {
		fields = append(fields, routecontrol.FieldMileageUnit)
	}
	if m.generate_routes != nil {
		fields = append(fields, routecontrol.FieldGenerateRoutes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RouteControlMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case routecontrol.FieldCreatedAt:
		return m.CreatedAt()
	case routecontrol.FieldUpdatedAt:
		return m.UpdatedAt()
	case routecontrol.FieldDistanceMethod:
		return m.DistanceMethod()
	case routecontrol.FieldMileageUnit:
		return m.MileageUnit()
	case routecontrol.FieldGenerateRoutes:
		return m.GenerateRoutes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RouteControlMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case routecontrol.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case routecontrol.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case routecontrol.FieldDistanceMethod:
		return m.OldDistanceMethod(ctx)
	case routecontrol.FieldMileageUnit:
		return m.OldMileageUnit(ctx)
	case routecontrol.FieldGenerateRoutes:
		return m.OldGenerateRoutes(ctx)
	}
	return nil, fmt.Errorf("unknown RouteControl field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RouteControlMutation) SetField(name string, value ent.Value) error {
	switch name {
	case routecontrol.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case routecontrol.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case routecontrol.FieldDistanceMethod:
		v, ok := value.(routecontrol.DistanceMethod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistanceMethod(v)
		return nil
	case routecontrol.FieldMileageUnit:
		v, ok := value.(routecontrol.MileageUnit)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMileageUnit(v)
		return nil
	case routecontrol.FieldGenerateRoutes:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenerateRoutes(v)
		return nil
	}
	return fmt.Errorf("unknown RouteControl field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RouteControlMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RouteControlMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RouteControlMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RouteControl numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RouteControlMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RouteControlMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RouteControlMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RouteControl nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RouteControlMutation) ResetField(name string) error {
	switch name {
	case routecontrol.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case routecontrol.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case routecontrol.FieldDistanceMethod:
		m.ResetDistanceMethod()
		return nil
	case routecontrol.FieldMileageUnit:
		m.ResetMileageUnit()
		return nil
	case routecontrol.FieldGenerateRoutes:
		m.ResetGenerateRoutes()
		return nil
	}
	return fmt.Errorf("unknown RouteControl field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RouteControlMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.organization != nil {
		edges = append(edges, routecontrol.EdgeOrganization)
	}
	if m.business_unit != nil {
		edges = append(edges, routecontrol.EdgeBusinessUnit)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RouteControlMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case routecontrol.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case routecontrol.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RouteControlMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RouteControlMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RouteControlMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorganization {
		edges = append(edges, routecontrol.EdgeOrganization)
	}
	if m.clearedbusiness_unit {
		edges = append(edges, routecontrol.EdgeBusinessUnit)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RouteControlMutation) EdgeCleared(name string) bool {
	switch name {
	case routecontrol.EdgeOrganization:
		return m.clearedorganization
	case routecontrol.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RouteControlMutation) ClearEdge(name string) error {
	switch name {
	case routecontrol.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case routecontrol.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	}
	return fmt.Errorf("unknown RouteControl unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RouteControlMutation) ResetEdge(name string) error {
	switch name {
	case routecontrol.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case routecontrol.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	}
	return fmt.Errorf("unknown RouteControl edge %s", name)
}

// ShipmentControlMutation represents an operation that mutates the ShipmentControl nodes in the graph.
type ShipmentControlMutation struct {
	config
	op                         Op
	typ                        string
	id                         *uuid.UUID
	created_at                 *time.Time
	updated_at                 *time.Time
	auto_rate_shipment         *bool
	calculate_distance         *bool
	enforce_rev_code           *bool
	enforce_voided_comm        *bool
	generate_routes            *bool
	enforce_commodity          *bool
	auto_sequence_stops        *bool
	auto_shipment_total        *bool
	enforce_origin_destination *bool
	check_for_duplicate_bol    *bool
	send_placard_info          *bool
	enforce_hazmat_seg_rules   *bool
	clearedFields              map[string]struct{}
	organization               *uuid.UUID
	clearedorganization        bool
	business_unit              *uuid.UUID
	clearedbusiness_unit       bool
	done                       bool
	oldValue                   func(context.Context) (*ShipmentControl, error)
	predicates                 []predicate.ShipmentControl
}

var _ ent.Mutation = (*ShipmentControlMutation)(nil)

// shipmentcontrolOption allows management of the mutation configuration using functional options.
type shipmentcontrolOption func(*ShipmentControlMutation)

// newShipmentControlMutation creates new mutation for the ShipmentControl entity.
func newShipmentControlMutation(c config, op Op, opts ...shipmentcontrolOption) *ShipmentControlMutation {
	m := &ShipmentControlMutation{
		config:        c,
		op:            op,
		typ:           TypeShipmentControl,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShipmentControlID sets the ID field of the mutation.
func withShipmentControlID(id uuid.UUID) shipmentcontrolOption {
	return func(m *ShipmentControlMutation) {
		var (
			err   error
			once  sync.Once
			value *ShipmentControl
		)
		m.oldValue = func(ctx context.Context) (*ShipmentControl, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShipmentControl.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShipmentControl sets the old ShipmentControl of the mutation.
func withShipmentControl(node *ShipmentControl) shipmentcontrolOption {
	return func(m *ShipmentControlMutation) {
		m.oldValue = func(context.Context) (*ShipmentControl, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShipmentControlMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShipmentControlMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ShipmentControl entities.
func (m *ShipmentControlMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShipmentControlMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ShipmentControlMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ShipmentControl.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ShipmentControlMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ShipmentControlMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ShipmentControl entity.
// If the ShipmentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentControlMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ShipmentControlMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ShipmentControlMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ShipmentControlMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ShipmentControl entity.
// If the ShipmentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentControlMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ShipmentControlMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAutoRateShipment sets the "auto_rate_shipment" field.
func (m *ShipmentControlMutation) SetAutoRateShipment(b bool) {
	m.auto_rate_shipment = &b
}

// AutoRateShipment returns the value of the "auto_rate_shipment" field in the mutation.
func (m *ShipmentControlMutation) AutoRateShipment() (r bool, exists bool) {
	v := m.auto_rate_shipment
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoRateShipment returns the old "auto_rate_shipment" field's value of the ShipmentControl entity.
// If the ShipmentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentControlMutation) OldAutoRateShipment(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoRateShipment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoRateShipment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoRateShipment: %w", err)
	}
	return oldValue.AutoRateShipment, nil
}

// ResetAutoRateShipment resets all changes to the "auto_rate_shipment" field.
func (m *ShipmentControlMutation) ResetAutoRateShipment() {
	m.auto_rate_shipment = nil
}

// SetCalculateDistance sets the "calculate_distance" field.
func (m *ShipmentControlMutation) SetCalculateDistance(b bool) {
	m.calculate_distance = &b
}

// CalculateDistance returns the value of the "calculate_distance" field in the mutation.
func (m *ShipmentControlMutation) CalculateDistance() (r bool, exists bool) {
	v := m.calculate_distance
	if v == nil {
		return
	}
	return *v, true
}

// OldCalculateDistance returns the old "calculate_distance" field's value of the ShipmentControl entity.
// If the ShipmentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentControlMutation) OldCalculateDistance(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCalculateDistance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCalculateDistance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCalculateDistance: %w", err)
	}
	return oldValue.CalculateDistance, nil
}

// ResetCalculateDistance resets all changes to the "calculate_distance" field.
func (m *ShipmentControlMutation) ResetCalculateDistance() {
	m.calculate_distance = nil
}

// SetEnforceRevCode sets the "enforce_rev_code" field.
func (m *ShipmentControlMutation) SetEnforceRevCode(b bool) {
	m.enforce_rev_code = &b
}

// EnforceRevCode returns the value of the "enforce_rev_code" field in the mutation.
func (m *ShipmentControlMutation) EnforceRevCode() (r bool, exists bool) {
	v := m.enforce_rev_code
	if v == nil {
		return
	}
	return *v, true
}

// OldEnforceRevCode returns the old "enforce_rev_code" field's value of the ShipmentControl entity.
// If the ShipmentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentControlMutation) OldEnforceRevCode(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnforceRevCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnforceRevCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnforceRevCode: %w", err)
	}
	return oldValue.EnforceRevCode, nil
}

// ResetEnforceRevCode resets all changes to the "enforce_rev_code" field.
func (m *ShipmentControlMutation) ResetEnforceRevCode() {
	m.enforce_rev_code = nil
}

// SetEnforceVoidedComm sets the "enforce_voided_comm" field.
func (m *ShipmentControlMutation) SetEnforceVoidedComm(b bool) {
	m.enforce_voided_comm = &b
}

// EnforceVoidedComm returns the value of the "enforce_voided_comm" field in the mutation.
func (m *ShipmentControlMutation) EnforceVoidedComm() (r bool, exists bool) {
	v := m.enforce_voided_comm
	if v == nil {
		return
	}
	return *v, true
}

// OldEnforceVoidedComm returns the old "enforce_voided_comm" field's value of the ShipmentControl entity.
// If the ShipmentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentControlMutation) OldEnforceVoidedComm(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnforceVoidedComm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnforceVoidedComm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnforceVoidedComm: %w", err)
	}
	return oldValue.EnforceVoidedComm, nil
}

// ResetEnforceVoidedComm resets all changes to the "enforce_voided_comm" field.
func (m *ShipmentControlMutation) ResetEnforceVoidedComm() {
	m.enforce_voided_comm = nil
}

// SetGenerateRoutes sets the "generate_routes" field.
func (m *ShipmentControlMutation) SetGenerateRoutes(b bool) {
	m.generate_routes = &b
}

// GenerateRoutes returns the value of the "generate_routes" field in the mutation.
func (m *ShipmentControlMutation) GenerateRoutes() (r bool, exists bool) {
	v := m.generate_routes
	if v == nil {
		return
	}
	return *v, true
}

// OldGenerateRoutes returns the old "generate_routes" field's value of the ShipmentControl entity.
// If the ShipmentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentControlMutation) OldGenerateRoutes(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGenerateRoutes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGenerateRoutes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenerateRoutes: %w", err)
	}
	return oldValue.GenerateRoutes, nil
}

// ResetGenerateRoutes resets all changes to the "generate_routes" field.
func (m *ShipmentControlMutation) ResetGenerateRoutes() {
	m.generate_routes = nil
}

// SetEnforceCommodity sets the "enforce_commodity" field.
func (m *ShipmentControlMutation) SetEnforceCommodity(b bool) {
	m.enforce_commodity = &b
}

// EnforceCommodity returns the value of the "enforce_commodity" field in the mutation.
func (m *ShipmentControlMutation) EnforceCommodity() (r bool, exists bool) {
	v := m.enforce_commodity
	if v == nil {
		return
	}
	return *v, true
}

// OldEnforceCommodity returns the old "enforce_commodity" field's value of the ShipmentControl entity.
// If the ShipmentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentControlMutation) OldEnforceCommodity(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnforceCommodity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnforceCommodity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnforceCommodity: %w", err)
	}
	return oldValue.EnforceCommodity, nil
}

// ResetEnforceCommodity resets all changes to the "enforce_commodity" field.
func (m *ShipmentControlMutation) ResetEnforceCommodity() {
	m.enforce_commodity = nil
}

// SetAutoSequenceStops sets the "auto_sequence_stops" field.
func (m *ShipmentControlMutation) SetAutoSequenceStops(b bool) {
	m.auto_sequence_stops = &b
}

// AutoSequenceStops returns the value of the "auto_sequence_stops" field in the mutation.
func (m *ShipmentControlMutation) AutoSequenceStops() (r bool, exists bool) {
	v := m.auto_sequence_stops
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoSequenceStops returns the old "auto_sequence_stops" field's value of the ShipmentControl entity.
// If the ShipmentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentControlMutation) OldAutoSequenceStops(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoSequenceStops is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoSequenceStops requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoSequenceStops: %w", err)
	}
	return oldValue.AutoSequenceStops, nil
}

// ResetAutoSequenceStops resets all changes to the "auto_sequence_stops" field.
func (m *ShipmentControlMutation) ResetAutoSequenceStops() {
	m.auto_sequence_stops = nil
}

// SetAutoShipmentTotal sets the "auto_shipment_total" field.
func (m *ShipmentControlMutation) SetAutoShipmentTotal(b bool) {
	m.auto_shipment_total = &b
}

// AutoShipmentTotal returns the value of the "auto_shipment_total" field in the mutation.
func (m *ShipmentControlMutation) AutoShipmentTotal() (r bool, exists bool) {
	v := m.auto_shipment_total
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoShipmentTotal returns the old "auto_shipment_total" field's value of the ShipmentControl entity.
// If the ShipmentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentControlMutation) OldAutoShipmentTotal(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoShipmentTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoShipmentTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoShipmentTotal: %w", err)
	}
	return oldValue.AutoShipmentTotal, nil
}

// ResetAutoShipmentTotal resets all changes to the "auto_shipment_total" field.
func (m *ShipmentControlMutation) ResetAutoShipmentTotal() {
	m.auto_shipment_total = nil
}

// SetEnforceOriginDestination sets the "enforce_origin_destination" field.
func (m *ShipmentControlMutation) SetEnforceOriginDestination(b bool) {
	m.enforce_origin_destination = &b
}

// EnforceOriginDestination returns the value of the "enforce_origin_destination" field in the mutation.
func (m *ShipmentControlMutation) EnforceOriginDestination() (r bool, exists bool) {
	v := m.enforce_origin_destination
	if v == nil {
		return
	}
	return *v, true
}

// OldEnforceOriginDestination returns the old "enforce_origin_destination" field's value of the ShipmentControl entity.
// If the ShipmentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentControlMutation) OldEnforceOriginDestination(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnforceOriginDestination is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnforceOriginDestination requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnforceOriginDestination: %w", err)
	}
	return oldValue.EnforceOriginDestination, nil
}

// ResetEnforceOriginDestination resets all changes to the "enforce_origin_destination" field.
func (m *ShipmentControlMutation) ResetEnforceOriginDestination() {
	m.enforce_origin_destination = nil
}

// SetCheckForDuplicateBol sets the "check_for_duplicate_bol" field.
func (m *ShipmentControlMutation) SetCheckForDuplicateBol(b bool) {
	m.check_for_duplicate_bol = &b
}

// CheckForDuplicateBol returns the value of the "check_for_duplicate_bol" field in the mutation.
func (m *ShipmentControlMutation) CheckForDuplicateBol() (r bool, exists bool) {
	v := m.check_for_duplicate_bol
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckForDuplicateBol returns the old "check_for_duplicate_bol" field's value of the ShipmentControl entity.
// If the ShipmentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentControlMutation) OldCheckForDuplicateBol(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCheckForDuplicateBol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCheckForDuplicateBol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckForDuplicateBol: %w", err)
	}
	return oldValue.CheckForDuplicateBol, nil
}

// ResetCheckForDuplicateBol resets all changes to the "check_for_duplicate_bol" field.
func (m *ShipmentControlMutation) ResetCheckForDuplicateBol() {
	m.check_for_duplicate_bol = nil
}

// SetSendPlacardInfo sets the "send_placard_info" field.
func (m *ShipmentControlMutation) SetSendPlacardInfo(b bool) {
	m.send_placard_info = &b
}

// SendPlacardInfo returns the value of the "send_placard_info" field in the mutation.
func (m *ShipmentControlMutation) SendPlacardInfo() (r bool, exists bool) {
	v := m.send_placard_info
	if v == nil {
		return
	}
	return *v, true
}

// OldSendPlacardInfo returns the old "send_placard_info" field's value of the ShipmentControl entity.
// If the ShipmentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentControlMutation) OldSendPlacardInfo(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSendPlacardInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSendPlacardInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSendPlacardInfo: %w", err)
	}
	return oldValue.SendPlacardInfo, nil
}

// ResetSendPlacardInfo resets all changes to the "send_placard_info" field.
func (m *ShipmentControlMutation) ResetSendPlacardInfo() {
	m.send_placard_info = nil
}

// SetEnforceHazmatSegRules sets the "enforce_hazmat_seg_rules" field.
func (m *ShipmentControlMutation) SetEnforceHazmatSegRules(b bool) {
	m.enforce_hazmat_seg_rules = &b
}

// EnforceHazmatSegRules returns the value of the "enforce_hazmat_seg_rules" field in the mutation.
func (m *ShipmentControlMutation) EnforceHazmatSegRules() (r bool, exists bool) {
	v := m.enforce_hazmat_seg_rules
	if v == nil {
		return
	}
	return *v, true
}

// OldEnforceHazmatSegRules returns the old "enforce_hazmat_seg_rules" field's value of the ShipmentControl entity.
// If the ShipmentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentControlMutation) OldEnforceHazmatSegRules(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnforceHazmatSegRules is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnforceHazmatSegRules requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnforceHazmatSegRules: %w", err)
	}
	return oldValue.EnforceHazmatSegRules, nil
}

// ResetEnforceHazmatSegRules resets all changes to the "enforce_hazmat_seg_rules" field.
func (m *ShipmentControlMutation) ResetEnforceHazmatSegRules() {
	m.enforce_hazmat_seg_rules = nil
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *ShipmentControlMutation) SetOrganizationID(id uuid.UUID) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *ShipmentControlMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *ShipmentControlMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *ShipmentControlMutation) OrganizationID() (id uuid.UUID, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *ShipmentControlMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *ShipmentControlMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// SetBusinessUnitID sets the "business_unit" edge to the BusinessUnit entity by id.
func (m *ShipmentControlMutation) SetBusinessUnitID(id uuid.UUID) {
	m.business_unit = &id
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *ShipmentControlMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *ShipmentControlMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitID returns the "business_unit" edge ID in the mutation.
func (m *ShipmentControlMutation) BusinessUnitID() (id uuid.UUID, exists bool) {
	if m.business_unit != nil {
		return *m.business_unit, true
	}
	return
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *ShipmentControlMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *ShipmentControlMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// Where appends a list predicates to the ShipmentControlMutation builder.
func (m *ShipmentControlMutation) Where(ps ...predicate.ShipmentControl) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ShipmentControlMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ShipmentControlMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ShipmentControl, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ShipmentControlMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ShipmentControlMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ShipmentControl).
func (m *ShipmentControlMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShipmentControlMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, shipmentcontrol.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, shipmentcontrol.FieldUpdatedAt)
	}
	if m.auto_rate_shipment != nil {
		fields = append(fields, shipmentcontrol.FieldAutoRateShipment)
	}
	if m.calculate_distance != nil {
		fields = append(fields, shipmentcontrol.FieldCalculateDistance)
	}
	if m.enforce_rev_code != nil {
		fields = append(fields, shipmentcontrol.FieldEnforceRevCode)
	}
	if m.enforce_voided_comm != nil {
		fields = append(fields, shipmentcontrol.FieldEnforceVoidedComm)
	}
	if m.generate_routes != nil {
		fields = append(fields, shipmentcontrol.FieldGenerateRoutes)
	}
	if m.enforce_commodity != nil {
		fields = append(fields, shipmentcontrol.FieldEnforceCommodity)
	}
	if m.auto_sequence_stops != nil {
		fields = append(fields, shipmentcontrol.FieldAutoSequenceStops)
	}
	if m.auto_shipment_total != nil {
		fields = append(fields, shipmentcontrol.FieldAutoShipmentTotal)
	}
	if m.enforce_origin_destination != nil {
		fields = append(fields, shipmentcontrol.FieldEnforceOriginDestination)
	}
	if m.check_for_duplicate_bol != nil {
		fields = append(fields, shipmentcontrol.FieldCheckForDuplicateBol)
	}
	if m.send_placard_info != nil {
		fields = append(fields, shipmentcontrol.FieldSendPlacardInfo)
	}
	if m.enforce_hazmat_seg_rules != nil {
		fields = append(fields, shipmentcontrol.FieldEnforceHazmatSegRules)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShipmentControlMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shipmentcontrol.FieldCreatedAt:
		return m.CreatedAt()
	case shipmentcontrol.FieldUpdatedAt:
		return m.UpdatedAt()
	case shipmentcontrol.FieldAutoRateShipment:
		return m.AutoRateShipment()
	case shipmentcontrol.FieldCalculateDistance:
		return m.CalculateDistance()
	case shipmentcontrol.FieldEnforceRevCode:
		return m.EnforceRevCode()
	case shipmentcontrol.FieldEnforceVoidedComm:
		return m.EnforceVoidedComm()
	case shipmentcontrol.FieldGenerateRoutes:
		return m.GenerateRoutes()
	case shipmentcontrol.FieldEnforceCommodity:
		return m.EnforceCommodity()
	case shipmentcontrol.FieldAutoSequenceStops:
		return m.AutoSequenceStops()
	case shipmentcontrol.FieldAutoShipmentTotal:
		return m.AutoShipmentTotal()
	case shipmentcontrol.FieldEnforceOriginDestination:
		return m.EnforceOriginDestination()
	case shipmentcontrol.FieldCheckForDuplicateBol:
		return m.CheckForDuplicateBol()
	case shipmentcontrol.FieldSendPlacardInfo:
		return m.SendPlacardInfo()
	case shipmentcontrol.FieldEnforceHazmatSegRules:
		return m.EnforceHazmatSegRules()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShipmentControlMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shipmentcontrol.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case shipmentcontrol.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case shipmentcontrol.FieldAutoRateShipment:
		return m.OldAutoRateShipment(ctx)
	case shipmentcontrol.FieldCalculateDistance:
		return m.OldCalculateDistance(ctx)
	case shipmentcontrol.FieldEnforceRevCode:
		return m.OldEnforceRevCode(ctx)
	case shipmentcontrol.FieldEnforceVoidedComm:
		return m.OldEnforceVoidedComm(ctx)
	case shipmentcontrol.FieldGenerateRoutes:
		return m.OldGenerateRoutes(ctx)
	case shipmentcontrol.FieldEnforceCommodity:
		return m.OldEnforceCommodity(ctx)
	case shipmentcontrol.FieldAutoSequenceStops:
		return m.OldAutoSequenceStops(ctx)
	case shipmentcontrol.FieldAutoShipmentTotal:
		return m.OldAutoShipmentTotal(ctx)
	case shipmentcontrol.FieldEnforceOriginDestination:
		return m.OldEnforceOriginDestination(ctx)
	case shipmentcontrol.FieldCheckForDuplicateBol:
		return m.OldCheckForDuplicateBol(ctx)
	case shipmentcontrol.FieldSendPlacardInfo:
		return m.OldSendPlacardInfo(ctx)
	case shipmentcontrol.FieldEnforceHazmatSegRules:
		return m.OldEnforceHazmatSegRules(ctx)
	}
	return nil, fmt.Errorf("unknown ShipmentControl field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentControlMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shipmentcontrol.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case shipmentcontrol.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case shipmentcontrol.FieldAutoRateShipment:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoRateShipment(v)
		return nil
	case shipmentcontrol.FieldCalculateDistance:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCalculateDistance(v)
		return nil
	case shipmentcontrol.FieldEnforceRevCode:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnforceRevCode(v)
		return nil
	case shipmentcontrol.FieldEnforceVoidedComm:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnforceVoidedComm(v)
		return nil
	case shipmentcontrol.FieldGenerateRoutes:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenerateRoutes(v)
		return nil
	case shipmentcontrol.FieldEnforceCommodity:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnforceCommodity(v)
		return nil
	case shipmentcontrol.FieldAutoSequenceStops:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoSequenceStops(v)
		return nil
	case shipmentcontrol.FieldAutoShipmentTotal:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoShipmentTotal(v)
		return nil
	case shipmentcontrol.FieldEnforceOriginDestination:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnforceOriginDestination(v)
		return nil
	case shipmentcontrol.FieldCheckForDuplicateBol:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckForDuplicateBol(v)
		return nil
	case shipmentcontrol.FieldSendPlacardInfo:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSendPlacardInfo(v)
		return nil
	case shipmentcontrol.FieldEnforceHazmatSegRules:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnforceHazmatSegRules(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentControl field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShipmentControlMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShipmentControlMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentControlMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ShipmentControl numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShipmentControlMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShipmentControlMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShipmentControlMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ShipmentControl nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShipmentControlMutation) ResetField(name string) error {
	switch name {
	case shipmentcontrol.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case shipmentcontrol.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case shipmentcontrol.FieldAutoRateShipment:
		m.ResetAutoRateShipment()
		return nil
	case shipmentcontrol.FieldCalculateDistance:
		m.ResetCalculateDistance()
		return nil
	case shipmentcontrol.FieldEnforceRevCode:
		m.ResetEnforceRevCode()
		return nil
	case shipmentcontrol.FieldEnforceVoidedComm:
		m.ResetEnforceVoidedComm()
		return nil
	case shipmentcontrol.FieldGenerateRoutes:
		m.ResetGenerateRoutes()
		return nil
	case shipmentcontrol.FieldEnforceCommodity:
		m.ResetEnforceCommodity()
		return nil
	case shipmentcontrol.FieldAutoSequenceStops:
		m.ResetAutoSequenceStops()
		return nil
	case shipmentcontrol.FieldAutoShipmentTotal:
		m.ResetAutoShipmentTotal()
		return nil
	case shipmentcontrol.FieldEnforceOriginDestination:
		m.ResetEnforceOriginDestination()
		return nil
	case shipmentcontrol.FieldCheckForDuplicateBol:
		m.ResetCheckForDuplicateBol()
		return nil
	case shipmentcontrol.FieldSendPlacardInfo:
		m.ResetSendPlacardInfo()
		return nil
	case shipmentcontrol.FieldEnforceHazmatSegRules:
		m.ResetEnforceHazmatSegRules()
		return nil
	}
	return fmt.Errorf("unknown ShipmentControl field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShipmentControlMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.organization != nil {
		edges = append(edges, shipmentcontrol.EdgeOrganization)
	}
	if m.business_unit != nil {
		edges = append(edges, shipmentcontrol.EdgeBusinessUnit)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShipmentControlMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case shipmentcontrol.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case shipmentcontrol.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShipmentControlMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShipmentControlMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShipmentControlMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorganization {
		edges = append(edges, shipmentcontrol.EdgeOrganization)
	}
	if m.clearedbusiness_unit {
		edges = append(edges, shipmentcontrol.EdgeBusinessUnit)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShipmentControlMutation) EdgeCleared(name string) bool {
	switch name {
	case shipmentcontrol.EdgeOrganization:
		return m.clearedorganization
	case shipmentcontrol.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShipmentControlMutation) ClearEdge(name string) error {
	switch name {
	case shipmentcontrol.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case shipmentcontrol.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	}
	return fmt.Errorf("unknown ShipmentControl unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShipmentControlMutation) ResetEdge(name string) error {
	switch name {
	case shipmentcontrol.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case shipmentcontrol.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	}
	return fmt.Errorf("unknown ShipmentControl edge %s", name)
}

// TableChangeAlertMutation represents an operation that mutates the TableChangeAlert nodes in the graph.
type TableChangeAlertMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	status               *tablechangealert.Status
	name                 *string
	database_action      *tablechangealert.DatabaseAction
	source               *tablechangealert.Source
	table_name           *string
	topic                *string
	description          *string
	custom_subject       *string
	function_name        *string
	trigger_name         *string
	listener_name        *string
	email_recipients     *string
	conditional_logic    **schema.ConditionalLogic
	effective_date       *time.Time
	expiration_date      *time.Time
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	done                 bool
	oldValue             func(context.Context) (*TableChangeAlert, error)
	predicates           []predicate.TableChangeAlert
}

var _ ent.Mutation = (*TableChangeAlertMutation)(nil)

// tablechangealertOption allows management of the mutation configuration using functional options.
type tablechangealertOption func(*TableChangeAlertMutation)

// newTableChangeAlertMutation creates new mutation for the TableChangeAlert entity.
func newTableChangeAlertMutation(c config, op Op, opts ...tablechangealertOption) *TableChangeAlertMutation {
	m := &TableChangeAlertMutation{
		config:        c,
		op:            op,
		typ:           TypeTableChangeAlert,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTableChangeAlertID sets the ID field of the mutation.
func withTableChangeAlertID(id uuid.UUID) tablechangealertOption {
	return func(m *TableChangeAlertMutation) {
		var (
			err   error
			once  sync.Once
			value *TableChangeAlert
		)
		m.oldValue = func(ctx context.Context) (*TableChangeAlert, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TableChangeAlert.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTableChangeAlert sets the old TableChangeAlert of the mutation.
func withTableChangeAlert(node *TableChangeAlert) tablechangealertOption {
	return func(m *TableChangeAlertMutation) {
		m.oldValue = func(context.Context) (*TableChangeAlert, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TableChangeAlertMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TableChangeAlertMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TableChangeAlert entities.
func (m *TableChangeAlertMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TableChangeAlertMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TableChangeAlertMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TableChangeAlert.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *TableChangeAlertMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *TableChangeAlertMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *TableChangeAlertMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *TableChangeAlertMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *TableChangeAlertMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *TableChangeAlertMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TableChangeAlertMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TableChangeAlertMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TableChangeAlertMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TableChangeAlertMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TableChangeAlertMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TableChangeAlertMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *TableChangeAlertMutation) SetStatus(t tablechangealert.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *TableChangeAlertMutation) Status() (r tablechangealert.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldStatus(ctx context.Context) (v tablechangealert.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TableChangeAlertMutation) ResetStatus() {
	m.status = nil
}

// SetName sets the "name" field.
func (m *TableChangeAlertMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TableChangeAlertMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TableChangeAlertMutation) ResetName() {
	m.name = nil
}

// SetDatabaseAction sets the "database_action" field.
func (m *TableChangeAlertMutation) SetDatabaseAction(ta tablechangealert.DatabaseAction) {
	m.database_action = &ta
}

// DatabaseAction returns the value of the "database_action" field in the mutation.
func (m *TableChangeAlertMutation) DatabaseAction() (r tablechangealert.DatabaseAction, exists bool) {
	v := m.database_action
	if v == nil {
		return
	}
	return *v, true
}

// OldDatabaseAction returns the old "database_action" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldDatabaseAction(ctx context.Context) (v tablechangealert.DatabaseAction, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDatabaseAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDatabaseAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDatabaseAction: %w", err)
	}
	return oldValue.DatabaseAction, nil
}

// ResetDatabaseAction resets all changes to the "database_action" field.
func (m *TableChangeAlertMutation) ResetDatabaseAction() {
	m.database_action = nil
}

// SetSource sets the "source" field.
func (m *TableChangeAlertMutation) SetSource(t tablechangealert.Source) {
	m.source = &t
}

// Source returns the value of the "source" field in the mutation.
func (m *TableChangeAlertMutation) Source() (r tablechangealert.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldSource(ctx context.Context) (v tablechangealert.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *TableChangeAlertMutation) ResetSource() {
	m.source = nil
}

// SetTableName sets the "table_name" field.
func (m *TableChangeAlertMutation) SetTableName(s string) {
	m.table_name = &s
}

// TableName returns the value of the "table_name" field in the mutation.
func (m *TableChangeAlertMutation) TableName() (r string, exists bool) {
	v := m.table_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTableName returns the old "table_name" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldTableName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTableName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTableName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTableName: %w", err)
	}
	return oldValue.TableName, nil
}

// ClearTableName clears the value of the "table_name" field.
func (m *TableChangeAlertMutation) ClearTableName() {
	m.table_name = nil
	m.clearedFields[tablechangealert.FieldTableName] = struct{}{}
}

// TableNameCleared returns if the "table_name" field was cleared in this mutation.
func (m *TableChangeAlertMutation) TableNameCleared() bool {
	_, ok := m.clearedFields[tablechangealert.FieldTableName]
	return ok
}

// ResetTableName resets all changes to the "table_name" field.
func (m *TableChangeAlertMutation) ResetTableName() {
	m.table_name = nil
	delete(m.clearedFields, tablechangealert.FieldTableName)
}

// SetTopic sets the "topic" field.
func (m *TableChangeAlertMutation) SetTopic(s string) {
	m.topic = &s
}

// Topic returns the value of the "topic" field in the mutation.
func (m *TableChangeAlertMutation) Topic() (r string, exists bool) {
	v := m.topic
	if v == nil {
		return
	}
	return *v, true
}

// OldTopic returns the old "topic" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldTopic(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopic: %w", err)
	}
	return oldValue.Topic, nil
}

// ClearTopic clears the value of the "topic" field.
func (m *TableChangeAlertMutation) ClearTopic() {
	m.topic = nil
	m.clearedFields[tablechangealert.FieldTopic] = struct{}{}
}

// TopicCleared returns if the "topic" field was cleared in this mutation.
func (m *TableChangeAlertMutation) TopicCleared() bool {
	_, ok := m.clearedFields[tablechangealert.FieldTopic]
	return ok
}

// ResetTopic resets all changes to the "topic" field.
func (m *TableChangeAlertMutation) ResetTopic() {
	m.topic = nil
	delete(m.clearedFields, tablechangealert.FieldTopic)
}

// SetDescription sets the "description" field.
func (m *TableChangeAlertMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TableChangeAlertMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TableChangeAlertMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[tablechangealert.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TableChangeAlertMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[tablechangealert.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TableChangeAlertMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, tablechangealert.FieldDescription)
}

// SetCustomSubject sets the "custom_subject" field.
func (m *TableChangeAlertMutation) SetCustomSubject(s string) {
	m.custom_subject = &s
}

// CustomSubject returns the value of the "custom_subject" field in the mutation.
func (m *TableChangeAlertMutation) CustomSubject() (r string, exists bool) {
	v := m.custom_subject
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomSubject returns the old "custom_subject" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldCustomSubject(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomSubject: %w", err)
	}
	return oldValue.CustomSubject, nil
}

// ClearCustomSubject clears the value of the "custom_subject" field.
func (m *TableChangeAlertMutation) ClearCustomSubject() {
	m.custom_subject = nil
	m.clearedFields[tablechangealert.FieldCustomSubject] = struct{}{}
}

// CustomSubjectCleared returns if the "custom_subject" field was cleared in this mutation.
func (m *TableChangeAlertMutation) CustomSubjectCleared() bool {
	_, ok := m.clearedFields[tablechangealert.FieldCustomSubject]
	return ok
}

// ResetCustomSubject resets all changes to the "custom_subject" field.
func (m *TableChangeAlertMutation) ResetCustomSubject() {
	m.custom_subject = nil
	delete(m.clearedFields, tablechangealert.FieldCustomSubject)
}

// SetFunctionName sets the "function_name" field.
func (m *TableChangeAlertMutation) SetFunctionName(s string) {
	m.function_name = &s
}

// FunctionName returns the value of the "function_name" field in the mutation.
func (m *TableChangeAlertMutation) FunctionName() (r string, exists bool) {
	v := m.function_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFunctionName returns the old "function_name" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldFunctionName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFunctionName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFunctionName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFunctionName: %w", err)
	}
	return oldValue.FunctionName, nil
}

// ClearFunctionName clears the value of the "function_name" field.
func (m *TableChangeAlertMutation) ClearFunctionName() {
	m.function_name = nil
	m.clearedFields[tablechangealert.FieldFunctionName] = struct{}{}
}

// FunctionNameCleared returns if the "function_name" field was cleared in this mutation.
func (m *TableChangeAlertMutation) FunctionNameCleared() bool {
	_, ok := m.clearedFields[tablechangealert.FieldFunctionName]
	return ok
}

// ResetFunctionName resets all changes to the "function_name" field.
func (m *TableChangeAlertMutation) ResetFunctionName() {
	m.function_name = nil
	delete(m.clearedFields, tablechangealert.FieldFunctionName)
}

// SetTriggerName sets the "trigger_name" field.
func (m *TableChangeAlertMutation) SetTriggerName(s string) {
	m.trigger_name = &s
}

// TriggerName returns the value of the "trigger_name" field in the mutation.
func (m *TableChangeAlertMutation) TriggerName() (r string, exists bool) {
	v := m.trigger_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTriggerName returns the old "trigger_name" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldTriggerName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTriggerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTriggerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTriggerName: %w", err)
	}
	return oldValue.TriggerName, nil
}

// ClearTriggerName clears the value of the "trigger_name" field.
func (m *TableChangeAlertMutation) ClearTriggerName() {
	m.trigger_name = nil
	m.clearedFields[tablechangealert.FieldTriggerName] = struct{}{}
}

// TriggerNameCleared returns if the "trigger_name" field was cleared in this mutation.
func (m *TableChangeAlertMutation) TriggerNameCleared() bool {
	_, ok := m.clearedFields[tablechangealert.FieldTriggerName]
	return ok
}

// ResetTriggerName resets all changes to the "trigger_name" field.
func (m *TableChangeAlertMutation) ResetTriggerName() {
	m.trigger_name = nil
	delete(m.clearedFields, tablechangealert.FieldTriggerName)
}

// SetListenerName sets the "listener_name" field.
func (m *TableChangeAlertMutation) SetListenerName(s string) {
	m.listener_name = &s
}

// ListenerName returns the value of the "listener_name" field in the mutation.
func (m *TableChangeAlertMutation) ListenerName() (r string, exists bool) {
	v := m.listener_name
	if v == nil {
		return
	}
	return *v, true
}

// OldListenerName returns the old "listener_name" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldListenerName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldListenerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldListenerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldListenerName: %w", err)
	}
	return oldValue.ListenerName, nil
}

// ClearListenerName clears the value of the "listener_name" field.
func (m *TableChangeAlertMutation) ClearListenerName() {
	m.listener_name = nil
	m.clearedFields[tablechangealert.FieldListenerName] = struct{}{}
}

// ListenerNameCleared returns if the "listener_name" field was cleared in this mutation.
func (m *TableChangeAlertMutation) ListenerNameCleared() bool {
	_, ok := m.clearedFields[tablechangealert.FieldListenerName]
	return ok
}

// ResetListenerName resets all changes to the "listener_name" field.
func (m *TableChangeAlertMutation) ResetListenerName() {
	m.listener_name = nil
	delete(m.clearedFields, tablechangealert.FieldListenerName)
}

// SetEmailRecipients sets the "email_recipients" field.
func (m *TableChangeAlertMutation) SetEmailRecipients(s string) {
	m.email_recipients = &s
}

// EmailRecipients returns the value of the "email_recipients" field in the mutation.
func (m *TableChangeAlertMutation) EmailRecipients() (r string, exists bool) {
	v := m.email_recipients
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailRecipients returns the old "email_recipients" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldEmailRecipients(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailRecipients is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailRecipients requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailRecipients: %w", err)
	}
	return oldValue.EmailRecipients, nil
}

// ClearEmailRecipients clears the value of the "email_recipients" field.
func (m *TableChangeAlertMutation) ClearEmailRecipients() {
	m.email_recipients = nil
	m.clearedFields[tablechangealert.FieldEmailRecipients] = struct{}{}
}

// EmailRecipientsCleared returns if the "email_recipients" field was cleared in this mutation.
func (m *TableChangeAlertMutation) EmailRecipientsCleared() bool {
	_, ok := m.clearedFields[tablechangealert.FieldEmailRecipients]
	return ok
}

// ResetEmailRecipients resets all changes to the "email_recipients" field.
func (m *TableChangeAlertMutation) ResetEmailRecipients() {
	m.email_recipients = nil
	delete(m.clearedFields, tablechangealert.FieldEmailRecipients)
}

// SetConditionalLogic sets the "conditional_logic" field.
func (m *TableChangeAlertMutation) SetConditionalLogic(sl *schema.ConditionalLogic) {
	m.conditional_logic = &sl
}

// ConditionalLogic returns the value of the "conditional_logic" field in the mutation.
func (m *TableChangeAlertMutation) ConditionalLogic() (r *schema.ConditionalLogic, exists bool) {
	v := m.conditional_logic
	if v == nil {
		return
	}
	return *v, true
}

// OldConditionalLogic returns the old "conditional_logic" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldConditionalLogic(ctx context.Context) (v *schema.ConditionalLogic, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConditionalLogic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConditionalLogic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConditionalLogic: %w", err)
	}
	return oldValue.ConditionalLogic, nil
}

// ClearConditionalLogic clears the value of the "conditional_logic" field.
func (m *TableChangeAlertMutation) ClearConditionalLogic() {
	m.conditional_logic = nil
	m.clearedFields[tablechangealert.FieldConditionalLogic] = struct{}{}
}

// ConditionalLogicCleared returns if the "conditional_logic" field was cleared in this mutation.
func (m *TableChangeAlertMutation) ConditionalLogicCleared() bool {
	_, ok := m.clearedFields[tablechangealert.FieldConditionalLogic]
	return ok
}

// ResetConditionalLogic resets all changes to the "conditional_logic" field.
func (m *TableChangeAlertMutation) ResetConditionalLogic() {
	m.conditional_logic = nil
	delete(m.clearedFields, tablechangealert.FieldConditionalLogic)
}

// SetEffectiveDate sets the "effective_date" field.
func (m *TableChangeAlertMutation) SetEffectiveDate(t time.Time) {
	m.effective_date = &t
}

// EffectiveDate returns the value of the "effective_date" field in the mutation.
func (m *TableChangeAlertMutation) EffectiveDate() (r time.Time, exists bool) {
	v := m.effective_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectiveDate returns the old "effective_date" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldEffectiveDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectiveDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectiveDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectiveDate: %w", err)
	}
	return oldValue.EffectiveDate, nil
}

// ClearEffectiveDate clears the value of the "effective_date" field.
func (m *TableChangeAlertMutation) ClearEffectiveDate() {
	m.effective_date = nil
	m.clearedFields[tablechangealert.FieldEffectiveDate] = struct{}{}
}

// EffectiveDateCleared returns if the "effective_date" field was cleared in this mutation.
func (m *TableChangeAlertMutation) EffectiveDateCleared() bool {
	_, ok := m.clearedFields[tablechangealert.FieldEffectiveDate]
	return ok
}

// ResetEffectiveDate resets all changes to the "effective_date" field.
func (m *TableChangeAlertMutation) ResetEffectiveDate() {
	m.effective_date = nil
	delete(m.clearedFields, tablechangealert.FieldEffectiveDate)
}

// SetExpirationDate sets the "expiration_date" field.
func (m *TableChangeAlertMutation) SetExpirationDate(t time.Time) {
	m.expiration_date = &t
}

// ExpirationDate returns the value of the "expiration_date" field in the mutation.
func (m *TableChangeAlertMutation) ExpirationDate() (r time.Time, exists bool) {
	v := m.expiration_date
	if v == nil {
		return
	}
	return *v, true
}

// OldExpirationDate returns the old "expiration_date" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldExpirationDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpirationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpirationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpirationDate: %w", err)
	}
	return oldValue.ExpirationDate, nil
}

// ClearExpirationDate clears the value of the "expiration_date" field.
func (m *TableChangeAlertMutation) ClearExpirationDate() {
	m.expiration_date = nil
	m.clearedFields[tablechangealert.FieldExpirationDate] = struct{}{}
}

// ExpirationDateCleared returns if the "expiration_date" field was cleared in this mutation.
func (m *TableChangeAlertMutation) ExpirationDateCleared() bool {
	_, ok := m.clearedFields[tablechangealert.FieldExpirationDate]
	return ok
}

// ResetExpirationDate resets all changes to the "expiration_date" field.
func (m *TableChangeAlertMutation) ResetExpirationDate() {
	m.expiration_date = nil
	delete(m.clearedFields, tablechangealert.FieldExpirationDate)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *TableChangeAlertMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[tablechangealert.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *TableChangeAlertMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *TableChangeAlertMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *TableChangeAlertMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *TableChangeAlertMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[tablechangealert.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *TableChangeAlertMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *TableChangeAlertMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *TableChangeAlertMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the TableChangeAlertMutation builder.
func (m *TableChangeAlertMutation) Where(ps ...predicate.TableChangeAlert) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TableChangeAlertMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TableChangeAlertMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TableChangeAlert, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TableChangeAlertMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TableChangeAlertMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TableChangeAlert).
func (m *TableChangeAlertMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TableChangeAlertMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.business_unit != nil {
		fields = append(fields, tablechangealert.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, tablechangealert.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, tablechangealert.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tablechangealert.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, tablechangealert.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, tablechangealert.FieldName)
	}
	if m.database_action != nil {
		fields = append(fields, tablechangealert.FieldDatabaseAction)
	}
	if m.source != nil {
		fields = append(fields, tablechangealert.FieldSource)
	}
	if m.table_name != nil {
		fields = append(fields, tablechangealert.FieldTableName)
	}
	if m.topic != nil {
		fields = append(fields, tablechangealert.FieldTopic)
	}
	if m.description != nil {
		fields = append(fields, tablechangealert.FieldDescription)
	}
	if m.custom_subject != nil {
		fields = append(fields, tablechangealert.FieldCustomSubject)
	}
	if m.function_name != nil {
		fields = append(fields, tablechangealert.FieldFunctionName)
	}
	if m.trigger_name != nil {
		fields = append(fields, tablechangealert.FieldTriggerName)
	}
	if m.listener_name != nil {
		fields = append(fields, tablechangealert.FieldListenerName)
	}
	if m.email_recipients != nil {
		fields = append(fields, tablechangealert.FieldEmailRecipients)
	}
	if m.conditional_logic != nil {
		fields = append(fields, tablechangealert.FieldConditionalLogic)
	}
	if m.effective_date != nil {
		fields = append(fields, tablechangealert.FieldEffectiveDate)
	}
	if m.expiration_date != nil {
		fields = append(fields, tablechangealert.FieldExpirationDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TableChangeAlertMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tablechangealert.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case tablechangealert.FieldOrganizationID:
		return m.OrganizationID()
	case tablechangealert.FieldCreatedAt:
		return m.CreatedAt()
	case tablechangealert.FieldUpdatedAt:
		return m.UpdatedAt()
	case tablechangealert.FieldStatus:
		return m.Status()
	case tablechangealert.FieldName:
		return m.Name()
	case tablechangealert.FieldDatabaseAction:
		return m.DatabaseAction()
	case tablechangealert.FieldSource:
		return m.Source()
	case tablechangealert.FieldTableName:
		return m.TableName()
	case tablechangealert.FieldTopic:
		return m.Topic()
	case tablechangealert.FieldDescription:
		return m.Description()
	case tablechangealert.FieldCustomSubject:
		return m.CustomSubject()
	case tablechangealert.FieldFunctionName:
		return m.FunctionName()
	case tablechangealert.FieldTriggerName:
		return m.TriggerName()
	case tablechangealert.FieldListenerName:
		return m.ListenerName()
	case tablechangealert.FieldEmailRecipients:
		return m.EmailRecipients()
	case tablechangealert.FieldConditionalLogic:
		return m.ConditionalLogic()
	case tablechangealert.FieldEffectiveDate:
		return m.EffectiveDate()
	case tablechangealert.FieldExpirationDate:
		return m.ExpirationDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TableChangeAlertMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tablechangealert.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case tablechangealert.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case tablechangealert.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tablechangealert.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tablechangealert.FieldStatus:
		return m.OldStatus(ctx)
	case tablechangealert.FieldName:
		return m.OldName(ctx)
	case tablechangealert.FieldDatabaseAction:
		return m.OldDatabaseAction(ctx)
	case tablechangealert.FieldSource:
		return m.OldSource(ctx)
	case tablechangealert.FieldTableName:
		return m.OldTableName(ctx)
	case tablechangealert.FieldTopic:
		return m.OldTopic(ctx)
	case tablechangealert.FieldDescription:
		return m.OldDescription(ctx)
	case tablechangealert.FieldCustomSubject:
		return m.OldCustomSubject(ctx)
	case tablechangealert.FieldFunctionName:
		return m.OldFunctionName(ctx)
	case tablechangealert.FieldTriggerName:
		return m.OldTriggerName(ctx)
	case tablechangealert.FieldListenerName:
		return m.OldListenerName(ctx)
	case tablechangealert.FieldEmailRecipients:
		return m.OldEmailRecipients(ctx)
	case tablechangealert.FieldConditionalLogic:
		return m.OldConditionalLogic(ctx)
	case tablechangealert.FieldEffectiveDate:
		return m.OldEffectiveDate(ctx)
	case tablechangealert.FieldExpirationDate:
		return m.OldExpirationDate(ctx)
	}
	return nil, fmt.Errorf("unknown TableChangeAlert field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TableChangeAlertMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tablechangealert.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case tablechangealert.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case tablechangealert.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tablechangealert.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tablechangealert.FieldStatus:
		v, ok := value.(tablechangealert.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case tablechangealert.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tablechangealert.FieldDatabaseAction:
		v, ok := value.(tablechangealert.DatabaseAction)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDatabaseAction(v)
		return nil
	case tablechangealert.FieldSource:
		v, ok := value.(tablechangealert.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case tablechangealert.FieldTableName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTableName(v)
		return nil
	case tablechangealert.FieldTopic:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopic(v)
		return nil
	case tablechangealert.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case tablechangealert.FieldCustomSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomSubject(v)
		return nil
	case tablechangealert.FieldFunctionName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFunctionName(v)
		return nil
	case tablechangealert.FieldTriggerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTriggerName(v)
		return nil
	case tablechangealert.FieldListenerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetListenerName(v)
		return nil
	case tablechangealert.FieldEmailRecipients:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailRecipients(v)
		return nil
	case tablechangealert.FieldConditionalLogic:
		v, ok := value.(*schema.ConditionalLogic)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConditionalLogic(v)
		return nil
	case tablechangealert.FieldEffectiveDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectiveDate(v)
		return nil
	case tablechangealert.FieldExpirationDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpirationDate(v)
		return nil
	}
	return fmt.Errorf("unknown TableChangeAlert field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TableChangeAlertMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TableChangeAlertMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TableChangeAlertMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TableChangeAlert numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TableChangeAlertMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tablechangealert.FieldTableName) {
		fields = append(fields, tablechangealert.FieldTableName)
	}
	if m.FieldCleared(tablechangealert.FieldTopic) {
		fields = append(fields, tablechangealert.FieldTopic)
	}
	if m.FieldCleared(tablechangealert.FieldDescription) {
		fields = append(fields, tablechangealert.FieldDescription)
	}
	if m.FieldCleared(tablechangealert.FieldCustomSubject) {
		fields = append(fields, tablechangealert.FieldCustomSubject)
	}
	if m.FieldCleared(tablechangealert.FieldFunctionName) {
		fields = append(fields, tablechangealert.FieldFunctionName)
	}
	if m.FieldCleared(tablechangealert.FieldTriggerName) {
		fields = append(fields, tablechangealert.FieldTriggerName)
	}
	if m.FieldCleared(tablechangealert.FieldListenerName) {
		fields = append(fields, tablechangealert.FieldListenerName)
	}
	if m.FieldCleared(tablechangealert.FieldEmailRecipients) {
		fields = append(fields, tablechangealert.FieldEmailRecipients)
	}
	if m.FieldCleared(tablechangealert.FieldConditionalLogic) {
		fields = append(fields, tablechangealert.FieldConditionalLogic)
	}
	if m.FieldCleared(tablechangealert.FieldEffectiveDate) {
		fields = append(fields, tablechangealert.FieldEffectiveDate)
	}
	if m.FieldCleared(tablechangealert.FieldExpirationDate) {
		fields = append(fields, tablechangealert.FieldExpirationDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TableChangeAlertMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TableChangeAlertMutation) ClearField(name string) error {
	switch name {
	case tablechangealert.FieldTableName:
		m.ClearTableName()
		return nil
	case tablechangealert.FieldTopic:
		m.ClearTopic()
		return nil
	case tablechangealert.FieldDescription:
		m.ClearDescription()
		return nil
	case tablechangealert.FieldCustomSubject:
		m.ClearCustomSubject()
		return nil
	case tablechangealert.FieldFunctionName:
		m.ClearFunctionName()
		return nil
	case tablechangealert.FieldTriggerName:
		m.ClearTriggerName()
		return nil
	case tablechangealert.FieldListenerName:
		m.ClearListenerName()
		return nil
	case tablechangealert.FieldEmailRecipients:
		m.ClearEmailRecipients()
		return nil
	case tablechangealert.FieldConditionalLogic:
		m.ClearConditionalLogic()
		return nil
	case tablechangealert.FieldEffectiveDate:
		m.ClearEffectiveDate()
		return nil
	case tablechangealert.FieldExpirationDate:
		m.ClearExpirationDate()
		return nil
	}
	return fmt.Errorf("unknown TableChangeAlert nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TableChangeAlertMutation) ResetField(name string) error {
	switch name {
	case tablechangealert.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case tablechangealert.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case tablechangealert.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tablechangealert.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tablechangealert.FieldStatus:
		m.ResetStatus()
		return nil
	case tablechangealert.FieldName:
		m.ResetName()
		return nil
	case tablechangealert.FieldDatabaseAction:
		m.ResetDatabaseAction()
		return nil
	case tablechangealert.FieldSource:
		m.ResetSource()
		return nil
	case tablechangealert.FieldTableName:
		m.ResetTableName()
		return nil
	case tablechangealert.FieldTopic:
		m.ResetTopic()
		return nil
	case tablechangealert.FieldDescription:
		m.ResetDescription()
		return nil
	case tablechangealert.FieldCustomSubject:
		m.ResetCustomSubject()
		return nil
	case tablechangealert.FieldFunctionName:
		m.ResetFunctionName()
		return nil
	case tablechangealert.FieldTriggerName:
		m.ResetTriggerName()
		return nil
	case tablechangealert.FieldListenerName:
		m.ResetListenerName()
		return nil
	case tablechangealert.FieldEmailRecipients:
		m.ResetEmailRecipients()
		return nil
	case tablechangealert.FieldConditionalLogic:
		m.ResetConditionalLogic()
		return nil
	case tablechangealert.FieldEffectiveDate:
		m.ResetEffectiveDate()
		return nil
	case tablechangealert.FieldExpirationDate:
		m.ResetExpirationDate()
		return nil
	}
	return fmt.Errorf("unknown TableChangeAlert field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TableChangeAlertMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.business_unit != nil {
		edges = append(edges, tablechangealert.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, tablechangealert.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TableChangeAlertMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tablechangealert.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case tablechangealert.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TableChangeAlertMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TableChangeAlertMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TableChangeAlertMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbusiness_unit {
		edges = append(edges, tablechangealert.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, tablechangealert.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TableChangeAlertMutation) EdgeCleared(name string) bool {
	switch name {
	case tablechangealert.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case tablechangealert.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TableChangeAlertMutation) ClearEdge(name string) error {
	switch name {
	case tablechangealert.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case tablechangealert.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown TableChangeAlert unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TableChangeAlertMutation) ResetEdge(name string) error {
	switch name {
	case tablechangealert.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case tablechangealert.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown TableChangeAlert edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	name                 *string
	description          *string
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	done                 bool
	oldValue             func(context.Context) (*Tag, error)
	predicates           []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id uuid.UUID) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tag entities.
func (m *TagMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *TagMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *TagMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *TagMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *TagMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *TagMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *TagMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TagMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *TagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TagMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *TagMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TagMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TagMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[tag.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TagMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[tag.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TagMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, tag.FieldDescription)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *TagMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[tag.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *TagMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *TagMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *TagMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *TagMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[tag.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *TagMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *TagMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *TagMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.business_unit != nil {
		fields = append(fields, tag.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, tag.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, tag.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tag.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, tag.FieldName)
	}
	if m.description != nil {
		fields = append(fields, tag.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case tag.FieldOrganizationID:
		return m.OrganizationID()
	case tag.FieldCreatedAt:
		return m.CreatedAt()
	case tag.FieldUpdatedAt:
		return m.UpdatedAt()
	case tag.FieldName:
		return m.Name()
	case tag.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case tag.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case tag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tag.FieldName:
		return m.OldName(ctx)
	case tag.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case tag.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case tag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tag.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tag.FieldDescription) {
		fields = append(fields, tag.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	switch name {
	case tag.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case tag.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case tag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tag.FieldName:
		m.ResetName()
		return nil
	case tag.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.business_unit != nil {
		edges = append(edges, tag.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, tag.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case tag.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbusiness_unit {
		edges = append(edges, tag.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, tag.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	switch name {
	case tag.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case tag.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	switch name {
	case tag.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case tag.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	switch name {
	case tag.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case tag.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown Tag edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	status               *user.Status
	name                 *string
	username             *string
	password             *string
	email                *string
	date_joined          *string
	timezone             *user.Timezone
	profile_pic_url      *string
	thumbnail_url        *string
	phone_number         *string
	is_admin             *bool
	is_super_admin       *bool
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	done                 bool
	oldValue             func(context.Context) (*User, error)
	predicates           []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *UserMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *UserMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *UserMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *UserMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *UserMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *UserMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(u user.Status) {
	m.status = &u
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r user.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v user.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetDateJoined sets the "date_joined" field.
func (m *UserMutation) SetDateJoined(s string) {
	m.date_joined = &s
}

// DateJoined returns the value of the "date_joined" field in the mutation.
func (m *UserMutation) DateJoined() (r string, exists bool) {
	v := m.date_joined
	if v == nil {
		return
	}
	return *v, true
}

// OldDateJoined returns the old "date_joined" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDateJoined(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDateJoined is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDateJoined requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateJoined: %w", err)
	}
	return oldValue.DateJoined, nil
}

// ClearDateJoined clears the value of the "date_joined" field.
func (m *UserMutation) ClearDateJoined() {
	m.date_joined = nil
	m.clearedFields[user.FieldDateJoined] = struct{}{}
}

// DateJoinedCleared returns if the "date_joined" field was cleared in this mutation.
func (m *UserMutation) DateJoinedCleared() bool {
	_, ok := m.clearedFields[user.FieldDateJoined]
	return ok
}

// ResetDateJoined resets all changes to the "date_joined" field.
func (m *UserMutation) ResetDateJoined() {
	m.date_joined = nil
	delete(m.clearedFields, user.FieldDateJoined)
}

// SetTimezone sets the "timezone" field.
func (m *UserMutation) SetTimezone(u user.Timezone) {
	m.timezone = &u
}

// Timezone returns the value of the "timezone" field in the mutation.
func (m *UserMutation) Timezone() (r user.Timezone, exists bool) {
	v := m.timezone
	if v == nil {
		return
	}
	return *v, true
}

// OldTimezone returns the old "timezone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTimezone(ctx context.Context) (v user.Timezone, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimezone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimezone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimezone: %w", err)
	}
	return oldValue.Timezone, nil
}

// ResetTimezone resets all changes to the "timezone" field.
func (m *UserMutation) ResetTimezone() {
	m.timezone = nil
}

// SetProfilePicURL sets the "profile_pic_url" field.
func (m *UserMutation) SetProfilePicURL(s string) {
	m.profile_pic_url = &s
}

// ProfilePicURL returns the value of the "profile_pic_url" field in the mutation.
func (m *UserMutation) ProfilePicURL() (r string, exists bool) {
	v := m.profile_pic_url
	if v == nil {
		return
	}
	return *v, true
}

// OldProfilePicURL returns the old "profile_pic_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldProfilePicURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfilePicURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfilePicURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfilePicURL: %w", err)
	}
	return oldValue.ProfilePicURL, nil
}

// ClearProfilePicURL clears the value of the "profile_pic_url" field.
func (m *UserMutation) ClearProfilePicURL() {
	m.profile_pic_url = nil
	m.clearedFields[user.FieldProfilePicURL] = struct{}{}
}

// ProfilePicURLCleared returns if the "profile_pic_url" field was cleared in this mutation.
func (m *UserMutation) ProfilePicURLCleared() bool {
	_, ok := m.clearedFields[user.FieldProfilePicURL]
	return ok
}

// ResetProfilePicURL resets all changes to the "profile_pic_url" field.
func (m *UserMutation) ResetProfilePicURL() {
	m.profile_pic_url = nil
	delete(m.clearedFields, user.FieldProfilePicURL)
}

// SetThumbnailURL sets the "thumbnail_url" field.
func (m *UserMutation) SetThumbnailURL(s string) {
	m.thumbnail_url = &s
}

// ThumbnailURL returns the value of the "thumbnail_url" field in the mutation.
func (m *UserMutation) ThumbnailURL() (r string, exists bool) {
	v := m.thumbnail_url
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnailURL returns the old "thumbnail_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldThumbnailURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnailURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnailURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnailURL: %w", err)
	}
	return oldValue.ThumbnailURL, nil
}

// ClearThumbnailURL clears the value of the "thumbnail_url" field.
func (m *UserMutation) ClearThumbnailURL() {
	m.thumbnail_url = nil
	m.clearedFields[user.FieldThumbnailURL] = struct{}{}
}

// ThumbnailURLCleared returns if the "thumbnail_url" field was cleared in this mutation.
func (m *UserMutation) ThumbnailURLCleared() bool {
	_, ok := m.clearedFields[user.FieldThumbnailURL]
	return ok
}

// ResetThumbnailURL resets all changes to the "thumbnail_url" field.
func (m *UserMutation) ResetThumbnailURL() {
	m.thumbnail_url = nil
	delete(m.clearedFields, user.FieldThumbnailURL)
}

// SetPhoneNumber sets the "phone_number" field.
func (m *UserMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *UserMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ClearPhoneNumber clears the value of the "phone_number" field.
func (m *UserMutation) ClearPhoneNumber() {
	m.phone_number = nil
	m.clearedFields[user.FieldPhoneNumber] = struct{}{}
}

// PhoneNumberCleared returns if the "phone_number" field was cleared in this mutation.
func (m *UserMutation) PhoneNumberCleared() bool {
	_, ok := m.clearedFields[user.FieldPhoneNumber]
	return ok
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *UserMutation) ResetPhoneNumber() {
	m.phone_number = nil
	delete(m.clearedFields, user.FieldPhoneNumber)
}

// SetIsAdmin sets the "is_admin" field.
func (m *UserMutation) SetIsAdmin(b bool) {
	m.is_admin = &b
}

// IsAdmin returns the value of the "is_admin" field in the mutation.
func (m *UserMutation) IsAdmin() (r bool, exists bool) {
	v := m.is_admin
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAdmin returns the old "is_admin" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsAdmin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAdmin: %w", err)
	}
	return oldValue.IsAdmin, nil
}

// ResetIsAdmin resets all changes to the "is_admin" field.
func (m *UserMutation) ResetIsAdmin() {
	m.is_admin = nil
}

// SetIsSuperAdmin sets the "is_super_admin" field.
func (m *UserMutation) SetIsSuperAdmin(b bool) {
	m.is_super_admin = &b
}

// IsSuperAdmin returns the value of the "is_super_admin" field in the mutation.
func (m *UserMutation) IsSuperAdmin() (r bool, exists bool) {
	v := m.is_super_admin
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSuperAdmin returns the old "is_super_admin" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsSuperAdmin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSuperAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSuperAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSuperAdmin: %w", err)
	}
	return oldValue.IsSuperAdmin, nil
}

// ResetIsSuperAdmin resets all changes to the "is_super_admin" field.
func (m *UserMutation) ResetIsSuperAdmin() {
	m.is_super_admin = nil
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *UserMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[user.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *UserMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *UserMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *UserMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *UserMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[user.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *UserMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *UserMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *UserMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.business_unit != nil {
		fields = append(fields, user.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, user.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.date_joined != nil {
		fields = append(fields, user.FieldDateJoined)
	}
	if m.timezone != nil {
		fields = append(fields, user.FieldTimezone)
	}
	if m.profile_pic_url != nil {
		fields = append(fields, user.FieldProfilePicURL)
	}
	if m.thumbnail_url != nil {
		fields = append(fields, user.FieldThumbnailURL)
	}
	if m.phone_number != nil {
		fields = append(fields, user.FieldPhoneNumber)
	}
	if m.is_admin != nil {
		fields = append(fields, user.FieldIsAdmin)
	}
	if m.is_super_admin != nil {
		fields = append(fields, user.FieldIsSuperAdmin)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case user.FieldOrganizationID:
		return m.OrganizationID()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldStatus:
		return m.Status()
	case user.FieldName:
		return m.Name()
	case user.FieldUsername:
		return m.Username()
	case user.FieldPassword:
		return m.Password()
	case user.FieldEmail:
		return m.Email()
	case user.FieldDateJoined:
		return m.DateJoined()
	case user.FieldTimezone:
		return m.Timezone()
	case user.FieldProfilePicURL:
		return m.ProfilePicURL()
	case user.FieldThumbnailURL:
		return m.ThumbnailURL()
	case user.FieldPhoneNumber:
		return m.PhoneNumber()
	case user.FieldIsAdmin:
		return m.IsAdmin()
	case user.FieldIsSuperAdmin:
		return m.IsSuperAdmin()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case user.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldDateJoined:
		return m.OldDateJoined(ctx)
	case user.FieldTimezone:
		return m.OldTimezone(ctx)
	case user.FieldProfilePicURL:
		return m.OldProfilePicURL(ctx)
	case user.FieldThumbnailURL:
		return m.OldThumbnailURL(ctx)
	case user.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case user.FieldIsAdmin:
		return m.OldIsAdmin(ctx)
	case user.FieldIsSuperAdmin:
		return m.OldIsSuperAdmin(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case user.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(user.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldDateJoined:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateJoined(v)
		return nil
	case user.FieldTimezone:
		v, ok := value.(user.Timezone)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimezone(v)
		return nil
	case user.FieldProfilePicURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfilePicURL(v)
		return nil
	case user.FieldThumbnailURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnailURL(v)
		return nil
	case user.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case user.FieldIsAdmin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAdmin(v)
		return nil
	case user.FieldIsSuperAdmin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSuperAdmin(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldDateJoined) {
		fields = append(fields, user.FieldDateJoined)
	}
	if m.FieldCleared(user.FieldProfilePicURL) {
		fields = append(fields, user.FieldProfilePicURL)
	}
	if m.FieldCleared(user.FieldThumbnailURL) {
		fields = append(fields, user.FieldThumbnailURL)
	}
	if m.FieldCleared(user.FieldPhoneNumber) {
		fields = append(fields, user.FieldPhoneNumber)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldDateJoined:
		m.ClearDateJoined()
		return nil
	case user.FieldProfilePicURL:
		m.ClearProfilePicURL()
		return nil
	case user.FieldThumbnailURL:
		m.ClearThumbnailURL()
		return nil
	case user.FieldPhoneNumber:
		m.ClearPhoneNumber()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case user.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldDateJoined:
		m.ResetDateJoined()
		return nil
	case user.FieldTimezone:
		m.ResetTimezone()
		return nil
	case user.FieldProfilePicURL:
		m.ResetProfilePicURL()
		return nil
	case user.FieldThumbnailURL:
		m.ResetThumbnailURL()
		return nil
	case user.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case user.FieldIsAdmin:
		m.ResetIsAdmin()
		return nil
	case user.FieldIsSuperAdmin:
		m.ResetIsSuperAdmin()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.business_unit != nil {
		edges = append(edges, user.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, user.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbusiness_unit {
		edges = append(edges, user.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, user.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case user.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case user.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case user.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
