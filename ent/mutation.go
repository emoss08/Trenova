// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/emoss08/trenova/ent/accessorialcharge"
	"github.com/emoss08/trenova/ent/accountingcontrol"
	"github.com/emoss08/trenova/ent/billingcontrol"
	"github.com/emoss08/trenova/ent/businessunit"
	"github.com/emoss08/trenova/ent/chargetype"
	"github.com/emoss08/trenova/ent/commenttype"
	"github.com/emoss08/trenova/ent/commodity"
	"github.com/emoss08/trenova/ent/customer"
	"github.com/emoss08/trenova/ent/delaycode"
	"github.com/emoss08/trenova/ent/dispatchcontrol"
	"github.com/emoss08/trenova/ent/divisioncode"
	"github.com/emoss08/trenova/ent/documentclassification"
	"github.com/emoss08/trenova/ent/emailcontrol"
	"github.com/emoss08/trenova/ent/emailprofile"
	"github.com/emoss08/trenova/ent/equipmentmanufactuer"
	"github.com/emoss08/trenova/ent/equipmenttype"
	"github.com/emoss08/trenova/ent/feasibilitytoolcontrol"
	"github.com/emoss08/trenova/ent/fleetcode"
	"github.com/emoss08/trenova/ent/generalledgeraccount"
	"github.com/emoss08/trenova/ent/googleapi"
	"github.com/emoss08/trenova/ent/hazardousmaterial"
	"github.com/emoss08/trenova/ent/hazardousmaterialsegregation"
	"github.com/emoss08/trenova/ent/invoicecontrol"
	"github.com/emoss08/trenova/ent/locationcategory"
	"github.com/emoss08/trenova/ent/organization"
	"github.com/emoss08/trenova/ent/predicate"
	"github.com/emoss08/trenova/ent/qualifiercode"
	"github.com/emoss08/trenova/ent/reasoncode"
	"github.com/emoss08/trenova/ent/revenuecode"
	"github.com/emoss08/trenova/ent/routecontrol"
	"github.com/emoss08/trenova/ent/servicetype"
	"github.com/emoss08/trenova/ent/session"
	"github.com/emoss08/trenova/ent/shipmentcontrol"
	"github.com/emoss08/trenova/ent/shipmenttype"
	"github.com/emoss08/trenova/ent/tablechangealert"
	"github.com/emoss08/trenova/ent/tag"
	"github.com/emoss08/trenova/ent/tractor"
	"github.com/emoss08/trenova/ent/user"
	"github.com/emoss08/trenova/ent/userfavorite"
	"github.com/emoss08/trenova/ent/usstate"
	"github.com/emoss08/trenova/ent/worker"
	"github.com/emoss08/trenova/ent/workercomment"
	"github.com/emoss08/trenova/ent/workercontact"
	"github.com/emoss08/trenova/ent/workerprofile"
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccessorialCharge            = "AccessorialCharge"
	TypeAccountingControl            = "AccountingControl"
	TypeBillingControl               = "BillingControl"
	TypeBusinessUnit                 = "BusinessUnit"
	TypeChargeType                   = "ChargeType"
	TypeCommentType                  = "CommentType"
	TypeCommodity                    = "Commodity"
	TypeCustomer                     = "Customer"
	TypeDelayCode                    = "DelayCode"
	TypeDispatchControl              = "DispatchControl"
	TypeDivisionCode                 = "DivisionCode"
	TypeDocumentClassification       = "DocumentClassification"
	TypeEmailControl                 = "EmailControl"
	TypeEmailProfile                 = "EmailProfile"
	TypeEquipmentManufactuer         = "EquipmentManufactuer"
	TypeEquipmentType                = "EquipmentType"
	TypeFeasibilityToolControl       = "FeasibilityToolControl"
	TypeFleetCode                    = "FleetCode"
	TypeGeneralLedgerAccount         = "GeneralLedgerAccount"
	TypeGoogleApi                    = "GoogleApi"
	TypeHazardousMaterial            = "HazardousMaterial"
	TypeHazardousMaterialSegregation = "HazardousMaterialSegregation"
	TypeInvoiceControl               = "InvoiceControl"
	TypeLocationCategory             = "LocationCategory"
	TypeOrganization                 = "Organization"
	TypeQualifierCode                = "QualifierCode"
	TypeReasonCode                   = "ReasonCode"
	TypeRevenueCode                  = "RevenueCode"
	TypeRouteControl                 = "RouteControl"
	TypeServiceType                  = "ServiceType"
	TypeSession                      = "Session"
	TypeShipmentControl              = "ShipmentControl"
	TypeShipmentType                 = "ShipmentType"
	TypeTableChangeAlert             = "TableChangeAlert"
	TypeTag                          = "Tag"
	TypeTractor                      = "Tractor"
	TypeUsState                      = "UsState"
	TypeUser                         = "User"
	TypeUserFavorite                 = "UserFavorite"
	TypeWorker                       = "Worker"
	TypeWorkerComment                = "WorkerComment"
	TypeWorkerContact                = "WorkerContact"
	TypeWorkerProfile                = "WorkerProfile"
)

// AccessorialChargeMutation represents an operation that mutates the AccessorialCharge nodes in the graph.
type AccessorialChargeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	status               *accessorialcharge.Status
	code                 *string
	description          *string
	is_detention         *bool
	method               *accessorialcharge.Method
	amount               *float64
	addamount            *float64
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	done                 bool
	oldValue             func(context.Context) (*AccessorialCharge, error)
	predicates           []predicate.AccessorialCharge
}

var _ ent.Mutation = (*AccessorialChargeMutation)(nil)

// accessorialchargeOption allows management of the mutation configuration using functional options.
type accessorialchargeOption func(*AccessorialChargeMutation)

// newAccessorialChargeMutation creates new mutation for the AccessorialCharge entity.
func newAccessorialChargeMutation(c config, op Op, opts ...accessorialchargeOption) *AccessorialChargeMutation {
	m := &AccessorialChargeMutation{
		config:        c,
		op:            op,
		typ:           TypeAccessorialCharge,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccessorialChargeID sets the ID field of the mutation.
func withAccessorialChargeID(id uuid.UUID) accessorialchargeOption {
	return func(m *AccessorialChargeMutation) {
		var (
			err   error
			once  sync.Once
			value *AccessorialCharge
		)
		m.oldValue = func(ctx context.Context) (*AccessorialCharge, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AccessorialCharge.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccessorialCharge sets the old AccessorialCharge of the mutation.
func withAccessorialCharge(node *AccessorialCharge) accessorialchargeOption {
	return func(m *AccessorialChargeMutation) {
		m.oldValue = func(context.Context) (*AccessorialCharge, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccessorialChargeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccessorialChargeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AccessorialCharge entities.
func (m *AccessorialChargeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccessorialChargeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccessorialChargeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AccessorialCharge.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *AccessorialChargeMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *AccessorialChargeMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the AccessorialCharge entity.
// If the AccessorialCharge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessorialChargeMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *AccessorialChargeMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *AccessorialChargeMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *AccessorialChargeMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the AccessorialCharge entity.
// If the AccessorialCharge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessorialChargeMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *AccessorialChargeMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AccessorialChargeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccessorialChargeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AccessorialCharge entity.
// If the AccessorialCharge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessorialChargeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccessorialChargeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AccessorialChargeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AccessorialChargeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AccessorialCharge entity.
// If the AccessorialCharge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessorialChargeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AccessorialChargeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *AccessorialChargeMutation) SetStatus(a accessorialcharge.Status) {
	m.status = &a
}

// Status returns the value of the "status" field in the mutation.
func (m *AccessorialChargeMutation) Status() (r accessorialcharge.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AccessorialCharge entity.
// If the AccessorialCharge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessorialChargeMutation) OldStatus(ctx context.Context) (v accessorialcharge.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *AccessorialChargeMutation) ResetStatus() {
	m.status = nil
}

// SetCode sets the "code" field.
func (m *AccessorialChargeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *AccessorialChargeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the AccessorialCharge entity.
// If the AccessorialCharge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessorialChargeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *AccessorialChargeMutation) ResetCode() {
	m.code = nil
}

// SetDescription sets the "description" field.
func (m *AccessorialChargeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AccessorialChargeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AccessorialCharge entity.
// If the AccessorialCharge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessorialChargeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AccessorialChargeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[accessorialcharge.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AccessorialChargeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[accessorialcharge.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AccessorialChargeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, accessorialcharge.FieldDescription)
}

// SetIsDetention sets the "is_detention" field.
func (m *AccessorialChargeMutation) SetIsDetention(b bool) {
	m.is_detention = &b
}

// IsDetention returns the value of the "is_detention" field in the mutation.
func (m *AccessorialChargeMutation) IsDetention() (r bool, exists bool) {
	v := m.is_detention
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDetention returns the old "is_detention" field's value of the AccessorialCharge entity.
// If the AccessorialCharge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessorialChargeMutation) OldIsDetention(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDetention is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDetention requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDetention: %w", err)
	}
	return oldValue.IsDetention, nil
}

// ResetIsDetention resets all changes to the "is_detention" field.
func (m *AccessorialChargeMutation) ResetIsDetention() {
	m.is_detention = nil
}

// SetMethod sets the "method" field.
func (m *AccessorialChargeMutation) SetMethod(a accessorialcharge.Method) {
	m.method = &a
}

// Method returns the value of the "method" field in the mutation.
func (m *AccessorialChargeMutation) Method() (r accessorialcharge.Method, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the AccessorialCharge entity.
// If the AccessorialCharge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessorialChargeMutation) OldMethod(ctx context.Context) (v accessorialcharge.Method, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ResetMethod resets all changes to the "method" field.
func (m *AccessorialChargeMutation) ResetMethod() {
	m.method = nil
}

// SetAmount sets the "amount" field.
func (m *AccessorialChargeMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *AccessorialChargeMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the AccessorialCharge entity.
// If the AccessorialCharge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessorialChargeMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *AccessorialChargeMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *AccessorialChargeMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *AccessorialChargeMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *AccessorialChargeMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[accessorialcharge.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *AccessorialChargeMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *AccessorialChargeMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *AccessorialChargeMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *AccessorialChargeMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[accessorialcharge.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *AccessorialChargeMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *AccessorialChargeMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *AccessorialChargeMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the AccessorialChargeMutation builder.
func (m *AccessorialChargeMutation) Where(ps ...predicate.AccessorialCharge) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccessorialChargeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccessorialChargeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AccessorialCharge, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccessorialChargeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccessorialChargeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AccessorialCharge).
func (m *AccessorialChargeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccessorialChargeMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.business_unit != nil {
		fields = append(fields, accessorialcharge.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, accessorialcharge.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, accessorialcharge.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, accessorialcharge.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, accessorialcharge.FieldStatus)
	}
	if m.code != nil {
		fields = append(fields, accessorialcharge.FieldCode)
	}
	if m.description != nil {
		fields = append(fields, accessorialcharge.FieldDescription)
	}
	if m.is_detention != nil {
		fields = append(fields, accessorialcharge.FieldIsDetention)
	}
	if m.method != nil {
		fields = append(fields, accessorialcharge.FieldMethod)
	}
	if m.amount != nil {
		fields = append(fields, accessorialcharge.FieldAmount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccessorialChargeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case accessorialcharge.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case accessorialcharge.FieldOrganizationID:
		return m.OrganizationID()
	case accessorialcharge.FieldCreatedAt:
		return m.CreatedAt()
	case accessorialcharge.FieldUpdatedAt:
		return m.UpdatedAt()
	case accessorialcharge.FieldStatus:
		return m.Status()
	case accessorialcharge.FieldCode:
		return m.Code()
	case accessorialcharge.FieldDescription:
		return m.Description()
	case accessorialcharge.FieldIsDetention:
		return m.IsDetention()
	case accessorialcharge.FieldMethod:
		return m.Method()
	case accessorialcharge.FieldAmount:
		return m.Amount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccessorialChargeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case accessorialcharge.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case accessorialcharge.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case accessorialcharge.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case accessorialcharge.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case accessorialcharge.FieldStatus:
		return m.OldStatus(ctx)
	case accessorialcharge.FieldCode:
		return m.OldCode(ctx)
	case accessorialcharge.FieldDescription:
		return m.OldDescription(ctx)
	case accessorialcharge.FieldIsDetention:
		return m.OldIsDetention(ctx)
	case accessorialcharge.FieldMethod:
		return m.OldMethod(ctx)
	case accessorialcharge.FieldAmount:
		return m.OldAmount(ctx)
	}
	return nil, fmt.Errorf("unknown AccessorialCharge field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccessorialChargeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case accessorialcharge.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case accessorialcharge.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case accessorialcharge.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case accessorialcharge.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case accessorialcharge.FieldStatus:
		v, ok := value.(accessorialcharge.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case accessorialcharge.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case accessorialcharge.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case accessorialcharge.FieldIsDetention:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDetention(v)
		return nil
	case accessorialcharge.FieldMethod:
		v, ok := value.(accessorialcharge.Method)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case accessorialcharge.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	}
	return fmt.Errorf("unknown AccessorialCharge field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccessorialChargeMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, accessorialcharge.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccessorialChargeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case accessorialcharge.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccessorialChargeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case accessorialcharge.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown AccessorialCharge numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccessorialChargeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(accessorialcharge.FieldDescription) {
		fields = append(fields, accessorialcharge.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccessorialChargeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccessorialChargeMutation) ClearField(name string) error {
	switch name {
	case accessorialcharge.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown AccessorialCharge nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccessorialChargeMutation) ResetField(name string) error {
	switch name {
	case accessorialcharge.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case accessorialcharge.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case accessorialcharge.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case accessorialcharge.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case accessorialcharge.FieldStatus:
		m.ResetStatus()
		return nil
	case accessorialcharge.FieldCode:
		m.ResetCode()
		return nil
	case accessorialcharge.FieldDescription:
		m.ResetDescription()
		return nil
	case accessorialcharge.FieldIsDetention:
		m.ResetIsDetention()
		return nil
	case accessorialcharge.FieldMethod:
		m.ResetMethod()
		return nil
	case accessorialcharge.FieldAmount:
		m.ResetAmount()
		return nil
	}
	return fmt.Errorf("unknown AccessorialCharge field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccessorialChargeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.business_unit != nil {
		edges = append(edges, accessorialcharge.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, accessorialcharge.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccessorialChargeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case accessorialcharge.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case accessorialcharge.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccessorialChargeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccessorialChargeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccessorialChargeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbusiness_unit {
		edges = append(edges, accessorialcharge.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, accessorialcharge.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccessorialChargeMutation) EdgeCleared(name string) bool {
	switch name {
	case accessorialcharge.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case accessorialcharge.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccessorialChargeMutation) ClearEdge(name string) error {
	switch name {
	case accessorialcharge.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case accessorialcharge.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown AccessorialCharge unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccessorialChargeMutation) ResetEdge(name string) error {
	switch name {
	case accessorialcharge.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case accessorialcharge.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown AccessorialCharge edge %s", name)
}

// AccountingControlMutation represents an operation that mutates the AccountingControl nodes in the graph.
type AccountingControlMutation struct {
	config
	op                              Op
	typ                             string
	id                              *uuid.UUID
	created_at                      *time.Time
	updated_at                      *time.Time
	rec_threshold                   *int8
	addrec_threshold                *int8
	rec_threshold_action            *accountingcontrol.RecThresholdAction
	auto_create_journal_entries     *bool
	journal_entry_criteria          *accountingcontrol.JournalEntryCriteria
	restrict_manual_journal_entries *bool
	require_journal_entry_approval  *bool
	enable_rec_notifications        *bool
	halt_on_pending_rec             *bool
	critical_processes              *string
	clearedFields                   map[string]struct{}
	organization                    *uuid.UUID
	clearedorganization             bool
	business_unit                   *uuid.UUID
	clearedbusiness_unit            bool
	default_rev_account             *uuid.UUID
	cleareddefault_rev_account      bool
	default_exp_account             *uuid.UUID
	cleareddefault_exp_account      bool
	done                            bool
	oldValue                        func(context.Context) (*AccountingControl, error)
	predicates                      []predicate.AccountingControl
}

var _ ent.Mutation = (*AccountingControlMutation)(nil)

// accountingcontrolOption allows management of the mutation configuration using functional options.
type accountingcontrolOption func(*AccountingControlMutation)

// newAccountingControlMutation creates new mutation for the AccountingControl entity.
func newAccountingControlMutation(c config, op Op, opts ...accountingcontrolOption) *AccountingControlMutation {
	m := &AccountingControlMutation{
		config:        c,
		op:            op,
		typ:           TypeAccountingControl,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountingControlID sets the ID field of the mutation.
func withAccountingControlID(id uuid.UUID) accountingcontrolOption {
	return func(m *AccountingControlMutation) {
		var (
			err   error
			once  sync.Once
			value *AccountingControl
		)
		m.oldValue = func(ctx context.Context) (*AccountingControl, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AccountingControl.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccountingControl sets the old AccountingControl of the mutation.
func withAccountingControl(node *AccountingControl) accountingcontrolOption {
	return func(m *AccountingControlMutation) {
		m.oldValue = func(context.Context) (*AccountingControl, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountingControlMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountingControlMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AccountingControl entities.
func (m *AccountingControlMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountingControlMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountingControlMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AccountingControl.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountingControlMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountingControlMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AccountingControl entity.
// If the AccountingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingControlMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountingControlMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AccountingControlMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AccountingControlMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AccountingControl entity.
// If the AccountingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingControlMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AccountingControlMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetRecThreshold sets the "rec_threshold" field.
func (m *AccountingControlMutation) SetRecThreshold(i int8) {
	m.rec_threshold = &i
	m.addrec_threshold = nil
}

// RecThreshold returns the value of the "rec_threshold" field in the mutation.
func (m *AccountingControlMutation) RecThreshold() (r int8, exists bool) {
	v := m.rec_threshold
	if v == nil {
		return
	}
	return *v, true
}

// OldRecThreshold returns the old "rec_threshold" field's value of the AccountingControl entity.
// If the AccountingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingControlMutation) OldRecThreshold(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecThreshold is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecThreshold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecThreshold: %w", err)
	}
	return oldValue.RecThreshold, nil
}

// AddRecThreshold adds i to the "rec_threshold" field.
func (m *AccountingControlMutation) AddRecThreshold(i int8) {
	if m.addrec_threshold != nil {
		*m.addrec_threshold += i
	} else {
		m.addrec_threshold = &i
	}
}

// AddedRecThreshold returns the value that was added to the "rec_threshold" field in this mutation.
func (m *AccountingControlMutation) AddedRecThreshold() (r int8, exists bool) {
	v := m.addrec_threshold
	if v == nil {
		return
	}
	return *v, true
}

// ResetRecThreshold resets all changes to the "rec_threshold" field.
func (m *AccountingControlMutation) ResetRecThreshold() {
	m.rec_threshold = nil
	m.addrec_threshold = nil
}

// SetRecThresholdAction sets the "rec_threshold_action" field.
func (m *AccountingControlMutation) SetRecThresholdAction(ata accountingcontrol.RecThresholdAction) {
	m.rec_threshold_action = &ata
}

// RecThresholdAction returns the value of the "rec_threshold_action" field in the mutation.
func (m *AccountingControlMutation) RecThresholdAction() (r accountingcontrol.RecThresholdAction, exists bool) {
	v := m.rec_threshold_action
	if v == nil {
		return
	}
	return *v, true
}

// OldRecThresholdAction returns the old "rec_threshold_action" field's value of the AccountingControl entity.
// If the AccountingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingControlMutation) OldRecThresholdAction(ctx context.Context) (v accountingcontrol.RecThresholdAction, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecThresholdAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecThresholdAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecThresholdAction: %w", err)
	}
	return oldValue.RecThresholdAction, nil
}

// ResetRecThresholdAction resets all changes to the "rec_threshold_action" field.
func (m *AccountingControlMutation) ResetRecThresholdAction() {
	m.rec_threshold_action = nil
}

// SetAutoCreateJournalEntries sets the "auto_create_journal_entries" field.
func (m *AccountingControlMutation) SetAutoCreateJournalEntries(b bool) {
	m.auto_create_journal_entries = &b
}

// AutoCreateJournalEntries returns the value of the "auto_create_journal_entries" field in the mutation.
func (m *AccountingControlMutation) AutoCreateJournalEntries() (r bool, exists bool) {
	v := m.auto_create_journal_entries
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoCreateJournalEntries returns the old "auto_create_journal_entries" field's value of the AccountingControl entity.
// If the AccountingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingControlMutation) OldAutoCreateJournalEntries(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoCreateJournalEntries is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoCreateJournalEntries requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoCreateJournalEntries: %w", err)
	}
	return oldValue.AutoCreateJournalEntries, nil
}

// ResetAutoCreateJournalEntries resets all changes to the "auto_create_journal_entries" field.
func (m *AccountingControlMutation) ResetAutoCreateJournalEntries() {
	m.auto_create_journal_entries = nil
}

// SetJournalEntryCriteria sets the "journal_entry_criteria" field.
func (m *AccountingControlMutation) SetJournalEntryCriteria(aec accountingcontrol.JournalEntryCriteria) {
	m.journal_entry_criteria = &aec
}

// JournalEntryCriteria returns the value of the "journal_entry_criteria" field in the mutation.
func (m *AccountingControlMutation) JournalEntryCriteria() (r accountingcontrol.JournalEntryCriteria, exists bool) {
	v := m.journal_entry_criteria
	if v == nil {
		return
	}
	return *v, true
}

// OldJournalEntryCriteria returns the old "journal_entry_criteria" field's value of the AccountingControl entity.
// If the AccountingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingControlMutation) OldJournalEntryCriteria(ctx context.Context) (v accountingcontrol.JournalEntryCriteria, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJournalEntryCriteria is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJournalEntryCriteria requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJournalEntryCriteria: %w", err)
	}
	return oldValue.JournalEntryCriteria, nil
}

// ResetJournalEntryCriteria resets all changes to the "journal_entry_criteria" field.
func (m *AccountingControlMutation) ResetJournalEntryCriteria() {
	m.journal_entry_criteria = nil
}

// SetRestrictManualJournalEntries sets the "restrict_manual_journal_entries" field.
func (m *AccountingControlMutation) SetRestrictManualJournalEntries(b bool) {
	m.restrict_manual_journal_entries = &b
}

// RestrictManualJournalEntries returns the value of the "restrict_manual_journal_entries" field in the mutation.
func (m *AccountingControlMutation) RestrictManualJournalEntries() (r bool, exists bool) {
	v := m.restrict_manual_journal_entries
	if v == nil {
		return
	}
	return *v, true
}

// OldRestrictManualJournalEntries returns the old "restrict_manual_journal_entries" field's value of the AccountingControl entity.
// If the AccountingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingControlMutation) OldRestrictManualJournalEntries(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRestrictManualJournalEntries is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRestrictManualJournalEntries requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRestrictManualJournalEntries: %w", err)
	}
	return oldValue.RestrictManualJournalEntries, nil
}

// ResetRestrictManualJournalEntries resets all changes to the "restrict_manual_journal_entries" field.
func (m *AccountingControlMutation) ResetRestrictManualJournalEntries() {
	m.restrict_manual_journal_entries = nil
}

// SetRequireJournalEntryApproval sets the "require_journal_entry_approval" field.
func (m *AccountingControlMutation) SetRequireJournalEntryApproval(b bool) {
	m.require_journal_entry_approval = &b
}

// RequireJournalEntryApproval returns the value of the "require_journal_entry_approval" field in the mutation.
func (m *AccountingControlMutation) RequireJournalEntryApproval() (r bool, exists bool) {
	v := m.require_journal_entry_approval
	if v == nil {
		return
	}
	return *v, true
}

// OldRequireJournalEntryApproval returns the old "require_journal_entry_approval" field's value of the AccountingControl entity.
// If the AccountingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingControlMutation) OldRequireJournalEntryApproval(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequireJournalEntryApproval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequireJournalEntryApproval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequireJournalEntryApproval: %w", err)
	}
	return oldValue.RequireJournalEntryApproval, nil
}

// ResetRequireJournalEntryApproval resets all changes to the "require_journal_entry_approval" field.
func (m *AccountingControlMutation) ResetRequireJournalEntryApproval() {
	m.require_journal_entry_approval = nil
}

// SetEnableRecNotifications sets the "enable_rec_notifications" field.
func (m *AccountingControlMutation) SetEnableRecNotifications(b bool) {
	m.enable_rec_notifications = &b
}

// EnableRecNotifications returns the value of the "enable_rec_notifications" field in the mutation.
func (m *AccountingControlMutation) EnableRecNotifications() (r bool, exists bool) {
	v := m.enable_rec_notifications
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableRecNotifications returns the old "enable_rec_notifications" field's value of the AccountingControl entity.
// If the AccountingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingControlMutation) OldEnableRecNotifications(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnableRecNotifications is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnableRecNotifications requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableRecNotifications: %w", err)
	}
	return oldValue.EnableRecNotifications, nil
}

// ResetEnableRecNotifications resets all changes to the "enable_rec_notifications" field.
func (m *AccountingControlMutation) ResetEnableRecNotifications() {
	m.enable_rec_notifications = nil
}

// SetHaltOnPendingRec sets the "halt_on_pending_rec" field.
func (m *AccountingControlMutation) SetHaltOnPendingRec(b bool) {
	m.halt_on_pending_rec = &b
}

// HaltOnPendingRec returns the value of the "halt_on_pending_rec" field in the mutation.
func (m *AccountingControlMutation) HaltOnPendingRec() (r bool, exists bool) {
	v := m.halt_on_pending_rec
	if v == nil {
		return
	}
	return *v, true
}

// OldHaltOnPendingRec returns the old "halt_on_pending_rec" field's value of the AccountingControl entity.
// If the AccountingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingControlMutation) OldHaltOnPendingRec(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHaltOnPendingRec is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHaltOnPendingRec requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHaltOnPendingRec: %w", err)
	}
	return oldValue.HaltOnPendingRec, nil
}

// ResetHaltOnPendingRec resets all changes to the "halt_on_pending_rec" field.
func (m *AccountingControlMutation) ResetHaltOnPendingRec() {
	m.halt_on_pending_rec = nil
}

// SetCriticalProcesses sets the "critical_processes" field.
func (m *AccountingControlMutation) SetCriticalProcesses(s string) {
	m.critical_processes = &s
}

// CriticalProcesses returns the value of the "critical_processes" field in the mutation.
func (m *AccountingControlMutation) CriticalProcesses() (r string, exists bool) {
	v := m.critical_processes
	if v == nil {
		return
	}
	return *v, true
}

// OldCriticalProcesses returns the old "critical_processes" field's value of the AccountingControl entity.
// If the AccountingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingControlMutation) OldCriticalProcesses(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCriticalProcesses is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCriticalProcesses requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCriticalProcesses: %w", err)
	}
	return oldValue.CriticalProcesses, nil
}

// ClearCriticalProcesses clears the value of the "critical_processes" field.
func (m *AccountingControlMutation) ClearCriticalProcesses() {
	m.critical_processes = nil
	m.clearedFields[accountingcontrol.FieldCriticalProcesses] = struct{}{}
}

// CriticalProcessesCleared returns if the "critical_processes" field was cleared in this mutation.
func (m *AccountingControlMutation) CriticalProcessesCleared() bool {
	_, ok := m.clearedFields[accountingcontrol.FieldCriticalProcesses]
	return ok
}

// ResetCriticalProcesses resets all changes to the "critical_processes" field.
func (m *AccountingControlMutation) ResetCriticalProcesses() {
	m.critical_processes = nil
	delete(m.clearedFields, accountingcontrol.FieldCriticalProcesses)
}

// SetDefaultRevAccountID sets the "default_rev_account_id" field.
func (m *AccountingControlMutation) SetDefaultRevAccountID(u uuid.UUID) {
	m.default_rev_account = &u
}

// DefaultRevAccountID returns the value of the "default_rev_account_id" field in the mutation.
func (m *AccountingControlMutation) DefaultRevAccountID() (r uuid.UUID, exists bool) {
	v := m.default_rev_account
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultRevAccountID returns the old "default_rev_account_id" field's value of the AccountingControl entity.
// If the AccountingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingControlMutation) OldDefaultRevAccountID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultRevAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultRevAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultRevAccountID: %w", err)
	}
	return oldValue.DefaultRevAccountID, nil
}

// ClearDefaultRevAccountID clears the value of the "default_rev_account_id" field.
func (m *AccountingControlMutation) ClearDefaultRevAccountID() {
	m.default_rev_account = nil
	m.clearedFields[accountingcontrol.FieldDefaultRevAccountID] = struct{}{}
}

// DefaultRevAccountIDCleared returns if the "default_rev_account_id" field was cleared in this mutation.
func (m *AccountingControlMutation) DefaultRevAccountIDCleared() bool {
	_, ok := m.clearedFields[accountingcontrol.FieldDefaultRevAccountID]
	return ok
}

// ResetDefaultRevAccountID resets all changes to the "default_rev_account_id" field.
func (m *AccountingControlMutation) ResetDefaultRevAccountID() {
	m.default_rev_account = nil
	delete(m.clearedFields, accountingcontrol.FieldDefaultRevAccountID)
}

// SetDefaultExpAccountID sets the "default_exp_account_id" field.
func (m *AccountingControlMutation) SetDefaultExpAccountID(u uuid.UUID) {
	m.default_exp_account = &u
}

// DefaultExpAccountID returns the value of the "default_exp_account_id" field in the mutation.
func (m *AccountingControlMutation) DefaultExpAccountID() (r uuid.UUID, exists bool) {
	v := m.default_exp_account
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultExpAccountID returns the old "default_exp_account_id" field's value of the AccountingControl entity.
// If the AccountingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountingControlMutation) OldDefaultExpAccountID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultExpAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultExpAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultExpAccountID: %w", err)
	}
	return oldValue.DefaultExpAccountID, nil
}

// ClearDefaultExpAccountID clears the value of the "default_exp_account_id" field.
func (m *AccountingControlMutation) ClearDefaultExpAccountID() {
	m.default_exp_account = nil
	m.clearedFields[accountingcontrol.FieldDefaultExpAccountID] = struct{}{}
}

// DefaultExpAccountIDCleared returns if the "default_exp_account_id" field was cleared in this mutation.
func (m *AccountingControlMutation) DefaultExpAccountIDCleared() bool {
	_, ok := m.clearedFields[accountingcontrol.FieldDefaultExpAccountID]
	return ok
}

// ResetDefaultExpAccountID resets all changes to the "default_exp_account_id" field.
func (m *AccountingControlMutation) ResetDefaultExpAccountID() {
	m.default_exp_account = nil
	delete(m.clearedFields, accountingcontrol.FieldDefaultExpAccountID)
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *AccountingControlMutation) SetOrganizationID(id uuid.UUID) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *AccountingControlMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *AccountingControlMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *AccountingControlMutation) OrganizationID() (id uuid.UUID, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *AccountingControlMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *AccountingControlMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// SetBusinessUnitID sets the "business_unit" edge to the BusinessUnit entity by id.
func (m *AccountingControlMutation) SetBusinessUnitID(id uuid.UUID) {
	m.business_unit = &id
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *AccountingControlMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *AccountingControlMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitID returns the "business_unit" edge ID in the mutation.
func (m *AccountingControlMutation) BusinessUnitID() (id uuid.UUID, exists bool) {
	if m.business_unit != nil {
		return *m.business_unit, true
	}
	return
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *AccountingControlMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *AccountingControlMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearDefaultRevAccount clears the "default_rev_account" edge to the GeneralLedgerAccount entity.
func (m *AccountingControlMutation) ClearDefaultRevAccount() {
	m.cleareddefault_rev_account = true
	m.clearedFields[accountingcontrol.FieldDefaultRevAccountID] = struct{}{}
}

// DefaultRevAccountCleared reports if the "default_rev_account" edge to the GeneralLedgerAccount entity was cleared.
func (m *AccountingControlMutation) DefaultRevAccountCleared() bool {
	return m.DefaultRevAccountIDCleared() || m.cleareddefault_rev_account
}

// DefaultRevAccountIDs returns the "default_rev_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DefaultRevAccountID instead. It exists only for internal usage by the builders.
func (m *AccountingControlMutation) DefaultRevAccountIDs() (ids []uuid.UUID) {
	if id := m.default_rev_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDefaultRevAccount resets all changes to the "default_rev_account" edge.
func (m *AccountingControlMutation) ResetDefaultRevAccount() {
	m.default_rev_account = nil
	m.cleareddefault_rev_account = false
}

// ClearDefaultExpAccount clears the "default_exp_account" edge to the GeneralLedgerAccount entity.
func (m *AccountingControlMutation) ClearDefaultExpAccount() {
	m.cleareddefault_exp_account = true
	m.clearedFields[accountingcontrol.FieldDefaultExpAccountID] = struct{}{}
}

// DefaultExpAccountCleared reports if the "default_exp_account" edge to the GeneralLedgerAccount entity was cleared.
func (m *AccountingControlMutation) DefaultExpAccountCleared() bool {
	return m.DefaultExpAccountIDCleared() || m.cleareddefault_exp_account
}

// DefaultExpAccountIDs returns the "default_exp_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DefaultExpAccountID instead. It exists only for internal usage by the builders.
func (m *AccountingControlMutation) DefaultExpAccountIDs() (ids []uuid.UUID) {
	if id := m.default_exp_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDefaultExpAccount resets all changes to the "default_exp_account" edge.
func (m *AccountingControlMutation) ResetDefaultExpAccount() {
	m.default_exp_account = nil
	m.cleareddefault_exp_account = false
}

// Where appends a list predicates to the AccountingControlMutation builder.
func (m *AccountingControlMutation) Where(ps ...predicate.AccountingControl) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountingControlMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountingControlMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AccountingControl, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountingControlMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountingControlMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AccountingControl).
func (m *AccountingControlMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountingControlMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, accountingcontrol.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, accountingcontrol.FieldUpdatedAt)
	}
	if m.rec_threshold != nil {
		fields = append(fields, accountingcontrol.FieldRecThreshold)
	}
	if m.rec_threshold_action != nil {
		fields = append(fields, accountingcontrol.FieldRecThresholdAction)
	}
	if m.auto_create_journal_entries != nil {
		fields = append(fields, accountingcontrol.FieldAutoCreateJournalEntries)
	}
	if m.journal_entry_criteria != nil {
		fields = append(fields, accountingcontrol.FieldJournalEntryCriteria)
	}
	if m.restrict_manual_journal_entries != nil {
		fields = append(fields, accountingcontrol.FieldRestrictManualJournalEntries)
	}
	if m.require_journal_entry_approval != nil {
		fields = append(fields, accountingcontrol.FieldRequireJournalEntryApproval)
	}
	if m.enable_rec_notifications != nil {
		fields = append(fields, accountingcontrol.FieldEnableRecNotifications)
	}
	if m.halt_on_pending_rec != nil {
		fields = append(fields, accountingcontrol.FieldHaltOnPendingRec)
	}
	if m.critical_processes != nil {
		fields = append(fields, accountingcontrol.FieldCriticalProcesses)
	}
	if m.default_rev_account != nil {
		fields = append(fields, accountingcontrol.FieldDefaultRevAccountID)
	}
	if m.default_exp_account != nil {
		fields = append(fields, accountingcontrol.FieldDefaultExpAccountID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountingControlMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case accountingcontrol.FieldCreatedAt:
		return m.CreatedAt()
	case accountingcontrol.FieldUpdatedAt:
		return m.UpdatedAt()
	case accountingcontrol.FieldRecThreshold:
		return m.RecThreshold()
	case accountingcontrol.FieldRecThresholdAction:
		return m.RecThresholdAction()
	case accountingcontrol.FieldAutoCreateJournalEntries:
		return m.AutoCreateJournalEntries()
	case accountingcontrol.FieldJournalEntryCriteria:
		return m.JournalEntryCriteria()
	case accountingcontrol.FieldRestrictManualJournalEntries:
		return m.RestrictManualJournalEntries()
	case accountingcontrol.FieldRequireJournalEntryApproval:
		return m.RequireJournalEntryApproval()
	case accountingcontrol.FieldEnableRecNotifications:
		return m.EnableRecNotifications()
	case accountingcontrol.FieldHaltOnPendingRec:
		return m.HaltOnPendingRec()
	case accountingcontrol.FieldCriticalProcesses:
		return m.CriticalProcesses()
	case accountingcontrol.FieldDefaultRevAccountID:
		return m.DefaultRevAccountID()
	case accountingcontrol.FieldDefaultExpAccountID:
		return m.DefaultExpAccountID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountingControlMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case accountingcontrol.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case accountingcontrol.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case accountingcontrol.FieldRecThreshold:
		return m.OldRecThreshold(ctx)
	case accountingcontrol.FieldRecThresholdAction:
		return m.OldRecThresholdAction(ctx)
	case accountingcontrol.FieldAutoCreateJournalEntries:
		return m.OldAutoCreateJournalEntries(ctx)
	case accountingcontrol.FieldJournalEntryCriteria:
		return m.OldJournalEntryCriteria(ctx)
	case accountingcontrol.FieldRestrictManualJournalEntries:
		return m.OldRestrictManualJournalEntries(ctx)
	case accountingcontrol.FieldRequireJournalEntryApproval:
		return m.OldRequireJournalEntryApproval(ctx)
	case accountingcontrol.FieldEnableRecNotifications:
		return m.OldEnableRecNotifications(ctx)
	case accountingcontrol.FieldHaltOnPendingRec:
		return m.OldHaltOnPendingRec(ctx)
	case accountingcontrol.FieldCriticalProcesses:
		return m.OldCriticalProcesses(ctx)
	case accountingcontrol.FieldDefaultRevAccountID:
		return m.OldDefaultRevAccountID(ctx)
	case accountingcontrol.FieldDefaultExpAccountID:
		return m.OldDefaultExpAccountID(ctx)
	}
	return nil, fmt.Errorf("unknown AccountingControl field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountingControlMutation) SetField(name string, value ent.Value) error {
	switch name {
	case accountingcontrol.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case accountingcontrol.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case accountingcontrol.FieldRecThreshold:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecThreshold(v)
		return nil
	case accountingcontrol.FieldRecThresholdAction:
		v, ok := value.(accountingcontrol.RecThresholdAction)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecThresholdAction(v)
		return nil
	case accountingcontrol.FieldAutoCreateJournalEntries:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoCreateJournalEntries(v)
		return nil
	case accountingcontrol.FieldJournalEntryCriteria:
		v, ok := value.(accountingcontrol.JournalEntryCriteria)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJournalEntryCriteria(v)
		return nil
	case accountingcontrol.FieldRestrictManualJournalEntries:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRestrictManualJournalEntries(v)
		return nil
	case accountingcontrol.FieldRequireJournalEntryApproval:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequireJournalEntryApproval(v)
		return nil
	case accountingcontrol.FieldEnableRecNotifications:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableRecNotifications(v)
		return nil
	case accountingcontrol.FieldHaltOnPendingRec:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHaltOnPendingRec(v)
		return nil
	case accountingcontrol.FieldCriticalProcesses:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCriticalProcesses(v)
		return nil
	case accountingcontrol.FieldDefaultRevAccountID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultRevAccountID(v)
		return nil
	case accountingcontrol.FieldDefaultExpAccountID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultExpAccountID(v)
		return nil
	}
	return fmt.Errorf("unknown AccountingControl field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountingControlMutation) AddedFields() []string {
	var fields []string
	if m.addrec_threshold != nil {
		fields = append(fields, accountingcontrol.FieldRecThreshold)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountingControlMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case accountingcontrol.FieldRecThreshold:
		return m.AddedRecThreshold()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountingControlMutation) AddField(name string, value ent.Value) error {
	switch name {
	case accountingcontrol.FieldRecThreshold:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRecThreshold(v)
		return nil
	}
	return fmt.Errorf("unknown AccountingControl numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountingControlMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(accountingcontrol.FieldCriticalProcesses) {
		fields = append(fields, accountingcontrol.FieldCriticalProcesses)
	}
	if m.FieldCleared(accountingcontrol.FieldDefaultRevAccountID) {
		fields = append(fields, accountingcontrol.FieldDefaultRevAccountID)
	}
	if m.FieldCleared(accountingcontrol.FieldDefaultExpAccountID) {
		fields = append(fields, accountingcontrol.FieldDefaultExpAccountID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountingControlMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountingControlMutation) ClearField(name string) error {
	switch name {
	case accountingcontrol.FieldCriticalProcesses:
		m.ClearCriticalProcesses()
		return nil
	case accountingcontrol.FieldDefaultRevAccountID:
		m.ClearDefaultRevAccountID()
		return nil
	case accountingcontrol.FieldDefaultExpAccountID:
		m.ClearDefaultExpAccountID()
		return nil
	}
	return fmt.Errorf("unknown AccountingControl nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountingControlMutation) ResetField(name string) error {
	switch name {
	case accountingcontrol.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case accountingcontrol.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case accountingcontrol.FieldRecThreshold:
		m.ResetRecThreshold()
		return nil
	case accountingcontrol.FieldRecThresholdAction:
		m.ResetRecThresholdAction()
		return nil
	case accountingcontrol.FieldAutoCreateJournalEntries:
		m.ResetAutoCreateJournalEntries()
		return nil
	case accountingcontrol.FieldJournalEntryCriteria:
		m.ResetJournalEntryCriteria()
		return nil
	case accountingcontrol.FieldRestrictManualJournalEntries:
		m.ResetRestrictManualJournalEntries()
		return nil
	case accountingcontrol.FieldRequireJournalEntryApproval:
		m.ResetRequireJournalEntryApproval()
		return nil
	case accountingcontrol.FieldEnableRecNotifications:
		m.ResetEnableRecNotifications()
		return nil
	case accountingcontrol.FieldHaltOnPendingRec:
		m.ResetHaltOnPendingRec()
		return nil
	case accountingcontrol.FieldCriticalProcesses:
		m.ResetCriticalProcesses()
		return nil
	case accountingcontrol.FieldDefaultRevAccountID:
		m.ResetDefaultRevAccountID()
		return nil
	case accountingcontrol.FieldDefaultExpAccountID:
		m.ResetDefaultExpAccountID()
		return nil
	}
	return fmt.Errorf("unknown AccountingControl field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountingControlMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.organization != nil {
		edges = append(edges, accountingcontrol.EdgeOrganization)
	}
	if m.business_unit != nil {
		edges = append(edges, accountingcontrol.EdgeBusinessUnit)
	}
	if m.default_rev_account != nil {
		edges = append(edges, accountingcontrol.EdgeDefaultRevAccount)
	}
	if m.default_exp_account != nil {
		edges = append(edges, accountingcontrol.EdgeDefaultExpAccount)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountingControlMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case accountingcontrol.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case accountingcontrol.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case accountingcontrol.EdgeDefaultRevAccount:
		if id := m.default_rev_account; id != nil {
			return []ent.Value{*id}
		}
	case accountingcontrol.EdgeDefaultExpAccount:
		if id := m.default_exp_account; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountingControlMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountingControlMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountingControlMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedorganization {
		edges = append(edges, accountingcontrol.EdgeOrganization)
	}
	if m.clearedbusiness_unit {
		edges = append(edges, accountingcontrol.EdgeBusinessUnit)
	}
	if m.cleareddefault_rev_account {
		edges = append(edges, accountingcontrol.EdgeDefaultRevAccount)
	}
	if m.cleareddefault_exp_account {
		edges = append(edges, accountingcontrol.EdgeDefaultExpAccount)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountingControlMutation) EdgeCleared(name string) bool {
	switch name {
	case accountingcontrol.EdgeOrganization:
		return m.clearedorganization
	case accountingcontrol.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case accountingcontrol.EdgeDefaultRevAccount:
		return m.cleareddefault_rev_account
	case accountingcontrol.EdgeDefaultExpAccount:
		return m.cleareddefault_exp_account
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountingControlMutation) ClearEdge(name string) error {
	switch name {
	case accountingcontrol.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case accountingcontrol.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case accountingcontrol.EdgeDefaultRevAccount:
		m.ClearDefaultRevAccount()
		return nil
	case accountingcontrol.EdgeDefaultExpAccount:
		m.ClearDefaultExpAccount()
		return nil
	}
	return fmt.Errorf("unknown AccountingControl unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountingControlMutation) ResetEdge(name string) error {
	switch name {
	case accountingcontrol.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case accountingcontrol.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case accountingcontrol.EdgeDefaultRevAccount:
		m.ResetDefaultRevAccount()
		return nil
	case accountingcontrol.EdgeDefaultExpAccount:
		m.ResetDefaultExpAccount()
		return nil
	}
	return fmt.Errorf("unknown AccountingControl edge %s", name)
}

// BillingControlMutation represents an operation that mutates the BillingControl nodes in the graph.
type BillingControlMutation struct {
	config
	op                         Op
	typ                        string
	id                         *uuid.UUID
	created_at                 *time.Time
	updated_at                 *time.Time
	remove_billing_history     *bool
	auto_bill_shipment         *bool
	auto_mark_ready_to_bill    *bool
	validate_customer_rates    *bool
	auto_bill_criteria         *billingcontrol.AutoBillCriteria
	shipment_transfer_criteria *billingcontrol.ShipmentTransferCriteria
	enforce_customer_billing   *bool
	clearedFields              map[string]struct{}
	organization               *uuid.UUID
	clearedorganization        bool
	business_unit              *uuid.UUID
	clearedbusiness_unit       bool
	done                       bool
	oldValue                   func(context.Context) (*BillingControl, error)
	predicates                 []predicate.BillingControl
}

var _ ent.Mutation = (*BillingControlMutation)(nil)

// billingcontrolOption allows management of the mutation configuration using functional options.
type billingcontrolOption func(*BillingControlMutation)

// newBillingControlMutation creates new mutation for the BillingControl entity.
func newBillingControlMutation(c config, op Op, opts ...billingcontrolOption) *BillingControlMutation {
	m := &BillingControlMutation{
		config:        c,
		op:            op,
		typ:           TypeBillingControl,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillingControlID sets the ID field of the mutation.
func withBillingControlID(id uuid.UUID) billingcontrolOption {
	return func(m *BillingControlMutation) {
		var (
			err   error
			once  sync.Once
			value *BillingControl
		)
		m.oldValue = func(ctx context.Context) (*BillingControl, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BillingControl.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBillingControl sets the old BillingControl of the mutation.
func withBillingControl(node *BillingControl) billingcontrolOption {
	return func(m *BillingControlMutation) {
		m.oldValue = func(context.Context) (*BillingControl, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillingControlMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillingControlMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BillingControl entities.
func (m *BillingControlMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BillingControlMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BillingControlMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BillingControl.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BillingControlMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BillingControlMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BillingControl entity.
// If the BillingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingControlMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BillingControlMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BillingControlMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BillingControlMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BillingControl entity.
// If the BillingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingControlMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BillingControlMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetRemoveBillingHistory sets the "remove_billing_history" field.
func (m *BillingControlMutation) SetRemoveBillingHistory(b bool) {
	m.remove_billing_history = &b
}

// RemoveBillingHistory returns the value of the "remove_billing_history" field in the mutation.
func (m *BillingControlMutation) RemoveBillingHistory() (r bool, exists bool) {
	v := m.remove_billing_history
	if v == nil {
		return
	}
	return *v, true
}

// OldRemoveBillingHistory returns the old "remove_billing_history" field's value of the BillingControl entity.
// If the BillingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingControlMutation) OldRemoveBillingHistory(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemoveBillingHistory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemoveBillingHistory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemoveBillingHistory: %w", err)
	}
	return oldValue.RemoveBillingHistory, nil
}

// ResetRemoveBillingHistory resets all changes to the "remove_billing_history" field.
func (m *BillingControlMutation) ResetRemoveBillingHistory() {
	m.remove_billing_history = nil
}

// SetAutoBillShipment sets the "auto_bill_shipment" field.
func (m *BillingControlMutation) SetAutoBillShipment(b bool) {
	m.auto_bill_shipment = &b
}

// AutoBillShipment returns the value of the "auto_bill_shipment" field in the mutation.
func (m *BillingControlMutation) AutoBillShipment() (r bool, exists bool) {
	v := m.auto_bill_shipment
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoBillShipment returns the old "auto_bill_shipment" field's value of the BillingControl entity.
// If the BillingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingControlMutation) OldAutoBillShipment(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoBillShipment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoBillShipment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoBillShipment: %w", err)
	}
	return oldValue.AutoBillShipment, nil
}

// ResetAutoBillShipment resets all changes to the "auto_bill_shipment" field.
func (m *BillingControlMutation) ResetAutoBillShipment() {
	m.auto_bill_shipment = nil
}

// SetAutoMarkReadyToBill sets the "auto_mark_ready_to_bill" field.
func (m *BillingControlMutation) SetAutoMarkReadyToBill(b bool) {
	m.auto_mark_ready_to_bill = &b
}

// AutoMarkReadyToBill returns the value of the "auto_mark_ready_to_bill" field in the mutation.
func (m *BillingControlMutation) AutoMarkReadyToBill() (r bool, exists bool) {
	v := m.auto_mark_ready_to_bill
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoMarkReadyToBill returns the old "auto_mark_ready_to_bill" field's value of the BillingControl entity.
// If the BillingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingControlMutation) OldAutoMarkReadyToBill(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoMarkReadyToBill is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoMarkReadyToBill requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoMarkReadyToBill: %w", err)
	}
	return oldValue.AutoMarkReadyToBill, nil
}

// ResetAutoMarkReadyToBill resets all changes to the "auto_mark_ready_to_bill" field.
func (m *BillingControlMutation) ResetAutoMarkReadyToBill() {
	m.auto_mark_ready_to_bill = nil
}

// SetValidateCustomerRates sets the "validate_customer_rates" field.
func (m *BillingControlMutation) SetValidateCustomerRates(b bool) {
	m.validate_customer_rates = &b
}

// ValidateCustomerRates returns the value of the "validate_customer_rates" field in the mutation.
func (m *BillingControlMutation) ValidateCustomerRates() (r bool, exists bool) {
	v := m.validate_customer_rates
	if v == nil {
		return
	}
	return *v, true
}

// OldValidateCustomerRates returns the old "validate_customer_rates" field's value of the BillingControl entity.
// If the BillingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingControlMutation) OldValidateCustomerRates(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidateCustomerRates is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidateCustomerRates requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidateCustomerRates: %w", err)
	}
	return oldValue.ValidateCustomerRates, nil
}

// ResetValidateCustomerRates resets all changes to the "validate_customer_rates" field.
func (m *BillingControlMutation) ResetValidateCustomerRates() {
	m.validate_customer_rates = nil
}

// SetAutoBillCriteria sets the "auto_bill_criteria" field.
func (m *BillingControlMutation) SetAutoBillCriteria(bbc billingcontrol.AutoBillCriteria) {
	m.auto_bill_criteria = &bbc
}

// AutoBillCriteria returns the value of the "auto_bill_criteria" field in the mutation.
func (m *BillingControlMutation) AutoBillCriteria() (r billingcontrol.AutoBillCriteria, exists bool) {
	v := m.auto_bill_criteria
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoBillCriteria returns the old "auto_bill_criteria" field's value of the BillingControl entity.
// If the BillingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingControlMutation) OldAutoBillCriteria(ctx context.Context) (v billingcontrol.AutoBillCriteria, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoBillCriteria is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoBillCriteria requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoBillCriteria: %w", err)
	}
	return oldValue.AutoBillCriteria, nil
}

// ResetAutoBillCriteria resets all changes to the "auto_bill_criteria" field.
func (m *BillingControlMutation) ResetAutoBillCriteria() {
	m.auto_bill_criteria = nil
}

// SetShipmentTransferCriteria sets the "shipment_transfer_criteria" field.
func (m *BillingControlMutation) SetShipmentTransferCriteria(btc billingcontrol.ShipmentTransferCriteria) {
	m.shipment_transfer_criteria = &btc
}

// ShipmentTransferCriteria returns the value of the "shipment_transfer_criteria" field in the mutation.
func (m *BillingControlMutation) ShipmentTransferCriteria() (r billingcontrol.ShipmentTransferCriteria, exists bool) {
	v := m.shipment_transfer_criteria
	if v == nil {
		return
	}
	return *v, true
}

// OldShipmentTransferCriteria returns the old "shipment_transfer_criteria" field's value of the BillingControl entity.
// If the BillingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingControlMutation) OldShipmentTransferCriteria(ctx context.Context) (v billingcontrol.ShipmentTransferCriteria, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShipmentTransferCriteria is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShipmentTransferCriteria requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipmentTransferCriteria: %w", err)
	}
	return oldValue.ShipmentTransferCriteria, nil
}

// ResetShipmentTransferCriteria resets all changes to the "shipment_transfer_criteria" field.
func (m *BillingControlMutation) ResetShipmentTransferCriteria() {
	m.shipment_transfer_criteria = nil
}

// SetEnforceCustomerBilling sets the "enforce_customer_billing" field.
func (m *BillingControlMutation) SetEnforceCustomerBilling(b bool) {
	m.enforce_customer_billing = &b
}

// EnforceCustomerBilling returns the value of the "enforce_customer_billing" field in the mutation.
func (m *BillingControlMutation) EnforceCustomerBilling() (r bool, exists bool) {
	v := m.enforce_customer_billing
	if v == nil {
		return
	}
	return *v, true
}

// OldEnforceCustomerBilling returns the old "enforce_customer_billing" field's value of the BillingControl entity.
// If the BillingControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingControlMutation) OldEnforceCustomerBilling(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnforceCustomerBilling is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnforceCustomerBilling requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnforceCustomerBilling: %w", err)
	}
	return oldValue.EnforceCustomerBilling, nil
}

// ResetEnforceCustomerBilling resets all changes to the "enforce_customer_billing" field.
func (m *BillingControlMutation) ResetEnforceCustomerBilling() {
	m.enforce_customer_billing = nil
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *BillingControlMutation) SetOrganizationID(id uuid.UUID) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *BillingControlMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *BillingControlMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *BillingControlMutation) OrganizationID() (id uuid.UUID, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *BillingControlMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *BillingControlMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// SetBusinessUnitID sets the "business_unit" edge to the BusinessUnit entity by id.
func (m *BillingControlMutation) SetBusinessUnitID(id uuid.UUID) {
	m.business_unit = &id
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *BillingControlMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *BillingControlMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitID returns the "business_unit" edge ID in the mutation.
func (m *BillingControlMutation) BusinessUnitID() (id uuid.UUID, exists bool) {
	if m.business_unit != nil {
		return *m.business_unit, true
	}
	return
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *BillingControlMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *BillingControlMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// Where appends a list predicates to the BillingControlMutation builder.
func (m *BillingControlMutation) Where(ps ...predicate.BillingControl) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BillingControlMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BillingControlMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BillingControl, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BillingControlMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BillingControlMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BillingControl).
func (m *BillingControlMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BillingControlMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, billingcontrol.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, billingcontrol.FieldUpdatedAt)
	}
	if m.remove_billing_history != nil {
		fields = append(fields, billingcontrol.FieldRemoveBillingHistory)
	}
	if m.auto_bill_shipment != nil {
		fields = append(fields, billingcontrol.FieldAutoBillShipment)
	}
	if m.auto_mark_ready_to_bill != nil {
		fields = append(fields, billingcontrol.FieldAutoMarkReadyToBill)
	}
	if m.validate_customer_rates != nil {
		fields = append(fields, billingcontrol.FieldValidateCustomerRates)
	}
	if m.auto_bill_criteria != nil {
		fields = append(fields, billingcontrol.FieldAutoBillCriteria)
	}
	if m.shipment_transfer_criteria != nil {
		fields = append(fields, billingcontrol.FieldShipmentTransferCriteria)
	}
	if m.enforce_customer_billing != nil {
		fields = append(fields, billingcontrol.FieldEnforceCustomerBilling)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BillingControlMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case billingcontrol.FieldCreatedAt:
		return m.CreatedAt()
	case billingcontrol.FieldUpdatedAt:
		return m.UpdatedAt()
	case billingcontrol.FieldRemoveBillingHistory:
		return m.RemoveBillingHistory()
	case billingcontrol.FieldAutoBillShipment:
		return m.AutoBillShipment()
	case billingcontrol.FieldAutoMarkReadyToBill:
		return m.AutoMarkReadyToBill()
	case billingcontrol.FieldValidateCustomerRates:
		return m.ValidateCustomerRates()
	case billingcontrol.FieldAutoBillCriteria:
		return m.AutoBillCriteria()
	case billingcontrol.FieldShipmentTransferCriteria:
		return m.ShipmentTransferCriteria()
	case billingcontrol.FieldEnforceCustomerBilling:
		return m.EnforceCustomerBilling()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BillingControlMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case billingcontrol.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case billingcontrol.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case billingcontrol.FieldRemoveBillingHistory:
		return m.OldRemoveBillingHistory(ctx)
	case billingcontrol.FieldAutoBillShipment:
		return m.OldAutoBillShipment(ctx)
	case billingcontrol.FieldAutoMarkReadyToBill:
		return m.OldAutoMarkReadyToBill(ctx)
	case billingcontrol.FieldValidateCustomerRates:
		return m.OldValidateCustomerRates(ctx)
	case billingcontrol.FieldAutoBillCriteria:
		return m.OldAutoBillCriteria(ctx)
	case billingcontrol.FieldShipmentTransferCriteria:
		return m.OldShipmentTransferCriteria(ctx)
	case billingcontrol.FieldEnforceCustomerBilling:
		return m.OldEnforceCustomerBilling(ctx)
	}
	return nil, fmt.Errorf("unknown BillingControl field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingControlMutation) SetField(name string, value ent.Value) error {
	switch name {
	case billingcontrol.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case billingcontrol.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case billingcontrol.FieldRemoveBillingHistory:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemoveBillingHistory(v)
		return nil
	case billingcontrol.FieldAutoBillShipment:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoBillShipment(v)
		return nil
	case billingcontrol.FieldAutoMarkReadyToBill:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoMarkReadyToBill(v)
		return nil
	case billingcontrol.FieldValidateCustomerRates:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidateCustomerRates(v)
		return nil
	case billingcontrol.FieldAutoBillCriteria:
		v, ok := value.(billingcontrol.AutoBillCriteria)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoBillCriteria(v)
		return nil
	case billingcontrol.FieldShipmentTransferCriteria:
		v, ok := value.(billingcontrol.ShipmentTransferCriteria)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipmentTransferCriteria(v)
		return nil
	case billingcontrol.FieldEnforceCustomerBilling:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnforceCustomerBilling(v)
		return nil
	}
	return fmt.Errorf("unknown BillingControl field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BillingControlMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BillingControlMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingControlMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BillingControl numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BillingControlMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BillingControlMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillingControlMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BillingControl nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BillingControlMutation) ResetField(name string) error {
	switch name {
	case billingcontrol.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case billingcontrol.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case billingcontrol.FieldRemoveBillingHistory:
		m.ResetRemoveBillingHistory()
		return nil
	case billingcontrol.FieldAutoBillShipment:
		m.ResetAutoBillShipment()
		return nil
	case billingcontrol.FieldAutoMarkReadyToBill:
		m.ResetAutoMarkReadyToBill()
		return nil
	case billingcontrol.FieldValidateCustomerRates:
		m.ResetValidateCustomerRates()
		return nil
	case billingcontrol.FieldAutoBillCriteria:
		m.ResetAutoBillCriteria()
		return nil
	case billingcontrol.FieldShipmentTransferCriteria:
		m.ResetShipmentTransferCriteria()
		return nil
	case billingcontrol.FieldEnforceCustomerBilling:
		m.ResetEnforceCustomerBilling()
		return nil
	}
	return fmt.Errorf("unknown BillingControl field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BillingControlMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.organization != nil {
		edges = append(edges, billingcontrol.EdgeOrganization)
	}
	if m.business_unit != nil {
		edges = append(edges, billingcontrol.EdgeBusinessUnit)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BillingControlMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case billingcontrol.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case billingcontrol.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BillingControlMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BillingControlMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BillingControlMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorganization {
		edges = append(edges, billingcontrol.EdgeOrganization)
	}
	if m.clearedbusiness_unit {
		edges = append(edges, billingcontrol.EdgeBusinessUnit)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BillingControlMutation) EdgeCleared(name string) bool {
	switch name {
	case billingcontrol.EdgeOrganization:
		return m.clearedorganization
	case billingcontrol.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BillingControlMutation) ClearEdge(name string) error {
	switch name {
	case billingcontrol.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case billingcontrol.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	}
	return fmt.Errorf("unknown BillingControl unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BillingControlMutation) ResetEdge(name string) error {
	switch name {
	case billingcontrol.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case billingcontrol.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	}
	return fmt.Errorf("unknown BillingControl edge %s", name)
}

// BusinessUnitMutation represents an operation that mutates the BusinessUnit nodes in the graph.
type BusinessUnitMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	status               *businessunit.Status
	name                 *string
	entity_key           *string
	phone_number         *string
	address              *string
	city                 *string
	state                *string
	country              *string
	postal_code          *string
	tax_id               *string
	subscription_plan    *string
	description          *string
	legal_name           *string
	contact_name         *string
	contact_email        *string
	paid_until           *time.Time
	settings             *map[string]interface{}
	free_trial           *bool
	clearedFields        map[string]struct{}
	prev                 *uuid.UUID
	clearedprev          bool
	next                 *uuid.UUID
	clearednext          bool
	organizations        map[uuid.UUID]struct{}
	removedorganizations map[uuid.UUID]struct{}
	clearedorganizations bool
	done                 bool
	oldValue             func(context.Context) (*BusinessUnit, error)
	predicates           []predicate.BusinessUnit
}

var _ ent.Mutation = (*BusinessUnitMutation)(nil)

// businessunitOption allows management of the mutation configuration using functional options.
type businessunitOption func(*BusinessUnitMutation)

// newBusinessUnitMutation creates new mutation for the BusinessUnit entity.
func newBusinessUnitMutation(c config, op Op, opts ...businessunitOption) *BusinessUnitMutation {
	m := &BusinessUnitMutation{
		config:        c,
		op:            op,
		typ:           TypeBusinessUnit,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBusinessUnitID sets the ID field of the mutation.
func withBusinessUnitID(id uuid.UUID) businessunitOption {
	return func(m *BusinessUnitMutation) {
		var (
			err   error
			once  sync.Once
			value *BusinessUnit
		)
		m.oldValue = func(ctx context.Context) (*BusinessUnit, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BusinessUnit.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBusinessUnit sets the old BusinessUnit of the mutation.
func withBusinessUnit(node *BusinessUnit) businessunitOption {
	return func(m *BusinessUnitMutation) {
		m.oldValue = func(context.Context) (*BusinessUnit, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BusinessUnitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BusinessUnitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BusinessUnit entities.
func (m *BusinessUnitMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BusinessUnitMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BusinessUnitMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BusinessUnit.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BusinessUnitMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BusinessUnitMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BusinessUnitMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BusinessUnitMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BusinessUnitMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BusinessUnitMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *BusinessUnitMutation) SetStatus(b businessunit.Status) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *BusinessUnitMutation) Status() (r businessunit.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldStatus(ctx context.Context) (v businessunit.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BusinessUnitMutation) ResetStatus() {
	m.status = nil
}

// SetName sets the "name" field.
func (m *BusinessUnitMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BusinessUnitMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BusinessUnitMutation) ResetName() {
	m.name = nil
}

// SetEntityKey sets the "entity_key" field.
func (m *BusinessUnitMutation) SetEntityKey(s string) {
	m.entity_key = &s
}

// EntityKey returns the value of the "entity_key" field in the mutation.
func (m *BusinessUnitMutation) EntityKey() (r string, exists bool) {
	v := m.entity_key
	if v == nil {
		return
	}
	return *v, true
}

// OldEntityKey returns the old "entity_key" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldEntityKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEntityKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEntityKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntityKey: %w", err)
	}
	return oldValue.EntityKey, nil
}

// ResetEntityKey resets all changes to the "entity_key" field.
func (m *BusinessUnitMutation) ResetEntityKey() {
	m.entity_key = nil
}

// SetPhoneNumber sets the "phone_number" field.
func (m *BusinessUnitMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *BusinessUnitMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *BusinessUnitMutation) ResetPhoneNumber() {
	m.phone_number = nil
}

// SetAddress sets the "address" field.
func (m *BusinessUnitMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *BusinessUnitMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *BusinessUnitMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[businessunit.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *BusinessUnitMutation) AddressCleared() bool {
	_, ok := m.clearedFields[businessunit.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *BusinessUnitMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, businessunit.FieldAddress)
}

// SetCity sets the "city" field.
func (m *BusinessUnitMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *BusinessUnitMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldCity(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ClearCity clears the value of the "city" field.
func (m *BusinessUnitMutation) ClearCity() {
	m.city = nil
	m.clearedFields[businessunit.FieldCity] = struct{}{}
}

// CityCleared returns if the "city" field was cleared in this mutation.
func (m *BusinessUnitMutation) CityCleared() bool {
	_, ok := m.clearedFields[businessunit.FieldCity]
	return ok
}

// ResetCity resets all changes to the "city" field.
func (m *BusinessUnitMutation) ResetCity() {
	m.city = nil
	delete(m.clearedFields, businessunit.FieldCity)
}

// SetState sets the "state" field.
func (m *BusinessUnitMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *BusinessUnitMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldState(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *BusinessUnitMutation) ClearState() {
	m.state = nil
	m.clearedFields[businessunit.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *BusinessUnitMutation) StateCleared() bool {
	_, ok := m.clearedFields[businessunit.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *BusinessUnitMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, businessunit.FieldState)
}

// SetCountry sets the "country" field.
func (m *BusinessUnitMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *BusinessUnitMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldCountry(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ClearCountry clears the value of the "country" field.
func (m *BusinessUnitMutation) ClearCountry() {
	m.country = nil
	m.clearedFields[businessunit.FieldCountry] = struct{}{}
}

// CountryCleared returns if the "country" field was cleared in this mutation.
func (m *BusinessUnitMutation) CountryCleared() bool {
	_, ok := m.clearedFields[businessunit.FieldCountry]
	return ok
}

// ResetCountry resets all changes to the "country" field.
func (m *BusinessUnitMutation) ResetCountry() {
	m.country = nil
	delete(m.clearedFields, businessunit.FieldCountry)
}

// SetPostalCode sets the "postal_code" field.
func (m *BusinessUnitMutation) SetPostalCode(s string) {
	m.postal_code = &s
}

// PostalCode returns the value of the "postal_code" field in the mutation.
func (m *BusinessUnitMutation) PostalCode() (r string, exists bool) {
	v := m.postal_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPostalCode returns the old "postal_code" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldPostalCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostalCode: %w", err)
	}
	return oldValue.PostalCode, nil
}

// ClearPostalCode clears the value of the "postal_code" field.
func (m *BusinessUnitMutation) ClearPostalCode() {
	m.postal_code = nil
	m.clearedFields[businessunit.FieldPostalCode] = struct{}{}
}

// PostalCodeCleared returns if the "postal_code" field was cleared in this mutation.
func (m *BusinessUnitMutation) PostalCodeCleared() bool {
	_, ok := m.clearedFields[businessunit.FieldPostalCode]
	return ok
}

// ResetPostalCode resets all changes to the "postal_code" field.
func (m *BusinessUnitMutation) ResetPostalCode() {
	m.postal_code = nil
	delete(m.clearedFields, businessunit.FieldPostalCode)
}

// SetTaxID sets the "tax_id" field.
func (m *BusinessUnitMutation) SetTaxID(s string) {
	m.tax_id = &s
}

// TaxID returns the value of the "tax_id" field in the mutation.
func (m *BusinessUnitMutation) TaxID() (r string, exists bool) {
	v := m.tax_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxID returns the old "tax_id" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldTaxID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxID: %w", err)
	}
	return oldValue.TaxID, nil
}

// ClearTaxID clears the value of the "tax_id" field.
func (m *BusinessUnitMutation) ClearTaxID() {
	m.tax_id = nil
	m.clearedFields[businessunit.FieldTaxID] = struct{}{}
}

// TaxIDCleared returns if the "tax_id" field was cleared in this mutation.
func (m *BusinessUnitMutation) TaxIDCleared() bool {
	_, ok := m.clearedFields[businessunit.FieldTaxID]
	return ok
}

// ResetTaxID resets all changes to the "tax_id" field.
func (m *BusinessUnitMutation) ResetTaxID() {
	m.tax_id = nil
	delete(m.clearedFields, businessunit.FieldTaxID)
}

// SetSubscriptionPlan sets the "subscription_plan" field.
func (m *BusinessUnitMutation) SetSubscriptionPlan(s string) {
	m.subscription_plan = &s
}

// SubscriptionPlan returns the value of the "subscription_plan" field in the mutation.
func (m *BusinessUnitMutation) SubscriptionPlan() (r string, exists bool) {
	v := m.subscription_plan
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionPlan returns the old "subscription_plan" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldSubscriptionPlan(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscriptionPlan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscriptionPlan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionPlan: %w", err)
	}
	return oldValue.SubscriptionPlan, nil
}

// ClearSubscriptionPlan clears the value of the "subscription_plan" field.
func (m *BusinessUnitMutation) ClearSubscriptionPlan() {
	m.subscription_plan = nil
	m.clearedFields[businessunit.FieldSubscriptionPlan] = struct{}{}
}

// SubscriptionPlanCleared returns if the "subscription_plan" field was cleared in this mutation.
func (m *BusinessUnitMutation) SubscriptionPlanCleared() bool {
	_, ok := m.clearedFields[businessunit.FieldSubscriptionPlan]
	return ok
}

// ResetSubscriptionPlan resets all changes to the "subscription_plan" field.
func (m *BusinessUnitMutation) ResetSubscriptionPlan() {
	m.subscription_plan = nil
	delete(m.clearedFields, businessunit.FieldSubscriptionPlan)
}

// SetDescription sets the "description" field.
func (m *BusinessUnitMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BusinessUnitMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *BusinessUnitMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[businessunit.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *BusinessUnitMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[businessunit.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *BusinessUnitMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, businessunit.FieldDescription)
}

// SetLegalName sets the "legal_name" field.
func (m *BusinessUnitMutation) SetLegalName(s string) {
	m.legal_name = &s
}

// LegalName returns the value of the "legal_name" field in the mutation.
func (m *BusinessUnitMutation) LegalName() (r string, exists bool) {
	v := m.legal_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLegalName returns the old "legal_name" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldLegalName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLegalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLegalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLegalName: %w", err)
	}
	return oldValue.LegalName, nil
}

// ClearLegalName clears the value of the "legal_name" field.
func (m *BusinessUnitMutation) ClearLegalName() {
	m.legal_name = nil
	m.clearedFields[businessunit.FieldLegalName] = struct{}{}
}

// LegalNameCleared returns if the "legal_name" field was cleared in this mutation.
func (m *BusinessUnitMutation) LegalNameCleared() bool {
	_, ok := m.clearedFields[businessunit.FieldLegalName]
	return ok
}

// ResetLegalName resets all changes to the "legal_name" field.
func (m *BusinessUnitMutation) ResetLegalName() {
	m.legal_name = nil
	delete(m.clearedFields, businessunit.FieldLegalName)
}

// SetContactName sets the "contact_name" field.
func (m *BusinessUnitMutation) SetContactName(s string) {
	m.contact_name = &s
}

// ContactName returns the value of the "contact_name" field in the mutation.
func (m *BusinessUnitMutation) ContactName() (r string, exists bool) {
	v := m.contact_name
	if v == nil {
		return
	}
	return *v, true
}

// OldContactName returns the old "contact_name" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldContactName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactName: %w", err)
	}
	return oldValue.ContactName, nil
}

// ClearContactName clears the value of the "contact_name" field.
func (m *BusinessUnitMutation) ClearContactName() {
	m.contact_name = nil
	m.clearedFields[businessunit.FieldContactName] = struct{}{}
}

// ContactNameCleared returns if the "contact_name" field was cleared in this mutation.
func (m *BusinessUnitMutation) ContactNameCleared() bool {
	_, ok := m.clearedFields[businessunit.FieldContactName]
	return ok
}

// ResetContactName resets all changes to the "contact_name" field.
func (m *BusinessUnitMutation) ResetContactName() {
	m.contact_name = nil
	delete(m.clearedFields, businessunit.FieldContactName)
}

// SetContactEmail sets the "contact_email" field.
func (m *BusinessUnitMutation) SetContactEmail(s string) {
	m.contact_email = &s
}

// ContactEmail returns the value of the "contact_email" field in the mutation.
func (m *BusinessUnitMutation) ContactEmail() (r string, exists bool) {
	v := m.contact_email
	if v == nil {
		return
	}
	return *v, true
}

// OldContactEmail returns the old "contact_email" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldContactEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactEmail: %w", err)
	}
	return oldValue.ContactEmail, nil
}

// ClearContactEmail clears the value of the "contact_email" field.
func (m *BusinessUnitMutation) ClearContactEmail() {
	m.contact_email = nil
	m.clearedFields[businessunit.FieldContactEmail] = struct{}{}
}

// ContactEmailCleared returns if the "contact_email" field was cleared in this mutation.
func (m *BusinessUnitMutation) ContactEmailCleared() bool {
	_, ok := m.clearedFields[businessunit.FieldContactEmail]
	return ok
}

// ResetContactEmail resets all changes to the "contact_email" field.
func (m *BusinessUnitMutation) ResetContactEmail() {
	m.contact_email = nil
	delete(m.clearedFields, businessunit.FieldContactEmail)
}

// SetPaidUntil sets the "paid_until" field.
func (m *BusinessUnitMutation) SetPaidUntil(t time.Time) {
	m.paid_until = &t
}

// PaidUntil returns the value of the "paid_until" field in the mutation.
func (m *BusinessUnitMutation) PaidUntil() (r time.Time, exists bool) {
	v := m.paid_until
	if v == nil {
		return
	}
	return *v, true
}

// OldPaidUntil returns the old "paid_until" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldPaidUntil(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaidUntil is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaidUntil requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaidUntil: %w", err)
	}
	return oldValue.PaidUntil, nil
}

// ClearPaidUntil clears the value of the "paid_until" field.
func (m *BusinessUnitMutation) ClearPaidUntil() {
	m.paid_until = nil
	m.clearedFields[businessunit.FieldPaidUntil] = struct{}{}
}

// PaidUntilCleared returns if the "paid_until" field was cleared in this mutation.
func (m *BusinessUnitMutation) PaidUntilCleared() bool {
	_, ok := m.clearedFields[businessunit.FieldPaidUntil]
	return ok
}

// ResetPaidUntil resets all changes to the "paid_until" field.
func (m *BusinessUnitMutation) ResetPaidUntil() {
	m.paid_until = nil
	delete(m.clearedFields, businessunit.FieldPaidUntil)
}

// SetSettings sets the "settings" field.
func (m *BusinessUnitMutation) SetSettings(value map[string]interface{}) {
	m.settings = &value
}

// Settings returns the value of the "settings" field in the mutation.
func (m *BusinessUnitMutation) Settings() (r map[string]interface{}, exists bool) {
	v := m.settings
	if v == nil {
		return
	}
	return *v, true
}

// OldSettings returns the old "settings" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldSettings(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettings: %w", err)
	}
	return oldValue.Settings, nil
}

// ClearSettings clears the value of the "settings" field.
func (m *BusinessUnitMutation) ClearSettings() {
	m.settings = nil
	m.clearedFields[businessunit.FieldSettings] = struct{}{}
}

// SettingsCleared returns if the "settings" field was cleared in this mutation.
func (m *BusinessUnitMutation) SettingsCleared() bool {
	_, ok := m.clearedFields[businessunit.FieldSettings]
	return ok
}

// ResetSettings resets all changes to the "settings" field.
func (m *BusinessUnitMutation) ResetSettings() {
	m.settings = nil
	delete(m.clearedFields, businessunit.FieldSettings)
}

// SetFreeTrial sets the "free_trial" field.
func (m *BusinessUnitMutation) SetFreeTrial(b bool) {
	m.free_trial = &b
}

// FreeTrial returns the value of the "free_trial" field in the mutation.
func (m *BusinessUnitMutation) FreeTrial() (r bool, exists bool) {
	v := m.free_trial
	if v == nil {
		return
	}
	return *v, true
}

// OldFreeTrial returns the old "free_trial" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldFreeTrial(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFreeTrial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFreeTrial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFreeTrial: %w", err)
	}
	return oldValue.FreeTrial, nil
}

// ResetFreeTrial resets all changes to the "free_trial" field.
func (m *BusinessUnitMutation) ResetFreeTrial() {
	m.free_trial = nil
}

// SetParentID sets the "parent_id" field.
func (m *BusinessUnitMutation) SetParentID(u uuid.UUID) {
	m.prev = &u
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *BusinessUnitMutation) ParentID() (r uuid.UUID, exists bool) {
	v := m.prev
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the BusinessUnit entity.
// If the BusinessUnit object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessUnitMutation) OldParentID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *BusinessUnitMutation) ClearParentID() {
	m.prev = nil
	m.clearedFields[businessunit.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *BusinessUnitMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[businessunit.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *BusinessUnitMutation) ResetParentID() {
	m.prev = nil
	delete(m.clearedFields, businessunit.FieldParentID)
}

// SetPrevID sets the "prev" edge to the BusinessUnit entity by id.
func (m *BusinessUnitMutation) SetPrevID(id uuid.UUID) {
	m.prev = &id
}

// ClearPrev clears the "prev" edge to the BusinessUnit entity.
func (m *BusinessUnitMutation) ClearPrev() {
	m.clearedprev = true
	m.clearedFields[businessunit.FieldParentID] = struct{}{}
}

// PrevCleared reports if the "prev" edge to the BusinessUnit entity was cleared.
func (m *BusinessUnitMutation) PrevCleared() bool {
	return m.ParentIDCleared() || m.clearedprev
}

// PrevID returns the "prev" edge ID in the mutation.
func (m *BusinessUnitMutation) PrevID() (id uuid.UUID, exists bool) {
	if m.prev != nil {
		return *m.prev, true
	}
	return
}

// PrevIDs returns the "prev" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PrevID instead. It exists only for internal usage by the builders.
func (m *BusinessUnitMutation) PrevIDs() (ids []uuid.UUID) {
	if id := m.prev; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrev resets all changes to the "prev" edge.
func (m *BusinessUnitMutation) ResetPrev() {
	m.prev = nil
	m.clearedprev = false
}

// SetNextID sets the "next" edge to the BusinessUnit entity by id.
func (m *BusinessUnitMutation) SetNextID(id uuid.UUID) {
	m.next = &id
}

// ClearNext clears the "next" edge to the BusinessUnit entity.
func (m *BusinessUnitMutation) ClearNext() {
	m.clearednext = true
}

// NextCleared reports if the "next" edge to the BusinessUnit entity was cleared.
func (m *BusinessUnitMutation) NextCleared() bool {
	return m.clearednext
}

// NextID returns the "next" edge ID in the mutation.
func (m *BusinessUnitMutation) NextID() (id uuid.UUID, exists bool) {
	if m.next != nil {
		return *m.next, true
	}
	return
}

// NextIDs returns the "next" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NextID instead. It exists only for internal usage by the builders.
func (m *BusinessUnitMutation) NextIDs() (ids []uuid.UUID) {
	if id := m.next; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNext resets all changes to the "next" edge.
func (m *BusinessUnitMutation) ResetNext() {
	m.next = nil
	m.clearednext = false
}

// AddOrganizationIDs adds the "organizations" edge to the Organization entity by ids.
func (m *BusinessUnitMutation) AddOrganizationIDs(ids ...uuid.UUID) {
	if m.organizations == nil {
		m.organizations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.organizations[ids[i]] = struct{}{}
	}
}

// ClearOrganizations clears the "organizations" edge to the Organization entity.
func (m *BusinessUnitMutation) ClearOrganizations() {
	m.clearedorganizations = true
}

// OrganizationsCleared reports if the "organizations" edge to the Organization entity was cleared.
func (m *BusinessUnitMutation) OrganizationsCleared() bool {
	return m.clearedorganizations
}

// RemoveOrganizationIDs removes the "organizations" edge to the Organization entity by IDs.
func (m *BusinessUnitMutation) RemoveOrganizationIDs(ids ...uuid.UUID) {
	if m.removedorganizations == nil {
		m.removedorganizations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.organizations, ids[i])
		m.removedorganizations[ids[i]] = struct{}{}
	}
}

// RemovedOrganizations returns the removed IDs of the "organizations" edge to the Organization entity.
func (m *BusinessUnitMutation) RemovedOrganizationsIDs() (ids []uuid.UUID) {
	for id := range m.removedorganizations {
		ids = append(ids, id)
	}
	return
}

// OrganizationsIDs returns the "organizations" edge IDs in the mutation.
func (m *BusinessUnitMutation) OrganizationsIDs() (ids []uuid.UUID) {
	for id := range m.organizations {
		ids = append(ids, id)
	}
	return
}

// ResetOrganizations resets all changes to the "organizations" edge.
func (m *BusinessUnitMutation) ResetOrganizations() {
	m.organizations = nil
	m.clearedorganizations = false
	m.removedorganizations = nil
}

// Where appends a list predicates to the BusinessUnitMutation builder.
func (m *BusinessUnitMutation) Where(ps ...predicate.BusinessUnit) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BusinessUnitMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BusinessUnitMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BusinessUnit, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BusinessUnitMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BusinessUnitMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BusinessUnit).
func (m *BusinessUnitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BusinessUnitMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.created_at != nil {
		fields = append(fields, businessunit.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, businessunit.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, businessunit.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, businessunit.FieldName)
	}
	if m.entity_key != nil {
		fields = append(fields, businessunit.FieldEntityKey)
	}
	if m.phone_number != nil {
		fields = append(fields, businessunit.FieldPhoneNumber)
	}
	if m.address != nil {
		fields = append(fields, businessunit.FieldAddress)
	}
	if m.city != nil {
		fields = append(fields, businessunit.FieldCity)
	}
	if m.state != nil {
		fields = append(fields, businessunit.FieldState)
	}
	if m.country != nil {
		fields = append(fields, businessunit.FieldCountry)
	}
	if m.postal_code != nil {
		fields = append(fields, businessunit.FieldPostalCode)
	}
	if m.tax_id != nil {
		fields = append(fields, businessunit.FieldTaxID)
	}
	if m.subscription_plan != nil {
		fields = append(fields, businessunit.FieldSubscriptionPlan)
	}
	if m.description != nil {
		fields = append(fields, businessunit.FieldDescription)
	}
	if m.legal_name != nil {
		fields = append(fields, businessunit.FieldLegalName)
	}
	if m.contact_name != nil {
		fields = append(fields, businessunit.FieldContactName)
	}
	if m.contact_email != nil {
		fields = append(fields, businessunit.FieldContactEmail)
	}
	if m.paid_until != nil {
		fields = append(fields, businessunit.FieldPaidUntil)
	}
	if m.settings != nil {
		fields = append(fields, businessunit.FieldSettings)
	}
	if m.free_trial != nil {
		fields = append(fields, businessunit.FieldFreeTrial)
	}
	if m.prev != nil {
		fields = append(fields, businessunit.FieldParentID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BusinessUnitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case businessunit.FieldCreatedAt:
		return m.CreatedAt()
	case businessunit.FieldUpdatedAt:
		return m.UpdatedAt()
	case businessunit.FieldStatus:
		return m.Status()
	case businessunit.FieldName:
		return m.Name()
	case businessunit.FieldEntityKey:
		return m.EntityKey()
	case businessunit.FieldPhoneNumber:
		return m.PhoneNumber()
	case businessunit.FieldAddress:
		return m.Address()
	case businessunit.FieldCity:
		return m.City()
	case businessunit.FieldState:
		return m.State()
	case businessunit.FieldCountry:
		return m.Country()
	case businessunit.FieldPostalCode:
		return m.PostalCode()
	case businessunit.FieldTaxID:
		return m.TaxID()
	case businessunit.FieldSubscriptionPlan:
		return m.SubscriptionPlan()
	case businessunit.FieldDescription:
		return m.Description()
	case businessunit.FieldLegalName:
		return m.LegalName()
	case businessunit.FieldContactName:
		return m.ContactName()
	case businessunit.FieldContactEmail:
		return m.ContactEmail()
	case businessunit.FieldPaidUntil:
		return m.PaidUntil()
	case businessunit.FieldSettings:
		return m.Settings()
	case businessunit.FieldFreeTrial:
		return m.FreeTrial()
	case businessunit.FieldParentID:
		return m.ParentID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BusinessUnitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case businessunit.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case businessunit.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case businessunit.FieldStatus:
		return m.OldStatus(ctx)
	case businessunit.FieldName:
		return m.OldName(ctx)
	case businessunit.FieldEntityKey:
		return m.OldEntityKey(ctx)
	case businessunit.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case businessunit.FieldAddress:
		return m.OldAddress(ctx)
	case businessunit.FieldCity:
		return m.OldCity(ctx)
	case businessunit.FieldState:
		return m.OldState(ctx)
	case businessunit.FieldCountry:
		return m.OldCountry(ctx)
	case businessunit.FieldPostalCode:
		return m.OldPostalCode(ctx)
	case businessunit.FieldTaxID:
		return m.OldTaxID(ctx)
	case businessunit.FieldSubscriptionPlan:
		return m.OldSubscriptionPlan(ctx)
	case businessunit.FieldDescription:
		return m.OldDescription(ctx)
	case businessunit.FieldLegalName:
		return m.OldLegalName(ctx)
	case businessunit.FieldContactName:
		return m.OldContactName(ctx)
	case businessunit.FieldContactEmail:
		return m.OldContactEmail(ctx)
	case businessunit.FieldPaidUntil:
		return m.OldPaidUntil(ctx)
	case businessunit.FieldSettings:
		return m.OldSettings(ctx)
	case businessunit.FieldFreeTrial:
		return m.OldFreeTrial(ctx)
	case businessunit.FieldParentID:
		return m.OldParentID(ctx)
	}
	return nil, fmt.Errorf("unknown BusinessUnit field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BusinessUnitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case businessunit.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case businessunit.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case businessunit.FieldStatus:
		v, ok := value.(businessunit.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case businessunit.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case businessunit.FieldEntityKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntityKey(v)
		return nil
	case businessunit.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case businessunit.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case businessunit.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case businessunit.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case businessunit.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case businessunit.FieldPostalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostalCode(v)
		return nil
	case businessunit.FieldTaxID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxID(v)
		return nil
	case businessunit.FieldSubscriptionPlan:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionPlan(v)
		return nil
	case businessunit.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case businessunit.FieldLegalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLegalName(v)
		return nil
	case businessunit.FieldContactName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactName(v)
		return nil
	case businessunit.FieldContactEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactEmail(v)
		return nil
	case businessunit.FieldPaidUntil:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaidUntil(v)
		return nil
	case businessunit.FieldSettings:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettings(v)
		return nil
	case businessunit.FieldFreeTrial:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFreeTrial(v)
		return nil
	case businessunit.FieldParentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	}
	return fmt.Errorf("unknown BusinessUnit field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BusinessUnitMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BusinessUnitMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BusinessUnitMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BusinessUnit numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BusinessUnitMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(businessunit.FieldAddress) {
		fields = append(fields, businessunit.FieldAddress)
	}
	if m.FieldCleared(businessunit.FieldCity) {
		fields = append(fields, businessunit.FieldCity)
	}
	if m.FieldCleared(businessunit.FieldState) {
		fields = append(fields, businessunit.FieldState)
	}
	if m.FieldCleared(businessunit.FieldCountry) {
		fields = append(fields, businessunit.FieldCountry)
	}
	if m.FieldCleared(businessunit.FieldPostalCode) {
		fields = append(fields, businessunit.FieldPostalCode)
	}
	if m.FieldCleared(businessunit.FieldTaxID) {
		fields = append(fields, businessunit.FieldTaxID)
	}
	if m.FieldCleared(businessunit.FieldSubscriptionPlan) {
		fields = append(fields, businessunit.FieldSubscriptionPlan)
	}
	if m.FieldCleared(businessunit.FieldDescription) {
		fields = append(fields, businessunit.FieldDescription)
	}
	if m.FieldCleared(businessunit.FieldLegalName) {
		fields = append(fields, businessunit.FieldLegalName)
	}
	if m.FieldCleared(businessunit.FieldContactName) {
		fields = append(fields, businessunit.FieldContactName)
	}
	if m.FieldCleared(businessunit.FieldContactEmail) {
		fields = append(fields, businessunit.FieldContactEmail)
	}
	if m.FieldCleared(businessunit.FieldPaidUntil) {
		fields = append(fields, businessunit.FieldPaidUntil)
	}
	if m.FieldCleared(businessunit.FieldSettings) {
		fields = append(fields, businessunit.FieldSettings)
	}
	if m.FieldCleared(businessunit.FieldParentID) {
		fields = append(fields, businessunit.FieldParentID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BusinessUnitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BusinessUnitMutation) ClearField(name string) error {
	switch name {
	case businessunit.FieldAddress:
		m.ClearAddress()
		return nil
	case businessunit.FieldCity:
		m.ClearCity()
		return nil
	case businessunit.FieldState:
		m.ClearState()
		return nil
	case businessunit.FieldCountry:
		m.ClearCountry()
		return nil
	case businessunit.FieldPostalCode:
		m.ClearPostalCode()
		return nil
	case businessunit.FieldTaxID:
		m.ClearTaxID()
		return nil
	case businessunit.FieldSubscriptionPlan:
		m.ClearSubscriptionPlan()
		return nil
	case businessunit.FieldDescription:
		m.ClearDescription()
		return nil
	case businessunit.FieldLegalName:
		m.ClearLegalName()
		return nil
	case businessunit.FieldContactName:
		m.ClearContactName()
		return nil
	case businessunit.FieldContactEmail:
		m.ClearContactEmail()
		return nil
	case businessunit.FieldPaidUntil:
		m.ClearPaidUntil()
		return nil
	case businessunit.FieldSettings:
		m.ClearSettings()
		return nil
	case businessunit.FieldParentID:
		m.ClearParentID()
		return nil
	}
	return fmt.Errorf("unknown BusinessUnit nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BusinessUnitMutation) ResetField(name string) error {
	switch name {
	case businessunit.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case businessunit.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case businessunit.FieldStatus:
		m.ResetStatus()
		return nil
	case businessunit.FieldName:
		m.ResetName()
		return nil
	case businessunit.FieldEntityKey:
		m.ResetEntityKey()
		return nil
	case businessunit.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case businessunit.FieldAddress:
		m.ResetAddress()
		return nil
	case businessunit.FieldCity:
		m.ResetCity()
		return nil
	case businessunit.FieldState:
		m.ResetState()
		return nil
	case businessunit.FieldCountry:
		m.ResetCountry()
		return nil
	case businessunit.FieldPostalCode:
		m.ResetPostalCode()
		return nil
	case businessunit.FieldTaxID:
		m.ResetTaxID()
		return nil
	case businessunit.FieldSubscriptionPlan:
		m.ResetSubscriptionPlan()
		return nil
	case businessunit.FieldDescription:
		m.ResetDescription()
		return nil
	case businessunit.FieldLegalName:
		m.ResetLegalName()
		return nil
	case businessunit.FieldContactName:
		m.ResetContactName()
		return nil
	case businessunit.FieldContactEmail:
		m.ResetContactEmail()
		return nil
	case businessunit.FieldPaidUntil:
		m.ResetPaidUntil()
		return nil
	case businessunit.FieldSettings:
		m.ResetSettings()
		return nil
	case businessunit.FieldFreeTrial:
		m.ResetFreeTrial()
		return nil
	case businessunit.FieldParentID:
		m.ResetParentID()
		return nil
	}
	return fmt.Errorf("unknown BusinessUnit field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BusinessUnitMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.prev != nil {
		edges = append(edges, businessunit.EdgePrev)
	}
	if m.next != nil {
		edges = append(edges, businessunit.EdgeNext)
	}
	if m.organizations != nil {
		edges = append(edges, businessunit.EdgeOrganizations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BusinessUnitMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case businessunit.EdgePrev:
		if id := m.prev; id != nil {
			return []ent.Value{*id}
		}
	case businessunit.EdgeNext:
		if id := m.next; id != nil {
			return []ent.Value{*id}
		}
	case businessunit.EdgeOrganizations:
		ids := make([]ent.Value, 0, len(m.organizations))
		for id := range m.organizations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BusinessUnitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedorganizations != nil {
		edges = append(edges, businessunit.EdgeOrganizations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BusinessUnitMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case businessunit.EdgeOrganizations:
		ids := make([]ent.Value, 0, len(m.removedorganizations))
		for id := range m.removedorganizations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BusinessUnitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedprev {
		edges = append(edges, businessunit.EdgePrev)
	}
	if m.clearednext {
		edges = append(edges, businessunit.EdgeNext)
	}
	if m.clearedorganizations {
		edges = append(edges, businessunit.EdgeOrganizations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BusinessUnitMutation) EdgeCleared(name string) bool {
	switch name {
	case businessunit.EdgePrev:
		return m.clearedprev
	case businessunit.EdgeNext:
		return m.clearednext
	case businessunit.EdgeOrganizations:
		return m.clearedorganizations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BusinessUnitMutation) ClearEdge(name string) error {
	switch name {
	case businessunit.EdgePrev:
		m.ClearPrev()
		return nil
	case businessunit.EdgeNext:
		m.ClearNext()
		return nil
	}
	return fmt.Errorf("unknown BusinessUnit unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BusinessUnitMutation) ResetEdge(name string) error {
	switch name {
	case businessunit.EdgePrev:
		m.ResetPrev()
		return nil
	case businessunit.EdgeNext:
		m.ResetNext()
		return nil
	case businessunit.EdgeOrganizations:
		m.ResetOrganizations()
		return nil
	}
	return fmt.Errorf("unknown BusinessUnit edge %s", name)
}

// ChargeTypeMutation represents an operation that mutates the ChargeType nodes in the graph.
type ChargeTypeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	status               *chargetype.Status
	name                 *string
	description          *string
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	done                 bool
	oldValue             func(context.Context) (*ChargeType, error)
	predicates           []predicate.ChargeType
}

var _ ent.Mutation = (*ChargeTypeMutation)(nil)

// chargetypeOption allows management of the mutation configuration using functional options.
type chargetypeOption func(*ChargeTypeMutation)

// newChargeTypeMutation creates new mutation for the ChargeType entity.
func newChargeTypeMutation(c config, op Op, opts ...chargetypeOption) *ChargeTypeMutation {
	m := &ChargeTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeChargeType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChargeTypeID sets the ID field of the mutation.
func withChargeTypeID(id uuid.UUID) chargetypeOption {
	return func(m *ChargeTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ChargeType
		)
		m.oldValue = func(ctx context.Context) (*ChargeType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ChargeType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChargeType sets the old ChargeType of the mutation.
func withChargeType(node *ChargeType) chargetypeOption {
	return func(m *ChargeTypeMutation) {
		m.oldValue = func(context.Context) (*ChargeType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChargeTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChargeTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ChargeType entities.
func (m *ChargeTypeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChargeTypeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChargeTypeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ChargeType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *ChargeTypeMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *ChargeTypeMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the ChargeType entity.
// If the ChargeType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChargeTypeMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *ChargeTypeMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *ChargeTypeMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *ChargeTypeMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the ChargeType entity.
// If the ChargeType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChargeTypeMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *ChargeTypeMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ChargeTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChargeTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ChargeType entity.
// If the ChargeType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChargeTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChargeTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ChargeTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ChargeTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ChargeType entity.
// If the ChargeType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChargeTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ChargeTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *ChargeTypeMutation) SetStatus(c chargetype.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *ChargeTypeMutation) Status() (r chargetype.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ChargeType entity.
// If the ChargeType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChargeTypeMutation) OldStatus(ctx context.Context) (v chargetype.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ChargeTypeMutation) ResetStatus() {
	m.status = nil
}

// SetName sets the "name" field.
func (m *ChargeTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ChargeTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ChargeType entity.
// If the ChargeType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChargeTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ChargeTypeMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ChargeTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ChargeTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ChargeType entity.
// If the ChargeType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChargeTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ChargeTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[chargetype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ChargeTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[chargetype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ChargeTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, chargetype.FieldDescription)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *ChargeTypeMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[chargetype.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *ChargeTypeMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *ChargeTypeMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *ChargeTypeMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *ChargeTypeMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[chargetype.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *ChargeTypeMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *ChargeTypeMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *ChargeTypeMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the ChargeTypeMutation builder.
func (m *ChargeTypeMutation) Where(ps ...predicate.ChargeType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChargeTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChargeTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ChargeType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChargeTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChargeTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ChargeType).
func (m *ChargeTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChargeTypeMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.business_unit != nil {
		fields = append(fields, chargetype.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, chargetype.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, chargetype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, chargetype.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, chargetype.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, chargetype.FieldName)
	}
	if m.description != nil {
		fields = append(fields, chargetype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChargeTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case chargetype.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case chargetype.FieldOrganizationID:
		return m.OrganizationID()
	case chargetype.FieldCreatedAt:
		return m.CreatedAt()
	case chargetype.FieldUpdatedAt:
		return m.UpdatedAt()
	case chargetype.FieldStatus:
		return m.Status()
	case chargetype.FieldName:
		return m.Name()
	case chargetype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChargeTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case chargetype.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case chargetype.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case chargetype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case chargetype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case chargetype.FieldStatus:
		return m.OldStatus(ctx)
	case chargetype.FieldName:
		return m.OldName(ctx)
	case chargetype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown ChargeType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChargeTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case chargetype.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case chargetype.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case chargetype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case chargetype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case chargetype.FieldStatus:
		v, ok := value.(chargetype.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case chargetype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case chargetype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown ChargeType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChargeTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChargeTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChargeTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ChargeType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChargeTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(chargetype.FieldDescription) {
		fields = append(fields, chargetype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChargeTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChargeTypeMutation) ClearField(name string) error {
	switch name {
	case chargetype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ChargeType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChargeTypeMutation) ResetField(name string) error {
	switch name {
	case chargetype.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case chargetype.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case chargetype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case chargetype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case chargetype.FieldStatus:
		m.ResetStatus()
		return nil
	case chargetype.FieldName:
		m.ResetName()
		return nil
	case chargetype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown ChargeType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChargeTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.business_unit != nil {
		edges = append(edges, chargetype.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, chargetype.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChargeTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case chargetype.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case chargetype.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChargeTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChargeTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChargeTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbusiness_unit {
		edges = append(edges, chargetype.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, chargetype.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChargeTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case chargetype.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case chargetype.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChargeTypeMutation) ClearEdge(name string) error {
	switch name {
	case chargetype.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case chargetype.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown ChargeType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChargeTypeMutation) ResetEdge(name string) error {
	switch name {
	case chargetype.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case chargetype.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown ChargeType edge %s", name)
}

// CommentTypeMutation represents an operation that mutates the CommentType nodes in the graph.
type CommentTypeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	status               *commenttype.Status
	name                 *string
	severity             *commenttype.Severity
	description          *string
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	done                 bool
	oldValue             func(context.Context) (*CommentType, error)
	predicates           []predicate.CommentType
}

var _ ent.Mutation = (*CommentTypeMutation)(nil)

// commenttypeOption allows management of the mutation configuration using functional options.
type commenttypeOption func(*CommentTypeMutation)

// newCommentTypeMutation creates new mutation for the CommentType entity.
func newCommentTypeMutation(c config, op Op, opts ...commenttypeOption) *CommentTypeMutation {
	m := &CommentTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeCommentType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommentTypeID sets the ID field of the mutation.
func withCommentTypeID(id uuid.UUID) commenttypeOption {
	return func(m *CommentTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *CommentType
		)
		m.oldValue = func(ctx context.Context) (*CommentType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CommentType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCommentType sets the old CommentType of the mutation.
func withCommentType(node *CommentType) commenttypeOption {
	return func(m *CommentTypeMutation) {
		m.oldValue = func(context.Context) (*CommentType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CommentType entities.
func (m *CommentTypeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommentTypeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommentTypeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CommentType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *CommentTypeMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *CommentTypeMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the CommentType entity.
// If the CommentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentTypeMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *CommentTypeMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *CommentTypeMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *CommentTypeMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the CommentType entity.
// If the CommentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentTypeMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *CommentTypeMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CommentTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CommentTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CommentType entity.
// If the CommentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CommentTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CommentTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CommentTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CommentType entity.
// If the CommentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CommentTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *CommentTypeMutation) SetStatus(c commenttype.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *CommentTypeMutation) Status() (r commenttype.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CommentType entity.
// If the CommentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentTypeMutation) OldStatus(ctx context.Context) (v commenttype.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CommentTypeMutation) ResetStatus() {
	m.status = nil
}

// SetName sets the "name" field.
func (m *CommentTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CommentTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CommentType entity.
// If the CommentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CommentTypeMutation) ResetName() {
	m.name = nil
}

// SetSeverity sets the "severity" field.
func (m *CommentTypeMutation) SetSeverity(c commenttype.Severity) {
	m.severity = &c
}

// Severity returns the value of the "severity" field in the mutation.
func (m *CommentTypeMutation) Severity() (r commenttype.Severity, exists bool) {
	v := m.severity
	if v == nil {
		return
	}
	return *v, true
}

// OldSeverity returns the old "severity" field's value of the CommentType entity.
// If the CommentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentTypeMutation) OldSeverity(ctx context.Context) (v commenttype.Severity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeverity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeverity: %w", err)
	}
	return oldValue.Severity, nil
}

// ResetSeverity resets all changes to the "severity" field.
func (m *CommentTypeMutation) ResetSeverity() {
	m.severity = nil
}

// SetDescription sets the "description" field.
func (m *CommentTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CommentTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the CommentType entity.
// If the CommentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CommentTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[commenttype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CommentTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[commenttype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CommentTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, commenttype.FieldDescription)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *CommentTypeMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[commenttype.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *CommentTypeMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *CommentTypeMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *CommentTypeMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *CommentTypeMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[commenttype.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *CommentTypeMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *CommentTypeMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *CommentTypeMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the CommentTypeMutation builder.
func (m *CommentTypeMutation) Where(ps ...predicate.CommentType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommentTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommentTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CommentType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommentTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommentTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CommentType).
func (m *CommentTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommentTypeMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.business_unit != nil {
		fields = append(fields, commenttype.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, commenttype.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, commenttype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, commenttype.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, commenttype.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, commenttype.FieldName)
	}
	if m.severity != nil {
		fields = append(fields, commenttype.FieldSeverity)
	}
	if m.description != nil {
		fields = append(fields, commenttype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommentTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case commenttype.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case commenttype.FieldOrganizationID:
		return m.OrganizationID()
	case commenttype.FieldCreatedAt:
		return m.CreatedAt()
	case commenttype.FieldUpdatedAt:
		return m.UpdatedAt()
	case commenttype.FieldStatus:
		return m.Status()
	case commenttype.FieldName:
		return m.Name()
	case commenttype.FieldSeverity:
		return m.Severity()
	case commenttype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommentTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case commenttype.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case commenttype.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case commenttype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case commenttype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case commenttype.FieldStatus:
		return m.OldStatus(ctx)
	case commenttype.FieldName:
		return m.OldName(ctx)
	case commenttype.FieldSeverity:
		return m.OldSeverity(ctx)
	case commenttype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown CommentType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case commenttype.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case commenttype.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case commenttype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case commenttype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case commenttype.FieldStatus:
		v, ok := value.(commenttype.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case commenttype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case commenttype.FieldSeverity:
		v, ok := value.(commenttype.Severity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeverity(v)
		return nil
	case commenttype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown CommentType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommentTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommentTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CommentType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommentTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(commenttype.FieldDescription) {
		fields = append(fields, commenttype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommentTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentTypeMutation) ClearField(name string) error {
	switch name {
	case commenttype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown CommentType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommentTypeMutation) ResetField(name string) error {
	switch name {
	case commenttype.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case commenttype.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case commenttype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case commenttype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case commenttype.FieldStatus:
		m.ResetStatus()
		return nil
	case commenttype.FieldName:
		m.ResetName()
		return nil
	case commenttype.FieldSeverity:
		m.ResetSeverity()
		return nil
	case commenttype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown CommentType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommentTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.business_unit != nil {
		edges = append(edges, commenttype.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, commenttype.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommentTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case commenttype.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case commenttype.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommentTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommentTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommentTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbusiness_unit {
		edges = append(edges, commenttype.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, commenttype.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommentTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case commenttype.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case commenttype.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommentTypeMutation) ClearEdge(name string) error {
	switch name {
	case commenttype.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case commenttype.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown CommentType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommentTypeMutation) ResetEdge(name string) error {
	switch name {
	case commenttype.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case commenttype.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown CommentType edge %s", name)
}

// CommodityMutation represents an operation that mutates the Commodity nodes in the graph.
type CommodityMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	created_at                *time.Time
	updated_at                *time.Time
	status                    *commodity.Status
	name                      *string
	is_hazmat                 *bool
	unit_of_measure           *string
	min_temp                  *int8
	addmin_temp               *int8
	max_temp                  *int8
	addmax_temp               *int8
	description               *string
	clearedFields             map[string]struct{}
	business_unit             *uuid.UUID
	clearedbusiness_unit      bool
	organization              *uuid.UUID
	clearedorganization       bool
	hazardous_material        *uuid.UUID
	clearedhazardous_material bool
	done                      bool
	oldValue                  func(context.Context) (*Commodity, error)
	predicates                []predicate.Commodity
}

var _ ent.Mutation = (*CommodityMutation)(nil)

// commodityOption allows management of the mutation configuration using functional options.
type commodityOption func(*CommodityMutation)

// newCommodityMutation creates new mutation for the Commodity entity.
func newCommodityMutation(c config, op Op, opts ...commodityOption) *CommodityMutation {
	m := &CommodityMutation{
		config:        c,
		op:            op,
		typ:           TypeCommodity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommodityID sets the ID field of the mutation.
func withCommodityID(id uuid.UUID) commodityOption {
	return func(m *CommodityMutation) {
		var (
			err   error
			once  sync.Once
			value *Commodity
		)
		m.oldValue = func(ctx context.Context) (*Commodity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Commodity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCommodity sets the old Commodity of the mutation.
func withCommodity(node *Commodity) commodityOption {
	return func(m *CommodityMutation) {
		m.oldValue = func(context.Context) (*Commodity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommodityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommodityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Commodity entities.
func (m *CommodityMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommodityMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommodityMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Commodity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *CommodityMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *CommodityMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the Commodity entity.
// If the Commodity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommodityMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *CommodityMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *CommodityMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *CommodityMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Commodity entity.
// If the Commodity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommodityMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *CommodityMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CommodityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CommodityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Commodity entity.
// If the Commodity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommodityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CommodityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CommodityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CommodityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Commodity entity.
// If the Commodity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommodityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CommodityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *CommodityMutation) SetStatus(c commodity.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *CommodityMutation) Status() (r commodity.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Commodity entity.
// If the Commodity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommodityMutation) OldStatus(ctx context.Context) (v commodity.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CommodityMutation) ResetStatus() {
	m.status = nil
}

// SetName sets the "name" field.
func (m *CommodityMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CommodityMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Commodity entity.
// If the Commodity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommodityMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CommodityMutation) ResetName() {
	m.name = nil
}

// SetIsHazmat sets the "is_hazmat" field.
func (m *CommodityMutation) SetIsHazmat(b bool) {
	m.is_hazmat = &b
}

// IsHazmat returns the value of the "is_hazmat" field in the mutation.
func (m *CommodityMutation) IsHazmat() (r bool, exists bool) {
	v := m.is_hazmat
	if v == nil {
		return
	}
	return *v, true
}

// OldIsHazmat returns the old "is_hazmat" field's value of the Commodity entity.
// If the Commodity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommodityMutation) OldIsHazmat(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsHazmat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsHazmat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsHazmat: %w", err)
	}
	return oldValue.IsHazmat, nil
}

// ResetIsHazmat resets all changes to the "is_hazmat" field.
func (m *CommodityMutation) ResetIsHazmat() {
	m.is_hazmat = nil
}

// SetUnitOfMeasure sets the "unit_of_measure" field.
func (m *CommodityMutation) SetUnitOfMeasure(s string) {
	m.unit_of_measure = &s
}

// UnitOfMeasure returns the value of the "unit_of_measure" field in the mutation.
func (m *CommodityMutation) UnitOfMeasure() (r string, exists bool) {
	v := m.unit_of_measure
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitOfMeasure returns the old "unit_of_measure" field's value of the Commodity entity.
// If the Commodity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommodityMutation) OldUnitOfMeasure(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitOfMeasure is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitOfMeasure requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitOfMeasure: %w", err)
	}
	return oldValue.UnitOfMeasure, nil
}

// ClearUnitOfMeasure clears the value of the "unit_of_measure" field.
func (m *CommodityMutation) ClearUnitOfMeasure() {
	m.unit_of_measure = nil
	m.clearedFields[commodity.FieldUnitOfMeasure] = struct{}{}
}

// UnitOfMeasureCleared returns if the "unit_of_measure" field was cleared in this mutation.
func (m *CommodityMutation) UnitOfMeasureCleared() bool {
	_, ok := m.clearedFields[commodity.FieldUnitOfMeasure]
	return ok
}

// ResetUnitOfMeasure resets all changes to the "unit_of_measure" field.
func (m *CommodityMutation) ResetUnitOfMeasure() {
	m.unit_of_measure = nil
	delete(m.clearedFields, commodity.FieldUnitOfMeasure)
}

// SetMinTemp sets the "min_temp" field.
func (m *CommodityMutation) SetMinTemp(i int8) {
	m.min_temp = &i
	m.addmin_temp = nil
}

// MinTemp returns the value of the "min_temp" field in the mutation.
func (m *CommodityMutation) MinTemp() (r int8, exists bool) {
	v := m.min_temp
	if v == nil {
		return
	}
	return *v, true
}

// OldMinTemp returns the old "min_temp" field's value of the Commodity entity.
// If the Commodity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommodityMutation) OldMinTemp(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinTemp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinTemp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinTemp: %w", err)
	}
	return oldValue.MinTemp, nil
}

// AddMinTemp adds i to the "min_temp" field.
func (m *CommodityMutation) AddMinTemp(i int8) {
	if m.addmin_temp != nil {
		*m.addmin_temp += i
	} else {
		m.addmin_temp = &i
	}
}

// AddedMinTemp returns the value that was added to the "min_temp" field in this mutation.
func (m *CommodityMutation) AddedMinTemp() (r int8, exists bool) {
	v := m.addmin_temp
	if v == nil {
		return
	}
	return *v, true
}

// ClearMinTemp clears the value of the "min_temp" field.
func (m *CommodityMutation) ClearMinTemp() {
	m.min_temp = nil
	m.addmin_temp = nil
	m.clearedFields[commodity.FieldMinTemp] = struct{}{}
}

// MinTempCleared returns if the "min_temp" field was cleared in this mutation.
func (m *CommodityMutation) MinTempCleared() bool {
	_, ok := m.clearedFields[commodity.FieldMinTemp]
	return ok
}

// ResetMinTemp resets all changes to the "min_temp" field.
func (m *CommodityMutation) ResetMinTemp() {
	m.min_temp = nil
	m.addmin_temp = nil
	delete(m.clearedFields, commodity.FieldMinTemp)
}

// SetMaxTemp sets the "max_temp" field.
func (m *CommodityMutation) SetMaxTemp(i int8) {
	m.max_temp = &i
	m.addmax_temp = nil
}

// MaxTemp returns the value of the "max_temp" field in the mutation.
func (m *CommodityMutation) MaxTemp() (r int8, exists bool) {
	v := m.max_temp
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxTemp returns the old "max_temp" field's value of the Commodity entity.
// If the Commodity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommodityMutation) OldMaxTemp(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxTemp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxTemp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxTemp: %w", err)
	}
	return oldValue.MaxTemp, nil
}

// AddMaxTemp adds i to the "max_temp" field.
func (m *CommodityMutation) AddMaxTemp(i int8) {
	if m.addmax_temp != nil {
		*m.addmax_temp += i
	} else {
		m.addmax_temp = &i
	}
}

// AddedMaxTemp returns the value that was added to the "max_temp" field in this mutation.
func (m *CommodityMutation) AddedMaxTemp() (r int8, exists bool) {
	v := m.addmax_temp
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxTemp clears the value of the "max_temp" field.
func (m *CommodityMutation) ClearMaxTemp() {
	m.max_temp = nil
	m.addmax_temp = nil
	m.clearedFields[commodity.FieldMaxTemp] = struct{}{}
}

// MaxTempCleared returns if the "max_temp" field was cleared in this mutation.
func (m *CommodityMutation) MaxTempCleared() bool {
	_, ok := m.clearedFields[commodity.FieldMaxTemp]
	return ok
}

// ResetMaxTemp resets all changes to the "max_temp" field.
func (m *CommodityMutation) ResetMaxTemp() {
	m.max_temp = nil
	m.addmax_temp = nil
	delete(m.clearedFields, commodity.FieldMaxTemp)
}

// SetDescription sets the "description" field.
func (m *CommodityMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CommodityMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Commodity entity.
// If the Commodity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommodityMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CommodityMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[commodity.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CommodityMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[commodity.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CommodityMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, commodity.FieldDescription)
}

// SetHazardousMaterialID sets the "hazardous_material_id" field.
func (m *CommodityMutation) SetHazardousMaterialID(u uuid.UUID) {
	m.hazardous_material = &u
}

// HazardousMaterialID returns the value of the "hazardous_material_id" field in the mutation.
func (m *CommodityMutation) HazardousMaterialID() (r uuid.UUID, exists bool) {
	v := m.hazardous_material
	if v == nil {
		return
	}
	return *v, true
}

// OldHazardousMaterialID returns the old "hazardous_material_id" field's value of the Commodity entity.
// If the Commodity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommodityMutation) OldHazardousMaterialID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHazardousMaterialID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHazardousMaterialID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHazardousMaterialID: %w", err)
	}
	return oldValue.HazardousMaterialID, nil
}

// ClearHazardousMaterialID clears the value of the "hazardous_material_id" field.
func (m *CommodityMutation) ClearHazardousMaterialID() {
	m.hazardous_material = nil
	m.clearedFields[commodity.FieldHazardousMaterialID] = struct{}{}
}

// HazardousMaterialIDCleared returns if the "hazardous_material_id" field was cleared in this mutation.
func (m *CommodityMutation) HazardousMaterialIDCleared() bool {
	_, ok := m.clearedFields[commodity.FieldHazardousMaterialID]
	return ok
}

// ResetHazardousMaterialID resets all changes to the "hazardous_material_id" field.
func (m *CommodityMutation) ResetHazardousMaterialID() {
	m.hazardous_material = nil
	delete(m.clearedFields, commodity.FieldHazardousMaterialID)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *CommodityMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[commodity.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *CommodityMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *CommodityMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *CommodityMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *CommodityMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[commodity.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *CommodityMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *CommodityMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *CommodityMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearHazardousMaterial clears the "hazardous_material" edge to the HazardousMaterial entity.
func (m *CommodityMutation) ClearHazardousMaterial() {
	m.clearedhazardous_material = true
	m.clearedFields[commodity.FieldHazardousMaterialID] = struct{}{}
}

// HazardousMaterialCleared reports if the "hazardous_material" edge to the HazardousMaterial entity was cleared.
func (m *CommodityMutation) HazardousMaterialCleared() bool {
	return m.HazardousMaterialIDCleared() || m.clearedhazardous_material
}

// HazardousMaterialIDs returns the "hazardous_material" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HazardousMaterialID instead. It exists only for internal usage by the builders.
func (m *CommodityMutation) HazardousMaterialIDs() (ids []uuid.UUID) {
	if id := m.hazardous_material; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHazardousMaterial resets all changes to the "hazardous_material" edge.
func (m *CommodityMutation) ResetHazardousMaterial() {
	m.hazardous_material = nil
	m.clearedhazardous_material = false
}

// Where appends a list predicates to the CommodityMutation builder.
func (m *CommodityMutation) Where(ps ...predicate.Commodity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommodityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommodityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Commodity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommodityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommodityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Commodity).
func (m *CommodityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommodityMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.business_unit != nil {
		fields = append(fields, commodity.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, commodity.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, commodity.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, commodity.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, commodity.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, commodity.FieldName)
	}
	if m.is_hazmat != nil {
		fields = append(fields, commodity.FieldIsHazmat)
	}
	if m.unit_of_measure != nil {
		fields = append(fields, commodity.FieldUnitOfMeasure)
	}
	if m.min_temp != nil {
		fields = append(fields, commodity.FieldMinTemp)
	}
	if m.max_temp != nil {
		fields = append(fields, commodity.FieldMaxTemp)
	}
	if m.description != nil {
		fields = append(fields, commodity.FieldDescription)
	}
	if m.hazardous_material != nil {
		fields = append(fields, commodity.FieldHazardousMaterialID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommodityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case commodity.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case commodity.FieldOrganizationID:
		return m.OrganizationID()
	case commodity.FieldCreatedAt:
		return m.CreatedAt()
	case commodity.FieldUpdatedAt:
		return m.UpdatedAt()
	case commodity.FieldStatus:
		return m.Status()
	case commodity.FieldName:
		return m.Name()
	case commodity.FieldIsHazmat:
		return m.IsHazmat()
	case commodity.FieldUnitOfMeasure:
		return m.UnitOfMeasure()
	case commodity.FieldMinTemp:
		return m.MinTemp()
	case commodity.FieldMaxTemp:
		return m.MaxTemp()
	case commodity.FieldDescription:
		return m.Description()
	case commodity.FieldHazardousMaterialID:
		return m.HazardousMaterialID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommodityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case commodity.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case commodity.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case commodity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case commodity.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case commodity.FieldStatus:
		return m.OldStatus(ctx)
	case commodity.FieldName:
		return m.OldName(ctx)
	case commodity.FieldIsHazmat:
		return m.OldIsHazmat(ctx)
	case commodity.FieldUnitOfMeasure:
		return m.OldUnitOfMeasure(ctx)
	case commodity.FieldMinTemp:
		return m.OldMinTemp(ctx)
	case commodity.FieldMaxTemp:
		return m.OldMaxTemp(ctx)
	case commodity.FieldDescription:
		return m.OldDescription(ctx)
	case commodity.FieldHazardousMaterialID:
		return m.OldHazardousMaterialID(ctx)
	}
	return nil, fmt.Errorf("unknown Commodity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommodityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case commodity.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case commodity.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case commodity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case commodity.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case commodity.FieldStatus:
		v, ok := value.(commodity.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case commodity.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case commodity.FieldIsHazmat:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsHazmat(v)
		return nil
	case commodity.FieldUnitOfMeasure:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitOfMeasure(v)
		return nil
	case commodity.FieldMinTemp:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinTemp(v)
		return nil
	case commodity.FieldMaxTemp:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxTemp(v)
		return nil
	case commodity.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case commodity.FieldHazardousMaterialID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHazardousMaterialID(v)
		return nil
	}
	return fmt.Errorf("unknown Commodity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommodityMutation) AddedFields() []string {
	var fields []string
	if m.addmin_temp != nil {
		fields = append(fields, commodity.FieldMinTemp)
	}
	if m.addmax_temp != nil {
		fields = append(fields, commodity.FieldMaxTemp)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommodityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case commodity.FieldMinTemp:
		return m.AddedMinTemp()
	case commodity.FieldMaxTemp:
		return m.AddedMaxTemp()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommodityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case commodity.FieldMinTemp:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinTemp(v)
		return nil
	case commodity.FieldMaxTemp:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxTemp(v)
		return nil
	}
	return fmt.Errorf("unknown Commodity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommodityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(commodity.FieldUnitOfMeasure) {
		fields = append(fields, commodity.FieldUnitOfMeasure)
	}
	if m.FieldCleared(commodity.FieldMinTemp) {
		fields = append(fields, commodity.FieldMinTemp)
	}
	if m.FieldCleared(commodity.FieldMaxTemp) {
		fields = append(fields, commodity.FieldMaxTemp)
	}
	if m.FieldCleared(commodity.FieldDescription) {
		fields = append(fields, commodity.FieldDescription)
	}
	if m.FieldCleared(commodity.FieldHazardousMaterialID) {
		fields = append(fields, commodity.FieldHazardousMaterialID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommodityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommodityMutation) ClearField(name string) error {
	switch name {
	case commodity.FieldUnitOfMeasure:
		m.ClearUnitOfMeasure()
		return nil
	case commodity.FieldMinTemp:
		m.ClearMinTemp()
		return nil
	case commodity.FieldMaxTemp:
		m.ClearMaxTemp()
		return nil
	case commodity.FieldDescription:
		m.ClearDescription()
		return nil
	case commodity.FieldHazardousMaterialID:
		m.ClearHazardousMaterialID()
		return nil
	}
	return fmt.Errorf("unknown Commodity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommodityMutation) ResetField(name string) error {
	switch name {
	case commodity.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case commodity.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case commodity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case commodity.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case commodity.FieldStatus:
		m.ResetStatus()
		return nil
	case commodity.FieldName:
		m.ResetName()
		return nil
	case commodity.FieldIsHazmat:
		m.ResetIsHazmat()
		return nil
	case commodity.FieldUnitOfMeasure:
		m.ResetUnitOfMeasure()
		return nil
	case commodity.FieldMinTemp:
		m.ResetMinTemp()
		return nil
	case commodity.FieldMaxTemp:
		m.ResetMaxTemp()
		return nil
	case commodity.FieldDescription:
		m.ResetDescription()
		return nil
	case commodity.FieldHazardousMaterialID:
		m.ResetHazardousMaterialID()
		return nil
	}
	return fmt.Errorf("unknown Commodity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommodityMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.business_unit != nil {
		edges = append(edges, commodity.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, commodity.EdgeOrganization)
	}
	if m.hazardous_material != nil {
		edges = append(edges, commodity.EdgeHazardousMaterial)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommodityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case commodity.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case commodity.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case commodity.EdgeHazardousMaterial:
		if id := m.hazardous_material; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommodityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommodityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommodityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbusiness_unit {
		edges = append(edges, commodity.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, commodity.EdgeOrganization)
	}
	if m.clearedhazardous_material {
		edges = append(edges, commodity.EdgeHazardousMaterial)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommodityMutation) EdgeCleared(name string) bool {
	switch name {
	case commodity.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case commodity.EdgeOrganization:
		return m.clearedorganization
	case commodity.EdgeHazardousMaterial:
		return m.clearedhazardous_material
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommodityMutation) ClearEdge(name string) error {
	switch name {
	case commodity.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case commodity.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case commodity.EdgeHazardousMaterial:
		m.ClearHazardousMaterial()
		return nil
	}
	return fmt.Errorf("unknown Commodity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommodityMutation) ResetEdge(name string) error {
	switch name {
	case commodity.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case commodity.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case commodity.EdgeHazardousMaterial:
		m.ResetHazardousMaterial()
		return nil
	}
	return fmt.Errorf("unknown Commodity edge %s", name)
}

// CustomerMutation represents an operation that mutates the Customer nodes in the graph.
type CustomerMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	created_at              *time.Time
	updated_at              *time.Time
	status                  *customer.Status
	code                    *string
	name                    *string
	address_line_1          *string
	address_line_2          *string
	city                    *string
	postal_code             *string
	has_customer_portal     *bool
	auto_mark_ready_to_bill *bool
	clearedFields           map[string]struct{}
	business_unit           *uuid.UUID
	clearedbusiness_unit    bool
	organization            *uuid.UUID
	clearedorganization     bool
	state                   *uuid.UUID
	clearedstate            bool
	done                    bool
	oldValue                func(context.Context) (*Customer, error)
	predicates              []predicate.Customer
}

var _ ent.Mutation = (*CustomerMutation)(nil)

// customerOption allows management of the mutation configuration using functional options.
type customerOption func(*CustomerMutation)

// newCustomerMutation creates new mutation for the Customer entity.
func newCustomerMutation(c config, op Op, opts ...customerOption) *CustomerMutation {
	m := &CustomerMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerID sets the ID field of the mutation.
func withCustomerID(id uuid.UUID) customerOption {
	return func(m *CustomerMutation) {
		var (
			err   error
			once  sync.Once
			value *Customer
		)
		m.oldValue = func(ctx context.Context) (*Customer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Customer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomer sets the old Customer of the mutation.
func withCustomer(node *Customer) customerOption {
	return func(m *CustomerMutation) {
		m.oldValue = func(context.Context) (*Customer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Customer entities.
func (m *CustomerMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CustomerMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CustomerMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Customer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *CustomerMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *CustomerMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *CustomerMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *CustomerMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *CustomerMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *CustomerMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CustomerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CustomerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CustomerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CustomerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CustomerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CustomerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *CustomerMutation) SetStatus(c customer.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *CustomerMutation) Status() (r customer.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldStatus(ctx context.Context) (v customer.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CustomerMutation) ResetStatus() {
	m.status = nil
}

// SetCode sets the "code" field.
func (m *CustomerMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *CustomerMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *CustomerMutation) ResetCode() {
	m.code = nil
}

// SetName sets the "name" field.
func (m *CustomerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CustomerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CustomerMutation) ResetName() {
	m.name = nil
}

// SetAddressLine1 sets the "address_line_1" field.
func (m *CustomerMutation) SetAddressLine1(s string) {
	m.address_line_1 = &s
}

// AddressLine1 returns the value of the "address_line_1" field in the mutation.
func (m *CustomerMutation) AddressLine1() (r string, exists bool) {
	v := m.address_line_1
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressLine1 returns the old "address_line_1" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldAddressLine1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddressLine1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddressLine1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressLine1: %w", err)
	}
	return oldValue.AddressLine1, nil
}

// ResetAddressLine1 resets all changes to the "address_line_1" field.
func (m *CustomerMutation) ResetAddressLine1() {
	m.address_line_1 = nil
}

// SetAddressLine2 sets the "address_line_2" field.
func (m *CustomerMutation) SetAddressLine2(s string) {
	m.address_line_2 = &s
}

// AddressLine2 returns the value of the "address_line_2" field in the mutation.
func (m *CustomerMutation) AddressLine2() (r string, exists bool) {
	v := m.address_line_2
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressLine2 returns the old "address_line_2" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldAddressLine2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddressLine2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddressLine2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressLine2: %w", err)
	}
	return oldValue.AddressLine2, nil
}

// ClearAddressLine2 clears the value of the "address_line_2" field.
func (m *CustomerMutation) ClearAddressLine2() {
	m.address_line_2 = nil
	m.clearedFields[customer.FieldAddressLine2] = struct{}{}
}

// AddressLine2Cleared returns if the "address_line_2" field was cleared in this mutation.
func (m *CustomerMutation) AddressLine2Cleared() bool {
	_, ok := m.clearedFields[customer.FieldAddressLine2]
	return ok
}

// ResetAddressLine2 resets all changes to the "address_line_2" field.
func (m *CustomerMutation) ResetAddressLine2() {
	m.address_line_2 = nil
	delete(m.clearedFields, customer.FieldAddressLine2)
}

// SetCity sets the "city" field.
func (m *CustomerMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *CustomerMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *CustomerMutation) ResetCity() {
	m.city = nil
}

// SetStateID sets the "state_id" field.
func (m *CustomerMutation) SetStateID(u uuid.UUID) {
	m.state = &u
}

// StateID returns the value of the "state_id" field in the mutation.
func (m *CustomerMutation) StateID() (r uuid.UUID, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldStateID returns the old "state_id" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldStateID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStateID: %w", err)
	}
	return oldValue.StateID, nil
}

// ResetStateID resets all changes to the "state_id" field.
func (m *CustomerMutation) ResetStateID() {
	m.state = nil
}

// SetPostalCode sets the "postal_code" field.
func (m *CustomerMutation) SetPostalCode(s string) {
	m.postal_code = &s
}

// PostalCode returns the value of the "postal_code" field in the mutation.
func (m *CustomerMutation) PostalCode() (r string, exists bool) {
	v := m.postal_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPostalCode returns the old "postal_code" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldPostalCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostalCode: %w", err)
	}
	return oldValue.PostalCode, nil
}

// ResetPostalCode resets all changes to the "postal_code" field.
func (m *CustomerMutation) ResetPostalCode() {
	m.postal_code = nil
}

// SetHasCustomerPortal sets the "has_customer_portal" field.
func (m *CustomerMutation) SetHasCustomerPortal(b bool) {
	m.has_customer_portal = &b
}

// HasCustomerPortal returns the value of the "has_customer_portal" field in the mutation.
func (m *CustomerMutation) HasCustomerPortal() (r bool, exists bool) {
	v := m.has_customer_portal
	if v == nil {
		return
	}
	return *v, true
}

// OldHasCustomerPortal returns the old "has_customer_portal" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldHasCustomerPortal(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasCustomerPortal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasCustomerPortal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasCustomerPortal: %w", err)
	}
	return oldValue.HasCustomerPortal, nil
}

// ResetHasCustomerPortal resets all changes to the "has_customer_portal" field.
func (m *CustomerMutation) ResetHasCustomerPortal() {
	m.has_customer_portal = nil
}

// SetAutoMarkReadyToBill sets the "auto_mark_ready_to_bill" field.
func (m *CustomerMutation) SetAutoMarkReadyToBill(b bool) {
	m.auto_mark_ready_to_bill = &b
}

// AutoMarkReadyToBill returns the value of the "auto_mark_ready_to_bill" field in the mutation.
func (m *CustomerMutation) AutoMarkReadyToBill() (r bool, exists bool) {
	v := m.auto_mark_ready_to_bill
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoMarkReadyToBill returns the old "auto_mark_ready_to_bill" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldAutoMarkReadyToBill(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoMarkReadyToBill is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoMarkReadyToBill requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoMarkReadyToBill: %w", err)
	}
	return oldValue.AutoMarkReadyToBill, nil
}

// ResetAutoMarkReadyToBill resets all changes to the "auto_mark_ready_to_bill" field.
func (m *CustomerMutation) ResetAutoMarkReadyToBill() {
	m.auto_mark_ready_to_bill = nil
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *CustomerMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[customer.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *CustomerMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *CustomerMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *CustomerMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *CustomerMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[customer.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *CustomerMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *CustomerMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *CustomerMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearState clears the "state" edge to the UsState entity.
func (m *CustomerMutation) ClearState() {
	m.clearedstate = true
	m.clearedFields[customer.FieldStateID] = struct{}{}
}

// StateCleared reports if the "state" edge to the UsState entity was cleared.
func (m *CustomerMutation) StateCleared() bool {
	return m.clearedstate
}

// StateIDs returns the "state" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StateID instead. It exists only for internal usage by the builders.
func (m *CustomerMutation) StateIDs() (ids []uuid.UUID) {
	if id := m.state; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetState resets all changes to the "state" edge.
func (m *CustomerMutation) ResetState() {
	m.state = nil
	m.clearedstate = false
}

// Where appends a list predicates to the CustomerMutation builder.
func (m *CustomerMutation) Where(ps ...predicate.Customer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CustomerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CustomerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Customer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CustomerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CustomerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Customer).
func (m *CustomerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomerMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.business_unit != nil {
		fields = append(fields, customer.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, customer.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, customer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, customer.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, customer.FieldStatus)
	}
	if m.code != nil {
		fields = append(fields, customer.FieldCode)
	}
	if m.name != nil {
		fields = append(fields, customer.FieldName)
	}
	if m.address_line_1 != nil {
		fields = append(fields, customer.FieldAddressLine1)
	}
	if m.address_line_2 != nil {
		fields = append(fields, customer.FieldAddressLine2)
	}
	if m.city != nil {
		fields = append(fields, customer.FieldCity)
	}
	if m.state != nil {
		fields = append(fields, customer.FieldStateID)
	}
	if m.postal_code != nil {
		fields = append(fields, customer.FieldPostalCode)
	}
	if m.has_customer_portal != nil {
		fields = append(fields, customer.FieldHasCustomerPortal)
	}
	if m.auto_mark_ready_to_bill != nil {
		fields = append(fields, customer.FieldAutoMarkReadyToBill)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customer.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case customer.FieldOrganizationID:
		return m.OrganizationID()
	case customer.FieldCreatedAt:
		return m.CreatedAt()
	case customer.FieldUpdatedAt:
		return m.UpdatedAt()
	case customer.FieldStatus:
		return m.Status()
	case customer.FieldCode:
		return m.Code()
	case customer.FieldName:
		return m.Name()
	case customer.FieldAddressLine1:
		return m.AddressLine1()
	case customer.FieldAddressLine2:
		return m.AddressLine2()
	case customer.FieldCity:
		return m.City()
	case customer.FieldStateID:
		return m.StateID()
	case customer.FieldPostalCode:
		return m.PostalCode()
	case customer.FieldHasCustomerPortal:
		return m.HasCustomerPortal()
	case customer.FieldAutoMarkReadyToBill:
		return m.AutoMarkReadyToBill()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customer.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case customer.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case customer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case customer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case customer.FieldStatus:
		return m.OldStatus(ctx)
	case customer.FieldCode:
		return m.OldCode(ctx)
	case customer.FieldName:
		return m.OldName(ctx)
	case customer.FieldAddressLine1:
		return m.OldAddressLine1(ctx)
	case customer.FieldAddressLine2:
		return m.OldAddressLine2(ctx)
	case customer.FieldCity:
		return m.OldCity(ctx)
	case customer.FieldStateID:
		return m.OldStateID(ctx)
	case customer.FieldPostalCode:
		return m.OldPostalCode(ctx)
	case customer.FieldHasCustomerPortal:
		return m.OldHasCustomerPortal(ctx)
	case customer.FieldAutoMarkReadyToBill:
		return m.OldAutoMarkReadyToBill(ctx)
	}
	return nil, fmt.Errorf("unknown Customer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customer.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case customer.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case customer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case customer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case customer.FieldStatus:
		v, ok := value.(customer.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case customer.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case customer.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case customer.FieldAddressLine1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressLine1(v)
		return nil
	case customer.FieldAddressLine2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressLine2(v)
		return nil
	case customer.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case customer.FieldStateID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStateID(v)
		return nil
	case customer.FieldPostalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostalCode(v)
		return nil
	case customer.FieldHasCustomerPortal:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasCustomerPortal(v)
		return nil
	case customer.FieldAutoMarkReadyToBill:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoMarkReadyToBill(v)
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Customer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(customer.FieldAddressLine2) {
		fields = append(fields, customer.FieldAddressLine2)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerMutation) ClearField(name string) error {
	switch name {
	case customer.FieldAddressLine2:
		m.ClearAddressLine2()
		return nil
	}
	return fmt.Errorf("unknown Customer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomerMutation) ResetField(name string) error {
	switch name {
	case customer.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case customer.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case customer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case customer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case customer.FieldStatus:
		m.ResetStatus()
		return nil
	case customer.FieldCode:
		m.ResetCode()
		return nil
	case customer.FieldName:
		m.ResetName()
		return nil
	case customer.FieldAddressLine1:
		m.ResetAddressLine1()
		return nil
	case customer.FieldAddressLine2:
		m.ResetAddressLine2()
		return nil
	case customer.FieldCity:
		m.ResetCity()
		return nil
	case customer.FieldStateID:
		m.ResetStateID()
		return nil
	case customer.FieldPostalCode:
		m.ResetPostalCode()
		return nil
	case customer.FieldHasCustomerPortal:
		m.ResetHasCustomerPortal()
		return nil
	case customer.FieldAutoMarkReadyToBill:
		m.ResetAutoMarkReadyToBill()
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomerMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.business_unit != nil {
		edges = append(edges, customer.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, customer.EdgeOrganization)
	}
	if m.state != nil {
		edges = append(edges, customer.EdgeState)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case customer.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case customer.EdgeState:
		if id := m.state; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbusiness_unit {
		edges = append(edges, customer.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, customer.EdgeOrganization)
	}
	if m.clearedstate {
		edges = append(edges, customer.EdgeState)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomerMutation) EdgeCleared(name string) bool {
	switch name {
	case customer.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case customer.EdgeOrganization:
		return m.clearedorganization
	case customer.EdgeState:
		return m.clearedstate
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomerMutation) ClearEdge(name string) error {
	switch name {
	case customer.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case customer.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case customer.EdgeState:
		m.ClearState()
		return nil
	}
	return fmt.Errorf("unknown Customer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomerMutation) ResetEdge(name string) error {
	switch name {
	case customer.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case customer.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case customer.EdgeState:
		m.ResetState()
		return nil
	}
	return fmt.Errorf("unknown Customer edge %s", name)
}

// DelayCodeMutation represents an operation that mutates the DelayCode nodes in the graph.
type DelayCodeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	status               *delaycode.Status
	code                 *string
	description          *string
	f_carrier_or_driver  *bool
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	done                 bool
	oldValue             func(context.Context) (*DelayCode, error)
	predicates           []predicate.DelayCode
}

var _ ent.Mutation = (*DelayCodeMutation)(nil)

// delaycodeOption allows management of the mutation configuration using functional options.
type delaycodeOption func(*DelayCodeMutation)

// newDelayCodeMutation creates new mutation for the DelayCode entity.
func newDelayCodeMutation(c config, op Op, opts ...delaycodeOption) *DelayCodeMutation {
	m := &DelayCodeMutation{
		config:        c,
		op:            op,
		typ:           TypeDelayCode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDelayCodeID sets the ID field of the mutation.
func withDelayCodeID(id uuid.UUID) delaycodeOption {
	return func(m *DelayCodeMutation) {
		var (
			err   error
			once  sync.Once
			value *DelayCode
		)
		m.oldValue = func(ctx context.Context) (*DelayCode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DelayCode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDelayCode sets the old DelayCode of the mutation.
func withDelayCode(node *DelayCode) delaycodeOption {
	return func(m *DelayCodeMutation) {
		m.oldValue = func(context.Context) (*DelayCode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DelayCodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DelayCodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DelayCode entities.
func (m *DelayCodeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DelayCodeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DelayCodeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DelayCode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *DelayCodeMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *DelayCodeMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the DelayCode entity.
// If the DelayCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelayCodeMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *DelayCodeMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *DelayCodeMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *DelayCodeMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the DelayCode entity.
// If the DelayCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelayCodeMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *DelayCodeMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DelayCodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DelayCodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DelayCode entity.
// If the DelayCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelayCodeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DelayCodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DelayCodeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DelayCodeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DelayCode entity.
// If the DelayCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelayCodeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DelayCodeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *DelayCodeMutation) SetStatus(d delaycode.Status) {
	m.status = &d
}

// Status returns the value of the "status" field in the mutation.
func (m *DelayCodeMutation) Status() (r delaycode.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the DelayCode entity.
// If the DelayCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelayCodeMutation) OldStatus(ctx context.Context) (v delaycode.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *DelayCodeMutation) ResetStatus() {
	m.status = nil
}

// SetCode sets the "code" field.
func (m *DelayCodeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *DelayCodeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the DelayCode entity.
// If the DelayCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelayCodeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *DelayCodeMutation) ResetCode() {
	m.code = nil
}

// SetDescription sets the "description" field.
func (m *DelayCodeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DelayCodeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the DelayCode entity.
// If the DelayCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelayCodeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *DelayCodeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[delaycode.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *DelayCodeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[delaycode.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *DelayCodeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, delaycode.FieldDescription)
}

// SetFCarrierOrDriver sets the "f_carrier_or_driver" field.
func (m *DelayCodeMutation) SetFCarrierOrDriver(b bool) {
	m.f_carrier_or_driver = &b
}

// FCarrierOrDriver returns the value of the "f_carrier_or_driver" field in the mutation.
func (m *DelayCodeMutation) FCarrierOrDriver() (r bool, exists bool) {
	v := m.f_carrier_or_driver
	if v == nil {
		return
	}
	return *v, true
}

// OldFCarrierOrDriver returns the old "f_carrier_or_driver" field's value of the DelayCode entity.
// If the DelayCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DelayCodeMutation) OldFCarrierOrDriver(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFCarrierOrDriver is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFCarrierOrDriver requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFCarrierOrDriver: %w", err)
	}
	return oldValue.FCarrierOrDriver, nil
}

// ClearFCarrierOrDriver clears the value of the "f_carrier_or_driver" field.
func (m *DelayCodeMutation) ClearFCarrierOrDriver() {
	m.f_carrier_or_driver = nil
	m.clearedFields[delaycode.FieldFCarrierOrDriver] = struct{}{}
}

// FCarrierOrDriverCleared returns if the "f_carrier_or_driver" field was cleared in this mutation.
func (m *DelayCodeMutation) FCarrierOrDriverCleared() bool {
	_, ok := m.clearedFields[delaycode.FieldFCarrierOrDriver]
	return ok
}

// ResetFCarrierOrDriver resets all changes to the "f_carrier_or_driver" field.
func (m *DelayCodeMutation) ResetFCarrierOrDriver() {
	m.f_carrier_or_driver = nil
	delete(m.clearedFields, delaycode.FieldFCarrierOrDriver)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *DelayCodeMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[delaycode.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *DelayCodeMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *DelayCodeMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *DelayCodeMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *DelayCodeMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[delaycode.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *DelayCodeMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *DelayCodeMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *DelayCodeMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the DelayCodeMutation builder.
func (m *DelayCodeMutation) Where(ps ...predicate.DelayCode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DelayCodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DelayCodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DelayCode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DelayCodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DelayCodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DelayCode).
func (m *DelayCodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DelayCodeMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.business_unit != nil {
		fields = append(fields, delaycode.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, delaycode.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, delaycode.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, delaycode.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, delaycode.FieldStatus)
	}
	if m.code != nil {
		fields = append(fields, delaycode.FieldCode)
	}
	if m.description != nil {
		fields = append(fields, delaycode.FieldDescription)
	}
	if m.f_carrier_or_driver != nil {
		fields = append(fields, delaycode.FieldFCarrierOrDriver)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DelayCodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case delaycode.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case delaycode.FieldOrganizationID:
		return m.OrganizationID()
	case delaycode.FieldCreatedAt:
		return m.CreatedAt()
	case delaycode.FieldUpdatedAt:
		return m.UpdatedAt()
	case delaycode.FieldStatus:
		return m.Status()
	case delaycode.FieldCode:
		return m.Code()
	case delaycode.FieldDescription:
		return m.Description()
	case delaycode.FieldFCarrierOrDriver:
		return m.FCarrierOrDriver()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DelayCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case delaycode.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case delaycode.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case delaycode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case delaycode.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case delaycode.FieldStatus:
		return m.OldStatus(ctx)
	case delaycode.FieldCode:
		return m.OldCode(ctx)
	case delaycode.FieldDescription:
		return m.OldDescription(ctx)
	case delaycode.FieldFCarrierOrDriver:
		return m.OldFCarrierOrDriver(ctx)
	}
	return nil, fmt.Errorf("unknown DelayCode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DelayCodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case delaycode.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case delaycode.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case delaycode.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case delaycode.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case delaycode.FieldStatus:
		v, ok := value.(delaycode.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case delaycode.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case delaycode.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case delaycode.FieldFCarrierOrDriver:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFCarrierOrDriver(v)
		return nil
	}
	return fmt.Errorf("unknown DelayCode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DelayCodeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DelayCodeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DelayCodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DelayCode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DelayCodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(delaycode.FieldDescription) {
		fields = append(fields, delaycode.FieldDescription)
	}
	if m.FieldCleared(delaycode.FieldFCarrierOrDriver) {
		fields = append(fields, delaycode.FieldFCarrierOrDriver)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DelayCodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DelayCodeMutation) ClearField(name string) error {
	switch name {
	case delaycode.FieldDescription:
		m.ClearDescription()
		return nil
	case delaycode.FieldFCarrierOrDriver:
		m.ClearFCarrierOrDriver()
		return nil
	}
	return fmt.Errorf("unknown DelayCode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DelayCodeMutation) ResetField(name string) error {
	switch name {
	case delaycode.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case delaycode.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case delaycode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case delaycode.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case delaycode.FieldStatus:
		m.ResetStatus()
		return nil
	case delaycode.FieldCode:
		m.ResetCode()
		return nil
	case delaycode.FieldDescription:
		m.ResetDescription()
		return nil
	case delaycode.FieldFCarrierOrDriver:
		m.ResetFCarrierOrDriver()
		return nil
	}
	return fmt.Errorf("unknown DelayCode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DelayCodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.business_unit != nil {
		edges = append(edges, delaycode.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, delaycode.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DelayCodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case delaycode.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case delaycode.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DelayCodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DelayCodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DelayCodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbusiness_unit {
		edges = append(edges, delaycode.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, delaycode.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DelayCodeMutation) EdgeCleared(name string) bool {
	switch name {
	case delaycode.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case delaycode.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DelayCodeMutation) ClearEdge(name string) error {
	switch name {
	case delaycode.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case delaycode.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown DelayCode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DelayCodeMutation) ResetEdge(name string) error {
	switch name {
	case delaycode.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case delaycode.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown DelayCode edge %s", name)
}

// DispatchControlMutation represents an operation that mutates the DispatchControl nodes in the graph.
type DispatchControlMutation struct {
	config
	op                              Op
	typ                             string
	id                              *uuid.UUID
	created_at                      *time.Time
	updated_at                      *time.Time
	record_service_incident         *dispatchcontrol.RecordServiceIncident
	deadhead_target                 *float64
	adddeadhead_target              *float64
	max_shipment_weight_limit       *int32
	addmax_shipment_weight_limit    *int32
	grace_period                    *uint8
	addgrace_period                 *int8
	enforce_worker_assign           *bool
	trailer_continuity              *bool
	dupe_trailer_check              *bool
	maintenance_compliance          *bool
	regulatory_check                *bool
	prev_shipment_on_hold           *bool
	worker_time_away_restriction    *bool
	tractor_worker_fleet_constraint *bool
	clearedFields                   map[string]struct{}
	organization                    *uuid.UUID
	clearedorganization             bool
	business_unit                   *uuid.UUID
	clearedbusiness_unit            bool
	done                            bool
	oldValue                        func(context.Context) (*DispatchControl, error)
	predicates                      []predicate.DispatchControl
}

var _ ent.Mutation = (*DispatchControlMutation)(nil)

// dispatchcontrolOption allows management of the mutation configuration using functional options.
type dispatchcontrolOption func(*DispatchControlMutation)

// newDispatchControlMutation creates new mutation for the DispatchControl entity.
func newDispatchControlMutation(c config, op Op, opts ...dispatchcontrolOption) *DispatchControlMutation {
	m := &DispatchControlMutation{
		config:        c,
		op:            op,
		typ:           TypeDispatchControl,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDispatchControlID sets the ID field of the mutation.
func withDispatchControlID(id uuid.UUID) dispatchcontrolOption {
	return func(m *DispatchControlMutation) {
		var (
			err   error
			once  sync.Once
			value *DispatchControl
		)
		m.oldValue = func(ctx context.Context) (*DispatchControl, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DispatchControl.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDispatchControl sets the old DispatchControl of the mutation.
func withDispatchControl(node *DispatchControl) dispatchcontrolOption {
	return func(m *DispatchControlMutation) {
		m.oldValue = func(context.Context) (*DispatchControl, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DispatchControlMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DispatchControlMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DispatchControl entities.
func (m *DispatchControlMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DispatchControlMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DispatchControlMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DispatchControl.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DispatchControlMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DispatchControlMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DispatchControl entity.
// If the DispatchControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DispatchControlMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DispatchControlMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DispatchControlMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DispatchControlMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DispatchControl entity.
// If the DispatchControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DispatchControlMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DispatchControlMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetRecordServiceIncident sets the "record_service_incident" field.
func (m *DispatchControlMutation) SetRecordServiceIncident(dsi dispatchcontrol.RecordServiceIncident) {
	m.record_service_incident = &dsi
}

// RecordServiceIncident returns the value of the "record_service_incident" field in the mutation.
func (m *DispatchControlMutation) RecordServiceIncident() (r dispatchcontrol.RecordServiceIncident, exists bool) {
	v := m.record_service_incident
	if v == nil {
		return
	}
	return *v, true
}

// OldRecordServiceIncident returns the old "record_service_incident" field's value of the DispatchControl entity.
// If the DispatchControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DispatchControlMutation) OldRecordServiceIncident(ctx context.Context) (v dispatchcontrol.RecordServiceIncident, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecordServiceIncident is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecordServiceIncident requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecordServiceIncident: %w", err)
	}
	return oldValue.RecordServiceIncident, nil
}

// ResetRecordServiceIncident resets all changes to the "record_service_incident" field.
func (m *DispatchControlMutation) ResetRecordServiceIncident() {
	m.record_service_incident = nil
}

// SetDeadheadTarget sets the "deadhead_target" field.
func (m *DispatchControlMutation) SetDeadheadTarget(f float64) {
	m.deadhead_target = &f
	m.adddeadhead_target = nil
}

// DeadheadTarget returns the value of the "deadhead_target" field in the mutation.
func (m *DispatchControlMutation) DeadheadTarget() (r float64, exists bool) {
	v := m.deadhead_target
	if v == nil {
		return
	}
	return *v, true
}

// OldDeadheadTarget returns the old "deadhead_target" field's value of the DispatchControl entity.
// If the DispatchControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DispatchControlMutation) OldDeadheadTarget(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeadheadTarget is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeadheadTarget requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeadheadTarget: %w", err)
	}
	return oldValue.DeadheadTarget, nil
}

// AddDeadheadTarget adds f to the "deadhead_target" field.
func (m *DispatchControlMutation) AddDeadheadTarget(f float64) {
	if m.adddeadhead_target != nil {
		*m.adddeadhead_target += f
	} else {
		m.adddeadhead_target = &f
	}
}

// AddedDeadheadTarget returns the value that was added to the "deadhead_target" field in this mutation.
func (m *DispatchControlMutation) AddedDeadheadTarget() (r float64, exists bool) {
	v := m.adddeadhead_target
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeadheadTarget resets all changes to the "deadhead_target" field.
func (m *DispatchControlMutation) ResetDeadheadTarget() {
	m.deadhead_target = nil
	m.adddeadhead_target = nil
}

// SetMaxShipmentWeightLimit sets the "max_shipment_weight_limit" field.
func (m *DispatchControlMutation) SetMaxShipmentWeightLimit(i int32) {
	m.max_shipment_weight_limit = &i
	m.addmax_shipment_weight_limit = nil
}

// MaxShipmentWeightLimit returns the value of the "max_shipment_weight_limit" field in the mutation.
func (m *DispatchControlMutation) MaxShipmentWeightLimit() (r int32, exists bool) {
	v := m.max_shipment_weight_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxShipmentWeightLimit returns the old "max_shipment_weight_limit" field's value of the DispatchControl entity.
// If the DispatchControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DispatchControlMutation) OldMaxShipmentWeightLimit(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxShipmentWeightLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxShipmentWeightLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxShipmentWeightLimit: %w", err)
	}
	return oldValue.MaxShipmentWeightLimit, nil
}

// AddMaxShipmentWeightLimit adds i to the "max_shipment_weight_limit" field.
func (m *DispatchControlMutation) AddMaxShipmentWeightLimit(i int32) {
	if m.addmax_shipment_weight_limit != nil {
		*m.addmax_shipment_weight_limit += i
	} else {
		m.addmax_shipment_weight_limit = &i
	}
}

// AddedMaxShipmentWeightLimit returns the value that was added to the "max_shipment_weight_limit" field in this mutation.
func (m *DispatchControlMutation) AddedMaxShipmentWeightLimit() (r int32, exists bool) {
	v := m.addmax_shipment_weight_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxShipmentWeightLimit resets all changes to the "max_shipment_weight_limit" field.
func (m *DispatchControlMutation) ResetMaxShipmentWeightLimit() {
	m.max_shipment_weight_limit = nil
	m.addmax_shipment_weight_limit = nil
}

// SetGracePeriod sets the "grace_period" field.
func (m *DispatchControlMutation) SetGracePeriod(u uint8) {
	m.grace_period = &u
	m.addgrace_period = nil
}

// GracePeriod returns the value of the "grace_period" field in the mutation.
func (m *DispatchControlMutation) GracePeriod() (r uint8, exists bool) {
	v := m.grace_period
	if v == nil {
		return
	}
	return *v, true
}

// OldGracePeriod returns the old "grace_period" field's value of the DispatchControl entity.
// If the DispatchControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DispatchControlMutation) OldGracePeriod(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGracePeriod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGracePeriod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGracePeriod: %w", err)
	}
	return oldValue.GracePeriod, nil
}

// AddGracePeriod adds u to the "grace_period" field.
func (m *DispatchControlMutation) AddGracePeriod(u int8) {
	if m.addgrace_period != nil {
		*m.addgrace_period += u
	} else {
		m.addgrace_period = &u
	}
}

// AddedGracePeriod returns the value that was added to the "grace_period" field in this mutation.
func (m *DispatchControlMutation) AddedGracePeriod() (r int8, exists bool) {
	v := m.addgrace_period
	if v == nil {
		return
	}
	return *v, true
}

// ResetGracePeriod resets all changes to the "grace_period" field.
func (m *DispatchControlMutation) ResetGracePeriod() {
	m.grace_period = nil
	m.addgrace_period = nil
}

// SetEnforceWorkerAssign sets the "enforce_worker_assign" field.
func (m *DispatchControlMutation) SetEnforceWorkerAssign(b bool) {
	m.enforce_worker_assign = &b
}

// EnforceWorkerAssign returns the value of the "enforce_worker_assign" field in the mutation.
func (m *DispatchControlMutation) EnforceWorkerAssign() (r bool, exists bool) {
	v := m.enforce_worker_assign
	if v == nil {
		return
	}
	return *v, true
}

// OldEnforceWorkerAssign returns the old "enforce_worker_assign" field's value of the DispatchControl entity.
// If the DispatchControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DispatchControlMutation) OldEnforceWorkerAssign(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnforceWorkerAssign is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnforceWorkerAssign requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnforceWorkerAssign: %w", err)
	}
	return oldValue.EnforceWorkerAssign, nil
}

// ResetEnforceWorkerAssign resets all changes to the "enforce_worker_assign" field.
func (m *DispatchControlMutation) ResetEnforceWorkerAssign() {
	m.enforce_worker_assign = nil
}

// SetTrailerContinuity sets the "trailer_continuity" field.
func (m *DispatchControlMutation) SetTrailerContinuity(b bool) {
	m.trailer_continuity = &b
}

// TrailerContinuity returns the value of the "trailer_continuity" field in the mutation.
func (m *DispatchControlMutation) TrailerContinuity() (r bool, exists bool) {
	v := m.trailer_continuity
	if v == nil {
		return
	}
	return *v, true
}

// OldTrailerContinuity returns the old "trailer_continuity" field's value of the DispatchControl entity.
// If the DispatchControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DispatchControlMutation) OldTrailerContinuity(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrailerContinuity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrailerContinuity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrailerContinuity: %w", err)
	}
	return oldValue.TrailerContinuity, nil
}

// ResetTrailerContinuity resets all changes to the "trailer_continuity" field.
func (m *DispatchControlMutation) ResetTrailerContinuity() {
	m.trailer_continuity = nil
}

// SetDupeTrailerCheck sets the "dupe_trailer_check" field.
func (m *DispatchControlMutation) SetDupeTrailerCheck(b bool) {
	m.dupe_trailer_check = &b
}

// DupeTrailerCheck returns the value of the "dupe_trailer_check" field in the mutation.
func (m *DispatchControlMutation) DupeTrailerCheck() (r bool, exists bool) {
	v := m.dupe_trailer_check
	if v == nil {
		return
	}
	return *v, true
}

// OldDupeTrailerCheck returns the old "dupe_trailer_check" field's value of the DispatchControl entity.
// If the DispatchControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DispatchControlMutation) OldDupeTrailerCheck(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDupeTrailerCheck is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDupeTrailerCheck requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDupeTrailerCheck: %w", err)
	}
	return oldValue.DupeTrailerCheck, nil
}

// ResetDupeTrailerCheck resets all changes to the "dupe_trailer_check" field.
func (m *DispatchControlMutation) ResetDupeTrailerCheck() {
	m.dupe_trailer_check = nil
}

// SetMaintenanceCompliance sets the "maintenance_compliance" field.
func (m *DispatchControlMutation) SetMaintenanceCompliance(b bool) {
	m.maintenance_compliance = &b
}

// MaintenanceCompliance returns the value of the "maintenance_compliance" field in the mutation.
func (m *DispatchControlMutation) MaintenanceCompliance() (r bool, exists bool) {
	v := m.maintenance_compliance
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintenanceCompliance returns the old "maintenance_compliance" field's value of the DispatchControl entity.
// If the DispatchControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DispatchControlMutation) OldMaintenanceCompliance(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintenanceCompliance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintenanceCompliance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintenanceCompliance: %w", err)
	}
	return oldValue.MaintenanceCompliance, nil
}

// ResetMaintenanceCompliance resets all changes to the "maintenance_compliance" field.
func (m *DispatchControlMutation) ResetMaintenanceCompliance() {
	m.maintenance_compliance = nil
}

// SetRegulatoryCheck sets the "regulatory_check" field.
func (m *DispatchControlMutation) SetRegulatoryCheck(b bool) {
	m.regulatory_check = &b
}

// RegulatoryCheck returns the value of the "regulatory_check" field in the mutation.
func (m *DispatchControlMutation) RegulatoryCheck() (r bool, exists bool) {
	v := m.regulatory_check
	if v == nil {
		return
	}
	return *v, true
}

// OldRegulatoryCheck returns the old "regulatory_check" field's value of the DispatchControl entity.
// If the DispatchControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DispatchControlMutation) OldRegulatoryCheck(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegulatoryCheck is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegulatoryCheck requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegulatoryCheck: %w", err)
	}
	return oldValue.RegulatoryCheck, nil
}

// ResetRegulatoryCheck resets all changes to the "regulatory_check" field.
func (m *DispatchControlMutation) ResetRegulatoryCheck() {
	m.regulatory_check = nil
}

// SetPrevShipmentOnHold sets the "prev_shipment_on_hold" field.
func (m *DispatchControlMutation) SetPrevShipmentOnHold(b bool) {
	m.prev_shipment_on_hold = &b
}

// PrevShipmentOnHold returns the value of the "prev_shipment_on_hold" field in the mutation.
func (m *DispatchControlMutation) PrevShipmentOnHold() (r bool, exists bool) {
	v := m.prev_shipment_on_hold
	if v == nil {
		return
	}
	return *v, true
}

// OldPrevShipmentOnHold returns the old "prev_shipment_on_hold" field's value of the DispatchControl entity.
// If the DispatchControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DispatchControlMutation) OldPrevShipmentOnHold(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrevShipmentOnHold is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrevShipmentOnHold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrevShipmentOnHold: %w", err)
	}
	return oldValue.PrevShipmentOnHold, nil
}

// ResetPrevShipmentOnHold resets all changes to the "prev_shipment_on_hold" field.
func (m *DispatchControlMutation) ResetPrevShipmentOnHold() {
	m.prev_shipment_on_hold = nil
}

// SetWorkerTimeAwayRestriction sets the "worker_time_away_restriction" field.
func (m *DispatchControlMutation) SetWorkerTimeAwayRestriction(b bool) {
	m.worker_time_away_restriction = &b
}

// WorkerTimeAwayRestriction returns the value of the "worker_time_away_restriction" field in the mutation.
func (m *DispatchControlMutation) WorkerTimeAwayRestriction() (r bool, exists bool) {
	v := m.worker_time_away_restriction
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkerTimeAwayRestriction returns the old "worker_time_away_restriction" field's value of the DispatchControl entity.
// If the DispatchControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DispatchControlMutation) OldWorkerTimeAwayRestriction(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkerTimeAwayRestriction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkerTimeAwayRestriction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkerTimeAwayRestriction: %w", err)
	}
	return oldValue.WorkerTimeAwayRestriction, nil
}

// ResetWorkerTimeAwayRestriction resets all changes to the "worker_time_away_restriction" field.
func (m *DispatchControlMutation) ResetWorkerTimeAwayRestriction() {
	m.worker_time_away_restriction = nil
}

// SetTractorWorkerFleetConstraint sets the "tractor_worker_fleet_constraint" field.
func (m *DispatchControlMutation) SetTractorWorkerFleetConstraint(b bool) {
	m.tractor_worker_fleet_constraint = &b
}

// TractorWorkerFleetConstraint returns the value of the "tractor_worker_fleet_constraint" field in the mutation.
func (m *DispatchControlMutation) TractorWorkerFleetConstraint() (r bool, exists bool) {
	v := m.tractor_worker_fleet_constraint
	if v == nil {
		return
	}
	return *v, true
}

// OldTractorWorkerFleetConstraint returns the old "tractor_worker_fleet_constraint" field's value of the DispatchControl entity.
// If the DispatchControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DispatchControlMutation) OldTractorWorkerFleetConstraint(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTractorWorkerFleetConstraint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTractorWorkerFleetConstraint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTractorWorkerFleetConstraint: %w", err)
	}
	return oldValue.TractorWorkerFleetConstraint, nil
}

// ResetTractorWorkerFleetConstraint resets all changes to the "tractor_worker_fleet_constraint" field.
func (m *DispatchControlMutation) ResetTractorWorkerFleetConstraint() {
	m.tractor_worker_fleet_constraint = nil
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *DispatchControlMutation) SetOrganizationID(id uuid.UUID) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *DispatchControlMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *DispatchControlMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *DispatchControlMutation) OrganizationID() (id uuid.UUID, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *DispatchControlMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *DispatchControlMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// SetBusinessUnitID sets the "business_unit" edge to the BusinessUnit entity by id.
func (m *DispatchControlMutation) SetBusinessUnitID(id uuid.UUID) {
	m.business_unit = &id
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *DispatchControlMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *DispatchControlMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitID returns the "business_unit" edge ID in the mutation.
func (m *DispatchControlMutation) BusinessUnitID() (id uuid.UUID, exists bool) {
	if m.business_unit != nil {
		return *m.business_unit, true
	}
	return
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *DispatchControlMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *DispatchControlMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// Where appends a list predicates to the DispatchControlMutation builder.
func (m *DispatchControlMutation) Where(ps ...predicate.DispatchControl) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DispatchControlMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DispatchControlMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DispatchControl, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DispatchControlMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DispatchControlMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DispatchControl).
func (m *DispatchControlMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DispatchControlMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, dispatchcontrol.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dispatchcontrol.FieldUpdatedAt)
	}
	if m.record_service_incident != nil {
		fields = append(fields, dispatchcontrol.FieldRecordServiceIncident)
	}
	if m.deadhead_target != nil {
		fields = append(fields, dispatchcontrol.FieldDeadheadTarget)
	}
	if m.max_shipment_weight_limit != nil {
		fields = append(fields, dispatchcontrol.FieldMaxShipmentWeightLimit)
	}
	if m.grace_period != nil {
		fields = append(fields, dispatchcontrol.FieldGracePeriod)
	}
	if m.enforce_worker_assign != nil {
		fields = append(fields, dispatchcontrol.FieldEnforceWorkerAssign)
	}
	if m.trailer_continuity != nil {
		fields = append(fields, dispatchcontrol.FieldTrailerContinuity)
	}
	if m.dupe_trailer_check != nil {
		fields = append(fields, dispatchcontrol.FieldDupeTrailerCheck)
	}
	if m.maintenance_compliance != nil {
		fields = append(fields, dispatchcontrol.FieldMaintenanceCompliance)
	}
	if m.regulatory_check != nil {
		fields = append(fields, dispatchcontrol.FieldRegulatoryCheck)
	}
	if m.prev_shipment_on_hold != nil {
		fields = append(fields, dispatchcontrol.FieldPrevShipmentOnHold)
	}
	if m.worker_time_away_restriction != nil {
		fields = append(fields, dispatchcontrol.FieldWorkerTimeAwayRestriction)
	}
	if m.tractor_worker_fleet_constraint != nil {
		fields = append(fields, dispatchcontrol.FieldTractorWorkerFleetConstraint)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DispatchControlMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dispatchcontrol.FieldCreatedAt:
		return m.CreatedAt()
	case dispatchcontrol.FieldUpdatedAt:
		return m.UpdatedAt()
	case dispatchcontrol.FieldRecordServiceIncident:
		return m.RecordServiceIncident()
	case dispatchcontrol.FieldDeadheadTarget:
		return m.DeadheadTarget()
	case dispatchcontrol.FieldMaxShipmentWeightLimit:
		return m.MaxShipmentWeightLimit()
	case dispatchcontrol.FieldGracePeriod:
		return m.GracePeriod()
	case dispatchcontrol.FieldEnforceWorkerAssign:
		return m.EnforceWorkerAssign()
	case dispatchcontrol.FieldTrailerContinuity:
		return m.TrailerContinuity()
	case dispatchcontrol.FieldDupeTrailerCheck:
		return m.DupeTrailerCheck()
	case dispatchcontrol.FieldMaintenanceCompliance:
		return m.MaintenanceCompliance()
	case dispatchcontrol.FieldRegulatoryCheck:
		return m.RegulatoryCheck()
	case dispatchcontrol.FieldPrevShipmentOnHold:
		return m.PrevShipmentOnHold()
	case dispatchcontrol.FieldWorkerTimeAwayRestriction:
		return m.WorkerTimeAwayRestriction()
	case dispatchcontrol.FieldTractorWorkerFleetConstraint:
		return m.TractorWorkerFleetConstraint()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DispatchControlMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dispatchcontrol.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dispatchcontrol.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dispatchcontrol.FieldRecordServiceIncident:
		return m.OldRecordServiceIncident(ctx)
	case dispatchcontrol.FieldDeadheadTarget:
		return m.OldDeadheadTarget(ctx)
	case dispatchcontrol.FieldMaxShipmentWeightLimit:
		return m.OldMaxShipmentWeightLimit(ctx)
	case dispatchcontrol.FieldGracePeriod:
		return m.OldGracePeriod(ctx)
	case dispatchcontrol.FieldEnforceWorkerAssign:
		return m.OldEnforceWorkerAssign(ctx)
	case dispatchcontrol.FieldTrailerContinuity:
		return m.OldTrailerContinuity(ctx)
	case dispatchcontrol.FieldDupeTrailerCheck:
		return m.OldDupeTrailerCheck(ctx)
	case dispatchcontrol.FieldMaintenanceCompliance:
		return m.OldMaintenanceCompliance(ctx)
	case dispatchcontrol.FieldRegulatoryCheck:
		return m.OldRegulatoryCheck(ctx)
	case dispatchcontrol.FieldPrevShipmentOnHold:
		return m.OldPrevShipmentOnHold(ctx)
	case dispatchcontrol.FieldWorkerTimeAwayRestriction:
		return m.OldWorkerTimeAwayRestriction(ctx)
	case dispatchcontrol.FieldTractorWorkerFleetConstraint:
		return m.OldTractorWorkerFleetConstraint(ctx)
	}
	return nil, fmt.Errorf("unknown DispatchControl field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DispatchControlMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dispatchcontrol.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dispatchcontrol.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dispatchcontrol.FieldRecordServiceIncident:
		v, ok := value.(dispatchcontrol.RecordServiceIncident)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecordServiceIncident(v)
		return nil
	case dispatchcontrol.FieldDeadheadTarget:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeadheadTarget(v)
		return nil
	case dispatchcontrol.FieldMaxShipmentWeightLimit:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxShipmentWeightLimit(v)
		return nil
	case dispatchcontrol.FieldGracePeriod:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGracePeriod(v)
		return nil
	case dispatchcontrol.FieldEnforceWorkerAssign:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnforceWorkerAssign(v)
		return nil
	case dispatchcontrol.FieldTrailerContinuity:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrailerContinuity(v)
		return nil
	case dispatchcontrol.FieldDupeTrailerCheck:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDupeTrailerCheck(v)
		return nil
	case dispatchcontrol.FieldMaintenanceCompliance:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintenanceCompliance(v)
		return nil
	case dispatchcontrol.FieldRegulatoryCheck:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegulatoryCheck(v)
		return nil
	case dispatchcontrol.FieldPrevShipmentOnHold:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrevShipmentOnHold(v)
		return nil
	case dispatchcontrol.FieldWorkerTimeAwayRestriction:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkerTimeAwayRestriction(v)
		return nil
	case dispatchcontrol.FieldTractorWorkerFleetConstraint:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTractorWorkerFleetConstraint(v)
		return nil
	}
	return fmt.Errorf("unknown DispatchControl field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DispatchControlMutation) AddedFields() []string {
	var fields []string
	if m.adddeadhead_target != nil {
		fields = append(fields, dispatchcontrol.FieldDeadheadTarget)
	}
	if m.addmax_shipment_weight_limit != nil {
		fields = append(fields, dispatchcontrol.FieldMaxShipmentWeightLimit)
	}
	if m.addgrace_period != nil {
		fields = append(fields, dispatchcontrol.FieldGracePeriod)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DispatchControlMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dispatchcontrol.FieldDeadheadTarget:
		return m.AddedDeadheadTarget()
	case dispatchcontrol.FieldMaxShipmentWeightLimit:
		return m.AddedMaxShipmentWeightLimit()
	case dispatchcontrol.FieldGracePeriod:
		return m.AddedGracePeriod()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DispatchControlMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dispatchcontrol.FieldDeadheadTarget:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeadheadTarget(v)
		return nil
	case dispatchcontrol.FieldMaxShipmentWeightLimit:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxShipmentWeightLimit(v)
		return nil
	case dispatchcontrol.FieldGracePeriod:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGracePeriod(v)
		return nil
	}
	return fmt.Errorf("unknown DispatchControl numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DispatchControlMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DispatchControlMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DispatchControlMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DispatchControl nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DispatchControlMutation) ResetField(name string) error {
	switch name {
	case dispatchcontrol.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dispatchcontrol.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dispatchcontrol.FieldRecordServiceIncident:
		m.ResetRecordServiceIncident()
		return nil
	case dispatchcontrol.FieldDeadheadTarget:
		m.ResetDeadheadTarget()
		return nil
	case dispatchcontrol.FieldMaxShipmentWeightLimit:
		m.ResetMaxShipmentWeightLimit()
		return nil
	case dispatchcontrol.FieldGracePeriod:
		m.ResetGracePeriod()
		return nil
	case dispatchcontrol.FieldEnforceWorkerAssign:
		m.ResetEnforceWorkerAssign()
		return nil
	case dispatchcontrol.FieldTrailerContinuity:
		m.ResetTrailerContinuity()
		return nil
	case dispatchcontrol.FieldDupeTrailerCheck:
		m.ResetDupeTrailerCheck()
		return nil
	case dispatchcontrol.FieldMaintenanceCompliance:
		m.ResetMaintenanceCompliance()
		return nil
	case dispatchcontrol.FieldRegulatoryCheck:
		m.ResetRegulatoryCheck()
		return nil
	case dispatchcontrol.FieldPrevShipmentOnHold:
		m.ResetPrevShipmentOnHold()
		return nil
	case dispatchcontrol.FieldWorkerTimeAwayRestriction:
		m.ResetWorkerTimeAwayRestriction()
		return nil
	case dispatchcontrol.FieldTractorWorkerFleetConstraint:
		m.ResetTractorWorkerFleetConstraint()
		return nil
	}
	return fmt.Errorf("unknown DispatchControl field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DispatchControlMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.organization != nil {
		edges = append(edges, dispatchcontrol.EdgeOrganization)
	}
	if m.business_unit != nil {
		edges = append(edges, dispatchcontrol.EdgeBusinessUnit)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DispatchControlMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dispatchcontrol.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case dispatchcontrol.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DispatchControlMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DispatchControlMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DispatchControlMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorganization {
		edges = append(edges, dispatchcontrol.EdgeOrganization)
	}
	if m.clearedbusiness_unit {
		edges = append(edges, dispatchcontrol.EdgeBusinessUnit)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DispatchControlMutation) EdgeCleared(name string) bool {
	switch name {
	case dispatchcontrol.EdgeOrganization:
		return m.clearedorganization
	case dispatchcontrol.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DispatchControlMutation) ClearEdge(name string) error {
	switch name {
	case dispatchcontrol.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case dispatchcontrol.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	}
	return fmt.Errorf("unknown DispatchControl unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DispatchControlMutation) ResetEdge(name string) error {
	switch name {
	case dispatchcontrol.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case dispatchcontrol.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	}
	return fmt.Errorf("unknown DispatchControl edge %s", name)
}

// DivisionCodeMutation represents an operation that mutates the DivisionCode nodes in the graph.
type DivisionCodeMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	created_at             *time.Time
	updated_at             *time.Time
	status                 *divisioncode.Status
	code                   *string
	description            *string
	clearedFields          map[string]struct{}
	business_unit          *uuid.UUID
	clearedbusiness_unit   bool
	organization           *uuid.UUID
	clearedorganization    bool
	cash_account           *uuid.UUID
	clearedcash_account    bool
	ap_account             *uuid.UUID
	clearedap_account      bool
	expense_account        *uuid.UUID
	clearedexpense_account bool
	done                   bool
	oldValue               func(context.Context) (*DivisionCode, error)
	predicates             []predicate.DivisionCode
}

var _ ent.Mutation = (*DivisionCodeMutation)(nil)

// divisioncodeOption allows management of the mutation configuration using functional options.
type divisioncodeOption func(*DivisionCodeMutation)

// newDivisionCodeMutation creates new mutation for the DivisionCode entity.
func newDivisionCodeMutation(c config, op Op, opts ...divisioncodeOption) *DivisionCodeMutation {
	m := &DivisionCodeMutation{
		config:        c,
		op:            op,
		typ:           TypeDivisionCode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDivisionCodeID sets the ID field of the mutation.
func withDivisionCodeID(id uuid.UUID) divisioncodeOption {
	return func(m *DivisionCodeMutation) {
		var (
			err   error
			once  sync.Once
			value *DivisionCode
		)
		m.oldValue = func(ctx context.Context) (*DivisionCode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DivisionCode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDivisionCode sets the old DivisionCode of the mutation.
func withDivisionCode(node *DivisionCode) divisioncodeOption {
	return func(m *DivisionCodeMutation) {
		m.oldValue = func(context.Context) (*DivisionCode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DivisionCodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DivisionCodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DivisionCode entities.
func (m *DivisionCodeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DivisionCodeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DivisionCodeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DivisionCode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *DivisionCodeMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *DivisionCodeMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the DivisionCode entity.
// If the DivisionCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionCodeMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *DivisionCodeMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *DivisionCodeMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *DivisionCodeMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the DivisionCode entity.
// If the DivisionCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionCodeMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *DivisionCodeMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DivisionCodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DivisionCodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DivisionCode entity.
// If the DivisionCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionCodeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DivisionCodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DivisionCodeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DivisionCodeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DivisionCode entity.
// If the DivisionCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionCodeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DivisionCodeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *DivisionCodeMutation) SetStatus(d divisioncode.Status) {
	m.status = &d
}

// Status returns the value of the "status" field in the mutation.
func (m *DivisionCodeMutation) Status() (r divisioncode.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the DivisionCode entity.
// If the DivisionCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionCodeMutation) OldStatus(ctx context.Context) (v divisioncode.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *DivisionCodeMutation) ResetStatus() {
	m.status = nil
}

// SetCode sets the "code" field.
func (m *DivisionCodeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *DivisionCodeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the DivisionCode entity.
// If the DivisionCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionCodeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *DivisionCodeMutation) ResetCode() {
	m.code = nil
}

// SetDescription sets the "description" field.
func (m *DivisionCodeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DivisionCodeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the DivisionCode entity.
// If the DivisionCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionCodeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *DivisionCodeMutation) ResetDescription() {
	m.description = nil
}

// SetCashAccountID sets the "cash_account_id" field.
func (m *DivisionCodeMutation) SetCashAccountID(u uuid.UUID) {
	m.cash_account = &u
}

// CashAccountID returns the value of the "cash_account_id" field in the mutation.
func (m *DivisionCodeMutation) CashAccountID() (r uuid.UUID, exists bool) {
	v := m.cash_account
	if v == nil {
		return
	}
	return *v, true
}

// OldCashAccountID returns the old "cash_account_id" field's value of the DivisionCode entity.
// If the DivisionCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionCodeMutation) OldCashAccountID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCashAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCashAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCashAccountID: %w", err)
	}
	return oldValue.CashAccountID, nil
}

// ClearCashAccountID clears the value of the "cash_account_id" field.
func (m *DivisionCodeMutation) ClearCashAccountID() {
	m.cash_account = nil
	m.clearedFields[divisioncode.FieldCashAccountID] = struct{}{}
}

// CashAccountIDCleared returns if the "cash_account_id" field was cleared in this mutation.
func (m *DivisionCodeMutation) CashAccountIDCleared() bool {
	_, ok := m.clearedFields[divisioncode.FieldCashAccountID]
	return ok
}

// ResetCashAccountID resets all changes to the "cash_account_id" field.
func (m *DivisionCodeMutation) ResetCashAccountID() {
	m.cash_account = nil
	delete(m.clearedFields, divisioncode.FieldCashAccountID)
}

// SetApAccountID sets the "ap_account_id" field.
func (m *DivisionCodeMutation) SetApAccountID(u uuid.UUID) {
	m.ap_account = &u
}

// ApAccountID returns the value of the "ap_account_id" field in the mutation.
func (m *DivisionCodeMutation) ApAccountID() (r uuid.UUID, exists bool) {
	v := m.ap_account
	if v == nil {
		return
	}
	return *v, true
}

// OldApAccountID returns the old "ap_account_id" field's value of the DivisionCode entity.
// If the DivisionCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionCodeMutation) OldApAccountID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApAccountID: %w", err)
	}
	return oldValue.ApAccountID, nil
}

// ClearApAccountID clears the value of the "ap_account_id" field.
func (m *DivisionCodeMutation) ClearApAccountID() {
	m.ap_account = nil
	m.clearedFields[divisioncode.FieldApAccountID] = struct{}{}
}

// ApAccountIDCleared returns if the "ap_account_id" field was cleared in this mutation.
func (m *DivisionCodeMutation) ApAccountIDCleared() bool {
	_, ok := m.clearedFields[divisioncode.FieldApAccountID]
	return ok
}

// ResetApAccountID resets all changes to the "ap_account_id" field.
func (m *DivisionCodeMutation) ResetApAccountID() {
	m.ap_account = nil
	delete(m.clearedFields, divisioncode.FieldApAccountID)
}

// SetExpenseAccountID sets the "expense_account_id" field.
func (m *DivisionCodeMutation) SetExpenseAccountID(u uuid.UUID) {
	m.expense_account = &u
}

// ExpenseAccountID returns the value of the "expense_account_id" field in the mutation.
func (m *DivisionCodeMutation) ExpenseAccountID() (r uuid.UUID, exists bool) {
	v := m.expense_account
	if v == nil {
		return
	}
	return *v, true
}

// OldExpenseAccountID returns the old "expense_account_id" field's value of the DivisionCode entity.
// If the DivisionCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivisionCodeMutation) OldExpenseAccountID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpenseAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpenseAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpenseAccountID: %w", err)
	}
	return oldValue.ExpenseAccountID, nil
}

// ClearExpenseAccountID clears the value of the "expense_account_id" field.
func (m *DivisionCodeMutation) ClearExpenseAccountID() {
	m.expense_account = nil
	m.clearedFields[divisioncode.FieldExpenseAccountID] = struct{}{}
}

// ExpenseAccountIDCleared returns if the "expense_account_id" field was cleared in this mutation.
func (m *DivisionCodeMutation) ExpenseAccountIDCleared() bool {
	_, ok := m.clearedFields[divisioncode.FieldExpenseAccountID]
	return ok
}

// ResetExpenseAccountID resets all changes to the "expense_account_id" field.
func (m *DivisionCodeMutation) ResetExpenseAccountID() {
	m.expense_account = nil
	delete(m.clearedFields, divisioncode.FieldExpenseAccountID)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *DivisionCodeMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[divisioncode.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *DivisionCodeMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *DivisionCodeMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *DivisionCodeMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *DivisionCodeMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[divisioncode.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *DivisionCodeMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *DivisionCodeMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *DivisionCodeMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearCashAccount clears the "cash_account" edge to the GeneralLedgerAccount entity.
func (m *DivisionCodeMutation) ClearCashAccount() {
	m.clearedcash_account = true
	m.clearedFields[divisioncode.FieldCashAccountID] = struct{}{}
}

// CashAccountCleared reports if the "cash_account" edge to the GeneralLedgerAccount entity was cleared.
func (m *DivisionCodeMutation) CashAccountCleared() bool {
	return m.CashAccountIDCleared() || m.clearedcash_account
}

// CashAccountIDs returns the "cash_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CashAccountID instead. It exists only for internal usage by the builders.
func (m *DivisionCodeMutation) CashAccountIDs() (ids []uuid.UUID) {
	if id := m.cash_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCashAccount resets all changes to the "cash_account" edge.
func (m *DivisionCodeMutation) ResetCashAccount() {
	m.cash_account = nil
	m.clearedcash_account = false
}

// ClearApAccount clears the "ap_account" edge to the GeneralLedgerAccount entity.
func (m *DivisionCodeMutation) ClearApAccount() {
	m.clearedap_account = true
	m.clearedFields[divisioncode.FieldApAccountID] = struct{}{}
}

// ApAccountCleared reports if the "ap_account" edge to the GeneralLedgerAccount entity was cleared.
func (m *DivisionCodeMutation) ApAccountCleared() bool {
	return m.ApAccountIDCleared() || m.clearedap_account
}

// ApAccountIDs returns the "ap_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ApAccountID instead. It exists only for internal usage by the builders.
func (m *DivisionCodeMutation) ApAccountIDs() (ids []uuid.UUID) {
	if id := m.ap_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApAccount resets all changes to the "ap_account" edge.
func (m *DivisionCodeMutation) ResetApAccount() {
	m.ap_account = nil
	m.clearedap_account = false
}

// ClearExpenseAccount clears the "expense_account" edge to the GeneralLedgerAccount entity.
func (m *DivisionCodeMutation) ClearExpenseAccount() {
	m.clearedexpense_account = true
	m.clearedFields[divisioncode.FieldExpenseAccountID] = struct{}{}
}

// ExpenseAccountCleared reports if the "expense_account" edge to the GeneralLedgerAccount entity was cleared.
func (m *DivisionCodeMutation) ExpenseAccountCleared() bool {
	return m.ExpenseAccountIDCleared() || m.clearedexpense_account
}

// ExpenseAccountIDs returns the "expense_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExpenseAccountID instead. It exists only for internal usage by the builders.
func (m *DivisionCodeMutation) ExpenseAccountIDs() (ids []uuid.UUID) {
	if id := m.expense_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExpenseAccount resets all changes to the "expense_account" edge.
func (m *DivisionCodeMutation) ResetExpenseAccount() {
	m.expense_account = nil
	m.clearedexpense_account = false
}

// Where appends a list predicates to the DivisionCodeMutation builder.
func (m *DivisionCodeMutation) Where(ps ...predicate.DivisionCode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DivisionCodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DivisionCodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DivisionCode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DivisionCodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DivisionCodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DivisionCode).
func (m *DivisionCodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DivisionCodeMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.business_unit != nil {
		fields = append(fields, divisioncode.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, divisioncode.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, divisioncode.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, divisioncode.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, divisioncode.FieldStatus)
	}
	if m.code != nil {
		fields = append(fields, divisioncode.FieldCode)
	}
	if m.description != nil {
		fields = append(fields, divisioncode.FieldDescription)
	}
	if m.cash_account != nil {
		fields = append(fields, divisioncode.FieldCashAccountID)
	}
	if m.ap_account != nil {
		fields = append(fields, divisioncode.FieldApAccountID)
	}
	if m.expense_account != nil {
		fields = append(fields, divisioncode.FieldExpenseAccountID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DivisionCodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case divisioncode.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case divisioncode.FieldOrganizationID:
		return m.OrganizationID()
	case divisioncode.FieldCreatedAt:
		return m.CreatedAt()
	case divisioncode.FieldUpdatedAt:
		return m.UpdatedAt()
	case divisioncode.FieldStatus:
		return m.Status()
	case divisioncode.FieldCode:
		return m.Code()
	case divisioncode.FieldDescription:
		return m.Description()
	case divisioncode.FieldCashAccountID:
		return m.CashAccountID()
	case divisioncode.FieldApAccountID:
		return m.ApAccountID()
	case divisioncode.FieldExpenseAccountID:
		return m.ExpenseAccountID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DivisionCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case divisioncode.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case divisioncode.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case divisioncode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case divisioncode.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case divisioncode.FieldStatus:
		return m.OldStatus(ctx)
	case divisioncode.FieldCode:
		return m.OldCode(ctx)
	case divisioncode.FieldDescription:
		return m.OldDescription(ctx)
	case divisioncode.FieldCashAccountID:
		return m.OldCashAccountID(ctx)
	case divisioncode.FieldApAccountID:
		return m.OldApAccountID(ctx)
	case divisioncode.FieldExpenseAccountID:
		return m.OldExpenseAccountID(ctx)
	}
	return nil, fmt.Errorf("unknown DivisionCode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DivisionCodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case divisioncode.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case divisioncode.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case divisioncode.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case divisioncode.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case divisioncode.FieldStatus:
		v, ok := value.(divisioncode.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case divisioncode.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case divisioncode.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case divisioncode.FieldCashAccountID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCashAccountID(v)
		return nil
	case divisioncode.FieldApAccountID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApAccountID(v)
		return nil
	case divisioncode.FieldExpenseAccountID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpenseAccountID(v)
		return nil
	}
	return fmt.Errorf("unknown DivisionCode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DivisionCodeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DivisionCodeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DivisionCodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DivisionCode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DivisionCodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(divisioncode.FieldCashAccountID) {
		fields = append(fields, divisioncode.FieldCashAccountID)
	}
	if m.FieldCleared(divisioncode.FieldApAccountID) {
		fields = append(fields, divisioncode.FieldApAccountID)
	}
	if m.FieldCleared(divisioncode.FieldExpenseAccountID) {
		fields = append(fields, divisioncode.FieldExpenseAccountID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DivisionCodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DivisionCodeMutation) ClearField(name string) error {
	switch name {
	case divisioncode.FieldCashAccountID:
		m.ClearCashAccountID()
		return nil
	case divisioncode.FieldApAccountID:
		m.ClearApAccountID()
		return nil
	case divisioncode.FieldExpenseAccountID:
		m.ClearExpenseAccountID()
		return nil
	}
	return fmt.Errorf("unknown DivisionCode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DivisionCodeMutation) ResetField(name string) error {
	switch name {
	case divisioncode.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case divisioncode.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case divisioncode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case divisioncode.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case divisioncode.FieldStatus:
		m.ResetStatus()
		return nil
	case divisioncode.FieldCode:
		m.ResetCode()
		return nil
	case divisioncode.FieldDescription:
		m.ResetDescription()
		return nil
	case divisioncode.FieldCashAccountID:
		m.ResetCashAccountID()
		return nil
	case divisioncode.FieldApAccountID:
		m.ResetApAccountID()
		return nil
	case divisioncode.FieldExpenseAccountID:
		m.ResetExpenseAccountID()
		return nil
	}
	return fmt.Errorf("unknown DivisionCode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DivisionCodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.business_unit != nil {
		edges = append(edges, divisioncode.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, divisioncode.EdgeOrganization)
	}
	if m.cash_account != nil {
		edges = append(edges, divisioncode.EdgeCashAccount)
	}
	if m.ap_account != nil {
		edges = append(edges, divisioncode.EdgeApAccount)
	}
	if m.expense_account != nil {
		edges = append(edges, divisioncode.EdgeExpenseAccount)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DivisionCodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case divisioncode.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case divisioncode.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case divisioncode.EdgeCashAccount:
		if id := m.cash_account; id != nil {
			return []ent.Value{*id}
		}
	case divisioncode.EdgeApAccount:
		if id := m.ap_account; id != nil {
			return []ent.Value{*id}
		}
	case divisioncode.EdgeExpenseAccount:
		if id := m.expense_account; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DivisionCodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DivisionCodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DivisionCodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedbusiness_unit {
		edges = append(edges, divisioncode.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, divisioncode.EdgeOrganization)
	}
	if m.clearedcash_account {
		edges = append(edges, divisioncode.EdgeCashAccount)
	}
	if m.clearedap_account {
		edges = append(edges, divisioncode.EdgeApAccount)
	}
	if m.clearedexpense_account {
		edges = append(edges, divisioncode.EdgeExpenseAccount)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DivisionCodeMutation) EdgeCleared(name string) bool {
	switch name {
	case divisioncode.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case divisioncode.EdgeOrganization:
		return m.clearedorganization
	case divisioncode.EdgeCashAccount:
		return m.clearedcash_account
	case divisioncode.EdgeApAccount:
		return m.clearedap_account
	case divisioncode.EdgeExpenseAccount:
		return m.clearedexpense_account
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DivisionCodeMutation) ClearEdge(name string) error {
	switch name {
	case divisioncode.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case divisioncode.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case divisioncode.EdgeCashAccount:
		m.ClearCashAccount()
		return nil
	case divisioncode.EdgeApAccount:
		m.ClearApAccount()
		return nil
	case divisioncode.EdgeExpenseAccount:
		m.ClearExpenseAccount()
		return nil
	}
	return fmt.Errorf("unknown DivisionCode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DivisionCodeMutation) ResetEdge(name string) error {
	switch name {
	case divisioncode.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case divisioncode.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case divisioncode.EdgeCashAccount:
		m.ResetCashAccount()
		return nil
	case divisioncode.EdgeApAccount:
		m.ResetApAccount()
		return nil
	case divisioncode.EdgeExpenseAccount:
		m.ResetExpenseAccount()
		return nil
	}
	return fmt.Errorf("unknown DivisionCode edge %s", name)
}

// DocumentClassificationMutation represents an operation that mutates the DocumentClassification nodes in the graph.
type DocumentClassificationMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	status               *documentclassification.Status
	name                 *string
	description          *string
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	done                 bool
	oldValue             func(context.Context) (*DocumentClassification, error)
	predicates           []predicate.DocumentClassification
}

var _ ent.Mutation = (*DocumentClassificationMutation)(nil)

// documentclassificationOption allows management of the mutation configuration using functional options.
type documentclassificationOption func(*DocumentClassificationMutation)

// newDocumentClassificationMutation creates new mutation for the DocumentClassification entity.
func newDocumentClassificationMutation(c config, op Op, opts ...documentclassificationOption) *DocumentClassificationMutation {
	m := &DocumentClassificationMutation{
		config:        c,
		op:            op,
		typ:           TypeDocumentClassification,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDocumentClassificationID sets the ID field of the mutation.
func withDocumentClassificationID(id uuid.UUID) documentclassificationOption {
	return func(m *DocumentClassificationMutation) {
		var (
			err   error
			once  sync.Once
			value *DocumentClassification
		)
		m.oldValue = func(ctx context.Context) (*DocumentClassification, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DocumentClassification.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDocumentClassification sets the old DocumentClassification of the mutation.
func withDocumentClassification(node *DocumentClassification) documentclassificationOption {
	return func(m *DocumentClassificationMutation) {
		m.oldValue = func(context.Context) (*DocumentClassification, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DocumentClassificationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DocumentClassificationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DocumentClassification entities.
func (m *DocumentClassificationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DocumentClassificationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DocumentClassificationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DocumentClassification.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *DocumentClassificationMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *DocumentClassificationMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the DocumentClassification entity.
// If the DocumentClassification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentClassificationMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *DocumentClassificationMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *DocumentClassificationMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *DocumentClassificationMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the DocumentClassification entity.
// If the DocumentClassification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentClassificationMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *DocumentClassificationMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DocumentClassificationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DocumentClassificationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DocumentClassification entity.
// If the DocumentClassification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentClassificationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DocumentClassificationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DocumentClassificationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DocumentClassificationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DocumentClassification entity.
// If the DocumentClassification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentClassificationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DocumentClassificationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *DocumentClassificationMutation) SetStatus(d documentclassification.Status) {
	m.status = &d
}

// Status returns the value of the "status" field in the mutation.
func (m *DocumentClassificationMutation) Status() (r documentclassification.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the DocumentClassification entity.
// If the DocumentClassification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentClassificationMutation) OldStatus(ctx context.Context) (v documentclassification.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *DocumentClassificationMutation) ResetStatus() {
	m.status = nil
}

// SetName sets the "name" field.
func (m *DocumentClassificationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DocumentClassificationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DocumentClassification entity.
// If the DocumentClassification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentClassificationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DocumentClassificationMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *DocumentClassificationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DocumentClassificationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the DocumentClassification entity.
// If the DocumentClassification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentClassificationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *DocumentClassificationMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[documentclassification.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *DocumentClassificationMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[documentclassification.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *DocumentClassificationMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, documentclassification.FieldDescription)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *DocumentClassificationMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[documentclassification.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *DocumentClassificationMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *DocumentClassificationMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *DocumentClassificationMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *DocumentClassificationMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[documentclassification.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *DocumentClassificationMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *DocumentClassificationMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *DocumentClassificationMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the DocumentClassificationMutation builder.
func (m *DocumentClassificationMutation) Where(ps ...predicate.DocumentClassification) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DocumentClassificationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DocumentClassificationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DocumentClassification, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DocumentClassificationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DocumentClassificationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DocumentClassification).
func (m *DocumentClassificationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DocumentClassificationMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.business_unit != nil {
		fields = append(fields, documentclassification.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, documentclassification.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, documentclassification.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, documentclassification.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, documentclassification.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, documentclassification.FieldName)
	}
	if m.description != nil {
		fields = append(fields, documentclassification.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DocumentClassificationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case documentclassification.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case documentclassification.FieldOrganizationID:
		return m.OrganizationID()
	case documentclassification.FieldCreatedAt:
		return m.CreatedAt()
	case documentclassification.FieldUpdatedAt:
		return m.UpdatedAt()
	case documentclassification.FieldStatus:
		return m.Status()
	case documentclassification.FieldName:
		return m.Name()
	case documentclassification.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DocumentClassificationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case documentclassification.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case documentclassification.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case documentclassification.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case documentclassification.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case documentclassification.FieldStatus:
		return m.OldStatus(ctx)
	case documentclassification.FieldName:
		return m.OldName(ctx)
	case documentclassification.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown DocumentClassification field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocumentClassificationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case documentclassification.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case documentclassification.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case documentclassification.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case documentclassification.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case documentclassification.FieldStatus:
		v, ok := value.(documentclassification.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case documentclassification.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case documentclassification.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown DocumentClassification field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DocumentClassificationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DocumentClassificationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocumentClassificationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DocumentClassification numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DocumentClassificationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(documentclassification.FieldDescription) {
		fields = append(fields, documentclassification.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DocumentClassificationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DocumentClassificationMutation) ClearField(name string) error {
	switch name {
	case documentclassification.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown DocumentClassification nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DocumentClassificationMutation) ResetField(name string) error {
	switch name {
	case documentclassification.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case documentclassification.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case documentclassification.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case documentclassification.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case documentclassification.FieldStatus:
		m.ResetStatus()
		return nil
	case documentclassification.FieldName:
		m.ResetName()
		return nil
	case documentclassification.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown DocumentClassification field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DocumentClassificationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.business_unit != nil {
		edges = append(edges, documentclassification.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, documentclassification.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DocumentClassificationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case documentclassification.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case documentclassification.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DocumentClassificationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DocumentClassificationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DocumentClassificationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbusiness_unit {
		edges = append(edges, documentclassification.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, documentclassification.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DocumentClassificationMutation) EdgeCleared(name string) bool {
	switch name {
	case documentclassification.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case documentclassification.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DocumentClassificationMutation) ClearEdge(name string) error {
	switch name {
	case documentclassification.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case documentclassification.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown DocumentClassification unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DocumentClassificationMutation) ResetEdge(name string) error {
	switch name {
	case documentclassification.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case documentclassification.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown DocumentClassification edge %s", name)
}

// EmailControlMutation represents an operation that mutates the EmailControl nodes in the graph.
type EmailControlMutation struct {
	config
	op                           Op
	typ                          string
	id                           *uuid.UUID
	created_at                   *time.Time
	updated_at                   *time.Time
	clearedFields                map[string]struct{}
	organization                 *uuid.UUID
	clearedorganization          bool
	business_unit                *uuid.UUID
	clearedbusiness_unit         bool
	billing_email_profile        *uuid.UUID
	clearedbilling_email_profile bool
	rate_email_profile           *uuid.UUID
	clearedrate_email_profile    bool
	done                         bool
	oldValue                     func(context.Context) (*EmailControl, error)
	predicates                   []predicate.EmailControl
}

var _ ent.Mutation = (*EmailControlMutation)(nil)

// emailcontrolOption allows management of the mutation configuration using functional options.
type emailcontrolOption func(*EmailControlMutation)

// newEmailControlMutation creates new mutation for the EmailControl entity.
func newEmailControlMutation(c config, op Op, opts ...emailcontrolOption) *EmailControlMutation {
	m := &EmailControlMutation{
		config:        c,
		op:            op,
		typ:           TypeEmailControl,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmailControlID sets the ID field of the mutation.
func withEmailControlID(id uuid.UUID) emailcontrolOption {
	return func(m *EmailControlMutation) {
		var (
			err   error
			once  sync.Once
			value *EmailControl
		)
		m.oldValue = func(ctx context.Context) (*EmailControl, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EmailControl.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmailControl sets the old EmailControl of the mutation.
func withEmailControl(node *EmailControl) emailcontrolOption {
	return func(m *EmailControlMutation) {
		m.oldValue = func(context.Context) (*EmailControl, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmailControlMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmailControlMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EmailControl entities.
func (m *EmailControlMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmailControlMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmailControlMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EmailControl.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EmailControlMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EmailControlMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EmailControl entity.
// If the EmailControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailControlMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EmailControlMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EmailControlMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EmailControlMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EmailControl entity.
// If the EmailControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailControlMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EmailControlMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetBillingEmailProfileID sets the "billing_email_profile_id" field.
func (m *EmailControlMutation) SetBillingEmailProfileID(u uuid.UUID) {
	m.billing_email_profile = &u
}

// BillingEmailProfileID returns the value of the "billing_email_profile_id" field in the mutation.
func (m *EmailControlMutation) BillingEmailProfileID() (r uuid.UUID, exists bool) {
	v := m.billing_email_profile
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingEmailProfileID returns the old "billing_email_profile_id" field's value of the EmailControl entity.
// If the EmailControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailControlMutation) OldBillingEmailProfileID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingEmailProfileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingEmailProfileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingEmailProfileID: %w", err)
	}
	return oldValue.BillingEmailProfileID, nil
}

// ClearBillingEmailProfileID clears the value of the "billing_email_profile_id" field.
func (m *EmailControlMutation) ClearBillingEmailProfileID() {
	m.billing_email_profile = nil
	m.clearedFields[emailcontrol.FieldBillingEmailProfileID] = struct{}{}
}

// BillingEmailProfileIDCleared returns if the "billing_email_profile_id" field was cleared in this mutation.
func (m *EmailControlMutation) BillingEmailProfileIDCleared() bool {
	_, ok := m.clearedFields[emailcontrol.FieldBillingEmailProfileID]
	return ok
}

// ResetBillingEmailProfileID resets all changes to the "billing_email_profile_id" field.
func (m *EmailControlMutation) ResetBillingEmailProfileID() {
	m.billing_email_profile = nil
	delete(m.clearedFields, emailcontrol.FieldBillingEmailProfileID)
}

// SetRateExpirtationEmailProfileID sets the "rate_expirtation_email_profile_id" field.
func (m *EmailControlMutation) SetRateExpirtationEmailProfileID(u uuid.UUID) {
	m.rate_email_profile = &u
}

// RateExpirtationEmailProfileID returns the value of the "rate_expirtation_email_profile_id" field in the mutation.
func (m *EmailControlMutation) RateExpirtationEmailProfileID() (r uuid.UUID, exists bool) {
	v := m.rate_email_profile
	if v == nil {
		return
	}
	return *v, true
}

// OldRateExpirtationEmailProfileID returns the old "rate_expirtation_email_profile_id" field's value of the EmailControl entity.
// If the EmailControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailControlMutation) OldRateExpirtationEmailProfileID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRateExpirtationEmailProfileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRateExpirtationEmailProfileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRateExpirtationEmailProfileID: %w", err)
	}
	return oldValue.RateExpirtationEmailProfileID, nil
}

// ClearRateExpirtationEmailProfileID clears the value of the "rate_expirtation_email_profile_id" field.
func (m *EmailControlMutation) ClearRateExpirtationEmailProfileID() {
	m.rate_email_profile = nil
	m.clearedFields[emailcontrol.FieldRateExpirtationEmailProfileID] = struct{}{}
}

// RateExpirtationEmailProfileIDCleared returns if the "rate_expirtation_email_profile_id" field was cleared in this mutation.
func (m *EmailControlMutation) RateExpirtationEmailProfileIDCleared() bool {
	_, ok := m.clearedFields[emailcontrol.FieldRateExpirtationEmailProfileID]
	return ok
}

// ResetRateExpirtationEmailProfileID resets all changes to the "rate_expirtation_email_profile_id" field.
func (m *EmailControlMutation) ResetRateExpirtationEmailProfileID() {
	m.rate_email_profile = nil
	delete(m.clearedFields, emailcontrol.FieldRateExpirtationEmailProfileID)
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *EmailControlMutation) SetOrganizationID(id uuid.UUID) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *EmailControlMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *EmailControlMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *EmailControlMutation) OrganizationID() (id uuid.UUID, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *EmailControlMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *EmailControlMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// SetBusinessUnitID sets the "business_unit" edge to the BusinessUnit entity by id.
func (m *EmailControlMutation) SetBusinessUnitID(id uuid.UUID) {
	m.business_unit = &id
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *EmailControlMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *EmailControlMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitID returns the "business_unit" edge ID in the mutation.
func (m *EmailControlMutation) BusinessUnitID() (id uuid.UUID, exists bool) {
	if m.business_unit != nil {
		return *m.business_unit, true
	}
	return
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *EmailControlMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *EmailControlMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearBillingEmailProfile clears the "billing_email_profile" edge to the EmailProfile entity.
func (m *EmailControlMutation) ClearBillingEmailProfile() {
	m.clearedbilling_email_profile = true
	m.clearedFields[emailcontrol.FieldBillingEmailProfileID] = struct{}{}
}

// BillingEmailProfileCleared reports if the "billing_email_profile" edge to the EmailProfile entity was cleared.
func (m *EmailControlMutation) BillingEmailProfileCleared() bool {
	return m.BillingEmailProfileIDCleared() || m.clearedbilling_email_profile
}

// BillingEmailProfileIDs returns the "billing_email_profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BillingEmailProfileID instead. It exists only for internal usage by the builders.
func (m *EmailControlMutation) BillingEmailProfileIDs() (ids []uuid.UUID) {
	if id := m.billing_email_profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBillingEmailProfile resets all changes to the "billing_email_profile" edge.
func (m *EmailControlMutation) ResetBillingEmailProfile() {
	m.billing_email_profile = nil
	m.clearedbilling_email_profile = false
}

// SetRateEmailProfileID sets the "rate_email_profile" edge to the EmailProfile entity by id.
func (m *EmailControlMutation) SetRateEmailProfileID(id uuid.UUID) {
	m.rate_email_profile = &id
}

// ClearRateEmailProfile clears the "rate_email_profile" edge to the EmailProfile entity.
func (m *EmailControlMutation) ClearRateEmailProfile() {
	m.clearedrate_email_profile = true
	m.clearedFields[emailcontrol.FieldRateExpirtationEmailProfileID] = struct{}{}
}

// RateEmailProfileCleared reports if the "rate_email_profile" edge to the EmailProfile entity was cleared.
func (m *EmailControlMutation) RateEmailProfileCleared() bool {
	return m.RateExpirtationEmailProfileIDCleared() || m.clearedrate_email_profile
}

// RateEmailProfileID returns the "rate_email_profile" edge ID in the mutation.
func (m *EmailControlMutation) RateEmailProfileID() (id uuid.UUID, exists bool) {
	if m.rate_email_profile != nil {
		return *m.rate_email_profile, true
	}
	return
}

// RateEmailProfileIDs returns the "rate_email_profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RateEmailProfileID instead. It exists only for internal usage by the builders.
func (m *EmailControlMutation) RateEmailProfileIDs() (ids []uuid.UUID) {
	if id := m.rate_email_profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRateEmailProfile resets all changes to the "rate_email_profile" edge.
func (m *EmailControlMutation) ResetRateEmailProfile() {
	m.rate_email_profile = nil
	m.clearedrate_email_profile = false
}

// Where appends a list predicates to the EmailControlMutation builder.
func (m *EmailControlMutation) Where(ps ...predicate.EmailControl) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmailControlMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmailControlMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EmailControl, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmailControlMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmailControlMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EmailControl).
func (m *EmailControlMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmailControlMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, emailcontrol.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, emailcontrol.FieldUpdatedAt)
	}
	if m.billing_email_profile != nil {
		fields = append(fields, emailcontrol.FieldBillingEmailProfileID)
	}
	if m.rate_email_profile != nil {
		fields = append(fields, emailcontrol.FieldRateExpirtationEmailProfileID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmailControlMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case emailcontrol.FieldCreatedAt:
		return m.CreatedAt()
	case emailcontrol.FieldUpdatedAt:
		return m.UpdatedAt()
	case emailcontrol.FieldBillingEmailProfileID:
		return m.BillingEmailProfileID()
	case emailcontrol.FieldRateExpirtationEmailProfileID:
		return m.RateExpirtationEmailProfileID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmailControlMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case emailcontrol.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case emailcontrol.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case emailcontrol.FieldBillingEmailProfileID:
		return m.OldBillingEmailProfileID(ctx)
	case emailcontrol.FieldRateExpirtationEmailProfileID:
		return m.OldRateExpirtationEmailProfileID(ctx)
	}
	return nil, fmt.Errorf("unknown EmailControl field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailControlMutation) SetField(name string, value ent.Value) error {
	switch name {
	case emailcontrol.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case emailcontrol.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case emailcontrol.FieldBillingEmailProfileID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingEmailProfileID(v)
		return nil
	case emailcontrol.FieldRateExpirtationEmailProfileID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRateExpirtationEmailProfileID(v)
		return nil
	}
	return fmt.Errorf("unknown EmailControl field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmailControlMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmailControlMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailControlMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EmailControl numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmailControlMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(emailcontrol.FieldBillingEmailProfileID) {
		fields = append(fields, emailcontrol.FieldBillingEmailProfileID)
	}
	if m.FieldCleared(emailcontrol.FieldRateExpirtationEmailProfileID) {
		fields = append(fields, emailcontrol.FieldRateExpirtationEmailProfileID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmailControlMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmailControlMutation) ClearField(name string) error {
	switch name {
	case emailcontrol.FieldBillingEmailProfileID:
		m.ClearBillingEmailProfileID()
		return nil
	case emailcontrol.FieldRateExpirtationEmailProfileID:
		m.ClearRateExpirtationEmailProfileID()
		return nil
	}
	return fmt.Errorf("unknown EmailControl nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmailControlMutation) ResetField(name string) error {
	switch name {
	case emailcontrol.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case emailcontrol.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case emailcontrol.FieldBillingEmailProfileID:
		m.ResetBillingEmailProfileID()
		return nil
	case emailcontrol.FieldRateExpirtationEmailProfileID:
		m.ResetRateExpirtationEmailProfileID()
		return nil
	}
	return fmt.Errorf("unknown EmailControl field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmailControlMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.organization != nil {
		edges = append(edges, emailcontrol.EdgeOrganization)
	}
	if m.business_unit != nil {
		edges = append(edges, emailcontrol.EdgeBusinessUnit)
	}
	if m.billing_email_profile != nil {
		edges = append(edges, emailcontrol.EdgeBillingEmailProfile)
	}
	if m.rate_email_profile != nil {
		edges = append(edges, emailcontrol.EdgeRateEmailProfile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmailControlMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case emailcontrol.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case emailcontrol.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case emailcontrol.EdgeBillingEmailProfile:
		if id := m.billing_email_profile; id != nil {
			return []ent.Value{*id}
		}
	case emailcontrol.EdgeRateEmailProfile:
		if id := m.rate_email_profile; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmailControlMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmailControlMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmailControlMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedorganization {
		edges = append(edges, emailcontrol.EdgeOrganization)
	}
	if m.clearedbusiness_unit {
		edges = append(edges, emailcontrol.EdgeBusinessUnit)
	}
	if m.clearedbilling_email_profile {
		edges = append(edges, emailcontrol.EdgeBillingEmailProfile)
	}
	if m.clearedrate_email_profile {
		edges = append(edges, emailcontrol.EdgeRateEmailProfile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmailControlMutation) EdgeCleared(name string) bool {
	switch name {
	case emailcontrol.EdgeOrganization:
		return m.clearedorganization
	case emailcontrol.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case emailcontrol.EdgeBillingEmailProfile:
		return m.clearedbilling_email_profile
	case emailcontrol.EdgeRateEmailProfile:
		return m.clearedrate_email_profile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmailControlMutation) ClearEdge(name string) error {
	switch name {
	case emailcontrol.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case emailcontrol.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case emailcontrol.EdgeBillingEmailProfile:
		m.ClearBillingEmailProfile()
		return nil
	case emailcontrol.EdgeRateEmailProfile:
		m.ClearRateEmailProfile()
		return nil
	}
	return fmt.Errorf("unknown EmailControl unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmailControlMutation) ResetEdge(name string) error {
	switch name {
	case emailcontrol.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case emailcontrol.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case emailcontrol.EdgeBillingEmailProfile:
		m.ResetBillingEmailProfile()
		return nil
	case emailcontrol.EdgeRateEmailProfile:
		m.ResetRateEmailProfile()
		return nil
	}
	return fmt.Errorf("unknown EmailControl edge %s", name)
}

// EmailProfileMutation represents an operation that mutates the EmailProfile nodes in the graph.
type EmailProfileMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	name                 *string
	email                *string
	protocol             *emailprofile.Protocol
	host                 *string
	port                 *int16
	addport              *int16
	username             *string
	password             *string
	is_default           *bool
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	done                 bool
	oldValue             func(context.Context) (*EmailProfile, error)
	predicates           []predicate.EmailProfile
}

var _ ent.Mutation = (*EmailProfileMutation)(nil)

// emailprofileOption allows management of the mutation configuration using functional options.
type emailprofileOption func(*EmailProfileMutation)

// newEmailProfileMutation creates new mutation for the EmailProfile entity.
func newEmailProfileMutation(c config, op Op, opts ...emailprofileOption) *EmailProfileMutation {
	m := &EmailProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeEmailProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmailProfileID sets the ID field of the mutation.
func withEmailProfileID(id uuid.UUID) emailprofileOption {
	return func(m *EmailProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *EmailProfile
		)
		m.oldValue = func(ctx context.Context) (*EmailProfile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EmailProfile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmailProfile sets the old EmailProfile of the mutation.
func withEmailProfile(node *EmailProfile) emailprofileOption {
	return func(m *EmailProfileMutation) {
		m.oldValue = func(context.Context) (*EmailProfile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmailProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmailProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EmailProfile entities.
func (m *EmailProfileMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmailProfileMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmailProfileMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EmailProfile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *EmailProfileMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *EmailProfileMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the EmailProfile entity.
// If the EmailProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailProfileMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *EmailProfileMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *EmailProfileMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *EmailProfileMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the EmailProfile entity.
// If the EmailProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailProfileMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *EmailProfileMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EmailProfileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EmailProfileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EmailProfile entity.
// If the EmailProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailProfileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EmailProfileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EmailProfileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EmailProfileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EmailProfile entity.
// If the EmailProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailProfileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EmailProfileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *EmailProfileMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EmailProfileMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the EmailProfile entity.
// If the EmailProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailProfileMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EmailProfileMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *EmailProfileMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *EmailProfileMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the EmailProfile entity.
// If the EmailProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailProfileMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *EmailProfileMutation) ResetEmail() {
	m.email = nil
}

// SetProtocol sets the "protocol" field.
func (m *EmailProfileMutation) SetProtocol(e emailprofile.Protocol) {
	m.protocol = &e
}

// Protocol returns the value of the "protocol" field in the mutation.
func (m *EmailProfileMutation) Protocol() (r emailprofile.Protocol, exists bool) {
	v := m.protocol
	if v == nil {
		return
	}
	return *v, true
}

// OldProtocol returns the old "protocol" field's value of the EmailProfile entity.
// If the EmailProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailProfileMutation) OldProtocol(ctx context.Context) (v emailprofile.Protocol, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProtocol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProtocol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProtocol: %w", err)
	}
	return oldValue.Protocol, nil
}

// ClearProtocol clears the value of the "protocol" field.
func (m *EmailProfileMutation) ClearProtocol() {
	m.protocol = nil
	m.clearedFields[emailprofile.FieldProtocol] = struct{}{}
}

// ProtocolCleared returns if the "protocol" field was cleared in this mutation.
func (m *EmailProfileMutation) ProtocolCleared() bool {
	_, ok := m.clearedFields[emailprofile.FieldProtocol]
	return ok
}

// ResetProtocol resets all changes to the "protocol" field.
func (m *EmailProfileMutation) ResetProtocol() {
	m.protocol = nil
	delete(m.clearedFields, emailprofile.FieldProtocol)
}

// SetHost sets the "host" field.
func (m *EmailProfileMutation) SetHost(s string) {
	m.host = &s
}

// Host returns the value of the "host" field in the mutation.
func (m *EmailProfileMutation) Host() (r string, exists bool) {
	v := m.host
	if v == nil {
		return
	}
	return *v, true
}

// OldHost returns the old "host" field's value of the EmailProfile entity.
// If the EmailProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailProfileMutation) OldHost(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHost: %w", err)
	}
	return oldValue.Host, nil
}

// ClearHost clears the value of the "host" field.
func (m *EmailProfileMutation) ClearHost() {
	m.host = nil
	m.clearedFields[emailprofile.FieldHost] = struct{}{}
}

// HostCleared returns if the "host" field was cleared in this mutation.
func (m *EmailProfileMutation) HostCleared() bool {
	_, ok := m.clearedFields[emailprofile.FieldHost]
	return ok
}

// ResetHost resets all changes to the "host" field.
func (m *EmailProfileMutation) ResetHost() {
	m.host = nil
	delete(m.clearedFields, emailprofile.FieldHost)
}

// SetPort sets the "port" field.
func (m *EmailProfileMutation) SetPort(i int16) {
	m.port = &i
	m.addport = nil
}

// Port returns the value of the "port" field in the mutation.
func (m *EmailProfileMutation) Port() (r int16, exists bool) {
	v := m.port
	if v == nil {
		return
	}
	return *v, true
}

// OldPort returns the old "port" field's value of the EmailProfile entity.
// If the EmailProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailProfileMutation) OldPort(ctx context.Context) (v int16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPort: %w", err)
	}
	return oldValue.Port, nil
}

// AddPort adds i to the "port" field.
func (m *EmailProfileMutation) AddPort(i int16) {
	if m.addport != nil {
		*m.addport += i
	} else {
		m.addport = &i
	}
}

// AddedPort returns the value that was added to the "port" field in this mutation.
func (m *EmailProfileMutation) AddedPort() (r int16, exists bool) {
	v := m.addport
	if v == nil {
		return
	}
	return *v, true
}

// ClearPort clears the value of the "port" field.
func (m *EmailProfileMutation) ClearPort() {
	m.port = nil
	m.addport = nil
	m.clearedFields[emailprofile.FieldPort] = struct{}{}
}

// PortCleared returns if the "port" field was cleared in this mutation.
func (m *EmailProfileMutation) PortCleared() bool {
	_, ok := m.clearedFields[emailprofile.FieldPort]
	return ok
}

// ResetPort resets all changes to the "port" field.
func (m *EmailProfileMutation) ResetPort() {
	m.port = nil
	m.addport = nil
	delete(m.clearedFields, emailprofile.FieldPort)
}

// SetUsername sets the "username" field.
func (m *EmailProfileMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *EmailProfileMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the EmailProfile entity.
// If the EmailProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailProfileMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *EmailProfileMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[emailprofile.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *EmailProfileMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[emailprofile.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *EmailProfileMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, emailprofile.FieldUsername)
}

// SetPassword sets the "password" field.
func (m *EmailProfileMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *EmailProfileMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the EmailProfile entity.
// If the EmailProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailProfileMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *EmailProfileMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[emailprofile.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *EmailProfileMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[emailprofile.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *EmailProfileMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, emailprofile.FieldPassword)
}

// SetIsDefault sets the "is_default" field.
func (m *EmailProfileMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *EmailProfileMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the EmailProfile entity.
// If the EmailProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailProfileMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *EmailProfileMutation) ResetIsDefault() {
	m.is_default = nil
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *EmailProfileMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[emailprofile.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *EmailProfileMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *EmailProfileMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *EmailProfileMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *EmailProfileMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[emailprofile.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *EmailProfileMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *EmailProfileMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *EmailProfileMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the EmailProfileMutation builder.
func (m *EmailProfileMutation) Where(ps ...predicate.EmailProfile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmailProfileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmailProfileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EmailProfile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmailProfileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmailProfileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EmailProfile).
func (m *EmailProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmailProfileMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.business_unit != nil {
		fields = append(fields, emailprofile.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, emailprofile.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, emailprofile.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, emailprofile.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, emailprofile.FieldName)
	}
	if m.email != nil {
		fields = append(fields, emailprofile.FieldEmail)
	}
	if m.protocol != nil {
		fields = append(fields, emailprofile.FieldProtocol)
	}
	if m.host != nil {
		fields = append(fields, emailprofile.FieldHost)
	}
	if m.port != nil {
		fields = append(fields, emailprofile.FieldPort)
	}
	if m.username != nil {
		fields = append(fields, emailprofile.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, emailprofile.FieldPassword)
	}
	if m.is_default != nil {
		fields = append(fields, emailprofile.FieldIsDefault)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmailProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case emailprofile.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case emailprofile.FieldOrganizationID:
		return m.OrganizationID()
	case emailprofile.FieldCreatedAt:
		return m.CreatedAt()
	case emailprofile.FieldUpdatedAt:
		return m.UpdatedAt()
	case emailprofile.FieldName:
		return m.Name()
	case emailprofile.FieldEmail:
		return m.Email()
	case emailprofile.FieldProtocol:
		return m.Protocol()
	case emailprofile.FieldHost:
		return m.Host()
	case emailprofile.FieldPort:
		return m.Port()
	case emailprofile.FieldUsername:
		return m.Username()
	case emailprofile.FieldPassword:
		return m.Password()
	case emailprofile.FieldIsDefault:
		return m.IsDefault()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmailProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case emailprofile.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case emailprofile.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case emailprofile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case emailprofile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case emailprofile.FieldName:
		return m.OldName(ctx)
	case emailprofile.FieldEmail:
		return m.OldEmail(ctx)
	case emailprofile.FieldProtocol:
		return m.OldProtocol(ctx)
	case emailprofile.FieldHost:
		return m.OldHost(ctx)
	case emailprofile.FieldPort:
		return m.OldPort(ctx)
	case emailprofile.FieldUsername:
		return m.OldUsername(ctx)
	case emailprofile.FieldPassword:
		return m.OldPassword(ctx)
	case emailprofile.FieldIsDefault:
		return m.OldIsDefault(ctx)
	}
	return nil, fmt.Errorf("unknown EmailProfile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case emailprofile.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case emailprofile.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case emailprofile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case emailprofile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case emailprofile.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case emailprofile.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case emailprofile.FieldProtocol:
		v, ok := value.(emailprofile.Protocol)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProtocol(v)
		return nil
	case emailprofile.FieldHost:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHost(v)
		return nil
	case emailprofile.FieldPort:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPort(v)
		return nil
	case emailprofile.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case emailprofile.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case emailprofile.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	}
	return fmt.Errorf("unknown EmailProfile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmailProfileMutation) AddedFields() []string {
	var fields []string
	if m.addport != nil {
		fields = append(fields, emailprofile.FieldPort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmailProfileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case emailprofile.FieldPort:
		return m.AddedPort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case emailprofile.FieldPort:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPort(v)
		return nil
	}
	return fmt.Errorf("unknown EmailProfile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmailProfileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(emailprofile.FieldProtocol) {
		fields = append(fields, emailprofile.FieldProtocol)
	}
	if m.FieldCleared(emailprofile.FieldHost) {
		fields = append(fields, emailprofile.FieldHost)
	}
	if m.FieldCleared(emailprofile.FieldPort) {
		fields = append(fields, emailprofile.FieldPort)
	}
	if m.FieldCleared(emailprofile.FieldUsername) {
		fields = append(fields, emailprofile.FieldUsername)
	}
	if m.FieldCleared(emailprofile.FieldPassword) {
		fields = append(fields, emailprofile.FieldPassword)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmailProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmailProfileMutation) ClearField(name string) error {
	switch name {
	case emailprofile.FieldProtocol:
		m.ClearProtocol()
		return nil
	case emailprofile.FieldHost:
		m.ClearHost()
		return nil
	case emailprofile.FieldPort:
		m.ClearPort()
		return nil
	case emailprofile.FieldUsername:
		m.ClearUsername()
		return nil
	case emailprofile.FieldPassword:
		m.ClearPassword()
		return nil
	}
	return fmt.Errorf("unknown EmailProfile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmailProfileMutation) ResetField(name string) error {
	switch name {
	case emailprofile.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case emailprofile.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case emailprofile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case emailprofile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case emailprofile.FieldName:
		m.ResetName()
		return nil
	case emailprofile.FieldEmail:
		m.ResetEmail()
		return nil
	case emailprofile.FieldProtocol:
		m.ResetProtocol()
		return nil
	case emailprofile.FieldHost:
		m.ResetHost()
		return nil
	case emailprofile.FieldPort:
		m.ResetPort()
		return nil
	case emailprofile.FieldUsername:
		m.ResetUsername()
		return nil
	case emailprofile.FieldPassword:
		m.ResetPassword()
		return nil
	case emailprofile.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	}
	return fmt.Errorf("unknown EmailProfile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmailProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.business_unit != nil {
		edges = append(edges, emailprofile.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, emailprofile.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmailProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case emailprofile.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case emailprofile.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmailProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmailProfileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmailProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbusiness_unit {
		edges = append(edges, emailprofile.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, emailprofile.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmailProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case emailprofile.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case emailprofile.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmailProfileMutation) ClearEdge(name string) error {
	switch name {
	case emailprofile.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case emailprofile.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown EmailProfile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmailProfileMutation) ResetEdge(name string) error {
	switch name {
	case emailprofile.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case emailprofile.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown EmailProfile edge %s", name)
}

// EquipmentManufactuerMutation represents an operation that mutates the EquipmentManufactuer nodes in the graph.
type EquipmentManufactuerMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	status               *equipmentmanufactuer.Status
	name                 *string
	description          *string
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	done                 bool
	oldValue             func(context.Context) (*EquipmentManufactuer, error)
	predicates           []predicate.EquipmentManufactuer
}

var _ ent.Mutation = (*EquipmentManufactuerMutation)(nil)

// equipmentmanufactuerOption allows management of the mutation configuration using functional options.
type equipmentmanufactuerOption func(*EquipmentManufactuerMutation)

// newEquipmentManufactuerMutation creates new mutation for the EquipmentManufactuer entity.
func newEquipmentManufactuerMutation(c config, op Op, opts ...equipmentmanufactuerOption) *EquipmentManufactuerMutation {
	m := &EquipmentManufactuerMutation{
		config:        c,
		op:            op,
		typ:           TypeEquipmentManufactuer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEquipmentManufactuerID sets the ID field of the mutation.
func withEquipmentManufactuerID(id uuid.UUID) equipmentmanufactuerOption {
	return func(m *EquipmentManufactuerMutation) {
		var (
			err   error
			once  sync.Once
			value *EquipmentManufactuer
		)
		m.oldValue = func(ctx context.Context) (*EquipmentManufactuer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EquipmentManufactuer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEquipmentManufactuer sets the old EquipmentManufactuer of the mutation.
func withEquipmentManufactuer(node *EquipmentManufactuer) equipmentmanufactuerOption {
	return func(m *EquipmentManufactuerMutation) {
		m.oldValue = func(context.Context) (*EquipmentManufactuer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EquipmentManufactuerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EquipmentManufactuerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EquipmentManufactuer entities.
func (m *EquipmentManufactuerMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EquipmentManufactuerMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EquipmentManufactuerMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EquipmentManufactuer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *EquipmentManufactuerMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *EquipmentManufactuerMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the EquipmentManufactuer entity.
// If the EquipmentManufactuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentManufactuerMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *EquipmentManufactuerMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *EquipmentManufactuerMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *EquipmentManufactuerMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the EquipmentManufactuer entity.
// If the EquipmentManufactuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentManufactuerMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *EquipmentManufactuerMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EquipmentManufactuerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EquipmentManufactuerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EquipmentManufactuer entity.
// If the EquipmentManufactuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentManufactuerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EquipmentManufactuerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EquipmentManufactuerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EquipmentManufactuerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EquipmentManufactuer entity.
// If the EquipmentManufactuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentManufactuerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EquipmentManufactuerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *EquipmentManufactuerMutation) SetStatus(e equipmentmanufactuer.Status) {
	m.status = &e
}

// Status returns the value of the "status" field in the mutation.
func (m *EquipmentManufactuerMutation) Status() (r equipmentmanufactuer.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the EquipmentManufactuer entity.
// If the EquipmentManufactuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentManufactuerMutation) OldStatus(ctx context.Context) (v equipmentmanufactuer.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *EquipmentManufactuerMutation) ResetStatus() {
	m.status = nil
}

// SetName sets the "name" field.
func (m *EquipmentManufactuerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EquipmentManufactuerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the EquipmentManufactuer entity.
// If the EquipmentManufactuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentManufactuerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EquipmentManufactuerMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *EquipmentManufactuerMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EquipmentManufactuerMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the EquipmentManufactuer entity.
// If the EquipmentManufactuer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentManufactuerMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *EquipmentManufactuerMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[equipmentmanufactuer.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *EquipmentManufactuerMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[equipmentmanufactuer.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *EquipmentManufactuerMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, equipmentmanufactuer.FieldDescription)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *EquipmentManufactuerMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[equipmentmanufactuer.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *EquipmentManufactuerMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *EquipmentManufactuerMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *EquipmentManufactuerMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *EquipmentManufactuerMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[equipmentmanufactuer.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *EquipmentManufactuerMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *EquipmentManufactuerMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *EquipmentManufactuerMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the EquipmentManufactuerMutation builder.
func (m *EquipmentManufactuerMutation) Where(ps ...predicate.EquipmentManufactuer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EquipmentManufactuerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EquipmentManufactuerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EquipmentManufactuer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EquipmentManufactuerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EquipmentManufactuerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EquipmentManufactuer).
func (m *EquipmentManufactuerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EquipmentManufactuerMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.business_unit != nil {
		fields = append(fields, equipmentmanufactuer.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, equipmentmanufactuer.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, equipmentmanufactuer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, equipmentmanufactuer.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, equipmentmanufactuer.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, equipmentmanufactuer.FieldName)
	}
	if m.description != nil {
		fields = append(fields, equipmentmanufactuer.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EquipmentManufactuerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case equipmentmanufactuer.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case equipmentmanufactuer.FieldOrganizationID:
		return m.OrganizationID()
	case equipmentmanufactuer.FieldCreatedAt:
		return m.CreatedAt()
	case equipmentmanufactuer.FieldUpdatedAt:
		return m.UpdatedAt()
	case equipmentmanufactuer.FieldStatus:
		return m.Status()
	case equipmentmanufactuer.FieldName:
		return m.Name()
	case equipmentmanufactuer.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EquipmentManufactuerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case equipmentmanufactuer.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case equipmentmanufactuer.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case equipmentmanufactuer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case equipmentmanufactuer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case equipmentmanufactuer.FieldStatus:
		return m.OldStatus(ctx)
	case equipmentmanufactuer.FieldName:
		return m.OldName(ctx)
	case equipmentmanufactuer.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown EquipmentManufactuer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EquipmentManufactuerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case equipmentmanufactuer.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case equipmentmanufactuer.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case equipmentmanufactuer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case equipmentmanufactuer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case equipmentmanufactuer.FieldStatus:
		v, ok := value.(equipmentmanufactuer.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case equipmentmanufactuer.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case equipmentmanufactuer.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown EquipmentManufactuer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EquipmentManufactuerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EquipmentManufactuerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EquipmentManufactuerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EquipmentManufactuer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EquipmentManufactuerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(equipmentmanufactuer.FieldDescription) {
		fields = append(fields, equipmentmanufactuer.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EquipmentManufactuerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EquipmentManufactuerMutation) ClearField(name string) error {
	switch name {
	case equipmentmanufactuer.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown EquipmentManufactuer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EquipmentManufactuerMutation) ResetField(name string) error {
	switch name {
	case equipmentmanufactuer.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case equipmentmanufactuer.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case equipmentmanufactuer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case equipmentmanufactuer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case equipmentmanufactuer.FieldStatus:
		m.ResetStatus()
		return nil
	case equipmentmanufactuer.FieldName:
		m.ResetName()
		return nil
	case equipmentmanufactuer.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown EquipmentManufactuer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EquipmentManufactuerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.business_unit != nil {
		edges = append(edges, equipmentmanufactuer.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, equipmentmanufactuer.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EquipmentManufactuerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case equipmentmanufactuer.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case equipmentmanufactuer.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EquipmentManufactuerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EquipmentManufactuerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EquipmentManufactuerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbusiness_unit {
		edges = append(edges, equipmentmanufactuer.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, equipmentmanufactuer.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EquipmentManufactuerMutation) EdgeCleared(name string) bool {
	switch name {
	case equipmentmanufactuer.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case equipmentmanufactuer.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EquipmentManufactuerMutation) ClearEdge(name string) error {
	switch name {
	case equipmentmanufactuer.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case equipmentmanufactuer.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown EquipmentManufactuer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EquipmentManufactuerMutation) ResetEdge(name string) error {
	switch name {
	case equipmentmanufactuer.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case equipmentmanufactuer.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown EquipmentManufactuer edge %s", name)
}

// EquipmentTypeMutation represents an operation that mutates the EquipmentType nodes in the graph.
type EquipmentTypeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	status               *equipmenttype.Status
	name                 *string
	description          *string
	cost_per_mile        *float64
	addcost_per_mile     *float64
	equipment_class      *equipmenttype.EquipmentClass
	fixed_cost           *float64
	addfixed_cost        *float64
	variable_cost        *float64
	addvariable_cost     *float64
	height               *float64
	addheight            *float64
	length               *float64
	addlength            *float64
	width                *float64
	addwidth             *float64
	weight               *float64
	addweight            *float64
	idling_fuel_usage    *float64
	addidling_fuel_usage *float64
	exempt_from_tolls    *bool
	color                *string
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	done                 bool
	oldValue             func(context.Context) (*EquipmentType, error)
	predicates           []predicate.EquipmentType
}

var _ ent.Mutation = (*EquipmentTypeMutation)(nil)

// equipmenttypeOption allows management of the mutation configuration using functional options.
type equipmenttypeOption func(*EquipmentTypeMutation)

// newEquipmentTypeMutation creates new mutation for the EquipmentType entity.
func newEquipmentTypeMutation(c config, op Op, opts ...equipmenttypeOption) *EquipmentTypeMutation {
	m := &EquipmentTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeEquipmentType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEquipmentTypeID sets the ID field of the mutation.
func withEquipmentTypeID(id uuid.UUID) equipmenttypeOption {
	return func(m *EquipmentTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *EquipmentType
		)
		m.oldValue = func(ctx context.Context) (*EquipmentType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EquipmentType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEquipmentType sets the old EquipmentType of the mutation.
func withEquipmentType(node *EquipmentType) equipmenttypeOption {
	return func(m *EquipmentTypeMutation) {
		m.oldValue = func(context.Context) (*EquipmentType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EquipmentTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EquipmentTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EquipmentType entities.
func (m *EquipmentTypeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EquipmentTypeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EquipmentTypeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EquipmentType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *EquipmentTypeMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *EquipmentTypeMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the EquipmentType entity.
// If the EquipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentTypeMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *EquipmentTypeMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *EquipmentTypeMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *EquipmentTypeMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the EquipmentType entity.
// If the EquipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentTypeMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *EquipmentTypeMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EquipmentTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EquipmentTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EquipmentType entity.
// If the EquipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EquipmentTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EquipmentTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EquipmentTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EquipmentType entity.
// If the EquipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EquipmentTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *EquipmentTypeMutation) SetStatus(e equipmenttype.Status) {
	m.status = &e
}

// Status returns the value of the "status" field in the mutation.
func (m *EquipmentTypeMutation) Status() (r equipmenttype.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the EquipmentType entity.
// If the EquipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentTypeMutation) OldStatus(ctx context.Context) (v equipmenttype.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *EquipmentTypeMutation) ResetStatus() {
	m.status = nil
}

// SetName sets the "name" field.
func (m *EquipmentTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EquipmentTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the EquipmentType entity.
// If the EquipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EquipmentTypeMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *EquipmentTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EquipmentTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the EquipmentType entity.
// If the EquipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *EquipmentTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[equipmenttype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *EquipmentTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[equipmenttype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *EquipmentTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, equipmenttype.FieldDescription)
}

// SetCostPerMile sets the "cost_per_mile" field.
func (m *EquipmentTypeMutation) SetCostPerMile(f float64) {
	m.cost_per_mile = &f
	m.addcost_per_mile = nil
}

// CostPerMile returns the value of the "cost_per_mile" field in the mutation.
func (m *EquipmentTypeMutation) CostPerMile() (r float64, exists bool) {
	v := m.cost_per_mile
	if v == nil {
		return
	}
	return *v, true
}

// OldCostPerMile returns the old "cost_per_mile" field's value of the EquipmentType entity.
// If the EquipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentTypeMutation) OldCostPerMile(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCostPerMile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCostPerMile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCostPerMile: %w", err)
	}
	return oldValue.CostPerMile, nil
}

// AddCostPerMile adds f to the "cost_per_mile" field.
func (m *EquipmentTypeMutation) AddCostPerMile(f float64) {
	if m.addcost_per_mile != nil {
		*m.addcost_per_mile += f
	} else {
		m.addcost_per_mile = &f
	}
}

// AddedCostPerMile returns the value that was added to the "cost_per_mile" field in this mutation.
func (m *EquipmentTypeMutation) AddedCostPerMile() (r float64, exists bool) {
	v := m.addcost_per_mile
	if v == nil {
		return
	}
	return *v, true
}

// ClearCostPerMile clears the value of the "cost_per_mile" field.
func (m *EquipmentTypeMutation) ClearCostPerMile() {
	m.cost_per_mile = nil
	m.addcost_per_mile = nil
	m.clearedFields[equipmenttype.FieldCostPerMile] = struct{}{}
}

// CostPerMileCleared returns if the "cost_per_mile" field was cleared in this mutation.
func (m *EquipmentTypeMutation) CostPerMileCleared() bool {
	_, ok := m.clearedFields[equipmenttype.FieldCostPerMile]
	return ok
}

// ResetCostPerMile resets all changes to the "cost_per_mile" field.
func (m *EquipmentTypeMutation) ResetCostPerMile() {
	m.cost_per_mile = nil
	m.addcost_per_mile = nil
	delete(m.clearedFields, equipmenttype.FieldCostPerMile)
}

// SetEquipmentClass sets the "equipment_class" field.
func (m *EquipmentTypeMutation) SetEquipmentClass(ec equipmenttype.EquipmentClass) {
	m.equipment_class = &ec
}

// EquipmentClass returns the value of the "equipment_class" field in the mutation.
func (m *EquipmentTypeMutation) EquipmentClass() (r equipmenttype.EquipmentClass, exists bool) {
	v := m.equipment_class
	if v == nil {
		return
	}
	return *v, true
}

// OldEquipmentClass returns the old "equipment_class" field's value of the EquipmentType entity.
// If the EquipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentTypeMutation) OldEquipmentClass(ctx context.Context) (v equipmenttype.EquipmentClass, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEquipmentClass is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEquipmentClass requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEquipmentClass: %w", err)
	}
	return oldValue.EquipmentClass, nil
}

// ResetEquipmentClass resets all changes to the "equipment_class" field.
func (m *EquipmentTypeMutation) ResetEquipmentClass() {
	m.equipment_class = nil
}

// SetFixedCost sets the "fixed_cost" field.
func (m *EquipmentTypeMutation) SetFixedCost(f float64) {
	m.fixed_cost = &f
	m.addfixed_cost = nil
}

// FixedCost returns the value of the "fixed_cost" field in the mutation.
func (m *EquipmentTypeMutation) FixedCost() (r float64, exists bool) {
	v := m.fixed_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldFixedCost returns the old "fixed_cost" field's value of the EquipmentType entity.
// If the EquipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentTypeMutation) OldFixedCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFixedCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFixedCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFixedCost: %w", err)
	}
	return oldValue.FixedCost, nil
}

// AddFixedCost adds f to the "fixed_cost" field.
func (m *EquipmentTypeMutation) AddFixedCost(f float64) {
	if m.addfixed_cost != nil {
		*m.addfixed_cost += f
	} else {
		m.addfixed_cost = &f
	}
}

// AddedFixedCost returns the value that was added to the "fixed_cost" field in this mutation.
func (m *EquipmentTypeMutation) AddedFixedCost() (r float64, exists bool) {
	v := m.addfixed_cost
	if v == nil {
		return
	}
	return *v, true
}

// ClearFixedCost clears the value of the "fixed_cost" field.
func (m *EquipmentTypeMutation) ClearFixedCost() {
	m.fixed_cost = nil
	m.addfixed_cost = nil
	m.clearedFields[equipmenttype.FieldFixedCost] = struct{}{}
}

// FixedCostCleared returns if the "fixed_cost" field was cleared in this mutation.
func (m *EquipmentTypeMutation) FixedCostCleared() bool {
	_, ok := m.clearedFields[equipmenttype.FieldFixedCost]
	return ok
}

// ResetFixedCost resets all changes to the "fixed_cost" field.
func (m *EquipmentTypeMutation) ResetFixedCost() {
	m.fixed_cost = nil
	m.addfixed_cost = nil
	delete(m.clearedFields, equipmenttype.FieldFixedCost)
}

// SetVariableCost sets the "variable_cost" field.
func (m *EquipmentTypeMutation) SetVariableCost(f float64) {
	m.variable_cost = &f
	m.addvariable_cost = nil
}

// VariableCost returns the value of the "variable_cost" field in the mutation.
func (m *EquipmentTypeMutation) VariableCost() (r float64, exists bool) {
	v := m.variable_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldVariableCost returns the old "variable_cost" field's value of the EquipmentType entity.
// If the EquipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentTypeMutation) OldVariableCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVariableCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVariableCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVariableCost: %w", err)
	}
	return oldValue.VariableCost, nil
}

// AddVariableCost adds f to the "variable_cost" field.
func (m *EquipmentTypeMutation) AddVariableCost(f float64) {
	if m.addvariable_cost != nil {
		*m.addvariable_cost += f
	} else {
		m.addvariable_cost = &f
	}
}

// AddedVariableCost returns the value that was added to the "variable_cost" field in this mutation.
func (m *EquipmentTypeMutation) AddedVariableCost() (r float64, exists bool) {
	v := m.addvariable_cost
	if v == nil {
		return
	}
	return *v, true
}

// ClearVariableCost clears the value of the "variable_cost" field.
func (m *EquipmentTypeMutation) ClearVariableCost() {
	m.variable_cost = nil
	m.addvariable_cost = nil
	m.clearedFields[equipmenttype.FieldVariableCost] = struct{}{}
}

// VariableCostCleared returns if the "variable_cost" field was cleared in this mutation.
func (m *EquipmentTypeMutation) VariableCostCleared() bool {
	_, ok := m.clearedFields[equipmenttype.FieldVariableCost]
	return ok
}

// ResetVariableCost resets all changes to the "variable_cost" field.
func (m *EquipmentTypeMutation) ResetVariableCost() {
	m.variable_cost = nil
	m.addvariable_cost = nil
	delete(m.clearedFields, equipmenttype.FieldVariableCost)
}

// SetHeight sets the "height" field.
func (m *EquipmentTypeMutation) SetHeight(f float64) {
	m.height = &f
	m.addheight = nil
}

// Height returns the value of the "height" field in the mutation.
func (m *EquipmentTypeMutation) Height() (r float64, exists bool) {
	v := m.height
	if v == nil {
		return
	}
	return *v, true
}

// OldHeight returns the old "height" field's value of the EquipmentType entity.
// If the EquipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentTypeMutation) OldHeight(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeight: %w", err)
	}
	return oldValue.Height, nil
}

// AddHeight adds f to the "height" field.
func (m *EquipmentTypeMutation) AddHeight(f float64) {
	if m.addheight != nil {
		*m.addheight += f
	} else {
		m.addheight = &f
	}
}

// AddedHeight returns the value that was added to the "height" field in this mutation.
func (m *EquipmentTypeMutation) AddedHeight() (r float64, exists bool) {
	v := m.addheight
	if v == nil {
		return
	}
	return *v, true
}

// ClearHeight clears the value of the "height" field.
func (m *EquipmentTypeMutation) ClearHeight() {
	m.height = nil
	m.addheight = nil
	m.clearedFields[equipmenttype.FieldHeight] = struct{}{}
}

// HeightCleared returns if the "height" field was cleared in this mutation.
func (m *EquipmentTypeMutation) HeightCleared() bool {
	_, ok := m.clearedFields[equipmenttype.FieldHeight]
	return ok
}

// ResetHeight resets all changes to the "height" field.
func (m *EquipmentTypeMutation) ResetHeight() {
	m.height = nil
	m.addheight = nil
	delete(m.clearedFields, equipmenttype.FieldHeight)
}

// SetLength sets the "length" field.
func (m *EquipmentTypeMutation) SetLength(f float64) {
	m.length = &f
	m.addlength = nil
}

// Length returns the value of the "length" field in the mutation.
func (m *EquipmentTypeMutation) Length() (r float64, exists bool) {
	v := m.length
	if v == nil {
		return
	}
	return *v, true
}

// OldLength returns the old "length" field's value of the EquipmentType entity.
// If the EquipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentTypeMutation) OldLength(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLength is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLength requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLength: %w", err)
	}
	return oldValue.Length, nil
}

// AddLength adds f to the "length" field.
func (m *EquipmentTypeMutation) AddLength(f float64) {
	if m.addlength != nil {
		*m.addlength += f
	} else {
		m.addlength = &f
	}
}

// AddedLength returns the value that was added to the "length" field in this mutation.
func (m *EquipmentTypeMutation) AddedLength() (r float64, exists bool) {
	v := m.addlength
	if v == nil {
		return
	}
	return *v, true
}

// ClearLength clears the value of the "length" field.
func (m *EquipmentTypeMutation) ClearLength() {
	m.length = nil
	m.addlength = nil
	m.clearedFields[equipmenttype.FieldLength] = struct{}{}
}

// LengthCleared returns if the "length" field was cleared in this mutation.
func (m *EquipmentTypeMutation) LengthCleared() bool {
	_, ok := m.clearedFields[equipmenttype.FieldLength]
	return ok
}

// ResetLength resets all changes to the "length" field.
func (m *EquipmentTypeMutation) ResetLength() {
	m.length = nil
	m.addlength = nil
	delete(m.clearedFields, equipmenttype.FieldLength)
}

// SetWidth sets the "width" field.
func (m *EquipmentTypeMutation) SetWidth(f float64) {
	m.width = &f
	m.addwidth = nil
}

// Width returns the value of the "width" field in the mutation.
func (m *EquipmentTypeMutation) Width() (r float64, exists bool) {
	v := m.width
	if v == nil {
		return
	}
	return *v, true
}

// OldWidth returns the old "width" field's value of the EquipmentType entity.
// If the EquipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentTypeMutation) OldWidth(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWidth: %w", err)
	}
	return oldValue.Width, nil
}

// AddWidth adds f to the "width" field.
func (m *EquipmentTypeMutation) AddWidth(f float64) {
	if m.addwidth != nil {
		*m.addwidth += f
	} else {
		m.addwidth = &f
	}
}

// AddedWidth returns the value that was added to the "width" field in this mutation.
func (m *EquipmentTypeMutation) AddedWidth() (r float64, exists bool) {
	v := m.addwidth
	if v == nil {
		return
	}
	return *v, true
}

// ClearWidth clears the value of the "width" field.
func (m *EquipmentTypeMutation) ClearWidth() {
	m.width = nil
	m.addwidth = nil
	m.clearedFields[equipmenttype.FieldWidth] = struct{}{}
}

// WidthCleared returns if the "width" field was cleared in this mutation.
func (m *EquipmentTypeMutation) WidthCleared() bool {
	_, ok := m.clearedFields[equipmenttype.FieldWidth]
	return ok
}

// ResetWidth resets all changes to the "width" field.
func (m *EquipmentTypeMutation) ResetWidth() {
	m.width = nil
	m.addwidth = nil
	delete(m.clearedFields, equipmenttype.FieldWidth)
}

// SetWeight sets the "weight" field.
func (m *EquipmentTypeMutation) SetWeight(f float64) {
	m.weight = &f
	m.addweight = nil
}

// Weight returns the value of the "weight" field in the mutation.
func (m *EquipmentTypeMutation) Weight() (r float64, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old "weight" field's value of the EquipmentType entity.
// If the EquipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentTypeMutation) OldWeight(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds f to the "weight" field.
func (m *EquipmentTypeMutation) AddWeight(f float64) {
	if m.addweight != nil {
		*m.addweight += f
	} else {
		m.addweight = &f
	}
}

// AddedWeight returns the value that was added to the "weight" field in this mutation.
func (m *EquipmentTypeMutation) AddedWeight() (r float64, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ClearWeight clears the value of the "weight" field.
func (m *EquipmentTypeMutation) ClearWeight() {
	m.weight = nil
	m.addweight = nil
	m.clearedFields[equipmenttype.FieldWeight] = struct{}{}
}

// WeightCleared returns if the "weight" field was cleared in this mutation.
func (m *EquipmentTypeMutation) WeightCleared() bool {
	_, ok := m.clearedFields[equipmenttype.FieldWeight]
	return ok
}

// ResetWeight resets all changes to the "weight" field.
func (m *EquipmentTypeMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
	delete(m.clearedFields, equipmenttype.FieldWeight)
}

// SetIdlingFuelUsage sets the "idling_fuel_usage" field.
func (m *EquipmentTypeMutation) SetIdlingFuelUsage(f float64) {
	m.idling_fuel_usage = &f
	m.addidling_fuel_usage = nil
}

// IdlingFuelUsage returns the value of the "idling_fuel_usage" field in the mutation.
func (m *EquipmentTypeMutation) IdlingFuelUsage() (r float64, exists bool) {
	v := m.idling_fuel_usage
	if v == nil {
		return
	}
	return *v, true
}

// OldIdlingFuelUsage returns the old "idling_fuel_usage" field's value of the EquipmentType entity.
// If the EquipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentTypeMutation) OldIdlingFuelUsage(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdlingFuelUsage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdlingFuelUsage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdlingFuelUsage: %w", err)
	}
	return oldValue.IdlingFuelUsage, nil
}

// AddIdlingFuelUsage adds f to the "idling_fuel_usage" field.
func (m *EquipmentTypeMutation) AddIdlingFuelUsage(f float64) {
	if m.addidling_fuel_usage != nil {
		*m.addidling_fuel_usage += f
	} else {
		m.addidling_fuel_usage = &f
	}
}

// AddedIdlingFuelUsage returns the value that was added to the "idling_fuel_usage" field in this mutation.
func (m *EquipmentTypeMutation) AddedIdlingFuelUsage() (r float64, exists bool) {
	v := m.addidling_fuel_usage
	if v == nil {
		return
	}
	return *v, true
}

// ClearIdlingFuelUsage clears the value of the "idling_fuel_usage" field.
func (m *EquipmentTypeMutation) ClearIdlingFuelUsage() {
	m.idling_fuel_usage = nil
	m.addidling_fuel_usage = nil
	m.clearedFields[equipmenttype.FieldIdlingFuelUsage] = struct{}{}
}

// IdlingFuelUsageCleared returns if the "idling_fuel_usage" field was cleared in this mutation.
func (m *EquipmentTypeMutation) IdlingFuelUsageCleared() bool {
	_, ok := m.clearedFields[equipmenttype.FieldIdlingFuelUsage]
	return ok
}

// ResetIdlingFuelUsage resets all changes to the "idling_fuel_usage" field.
func (m *EquipmentTypeMutation) ResetIdlingFuelUsage() {
	m.idling_fuel_usage = nil
	m.addidling_fuel_usage = nil
	delete(m.clearedFields, equipmenttype.FieldIdlingFuelUsage)
}

// SetExemptFromTolls sets the "exempt_from_tolls" field.
func (m *EquipmentTypeMutation) SetExemptFromTolls(b bool) {
	m.exempt_from_tolls = &b
}

// ExemptFromTolls returns the value of the "exempt_from_tolls" field in the mutation.
func (m *EquipmentTypeMutation) ExemptFromTolls() (r bool, exists bool) {
	v := m.exempt_from_tolls
	if v == nil {
		return
	}
	return *v, true
}

// OldExemptFromTolls returns the old "exempt_from_tolls" field's value of the EquipmentType entity.
// If the EquipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentTypeMutation) OldExemptFromTolls(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExemptFromTolls is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExemptFromTolls requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExemptFromTolls: %w", err)
	}
	return oldValue.ExemptFromTolls, nil
}

// ResetExemptFromTolls resets all changes to the "exempt_from_tolls" field.
func (m *EquipmentTypeMutation) ResetExemptFromTolls() {
	m.exempt_from_tolls = nil
}

// SetColor sets the "color" field.
func (m *EquipmentTypeMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *EquipmentTypeMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the EquipmentType entity.
// If the EquipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EquipmentTypeMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *EquipmentTypeMutation) ClearColor() {
	m.color = nil
	m.clearedFields[equipmenttype.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *EquipmentTypeMutation) ColorCleared() bool {
	_, ok := m.clearedFields[equipmenttype.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *EquipmentTypeMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, equipmenttype.FieldColor)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *EquipmentTypeMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[equipmenttype.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *EquipmentTypeMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *EquipmentTypeMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *EquipmentTypeMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *EquipmentTypeMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[equipmenttype.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *EquipmentTypeMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *EquipmentTypeMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *EquipmentTypeMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the EquipmentTypeMutation builder.
func (m *EquipmentTypeMutation) Where(ps ...predicate.EquipmentType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EquipmentTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EquipmentTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EquipmentType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EquipmentTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EquipmentTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EquipmentType).
func (m *EquipmentTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EquipmentTypeMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.business_unit != nil {
		fields = append(fields, equipmenttype.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, equipmenttype.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, equipmenttype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, equipmenttype.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, equipmenttype.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, equipmenttype.FieldName)
	}
	if m.description != nil {
		fields = append(fields, equipmenttype.FieldDescription)
	}
	if m.cost_per_mile != nil {
		fields = append(fields, equipmenttype.FieldCostPerMile)
	}
	if m.equipment_class != nil {
		fields = append(fields, equipmenttype.FieldEquipmentClass)
	}
	if m.fixed_cost != nil {
		fields = append(fields, equipmenttype.FieldFixedCost)
	}
	if m.variable_cost != nil {
		fields = append(fields, equipmenttype.FieldVariableCost)
	}
	if m.height != nil {
		fields = append(fields, equipmenttype.FieldHeight)
	}
	if m.length != nil {
		fields = append(fields, equipmenttype.FieldLength)
	}
	if m.width != nil {
		fields = append(fields, equipmenttype.FieldWidth)
	}
	if m.weight != nil {
		fields = append(fields, equipmenttype.FieldWeight)
	}
	if m.idling_fuel_usage != nil {
		fields = append(fields, equipmenttype.FieldIdlingFuelUsage)
	}
	if m.exempt_from_tolls != nil {
		fields = append(fields, equipmenttype.FieldExemptFromTolls)
	}
	if m.color != nil {
		fields = append(fields, equipmenttype.FieldColor)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EquipmentTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case equipmenttype.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case equipmenttype.FieldOrganizationID:
		return m.OrganizationID()
	case equipmenttype.FieldCreatedAt:
		return m.CreatedAt()
	case equipmenttype.FieldUpdatedAt:
		return m.UpdatedAt()
	case equipmenttype.FieldStatus:
		return m.Status()
	case equipmenttype.FieldName:
		return m.Name()
	case equipmenttype.FieldDescription:
		return m.Description()
	case equipmenttype.FieldCostPerMile:
		return m.CostPerMile()
	case equipmenttype.FieldEquipmentClass:
		return m.EquipmentClass()
	case equipmenttype.FieldFixedCost:
		return m.FixedCost()
	case equipmenttype.FieldVariableCost:
		return m.VariableCost()
	case equipmenttype.FieldHeight:
		return m.Height()
	case equipmenttype.FieldLength:
		return m.Length()
	case equipmenttype.FieldWidth:
		return m.Width()
	case equipmenttype.FieldWeight:
		return m.Weight()
	case equipmenttype.FieldIdlingFuelUsage:
		return m.IdlingFuelUsage()
	case equipmenttype.FieldExemptFromTolls:
		return m.ExemptFromTolls()
	case equipmenttype.FieldColor:
		return m.Color()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EquipmentTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case equipmenttype.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case equipmenttype.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case equipmenttype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case equipmenttype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case equipmenttype.FieldStatus:
		return m.OldStatus(ctx)
	case equipmenttype.FieldName:
		return m.OldName(ctx)
	case equipmenttype.FieldDescription:
		return m.OldDescription(ctx)
	case equipmenttype.FieldCostPerMile:
		return m.OldCostPerMile(ctx)
	case equipmenttype.FieldEquipmentClass:
		return m.OldEquipmentClass(ctx)
	case equipmenttype.FieldFixedCost:
		return m.OldFixedCost(ctx)
	case equipmenttype.FieldVariableCost:
		return m.OldVariableCost(ctx)
	case equipmenttype.FieldHeight:
		return m.OldHeight(ctx)
	case equipmenttype.FieldLength:
		return m.OldLength(ctx)
	case equipmenttype.FieldWidth:
		return m.OldWidth(ctx)
	case equipmenttype.FieldWeight:
		return m.OldWeight(ctx)
	case equipmenttype.FieldIdlingFuelUsage:
		return m.OldIdlingFuelUsage(ctx)
	case equipmenttype.FieldExemptFromTolls:
		return m.OldExemptFromTolls(ctx)
	case equipmenttype.FieldColor:
		return m.OldColor(ctx)
	}
	return nil, fmt.Errorf("unknown EquipmentType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EquipmentTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case equipmenttype.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case equipmenttype.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case equipmenttype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case equipmenttype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case equipmenttype.FieldStatus:
		v, ok := value.(equipmenttype.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case equipmenttype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case equipmenttype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case equipmenttype.FieldCostPerMile:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCostPerMile(v)
		return nil
	case equipmenttype.FieldEquipmentClass:
		v, ok := value.(equipmenttype.EquipmentClass)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEquipmentClass(v)
		return nil
	case equipmenttype.FieldFixedCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFixedCost(v)
		return nil
	case equipmenttype.FieldVariableCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVariableCost(v)
		return nil
	case equipmenttype.FieldHeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeight(v)
		return nil
	case equipmenttype.FieldLength:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLength(v)
		return nil
	case equipmenttype.FieldWidth:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWidth(v)
		return nil
	case equipmenttype.FieldWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case equipmenttype.FieldIdlingFuelUsage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdlingFuelUsage(v)
		return nil
	case equipmenttype.FieldExemptFromTolls:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExemptFromTolls(v)
		return nil
	case equipmenttype.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	}
	return fmt.Errorf("unknown EquipmentType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EquipmentTypeMutation) AddedFields() []string {
	var fields []string
	if m.addcost_per_mile != nil {
		fields = append(fields, equipmenttype.FieldCostPerMile)
	}
	if m.addfixed_cost != nil {
		fields = append(fields, equipmenttype.FieldFixedCost)
	}
	if m.addvariable_cost != nil {
		fields = append(fields, equipmenttype.FieldVariableCost)
	}
	if m.addheight != nil {
		fields = append(fields, equipmenttype.FieldHeight)
	}
	if m.addlength != nil {
		fields = append(fields, equipmenttype.FieldLength)
	}
	if m.addwidth != nil {
		fields = append(fields, equipmenttype.FieldWidth)
	}
	if m.addweight != nil {
		fields = append(fields, equipmenttype.FieldWeight)
	}
	if m.addidling_fuel_usage != nil {
		fields = append(fields, equipmenttype.FieldIdlingFuelUsage)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EquipmentTypeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case equipmenttype.FieldCostPerMile:
		return m.AddedCostPerMile()
	case equipmenttype.FieldFixedCost:
		return m.AddedFixedCost()
	case equipmenttype.FieldVariableCost:
		return m.AddedVariableCost()
	case equipmenttype.FieldHeight:
		return m.AddedHeight()
	case equipmenttype.FieldLength:
		return m.AddedLength()
	case equipmenttype.FieldWidth:
		return m.AddedWidth()
	case equipmenttype.FieldWeight:
		return m.AddedWeight()
	case equipmenttype.FieldIdlingFuelUsage:
		return m.AddedIdlingFuelUsage()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EquipmentTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case equipmenttype.FieldCostPerMile:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCostPerMile(v)
		return nil
	case equipmenttype.FieldFixedCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFixedCost(v)
		return nil
	case equipmenttype.FieldVariableCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVariableCost(v)
		return nil
	case equipmenttype.FieldHeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeight(v)
		return nil
	case equipmenttype.FieldLength:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLength(v)
		return nil
	case equipmenttype.FieldWidth:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWidth(v)
		return nil
	case equipmenttype.FieldWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	case equipmenttype.FieldIdlingFuelUsage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIdlingFuelUsage(v)
		return nil
	}
	return fmt.Errorf("unknown EquipmentType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EquipmentTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(equipmenttype.FieldDescription) {
		fields = append(fields, equipmenttype.FieldDescription)
	}
	if m.FieldCleared(equipmenttype.FieldCostPerMile) {
		fields = append(fields, equipmenttype.FieldCostPerMile)
	}
	if m.FieldCleared(equipmenttype.FieldFixedCost) {
		fields = append(fields, equipmenttype.FieldFixedCost)
	}
	if m.FieldCleared(equipmenttype.FieldVariableCost) {
		fields = append(fields, equipmenttype.FieldVariableCost)
	}
	if m.FieldCleared(equipmenttype.FieldHeight) {
		fields = append(fields, equipmenttype.FieldHeight)
	}
	if m.FieldCleared(equipmenttype.FieldLength) {
		fields = append(fields, equipmenttype.FieldLength)
	}
	if m.FieldCleared(equipmenttype.FieldWidth) {
		fields = append(fields, equipmenttype.FieldWidth)
	}
	if m.FieldCleared(equipmenttype.FieldWeight) {
		fields = append(fields, equipmenttype.FieldWeight)
	}
	if m.FieldCleared(equipmenttype.FieldIdlingFuelUsage) {
		fields = append(fields, equipmenttype.FieldIdlingFuelUsage)
	}
	if m.FieldCleared(equipmenttype.FieldColor) {
		fields = append(fields, equipmenttype.FieldColor)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EquipmentTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EquipmentTypeMutation) ClearField(name string) error {
	switch name {
	case equipmenttype.FieldDescription:
		m.ClearDescription()
		return nil
	case equipmenttype.FieldCostPerMile:
		m.ClearCostPerMile()
		return nil
	case equipmenttype.FieldFixedCost:
		m.ClearFixedCost()
		return nil
	case equipmenttype.FieldVariableCost:
		m.ClearVariableCost()
		return nil
	case equipmenttype.FieldHeight:
		m.ClearHeight()
		return nil
	case equipmenttype.FieldLength:
		m.ClearLength()
		return nil
	case equipmenttype.FieldWidth:
		m.ClearWidth()
		return nil
	case equipmenttype.FieldWeight:
		m.ClearWeight()
		return nil
	case equipmenttype.FieldIdlingFuelUsage:
		m.ClearIdlingFuelUsage()
		return nil
	case equipmenttype.FieldColor:
		m.ClearColor()
		return nil
	}
	return fmt.Errorf("unknown EquipmentType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EquipmentTypeMutation) ResetField(name string) error {
	switch name {
	case equipmenttype.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case equipmenttype.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case equipmenttype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case equipmenttype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case equipmenttype.FieldStatus:
		m.ResetStatus()
		return nil
	case equipmenttype.FieldName:
		m.ResetName()
		return nil
	case equipmenttype.FieldDescription:
		m.ResetDescription()
		return nil
	case equipmenttype.FieldCostPerMile:
		m.ResetCostPerMile()
		return nil
	case equipmenttype.FieldEquipmentClass:
		m.ResetEquipmentClass()
		return nil
	case equipmenttype.FieldFixedCost:
		m.ResetFixedCost()
		return nil
	case equipmenttype.FieldVariableCost:
		m.ResetVariableCost()
		return nil
	case equipmenttype.FieldHeight:
		m.ResetHeight()
		return nil
	case equipmenttype.FieldLength:
		m.ResetLength()
		return nil
	case equipmenttype.FieldWidth:
		m.ResetWidth()
		return nil
	case equipmenttype.FieldWeight:
		m.ResetWeight()
		return nil
	case equipmenttype.FieldIdlingFuelUsage:
		m.ResetIdlingFuelUsage()
		return nil
	case equipmenttype.FieldExemptFromTolls:
		m.ResetExemptFromTolls()
		return nil
	case equipmenttype.FieldColor:
		m.ResetColor()
		return nil
	}
	return fmt.Errorf("unknown EquipmentType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EquipmentTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.business_unit != nil {
		edges = append(edges, equipmenttype.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, equipmenttype.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EquipmentTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case equipmenttype.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case equipmenttype.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EquipmentTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EquipmentTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EquipmentTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbusiness_unit {
		edges = append(edges, equipmenttype.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, equipmenttype.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EquipmentTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case equipmenttype.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case equipmenttype.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EquipmentTypeMutation) ClearEdge(name string) error {
	switch name {
	case equipmenttype.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case equipmenttype.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown EquipmentType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EquipmentTypeMutation) ResetEdge(name string) error {
	switch name {
	case equipmenttype.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case equipmenttype.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown EquipmentType edge %s", name)
}

// FeasibilityToolControlMutation represents an operation that mutates the FeasibilityToolControl nodes in the graph.
type FeasibilityToolControlMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	otp_operator         *feasibilitytoolcontrol.OtpOperator
	otp_value            *float64
	addotp_value         *float64
	mpw_operator         *feasibilitytoolcontrol.MpwOperator
	mpw_value            *float64
	addmpw_value         *float64
	mpd_operator         *feasibilitytoolcontrol.MpdOperator
	mpd_value            *float64
	addmpd_value         *float64
	mpg_operator         *feasibilitytoolcontrol.MpgOperator
	mpg_value            *float64
	addmpg_value         *float64
	clearedFields        map[string]struct{}
	organization         *uuid.UUID
	clearedorganization  bool
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	done                 bool
	oldValue             func(context.Context) (*FeasibilityToolControl, error)
	predicates           []predicate.FeasibilityToolControl
}

var _ ent.Mutation = (*FeasibilityToolControlMutation)(nil)

// feasibilitytoolcontrolOption allows management of the mutation configuration using functional options.
type feasibilitytoolcontrolOption func(*FeasibilityToolControlMutation)

// newFeasibilityToolControlMutation creates new mutation for the FeasibilityToolControl entity.
func newFeasibilityToolControlMutation(c config, op Op, opts ...feasibilitytoolcontrolOption) *FeasibilityToolControlMutation {
	m := &FeasibilityToolControlMutation{
		config:        c,
		op:            op,
		typ:           TypeFeasibilityToolControl,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeasibilityToolControlID sets the ID field of the mutation.
func withFeasibilityToolControlID(id uuid.UUID) feasibilitytoolcontrolOption {
	return func(m *FeasibilityToolControlMutation) {
		var (
			err   error
			once  sync.Once
			value *FeasibilityToolControl
		)
		m.oldValue = func(ctx context.Context) (*FeasibilityToolControl, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FeasibilityToolControl.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeasibilityToolControl sets the old FeasibilityToolControl of the mutation.
func withFeasibilityToolControl(node *FeasibilityToolControl) feasibilitytoolcontrolOption {
	return func(m *FeasibilityToolControlMutation) {
		m.oldValue = func(context.Context) (*FeasibilityToolControl, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeasibilityToolControlMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeasibilityToolControlMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FeasibilityToolControl entities.
func (m *FeasibilityToolControlMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeasibilityToolControlMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeasibilityToolControlMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FeasibilityToolControl.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FeasibilityToolControlMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FeasibilityToolControlMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FeasibilityToolControl entity.
// If the FeasibilityToolControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeasibilityToolControlMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FeasibilityToolControlMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FeasibilityToolControlMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FeasibilityToolControlMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FeasibilityToolControl entity.
// If the FeasibilityToolControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeasibilityToolControlMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FeasibilityToolControlMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOtpOperator sets the "otp_operator" field.
func (m *FeasibilityToolControlMutation) SetOtpOperator(fo feasibilitytoolcontrol.OtpOperator) {
	m.otp_operator = &fo
}

// OtpOperator returns the value of the "otp_operator" field in the mutation.
func (m *FeasibilityToolControlMutation) OtpOperator() (r feasibilitytoolcontrol.OtpOperator, exists bool) {
	v := m.otp_operator
	if v == nil {
		return
	}
	return *v, true
}

// OldOtpOperator returns the old "otp_operator" field's value of the FeasibilityToolControl entity.
// If the FeasibilityToolControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeasibilityToolControlMutation) OldOtpOperator(ctx context.Context) (v feasibilitytoolcontrol.OtpOperator, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtpOperator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtpOperator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtpOperator: %w", err)
	}
	return oldValue.OtpOperator, nil
}

// ResetOtpOperator resets all changes to the "otp_operator" field.
func (m *FeasibilityToolControlMutation) ResetOtpOperator() {
	m.otp_operator = nil
}

// SetOtpValue sets the "otp_value" field.
func (m *FeasibilityToolControlMutation) SetOtpValue(f float64) {
	m.otp_value = &f
	m.addotp_value = nil
}

// OtpValue returns the value of the "otp_value" field in the mutation.
func (m *FeasibilityToolControlMutation) OtpValue() (r float64, exists bool) {
	v := m.otp_value
	if v == nil {
		return
	}
	return *v, true
}

// OldOtpValue returns the old "otp_value" field's value of the FeasibilityToolControl entity.
// If the FeasibilityToolControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeasibilityToolControlMutation) OldOtpValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtpValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtpValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtpValue: %w", err)
	}
	return oldValue.OtpValue, nil
}

// AddOtpValue adds f to the "otp_value" field.
func (m *FeasibilityToolControlMutation) AddOtpValue(f float64) {
	if m.addotp_value != nil {
		*m.addotp_value += f
	} else {
		m.addotp_value = &f
	}
}

// AddedOtpValue returns the value that was added to the "otp_value" field in this mutation.
func (m *FeasibilityToolControlMutation) AddedOtpValue() (r float64, exists bool) {
	v := m.addotp_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetOtpValue resets all changes to the "otp_value" field.
func (m *FeasibilityToolControlMutation) ResetOtpValue() {
	m.otp_value = nil
	m.addotp_value = nil
}

// SetMpwOperator sets the "mpw_operator" field.
func (m *FeasibilityToolControlMutation) SetMpwOperator(fo feasibilitytoolcontrol.MpwOperator) {
	m.mpw_operator = &fo
}

// MpwOperator returns the value of the "mpw_operator" field in the mutation.
func (m *FeasibilityToolControlMutation) MpwOperator() (r feasibilitytoolcontrol.MpwOperator, exists bool) {
	v := m.mpw_operator
	if v == nil {
		return
	}
	return *v, true
}

// OldMpwOperator returns the old "mpw_operator" field's value of the FeasibilityToolControl entity.
// If the FeasibilityToolControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeasibilityToolControlMutation) OldMpwOperator(ctx context.Context) (v feasibilitytoolcontrol.MpwOperator, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMpwOperator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMpwOperator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMpwOperator: %w", err)
	}
	return oldValue.MpwOperator, nil
}

// ResetMpwOperator resets all changes to the "mpw_operator" field.
func (m *FeasibilityToolControlMutation) ResetMpwOperator() {
	m.mpw_operator = nil
}

// SetMpwValue sets the "mpw_value" field.
func (m *FeasibilityToolControlMutation) SetMpwValue(f float64) {
	m.mpw_value = &f
	m.addmpw_value = nil
}

// MpwValue returns the value of the "mpw_value" field in the mutation.
func (m *FeasibilityToolControlMutation) MpwValue() (r float64, exists bool) {
	v := m.mpw_value
	if v == nil {
		return
	}
	return *v, true
}

// OldMpwValue returns the old "mpw_value" field's value of the FeasibilityToolControl entity.
// If the FeasibilityToolControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeasibilityToolControlMutation) OldMpwValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMpwValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMpwValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMpwValue: %w", err)
	}
	return oldValue.MpwValue, nil
}

// AddMpwValue adds f to the "mpw_value" field.
func (m *FeasibilityToolControlMutation) AddMpwValue(f float64) {
	if m.addmpw_value != nil {
		*m.addmpw_value += f
	} else {
		m.addmpw_value = &f
	}
}

// AddedMpwValue returns the value that was added to the "mpw_value" field in this mutation.
func (m *FeasibilityToolControlMutation) AddedMpwValue() (r float64, exists bool) {
	v := m.addmpw_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetMpwValue resets all changes to the "mpw_value" field.
func (m *FeasibilityToolControlMutation) ResetMpwValue() {
	m.mpw_value = nil
	m.addmpw_value = nil
}

// SetMpdOperator sets the "mpd_operator" field.
func (m *FeasibilityToolControlMutation) SetMpdOperator(fo feasibilitytoolcontrol.MpdOperator) {
	m.mpd_operator = &fo
}

// MpdOperator returns the value of the "mpd_operator" field in the mutation.
func (m *FeasibilityToolControlMutation) MpdOperator() (r feasibilitytoolcontrol.MpdOperator, exists bool) {
	v := m.mpd_operator
	if v == nil {
		return
	}
	return *v, true
}

// OldMpdOperator returns the old "mpd_operator" field's value of the FeasibilityToolControl entity.
// If the FeasibilityToolControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeasibilityToolControlMutation) OldMpdOperator(ctx context.Context) (v feasibilitytoolcontrol.MpdOperator, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMpdOperator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMpdOperator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMpdOperator: %w", err)
	}
	return oldValue.MpdOperator, nil
}

// ResetMpdOperator resets all changes to the "mpd_operator" field.
func (m *FeasibilityToolControlMutation) ResetMpdOperator() {
	m.mpd_operator = nil
}

// SetMpdValue sets the "mpd_value" field.
func (m *FeasibilityToolControlMutation) SetMpdValue(f float64) {
	m.mpd_value = &f
	m.addmpd_value = nil
}

// MpdValue returns the value of the "mpd_value" field in the mutation.
func (m *FeasibilityToolControlMutation) MpdValue() (r float64, exists bool) {
	v := m.mpd_value
	if v == nil {
		return
	}
	return *v, true
}

// OldMpdValue returns the old "mpd_value" field's value of the FeasibilityToolControl entity.
// If the FeasibilityToolControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeasibilityToolControlMutation) OldMpdValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMpdValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMpdValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMpdValue: %w", err)
	}
	return oldValue.MpdValue, nil
}

// AddMpdValue adds f to the "mpd_value" field.
func (m *FeasibilityToolControlMutation) AddMpdValue(f float64) {
	if m.addmpd_value != nil {
		*m.addmpd_value += f
	} else {
		m.addmpd_value = &f
	}
}

// AddedMpdValue returns the value that was added to the "mpd_value" field in this mutation.
func (m *FeasibilityToolControlMutation) AddedMpdValue() (r float64, exists bool) {
	v := m.addmpd_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetMpdValue resets all changes to the "mpd_value" field.
func (m *FeasibilityToolControlMutation) ResetMpdValue() {
	m.mpd_value = nil
	m.addmpd_value = nil
}

// SetMpgOperator sets the "mpg_operator" field.
func (m *FeasibilityToolControlMutation) SetMpgOperator(fo feasibilitytoolcontrol.MpgOperator) {
	m.mpg_operator = &fo
}

// MpgOperator returns the value of the "mpg_operator" field in the mutation.
func (m *FeasibilityToolControlMutation) MpgOperator() (r feasibilitytoolcontrol.MpgOperator, exists bool) {
	v := m.mpg_operator
	if v == nil {
		return
	}
	return *v, true
}

// OldMpgOperator returns the old "mpg_operator" field's value of the FeasibilityToolControl entity.
// If the FeasibilityToolControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeasibilityToolControlMutation) OldMpgOperator(ctx context.Context) (v feasibilitytoolcontrol.MpgOperator, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMpgOperator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMpgOperator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMpgOperator: %w", err)
	}
	return oldValue.MpgOperator, nil
}

// ResetMpgOperator resets all changes to the "mpg_operator" field.
func (m *FeasibilityToolControlMutation) ResetMpgOperator() {
	m.mpg_operator = nil
}

// SetMpgValue sets the "mpg_value" field.
func (m *FeasibilityToolControlMutation) SetMpgValue(f float64) {
	m.mpg_value = &f
	m.addmpg_value = nil
}

// MpgValue returns the value of the "mpg_value" field in the mutation.
func (m *FeasibilityToolControlMutation) MpgValue() (r float64, exists bool) {
	v := m.mpg_value
	if v == nil {
		return
	}
	return *v, true
}

// OldMpgValue returns the old "mpg_value" field's value of the FeasibilityToolControl entity.
// If the FeasibilityToolControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeasibilityToolControlMutation) OldMpgValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMpgValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMpgValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMpgValue: %w", err)
	}
	return oldValue.MpgValue, nil
}

// AddMpgValue adds f to the "mpg_value" field.
func (m *FeasibilityToolControlMutation) AddMpgValue(f float64) {
	if m.addmpg_value != nil {
		*m.addmpg_value += f
	} else {
		m.addmpg_value = &f
	}
}

// AddedMpgValue returns the value that was added to the "mpg_value" field in this mutation.
func (m *FeasibilityToolControlMutation) AddedMpgValue() (r float64, exists bool) {
	v := m.addmpg_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetMpgValue resets all changes to the "mpg_value" field.
func (m *FeasibilityToolControlMutation) ResetMpgValue() {
	m.mpg_value = nil
	m.addmpg_value = nil
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *FeasibilityToolControlMutation) SetOrganizationID(id uuid.UUID) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *FeasibilityToolControlMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *FeasibilityToolControlMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *FeasibilityToolControlMutation) OrganizationID() (id uuid.UUID, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *FeasibilityToolControlMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *FeasibilityToolControlMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// SetBusinessUnitID sets the "business_unit" edge to the BusinessUnit entity by id.
func (m *FeasibilityToolControlMutation) SetBusinessUnitID(id uuid.UUID) {
	m.business_unit = &id
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *FeasibilityToolControlMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *FeasibilityToolControlMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitID returns the "business_unit" edge ID in the mutation.
func (m *FeasibilityToolControlMutation) BusinessUnitID() (id uuid.UUID, exists bool) {
	if m.business_unit != nil {
		return *m.business_unit, true
	}
	return
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *FeasibilityToolControlMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *FeasibilityToolControlMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// Where appends a list predicates to the FeasibilityToolControlMutation builder.
func (m *FeasibilityToolControlMutation) Where(ps ...predicate.FeasibilityToolControl) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeasibilityToolControlMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeasibilityToolControlMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FeasibilityToolControl, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeasibilityToolControlMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeasibilityToolControlMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FeasibilityToolControl).
func (m *FeasibilityToolControlMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeasibilityToolControlMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, feasibilitytoolcontrol.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, feasibilitytoolcontrol.FieldUpdatedAt)
	}
	if m.otp_operator != nil {
		fields = append(fields, feasibilitytoolcontrol.FieldOtpOperator)
	}
	if m.otp_value != nil {
		fields = append(fields, feasibilitytoolcontrol.FieldOtpValue)
	}
	if m.mpw_operator != nil {
		fields = append(fields, feasibilitytoolcontrol.FieldMpwOperator)
	}
	if m.mpw_value != nil {
		fields = append(fields, feasibilitytoolcontrol.FieldMpwValue)
	}
	if m.mpd_operator != nil {
		fields = append(fields, feasibilitytoolcontrol.FieldMpdOperator)
	}
	if m.mpd_value != nil {
		fields = append(fields, feasibilitytoolcontrol.FieldMpdValue)
	}
	if m.mpg_operator != nil {
		fields = append(fields, feasibilitytoolcontrol.FieldMpgOperator)
	}
	if m.mpg_value != nil {
		fields = append(fields, feasibilitytoolcontrol.FieldMpgValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeasibilityToolControlMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case feasibilitytoolcontrol.FieldCreatedAt:
		return m.CreatedAt()
	case feasibilitytoolcontrol.FieldUpdatedAt:
		return m.UpdatedAt()
	case feasibilitytoolcontrol.FieldOtpOperator:
		return m.OtpOperator()
	case feasibilitytoolcontrol.FieldOtpValue:
		return m.OtpValue()
	case feasibilitytoolcontrol.FieldMpwOperator:
		return m.MpwOperator()
	case feasibilitytoolcontrol.FieldMpwValue:
		return m.MpwValue()
	case feasibilitytoolcontrol.FieldMpdOperator:
		return m.MpdOperator()
	case feasibilitytoolcontrol.FieldMpdValue:
		return m.MpdValue()
	case feasibilitytoolcontrol.FieldMpgOperator:
		return m.MpgOperator()
	case feasibilitytoolcontrol.FieldMpgValue:
		return m.MpgValue()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeasibilityToolControlMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case feasibilitytoolcontrol.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case feasibilitytoolcontrol.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case feasibilitytoolcontrol.FieldOtpOperator:
		return m.OldOtpOperator(ctx)
	case feasibilitytoolcontrol.FieldOtpValue:
		return m.OldOtpValue(ctx)
	case feasibilitytoolcontrol.FieldMpwOperator:
		return m.OldMpwOperator(ctx)
	case feasibilitytoolcontrol.FieldMpwValue:
		return m.OldMpwValue(ctx)
	case feasibilitytoolcontrol.FieldMpdOperator:
		return m.OldMpdOperator(ctx)
	case feasibilitytoolcontrol.FieldMpdValue:
		return m.OldMpdValue(ctx)
	case feasibilitytoolcontrol.FieldMpgOperator:
		return m.OldMpgOperator(ctx)
	case feasibilitytoolcontrol.FieldMpgValue:
		return m.OldMpgValue(ctx)
	}
	return nil, fmt.Errorf("unknown FeasibilityToolControl field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeasibilityToolControlMutation) SetField(name string, value ent.Value) error {
	switch name {
	case feasibilitytoolcontrol.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case feasibilitytoolcontrol.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case feasibilitytoolcontrol.FieldOtpOperator:
		v, ok := value.(feasibilitytoolcontrol.OtpOperator)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtpOperator(v)
		return nil
	case feasibilitytoolcontrol.FieldOtpValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtpValue(v)
		return nil
	case feasibilitytoolcontrol.FieldMpwOperator:
		v, ok := value.(feasibilitytoolcontrol.MpwOperator)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMpwOperator(v)
		return nil
	case feasibilitytoolcontrol.FieldMpwValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMpwValue(v)
		return nil
	case feasibilitytoolcontrol.FieldMpdOperator:
		v, ok := value.(feasibilitytoolcontrol.MpdOperator)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMpdOperator(v)
		return nil
	case feasibilitytoolcontrol.FieldMpdValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMpdValue(v)
		return nil
	case feasibilitytoolcontrol.FieldMpgOperator:
		v, ok := value.(feasibilitytoolcontrol.MpgOperator)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMpgOperator(v)
		return nil
	case feasibilitytoolcontrol.FieldMpgValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMpgValue(v)
		return nil
	}
	return fmt.Errorf("unknown FeasibilityToolControl field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeasibilityToolControlMutation) AddedFields() []string {
	var fields []string
	if m.addotp_value != nil {
		fields = append(fields, feasibilitytoolcontrol.FieldOtpValue)
	}
	if m.addmpw_value != nil {
		fields = append(fields, feasibilitytoolcontrol.FieldMpwValue)
	}
	if m.addmpd_value != nil {
		fields = append(fields, feasibilitytoolcontrol.FieldMpdValue)
	}
	if m.addmpg_value != nil {
		fields = append(fields, feasibilitytoolcontrol.FieldMpgValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeasibilityToolControlMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case feasibilitytoolcontrol.FieldOtpValue:
		return m.AddedOtpValue()
	case feasibilitytoolcontrol.FieldMpwValue:
		return m.AddedMpwValue()
	case feasibilitytoolcontrol.FieldMpdValue:
		return m.AddedMpdValue()
	case feasibilitytoolcontrol.FieldMpgValue:
		return m.AddedMpgValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeasibilityToolControlMutation) AddField(name string, value ent.Value) error {
	switch name {
	case feasibilitytoolcontrol.FieldOtpValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOtpValue(v)
		return nil
	case feasibilitytoolcontrol.FieldMpwValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMpwValue(v)
		return nil
	case feasibilitytoolcontrol.FieldMpdValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMpdValue(v)
		return nil
	case feasibilitytoolcontrol.FieldMpgValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMpgValue(v)
		return nil
	}
	return fmt.Errorf("unknown FeasibilityToolControl numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeasibilityToolControlMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeasibilityToolControlMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeasibilityToolControlMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FeasibilityToolControl nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeasibilityToolControlMutation) ResetField(name string) error {
	switch name {
	case feasibilitytoolcontrol.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case feasibilitytoolcontrol.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case feasibilitytoolcontrol.FieldOtpOperator:
		m.ResetOtpOperator()
		return nil
	case feasibilitytoolcontrol.FieldOtpValue:
		m.ResetOtpValue()
		return nil
	case feasibilitytoolcontrol.FieldMpwOperator:
		m.ResetMpwOperator()
		return nil
	case feasibilitytoolcontrol.FieldMpwValue:
		m.ResetMpwValue()
		return nil
	case feasibilitytoolcontrol.FieldMpdOperator:
		m.ResetMpdOperator()
		return nil
	case feasibilitytoolcontrol.FieldMpdValue:
		m.ResetMpdValue()
		return nil
	case feasibilitytoolcontrol.FieldMpgOperator:
		m.ResetMpgOperator()
		return nil
	case feasibilitytoolcontrol.FieldMpgValue:
		m.ResetMpgValue()
		return nil
	}
	return fmt.Errorf("unknown FeasibilityToolControl field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeasibilityToolControlMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.organization != nil {
		edges = append(edges, feasibilitytoolcontrol.EdgeOrganization)
	}
	if m.business_unit != nil {
		edges = append(edges, feasibilitytoolcontrol.EdgeBusinessUnit)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeasibilityToolControlMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case feasibilitytoolcontrol.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case feasibilitytoolcontrol.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeasibilityToolControlMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeasibilityToolControlMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeasibilityToolControlMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorganization {
		edges = append(edges, feasibilitytoolcontrol.EdgeOrganization)
	}
	if m.clearedbusiness_unit {
		edges = append(edges, feasibilitytoolcontrol.EdgeBusinessUnit)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeasibilityToolControlMutation) EdgeCleared(name string) bool {
	switch name {
	case feasibilitytoolcontrol.EdgeOrganization:
		return m.clearedorganization
	case feasibilitytoolcontrol.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeasibilityToolControlMutation) ClearEdge(name string) error {
	switch name {
	case feasibilitytoolcontrol.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case feasibilitytoolcontrol.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	}
	return fmt.Errorf("unknown FeasibilityToolControl unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeasibilityToolControlMutation) ResetEdge(name string) error {
	switch name {
	case feasibilitytoolcontrol.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case feasibilitytoolcontrol.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	}
	return fmt.Errorf("unknown FeasibilityToolControl edge %s", name)
}

// FleetCodeMutation represents an operation that mutates the FleetCode nodes in the graph.
type FleetCodeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	status               *fleetcode.Status
	code                 *string
	description          *string
	revenue_goal         *float64
	addrevenue_goal      *float64
	deadhead_goal        *float64
	adddeadhead_goal     *float64
	mileage_goal         *float64
	addmileage_goal      *float64
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	manager              *uuid.UUID
	clearedmanager       bool
	done                 bool
	oldValue             func(context.Context) (*FleetCode, error)
	predicates           []predicate.FleetCode
}

var _ ent.Mutation = (*FleetCodeMutation)(nil)

// fleetcodeOption allows management of the mutation configuration using functional options.
type fleetcodeOption func(*FleetCodeMutation)

// newFleetCodeMutation creates new mutation for the FleetCode entity.
func newFleetCodeMutation(c config, op Op, opts ...fleetcodeOption) *FleetCodeMutation {
	m := &FleetCodeMutation{
		config:        c,
		op:            op,
		typ:           TypeFleetCode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFleetCodeID sets the ID field of the mutation.
func withFleetCodeID(id uuid.UUID) fleetcodeOption {
	return func(m *FleetCodeMutation) {
		var (
			err   error
			once  sync.Once
			value *FleetCode
		)
		m.oldValue = func(ctx context.Context) (*FleetCode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FleetCode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFleetCode sets the old FleetCode of the mutation.
func withFleetCode(node *FleetCode) fleetcodeOption {
	return func(m *FleetCodeMutation) {
		m.oldValue = func(context.Context) (*FleetCode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FleetCodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FleetCodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FleetCode entities.
func (m *FleetCodeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FleetCodeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FleetCodeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FleetCode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *FleetCodeMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *FleetCodeMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the FleetCode entity.
// If the FleetCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FleetCodeMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *FleetCodeMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *FleetCodeMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *FleetCodeMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the FleetCode entity.
// If the FleetCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FleetCodeMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *FleetCodeMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FleetCodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FleetCodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FleetCode entity.
// If the FleetCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FleetCodeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FleetCodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FleetCodeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FleetCodeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FleetCode entity.
// If the FleetCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FleetCodeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FleetCodeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *FleetCodeMutation) SetStatus(f fleetcode.Status) {
	m.status = &f
}

// Status returns the value of the "status" field in the mutation.
func (m *FleetCodeMutation) Status() (r fleetcode.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the FleetCode entity.
// If the FleetCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FleetCodeMutation) OldStatus(ctx context.Context) (v fleetcode.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *FleetCodeMutation) ResetStatus() {
	m.status = nil
}

// SetCode sets the "code" field.
func (m *FleetCodeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *FleetCodeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the FleetCode entity.
// If the FleetCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FleetCodeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *FleetCodeMutation) ResetCode() {
	m.code = nil
}

// SetDescription sets the "description" field.
func (m *FleetCodeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FleetCodeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the FleetCode entity.
// If the FleetCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FleetCodeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *FleetCodeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[fleetcode.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *FleetCodeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[fleetcode.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *FleetCodeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, fleetcode.FieldDescription)
}

// SetRevenueGoal sets the "revenue_goal" field.
func (m *FleetCodeMutation) SetRevenueGoal(f float64) {
	m.revenue_goal = &f
	m.addrevenue_goal = nil
}

// RevenueGoal returns the value of the "revenue_goal" field in the mutation.
func (m *FleetCodeMutation) RevenueGoal() (r float64, exists bool) {
	v := m.revenue_goal
	if v == nil {
		return
	}
	return *v, true
}

// OldRevenueGoal returns the old "revenue_goal" field's value of the FleetCode entity.
// If the FleetCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FleetCodeMutation) OldRevenueGoal(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevenueGoal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevenueGoal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevenueGoal: %w", err)
	}
	return oldValue.RevenueGoal, nil
}

// AddRevenueGoal adds f to the "revenue_goal" field.
func (m *FleetCodeMutation) AddRevenueGoal(f float64) {
	if m.addrevenue_goal != nil {
		*m.addrevenue_goal += f
	} else {
		m.addrevenue_goal = &f
	}
}

// AddedRevenueGoal returns the value that was added to the "revenue_goal" field in this mutation.
func (m *FleetCodeMutation) AddedRevenueGoal() (r float64, exists bool) {
	v := m.addrevenue_goal
	if v == nil {
		return
	}
	return *v, true
}

// ClearRevenueGoal clears the value of the "revenue_goal" field.
func (m *FleetCodeMutation) ClearRevenueGoal() {
	m.revenue_goal = nil
	m.addrevenue_goal = nil
	m.clearedFields[fleetcode.FieldRevenueGoal] = struct{}{}
}

// RevenueGoalCleared returns if the "revenue_goal" field was cleared in this mutation.
func (m *FleetCodeMutation) RevenueGoalCleared() bool {
	_, ok := m.clearedFields[fleetcode.FieldRevenueGoal]
	return ok
}

// ResetRevenueGoal resets all changes to the "revenue_goal" field.
func (m *FleetCodeMutation) ResetRevenueGoal() {
	m.revenue_goal = nil
	m.addrevenue_goal = nil
	delete(m.clearedFields, fleetcode.FieldRevenueGoal)
}

// SetDeadheadGoal sets the "deadhead_goal" field.
func (m *FleetCodeMutation) SetDeadheadGoal(f float64) {
	m.deadhead_goal = &f
	m.adddeadhead_goal = nil
}

// DeadheadGoal returns the value of the "deadhead_goal" field in the mutation.
func (m *FleetCodeMutation) DeadheadGoal() (r float64, exists bool) {
	v := m.deadhead_goal
	if v == nil {
		return
	}
	return *v, true
}

// OldDeadheadGoal returns the old "deadhead_goal" field's value of the FleetCode entity.
// If the FleetCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FleetCodeMutation) OldDeadheadGoal(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeadheadGoal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeadheadGoal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeadheadGoal: %w", err)
	}
	return oldValue.DeadheadGoal, nil
}

// AddDeadheadGoal adds f to the "deadhead_goal" field.
func (m *FleetCodeMutation) AddDeadheadGoal(f float64) {
	if m.adddeadhead_goal != nil {
		*m.adddeadhead_goal += f
	} else {
		m.adddeadhead_goal = &f
	}
}

// AddedDeadheadGoal returns the value that was added to the "deadhead_goal" field in this mutation.
func (m *FleetCodeMutation) AddedDeadheadGoal() (r float64, exists bool) {
	v := m.adddeadhead_goal
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeadheadGoal clears the value of the "deadhead_goal" field.
func (m *FleetCodeMutation) ClearDeadheadGoal() {
	m.deadhead_goal = nil
	m.adddeadhead_goal = nil
	m.clearedFields[fleetcode.FieldDeadheadGoal] = struct{}{}
}

// DeadheadGoalCleared returns if the "deadhead_goal" field was cleared in this mutation.
func (m *FleetCodeMutation) DeadheadGoalCleared() bool {
	_, ok := m.clearedFields[fleetcode.FieldDeadheadGoal]
	return ok
}

// ResetDeadheadGoal resets all changes to the "deadhead_goal" field.
func (m *FleetCodeMutation) ResetDeadheadGoal() {
	m.deadhead_goal = nil
	m.adddeadhead_goal = nil
	delete(m.clearedFields, fleetcode.FieldDeadheadGoal)
}

// SetMileageGoal sets the "mileage_goal" field.
func (m *FleetCodeMutation) SetMileageGoal(f float64) {
	m.mileage_goal = &f
	m.addmileage_goal = nil
}

// MileageGoal returns the value of the "mileage_goal" field in the mutation.
func (m *FleetCodeMutation) MileageGoal() (r float64, exists bool) {
	v := m.mileage_goal
	if v == nil {
		return
	}
	return *v, true
}

// OldMileageGoal returns the old "mileage_goal" field's value of the FleetCode entity.
// If the FleetCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FleetCodeMutation) OldMileageGoal(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMileageGoal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMileageGoal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMileageGoal: %w", err)
	}
	return oldValue.MileageGoal, nil
}

// AddMileageGoal adds f to the "mileage_goal" field.
func (m *FleetCodeMutation) AddMileageGoal(f float64) {
	if m.addmileage_goal != nil {
		*m.addmileage_goal += f
	} else {
		m.addmileage_goal = &f
	}
}

// AddedMileageGoal returns the value that was added to the "mileage_goal" field in this mutation.
func (m *FleetCodeMutation) AddedMileageGoal() (r float64, exists bool) {
	v := m.addmileage_goal
	if v == nil {
		return
	}
	return *v, true
}

// ClearMileageGoal clears the value of the "mileage_goal" field.
func (m *FleetCodeMutation) ClearMileageGoal() {
	m.mileage_goal = nil
	m.addmileage_goal = nil
	m.clearedFields[fleetcode.FieldMileageGoal] = struct{}{}
}

// MileageGoalCleared returns if the "mileage_goal" field was cleared in this mutation.
func (m *FleetCodeMutation) MileageGoalCleared() bool {
	_, ok := m.clearedFields[fleetcode.FieldMileageGoal]
	return ok
}

// ResetMileageGoal resets all changes to the "mileage_goal" field.
func (m *FleetCodeMutation) ResetMileageGoal() {
	m.mileage_goal = nil
	m.addmileage_goal = nil
	delete(m.clearedFields, fleetcode.FieldMileageGoal)
}

// SetManagerID sets the "manager_id" field.
func (m *FleetCodeMutation) SetManagerID(u uuid.UUID) {
	m.manager = &u
}

// ManagerID returns the value of the "manager_id" field in the mutation.
func (m *FleetCodeMutation) ManagerID() (r uuid.UUID, exists bool) {
	v := m.manager
	if v == nil {
		return
	}
	return *v, true
}

// OldManagerID returns the old "manager_id" field's value of the FleetCode entity.
// If the FleetCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FleetCodeMutation) OldManagerID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManagerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManagerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManagerID: %w", err)
	}
	return oldValue.ManagerID, nil
}

// ClearManagerID clears the value of the "manager_id" field.
func (m *FleetCodeMutation) ClearManagerID() {
	m.manager = nil
	m.clearedFields[fleetcode.FieldManagerID] = struct{}{}
}

// ManagerIDCleared returns if the "manager_id" field was cleared in this mutation.
func (m *FleetCodeMutation) ManagerIDCleared() bool {
	_, ok := m.clearedFields[fleetcode.FieldManagerID]
	return ok
}

// ResetManagerID resets all changes to the "manager_id" field.
func (m *FleetCodeMutation) ResetManagerID() {
	m.manager = nil
	delete(m.clearedFields, fleetcode.FieldManagerID)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *FleetCodeMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[fleetcode.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *FleetCodeMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *FleetCodeMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *FleetCodeMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *FleetCodeMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[fleetcode.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *FleetCodeMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *FleetCodeMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *FleetCodeMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearManager clears the "manager" edge to the User entity.
func (m *FleetCodeMutation) ClearManager() {
	m.clearedmanager = true
	m.clearedFields[fleetcode.FieldManagerID] = struct{}{}
}

// ManagerCleared reports if the "manager" edge to the User entity was cleared.
func (m *FleetCodeMutation) ManagerCleared() bool {
	return m.ManagerIDCleared() || m.clearedmanager
}

// ManagerIDs returns the "manager" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ManagerID instead. It exists only for internal usage by the builders.
func (m *FleetCodeMutation) ManagerIDs() (ids []uuid.UUID) {
	if id := m.manager; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetManager resets all changes to the "manager" edge.
func (m *FleetCodeMutation) ResetManager() {
	m.manager = nil
	m.clearedmanager = false
}

// Where appends a list predicates to the FleetCodeMutation builder.
func (m *FleetCodeMutation) Where(ps ...predicate.FleetCode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FleetCodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FleetCodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FleetCode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FleetCodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FleetCodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FleetCode).
func (m *FleetCodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FleetCodeMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.business_unit != nil {
		fields = append(fields, fleetcode.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, fleetcode.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, fleetcode.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, fleetcode.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, fleetcode.FieldStatus)
	}
	if m.code != nil {
		fields = append(fields, fleetcode.FieldCode)
	}
	if m.description != nil {
		fields = append(fields, fleetcode.FieldDescription)
	}
	if m.revenue_goal != nil {
		fields = append(fields, fleetcode.FieldRevenueGoal)
	}
	if m.deadhead_goal != nil {
		fields = append(fields, fleetcode.FieldDeadheadGoal)
	}
	if m.mileage_goal != nil {
		fields = append(fields, fleetcode.FieldMileageGoal)
	}
	if m.manager != nil {
		fields = append(fields, fleetcode.FieldManagerID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FleetCodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fleetcode.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case fleetcode.FieldOrganizationID:
		return m.OrganizationID()
	case fleetcode.FieldCreatedAt:
		return m.CreatedAt()
	case fleetcode.FieldUpdatedAt:
		return m.UpdatedAt()
	case fleetcode.FieldStatus:
		return m.Status()
	case fleetcode.FieldCode:
		return m.Code()
	case fleetcode.FieldDescription:
		return m.Description()
	case fleetcode.FieldRevenueGoal:
		return m.RevenueGoal()
	case fleetcode.FieldDeadheadGoal:
		return m.DeadheadGoal()
	case fleetcode.FieldMileageGoal:
		return m.MileageGoal()
	case fleetcode.FieldManagerID:
		return m.ManagerID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FleetCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fleetcode.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case fleetcode.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case fleetcode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case fleetcode.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case fleetcode.FieldStatus:
		return m.OldStatus(ctx)
	case fleetcode.FieldCode:
		return m.OldCode(ctx)
	case fleetcode.FieldDescription:
		return m.OldDescription(ctx)
	case fleetcode.FieldRevenueGoal:
		return m.OldRevenueGoal(ctx)
	case fleetcode.FieldDeadheadGoal:
		return m.OldDeadheadGoal(ctx)
	case fleetcode.FieldMileageGoal:
		return m.OldMileageGoal(ctx)
	case fleetcode.FieldManagerID:
		return m.OldManagerID(ctx)
	}
	return nil, fmt.Errorf("unknown FleetCode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FleetCodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fleetcode.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case fleetcode.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case fleetcode.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case fleetcode.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case fleetcode.FieldStatus:
		v, ok := value.(fleetcode.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case fleetcode.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case fleetcode.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case fleetcode.FieldRevenueGoal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevenueGoal(v)
		return nil
	case fleetcode.FieldDeadheadGoal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeadheadGoal(v)
		return nil
	case fleetcode.FieldMileageGoal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMileageGoal(v)
		return nil
	case fleetcode.FieldManagerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManagerID(v)
		return nil
	}
	return fmt.Errorf("unknown FleetCode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FleetCodeMutation) AddedFields() []string {
	var fields []string
	if m.addrevenue_goal != nil {
		fields = append(fields, fleetcode.FieldRevenueGoal)
	}
	if m.adddeadhead_goal != nil {
		fields = append(fields, fleetcode.FieldDeadheadGoal)
	}
	if m.addmileage_goal != nil {
		fields = append(fields, fleetcode.FieldMileageGoal)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FleetCodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case fleetcode.FieldRevenueGoal:
		return m.AddedRevenueGoal()
	case fleetcode.FieldDeadheadGoal:
		return m.AddedDeadheadGoal()
	case fleetcode.FieldMileageGoal:
		return m.AddedMileageGoal()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FleetCodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case fleetcode.FieldRevenueGoal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRevenueGoal(v)
		return nil
	case fleetcode.FieldDeadheadGoal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeadheadGoal(v)
		return nil
	case fleetcode.FieldMileageGoal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMileageGoal(v)
		return nil
	}
	return fmt.Errorf("unknown FleetCode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FleetCodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(fleetcode.FieldDescription) {
		fields = append(fields, fleetcode.FieldDescription)
	}
	if m.FieldCleared(fleetcode.FieldRevenueGoal) {
		fields = append(fields, fleetcode.FieldRevenueGoal)
	}
	if m.FieldCleared(fleetcode.FieldDeadheadGoal) {
		fields = append(fields, fleetcode.FieldDeadheadGoal)
	}
	if m.FieldCleared(fleetcode.FieldMileageGoal) {
		fields = append(fields, fleetcode.FieldMileageGoal)
	}
	if m.FieldCleared(fleetcode.FieldManagerID) {
		fields = append(fields, fleetcode.FieldManagerID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FleetCodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FleetCodeMutation) ClearField(name string) error {
	switch name {
	case fleetcode.FieldDescription:
		m.ClearDescription()
		return nil
	case fleetcode.FieldRevenueGoal:
		m.ClearRevenueGoal()
		return nil
	case fleetcode.FieldDeadheadGoal:
		m.ClearDeadheadGoal()
		return nil
	case fleetcode.FieldMileageGoal:
		m.ClearMileageGoal()
		return nil
	case fleetcode.FieldManagerID:
		m.ClearManagerID()
		return nil
	}
	return fmt.Errorf("unknown FleetCode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FleetCodeMutation) ResetField(name string) error {
	switch name {
	case fleetcode.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case fleetcode.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case fleetcode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case fleetcode.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case fleetcode.FieldStatus:
		m.ResetStatus()
		return nil
	case fleetcode.FieldCode:
		m.ResetCode()
		return nil
	case fleetcode.FieldDescription:
		m.ResetDescription()
		return nil
	case fleetcode.FieldRevenueGoal:
		m.ResetRevenueGoal()
		return nil
	case fleetcode.FieldDeadheadGoal:
		m.ResetDeadheadGoal()
		return nil
	case fleetcode.FieldMileageGoal:
		m.ResetMileageGoal()
		return nil
	case fleetcode.FieldManagerID:
		m.ResetManagerID()
		return nil
	}
	return fmt.Errorf("unknown FleetCode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FleetCodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.business_unit != nil {
		edges = append(edges, fleetcode.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, fleetcode.EdgeOrganization)
	}
	if m.manager != nil {
		edges = append(edges, fleetcode.EdgeManager)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FleetCodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case fleetcode.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case fleetcode.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case fleetcode.EdgeManager:
		if id := m.manager; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FleetCodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FleetCodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FleetCodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbusiness_unit {
		edges = append(edges, fleetcode.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, fleetcode.EdgeOrganization)
	}
	if m.clearedmanager {
		edges = append(edges, fleetcode.EdgeManager)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FleetCodeMutation) EdgeCleared(name string) bool {
	switch name {
	case fleetcode.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case fleetcode.EdgeOrganization:
		return m.clearedorganization
	case fleetcode.EdgeManager:
		return m.clearedmanager
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FleetCodeMutation) ClearEdge(name string) error {
	switch name {
	case fleetcode.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case fleetcode.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case fleetcode.EdgeManager:
		m.ClearManager()
		return nil
	}
	return fmt.Errorf("unknown FleetCode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FleetCodeMutation) ResetEdge(name string) error {
	switch name {
	case fleetcode.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case fleetcode.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case fleetcode.EdgeManager:
		m.ResetManager()
		return nil
	}
	return fmt.Errorf("unknown FleetCode edge %s", name)
}

// GeneralLedgerAccountMutation represents an operation that mutates the GeneralLedgerAccount nodes in the graph.
type GeneralLedgerAccountMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	status               *generalledgeraccount.Status
	account_number       *string
	account_type         *generalledgeraccount.AccountType
	cash_flow_type       *string
	account_sub_type     *string
	account_class        *string
	balance              *float64
	addbalance           *float64
	interest_rate        *float64
	addinterest_rate     *float64
	date_opened          **pgtype.Date
	date_closed          **pgtype.Date
	notes                *string
	is_tax_relevant      *bool
	is_reconciled        *bool
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	tags                 map[uuid.UUID]struct{}
	removedtags          map[uuid.UUID]struct{}
	clearedtags          bool
	done                 bool
	oldValue             func(context.Context) (*GeneralLedgerAccount, error)
	predicates           []predicate.GeneralLedgerAccount
}

var _ ent.Mutation = (*GeneralLedgerAccountMutation)(nil)

// generalledgeraccountOption allows management of the mutation configuration using functional options.
type generalledgeraccountOption func(*GeneralLedgerAccountMutation)

// newGeneralLedgerAccountMutation creates new mutation for the GeneralLedgerAccount entity.
func newGeneralLedgerAccountMutation(c config, op Op, opts ...generalledgeraccountOption) *GeneralLedgerAccountMutation {
	m := &GeneralLedgerAccountMutation{
		config:        c,
		op:            op,
		typ:           TypeGeneralLedgerAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGeneralLedgerAccountID sets the ID field of the mutation.
func withGeneralLedgerAccountID(id uuid.UUID) generalledgeraccountOption {
	return func(m *GeneralLedgerAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *GeneralLedgerAccount
		)
		m.oldValue = func(ctx context.Context) (*GeneralLedgerAccount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GeneralLedgerAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGeneralLedgerAccount sets the old GeneralLedgerAccount of the mutation.
func withGeneralLedgerAccount(node *GeneralLedgerAccount) generalledgeraccountOption {
	return func(m *GeneralLedgerAccountMutation) {
		m.oldValue = func(context.Context) (*GeneralLedgerAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GeneralLedgerAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GeneralLedgerAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GeneralLedgerAccount entities.
func (m *GeneralLedgerAccountMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GeneralLedgerAccountMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GeneralLedgerAccountMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GeneralLedgerAccount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *GeneralLedgerAccountMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *GeneralLedgerAccountMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *GeneralLedgerAccountMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *GeneralLedgerAccountMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *GeneralLedgerAccountMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *GeneralLedgerAccountMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *GeneralLedgerAccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GeneralLedgerAccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GeneralLedgerAccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GeneralLedgerAccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GeneralLedgerAccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GeneralLedgerAccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *GeneralLedgerAccountMutation) SetStatus(ge generalledgeraccount.Status) {
	m.status = &ge
}

// Status returns the value of the "status" field in the mutation.
func (m *GeneralLedgerAccountMutation) Status() (r generalledgeraccount.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldStatus(ctx context.Context) (v generalledgeraccount.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *GeneralLedgerAccountMutation) ResetStatus() {
	m.status = nil
}

// SetAccountNumber sets the "account_number" field.
func (m *GeneralLedgerAccountMutation) SetAccountNumber(s string) {
	m.account_number = &s
}

// AccountNumber returns the value of the "account_number" field in the mutation.
func (m *GeneralLedgerAccountMutation) AccountNumber() (r string, exists bool) {
	v := m.account_number
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountNumber returns the old "account_number" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldAccountNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountNumber: %w", err)
	}
	return oldValue.AccountNumber, nil
}

// ResetAccountNumber resets all changes to the "account_number" field.
func (m *GeneralLedgerAccountMutation) ResetAccountNumber() {
	m.account_number = nil
}

// SetAccountType sets the "account_type" field.
func (m *GeneralLedgerAccountMutation) SetAccountType(gt generalledgeraccount.AccountType) {
	m.account_type = &gt
}

// AccountType returns the value of the "account_type" field in the mutation.
func (m *GeneralLedgerAccountMutation) AccountType() (r generalledgeraccount.AccountType, exists bool) {
	v := m.account_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountType returns the old "account_type" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldAccountType(ctx context.Context) (v generalledgeraccount.AccountType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountType: %w", err)
	}
	return oldValue.AccountType, nil
}

// ResetAccountType resets all changes to the "account_type" field.
func (m *GeneralLedgerAccountMutation) ResetAccountType() {
	m.account_type = nil
}

// SetCashFlowType sets the "cash_flow_type" field.
func (m *GeneralLedgerAccountMutation) SetCashFlowType(s string) {
	m.cash_flow_type = &s
}

// CashFlowType returns the value of the "cash_flow_type" field in the mutation.
func (m *GeneralLedgerAccountMutation) CashFlowType() (r string, exists bool) {
	v := m.cash_flow_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCashFlowType returns the old "cash_flow_type" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldCashFlowType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCashFlowType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCashFlowType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCashFlowType: %w", err)
	}
	return oldValue.CashFlowType, nil
}

// ClearCashFlowType clears the value of the "cash_flow_type" field.
func (m *GeneralLedgerAccountMutation) ClearCashFlowType() {
	m.cash_flow_type = nil
	m.clearedFields[generalledgeraccount.FieldCashFlowType] = struct{}{}
}

// CashFlowTypeCleared returns if the "cash_flow_type" field was cleared in this mutation.
func (m *GeneralLedgerAccountMutation) CashFlowTypeCleared() bool {
	_, ok := m.clearedFields[generalledgeraccount.FieldCashFlowType]
	return ok
}

// ResetCashFlowType resets all changes to the "cash_flow_type" field.
func (m *GeneralLedgerAccountMutation) ResetCashFlowType() {
	m.cash_flow_type = nil
	delete(m.clearedFields, generalledgeraccount.FieldCashFlowType)
}

// SetAccountSubType sets the "account_sub_type" field.
func (m *GeneralLedgerAccountMutation) SetAccountSubType(s string) {
	m.account_sub_type = &s
}

// AccountSubType returns the value of the "account_sub_type" field in the mutation.
func (m *GeneralLedgerAccountMutation) AccountSubType() (r string, exists bool) {
	v := m.account_sub_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountSubType returns the old "account_sub_type" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldAccountSubType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountSubType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountSubType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountSubType: %w", err)
	}
	return oldValue.AccountSubType, nil
}

// ClearAccountSubType clears the value of the "account_sub_type" field.
func (m *GeneralLedgerAccountMutation) ClearAccountSubType() {
	m.account_sub_type = nil
	m.clearedFields[generalledgeraccount.FieldAccountSubType] = struct{}{}
}

// AccountSubTypeCleared returns if the "account_sub_type" field was cleared in this mutation.
func (m *GeneralLedgerAccountMutation) AccountSubTypeCleared() bool {
	_, ok := m.clearedFields[generalledgeraccount.FieldAccountSubType]
	return ok
}

// ResetAccountSubType resets all changes to the "account_sub_type" field.
func (m *GeneralLedgerAccountMutation) ResetAccountSubType() {
	m.account_sub_type = nil
	delete(m.clearedFields, generalledgeraccount.FieldAccountSubType)
}

// SetAccountClass sets the "account_class" field.
func (m *GeneralLedgerAccountMutation) SetAccountClass(s string) {
	m.account_class = &s
}

// AccountClass returns the value of the "account_class" field in the mutation.
func (m *GeneralLedgerAccountMutation) AccountClass() (r string, exists bool) {
	v := m.account_class
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountClass returns the old "account_class" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldAccountClass(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountClass is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountClass requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountClass: %w", err)
	}
	return oldValue.AccountClass, nil
}

// ClearAccountClass clears the value of the "account_class" field.
func (m *GeneralLedgerAccountMutation) ClearAccountClass() {
	m.account_class = nil
	m.clearedFields[generalledgeraccount.FieldAccountClass] = struct{}{}
}

// AccountClassCleared returns if the "account_class" field was cleared in this mutation.
func (m *GeneralLedgerAccountMutation) AccountClassCleared() bool {
	_, ok := m.clearedFields[generalledgeraccount.FieldAccountClass]
	return ok
}

// ResetAccountClass resets all changes to the "account_class" field.
func (m *GeneralLedgerAccountMutation) ResetAccountClass() {
	m.account_class = nil
	delete(m.clearedFields, generalledgeraccount.FieldAccountClass)
}

// SetBalance sets the "balance" field.
func (m *GeneralLedgerAccountMutation) SetBalance(f float64) {
	m.balance = &f
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *GeneralLedgerAccountMutation) Balance() (r float64, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldBalance(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds f to the "balance" field.
func (m *GeneralLedgerAccountMutation) AddBalance(f float64) {
	if m.addbalance != nil {
		*m.addbalance += f
	} else {
		m.addbalance = &f
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *GeneralLedgerAccountMutation) AddedBalance() (r float64, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ClearBalance clears the value of the "balance" field.
func (m *GeneralLedgerAccountMutation) ClearBalance() {
	m.balance = nil
	m.addbalance = nil
	m.clearedFields[generalledgeraccount.FieldBalance] = struct{}{}
}

// BalanceCleared returns if the "balance" field was cleared in this mutation.
func (m *GeneralLedgerAccountMutation) BalanceCleared() bool {
	_, ok := m.clearedFields[generalledgeraccount.FieldBalance]
	return ok
}

// ResetBalance resets all changes to the "balance" field.
func (m *GeneralLedgerAccountMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
	delete(m.clearedFields, generalledgeraccount.FieldBalance)
}

// SetInterestRate sets the "interest_rate" field.
func (m *GeneralLedgerAccountMutation) SetInterestRate(f float64) {
	m.interest_rate = &f
	m.addinterest_rate = nil
}

// InterestRate returns the value of the "interest_rate" field in the mutation.
func (m *GeneralLedgerAccountMutation) InterestRate() (r float64, exists bool) {
	v := m.interest_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldInterestRate returns the old "interest_rate" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldInterestRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInterestRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInterestRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterestRate: %w", err)
	}
	return oldValue.InterestRate, nil
}

// AddInterestRate adds f to the "interest_rate" field.
func (m *GeneralLedgerAccountMutation) AddInterestRate(f float64) {
	if m.addinterest_rate != nil {
		*m.addinterest_rate += f
	} else {
		m.addinterest_rate = &f
	}
}

// AddedInterestRate returns the value that was added to the "interest_rate" field in this mutation.
func (m *GeneralLedgerAccountMutation) AddedInterestRate() (r float64, exists bool) {
	v := m.addinterest_rate
	if v == nil {
		return
	}
	return *v, true
}

// ClearInterestRate clears the value of the "interest_rate" field.
func (m *GeneralLedgerAccountMutation) ClearInterestRate() {
	m.interest_rate = nil
	m.addinterest_rate = nil
	m.clearedFields[generalledgeraccount.FieldInterestRate] = struct{}{}
}

// InterestRateCleared returns if the "interest_rate" field was cleared in this mutation.
func (m *GeneralLedgerAccountMutation) InterestRateCleared() bool {
	_, ok := m.clearedFields[generalledgeraccount.FieldInterestRate]
	return ok
}

// ResetInterestRate resets all changes to the "interest_rate" field.
func (m *GeneralLedgerAccountMutation) ResetInterestRate() {
	m.interest_rate = nil
	m.addinterest_rate = nil
	delete(m.clearedFields, generalledgeraccount.FieldInterestRate)
}

// SetDateOpened sets the "date_opened" field.
func (m *GeneralLedgerAccountMutation) SetDateOpened(pg *pgtype.Date) {
	m.date_opened = &pg
}

// DateOpened returns the value of the "date_opened" field in the mutation.
func (m *GeneralLedgerAccountMutation) DateOpened() (r *pgtype.Date, exists bool) {
	v := m.date_opened
	if v == nil {
		return
	}
	return *v, true
}

// OldDateOpened returns the old "date_opened" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldDateOpened(ctx context.Context) (v *pgtype.Date, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDateOpened is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDateOpened requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateOpened: %w", err)
	}
	return oldValue.DateOpened, nil
}

// ResetDateOpened resets all changes to the "date_opened" field.
func (m *GeneralLedgerAccountMutation) ResetDateOpened() {
	m.date_opened = nil
}

// SetDateClosed sets the "date_closed" field.
func (m *GeneralLedgerAccountMutation) SetDateClosed(pg *pgtype.Date) {
	m.date_closed = &pg
}

// DateClosed returns the value of the "date_closed" field in the mutation.
func (m *GeneralLedgerAccountMutation) DateClosed() (r *pgtype.Date, exists bool) {
	v := m.date_closed
	if v == nil {
		return
	}
	return *v, true
}

// OldDateClosed returns the old "date_closed" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldDateClosed(ctx context.Context) (v *pgtype.Date, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDateClosed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDateClosed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateClosed: %w", err)
	}
	return oldValue.DateClosed, nil
}

// ClearDateClosed clears the value of the "date_closed" field.
func (m *GeneralLedgerAccountMutation) ClearDateClosed() {
	m.date_closed = nil
	m.clearedFields[generalledgeraccount.FieldDateClosed] = struct{}{}
}

// DateClosedCleared returns if the "date_closed" field was cleared in this mutation.
func (m *GeneralLedgerAccountMutation) DateClosedCleared() bool {
	_, ok := m.clearedFields[generalledgeraccount.FieldDateClosed]
	return ok
}

// ResetDateClosed resets all changes to the "date_closed" field.
func (m *GeneralLedgerAccountMutation) ResetDateClosed() {
	m.date_closed = nil
	delete(m.clearedFields, generalledgeraccount.FieldDateClosed)
}

// SetNotes sets the "notes" field.
func (m *GeneralLedgerAccountMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *GeneralLedgerAccountMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *GeneralLedgerAccountMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[generalledgeraccount.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *GeneralLedgerAccountMutation) NotesCleared() bool {
	_, ok := m.clearedFields[generalledgeraccount.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *GeneralLedgerAccountMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, generalledgeraccount.FieldNotes)
}

// SetIsTaxRelevant sets the "is_tax_relevant" field.
func (m *GeneralLedgerAccountMutation) SetIsTaxRelevant(b bool) {
	m.is_tax_relevant = &b
}

// IsTaxRelevant returns the value of the "is_tax_relevant" field in the mutation.
func (m *GeneralLedgerAccountMutation) IsTaxRelevant() (r bool, exists bool) {
	v := m.is_tax_relevant
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTaxRelevant returns the old "is_tax_relevant" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldIsTaxRelevant(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTaxRelevant is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTaxRelevant requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTaxRelevant: %w", err)
	}
	return oldValue.IsTaxRelevant, nil
}

// ResetIsTaxRelevant resets all changes to the "is_tax_relevant" field.
func (m *GeneralLedgerAccountMutation) ResetIsTaxRelevant() {
	m.is_tax_relevant = nil
}

// SetIsReconciled sets the "is_reconciled" field.
func (m *GeneralLedgerAccountMutation) SetIsReconciled(b bool) {
	m.is_reconciled = &b
}

// IsReconciled returns the value of the "is_reconciled" field in the mutation.
func (m *GeneralLedgerAccountMutation) IsReconciled() (r bool, exists bool) {
	v := m.is_reconciled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsReconciled returns the old "is_reconciled" field's value of the GeneralLedgerAccount entity.
// If the GeneralLedgerAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GeneralLedgerAccountMutation) OldIsReconciled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsReconciled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsReconciled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsReconciled: %w", err)
	}
	return oldValue.IsReconciled, nil
}

// ResetIsReconciled resets all changes to the "is_reconciled" field.
func (m *GeneralLedgerAccountMutation) ResetIsReconciled() {
	m.is_reconciled = nil
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *GeneralLedgerAccountMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[generalledgeraccount.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *GeneralLedgerAccountMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *GeneralLedgerAccountMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *GeneralLedgerAccountMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *GeneralLedgerAccountMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[generalledgeraccount.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *GeneralLedgerAccountMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *GeneralLedgerAccountMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *GeneralLedgerAccountMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *GeneralLedgerAccountMutation) AddTagIDs(ids ...uuid.UUID) {
	if m.tags == nil {
		m.tags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *GeneralLedgerAccountMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *GeneralLedgerAccountMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *GeneralLedgerAccountMutation) RemoveTagIDs(ids ...uuid.UUID) {
	if m.removedtags == nil {
		m.removedtags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *GeneralLedgerAccountMutation) RemovedTagsIDs() (ids []uuid.UUID) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *GeneralLedgerAccountMutation) TagsIDs() (ids []uuid.UUID) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *GeneralLedgerAccountMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// Where appends a list predicates to the GeneralLedgerAccountMutation builder.
func (m *GeneralLedgerAccountMutation) Where(ps ...predicate.GeneralLedgerAccount) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GeneralLedgerAccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GeneralLedgerAccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GeneralLedgerAccount, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GeneralLedgerAccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GeneralLedgerAccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GeneralLedgerAccount).
func (m *GeneralLedgerAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GeneralLedgerAccountMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.business_unit != nil {
		fields = append(fields, generalledgeraccount.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, generalledgeraccount.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, generalledgeraccount.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, generalledgeraccount.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, generalledgeraccount.FieldStatus)
	}
	if m.account_number != nil {
		fields = append(fields, generalledgeraccount.FieldAccountNumber)
	}
	if m.account_type != nil {
		fields = append(fields, generalledgeraccount.FieldAccountType)
	}
	if m.cash_flow_type != nil {
		fields = append(fields, generalledgeraccount.FieldCashFlowType)
	}
	if m.account_sub_type != nil {
		fields = append(fields, generalledgeraccount.FieldAccountSubType)
	}
	if m.account_class != nil {
		fields = append(fields, generalledgeraccount.FieldAccountClass)
	}
	if m.balance != nil {
		fields = append(fields, generalledgeraccount.FieldBalance)
	}
	if m.interest_rate != nil {
		fields = append(fields, generalledgeraccount.FieldInterestRate)
	}
	if m.date_opened != nil {
		fields = append(fields, generalledgeraccount.FieldDateOpened)
	}
	if m.date_closed != nil {
		fields = append(fields, generalledgeraccount.FieldDateClosed)
	}
	if m.notes != nil {
		fields = append(fields, generalledgeraccount.FieldNotes)
	}
	if m.is_tax_relevant != nil {
		fields = append(fields, generalledgeraccount.FieldIsTaxRelevant)
	}
	if m.is_reconciled != nil {
		fields = append(fields, generalledgeraccount.FieldIsReconciled)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GeneralLedgerAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case generalledgeraccount.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case generalledgeraccount.FieldOrganizationID:
		return m.OrganizationID()
	case generalledgeraccount.FieldCreatedAt:
		return m.CreatedAt()
	case generalledgeraccount.FieldUpdatedAt:
		return m.UpdatedAt()
	case generalledgeraccount.FieldStatus:
		return m.Status()
	case generalledgeraccount.FieldAccountNumber:
		return m.AccountNumber()
	case generalledgeraccount.FieldAccountType:
		return m.AccountType()
	case generalledgeraccount.FieldCashFlowType:
		return m.CashFlowType()
	case generalledgeraccount.FieldAccountSubType:
		return m.AccountSubType()
	case generalledgeraccount.FieldAccountClass:
		return m.AccountClass()
	case generalledgeraccount.FieldBalance:
		return m.Balance()
	case generalledgeraccount.FieldInterestRate:
		return m.InterestRate()
	case generalledgeraccount.FieldDateOpened:
		return m.DateOpened()
	case generalledgeraccount.FieldDateClosed:
		return m.DateClosed()
	case generalledgeraccount.FieldNotes:
		return m.Notes()
	case generalledgeraccount.FieldIsTaxRelevant:
		return m.IsTaxRelevant()
	case generalledgeraccount.FieldIsReconciled:
		return m.IsReconciled()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GeneralLedgerAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case generalledgeraccount.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case generalledgeraccount.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case generalledgeraccount.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case generalledgeraccount.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case generalledgeraccount.FieldStatus:
		return m.OldStatus(ctx)
	case generalledgeraccount.FieldAccountNumber:
		return m.OldAccountNumber(ctx)
	case generalledgeraccount.FieldAccountType:
		return m.OldAccountType(ctx)
	case generalledgeraccount.FieldCashFlowType:
		return m.OldCashFlowType(ctx)
	case generalledgeraccount.FieldAccountSubType:
		return m.OldAccountSubType(ctx)
	case generalledgeraccount.FieldAccountClass:
		return m.OldAccountClass(ctx)
	case generalledgeraccount.FieldBalance:
		return m.OldBalance(ctx)
	case generalledgeraccount.FieldInterestRate:
		return m.OldInterestRate(ctx)
	case generalledgeraccount.FieldDateOpened:
		return m.OldDateOpened(ctx)
	case generalledgeraccount.FieldDateClosed:
		return m.OldDateClosed(ctx)
	case generalledgeraccount.FieldNotes:
		return m.OldNotes(ctx)
	case generalledgeraccount.FieldIsTaxRelevant:
		return m.OldIsTaxRelevant(ctx)
	case generalledgeraccount.FieldIsReconciled:
		return m.OldIsReconciled(ctx)
	}
	return nil, fmt.Errorf("unknown GeneralLedgerAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GeneralLedgerAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case generalledgeraccount.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case generalledgeraccount.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case generalledgeraccount.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case generalledgeraccount.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case generalledgeraccount.FieldStatus:
		v, ok := value.(generalledgeraccount.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case generalledgeraccount.FieldAccountNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountNumber(v)
		return nil
	case generalledgeraccount.FieldAccountType:
		v, ok := value.(generalledgeraccount.AccountType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountType(v)
		return nil
	case generalledgeraccount.FieldCashFlowType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCashFlowType(v)
		return nil
	case generalledgeraccount.FieldAccountSubType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountSubType(v)
		return nil
	case generalledgeraccount.FieldAccountClass:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountClass(v)
		return nil
	case generalledgeraccount.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	case generalledgeraccount.FieldInterestRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterestRate(v)
		return nil
	case generalledgeraccount.FieldDateOpened:
		v, ok := value.(*pgtype.Date)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateOpened(v)
		return nil
	case generalledgeraccount.FieldDateClosed:
		v, ok := value.(*pgtype.Date)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateClosed(v)
		return nil
	case generalledgeraccount.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case generalledgeraccount.FieldIsTaxRelevant:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTaxRelevant(v)
		return nil
	case generalledgeraccount.FieldIsReconciled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsReconciled(v)
		return nil
	}
	return fmt.Errorf("unknown GeneralLedgerAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GeneralLedgerAccountMutation) AddedFields() []string {
	var fields []string
	if m.addbalance != nil {
		fields = append(fields, generalledgeraccount.FieldBalance)
	}
	if m.addinterest_rate != nil {
		fields = append(fields, generalledgeraccount.FieldInterestRate)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GeneralLedgerAccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case generalledgeraccount.FieldBalance:
		return m.AddedBalance()
	case generalledgeraccount.FieldInterestRate:
		return m.AddedInterestRate()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GeneralLedgerAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case generalledgeraccount.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	case generalledgeraccount.FieldInterestRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInterestRate(v)
		return nil
	}
	return fmt.Errorf("unknown GeneralLedgerAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GeneralLedgerAccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(generalledgeraccount.FieldCashFlowType) {
		fields = append(fields, generalledgeraccount.FieldCashFlowType)
	}
	if m.FieldCleared(generalledgeraccount.FieldAccountSubType) {
		fields = append(fields, generalledgeraccount.FieldAccountSubType)
	}
	if m.FieldCleared(generalledgeraccount.FieldAccountClass) {
		fields = append(fields, generalledgeraccount.FieldAccountClass)
	}
	if m.FieldCleared(generalledgeraccount.FieldBalance) {
		fields = append(fields, generalledgeraccount.FieldBalance)
	}
	if m.FieldCleared(generalledgeraccount.FieldInterestRate) {
		fields = append(fields, generalledgeraccount.FieldInterestRate)
	}
	if m.FieldCleared(generalledgeraccount.FieldDateClosed) {
		fields = append(fields, generalledgeraccount.FieldDateClosed)
	}
	if m.FieldCleared(generalledgeraccount.FieldNotes) {
		fields = append(fields, generalledgeraccount.FieldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GeneralLedgerAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GeneralLedgerAccountMutation) ClearField(name string) error {
	switch name {
	case generalledgeraccount.FieldCashFlowType:
		m.ClearCashFlowType()
		return nil
	case generalledgeraccount.FieldAccountSubType:
		m.ClearAccountSubType()
		return nil
	case generalledgeraccount.FieldAccountClass:
		m.ClearAccountClass()
		return nil
	case generalledgeraccount.FieldBalance:
		m.ClearBalance()
		return nil
	case generalledgeraccount.FieldInterestRate:
		m.ClearInterestRate()
		return nil
	case generalledgeraccount.FieldDateClosed:
		m.ClearDateClosed()
		return nil
	case generalledgeraccount.FieldNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown GeneralLedgerAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GeneralLedgerAccountMutation) ResetField(name string) error {
	switch name {
	case generalledgeraccount.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case generalledgeraccount.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case generalledgeraccount.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case generalledgeraccount.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case generalledgeraccount.FieldStatus:
		m.ResetStatus()
		return nil
	case generalledgeraccount.FieldAccountNumber:
		m.ResetAccountNumber()
		return nil
	case generalledgeraccount.FieldAccountType:
		m.ResetAccountType()
		return nil
	case generalledgeraccount.FieldCashFlowType:
		m.ResetCashFlowType()
		return nil
	case generalledgeraccount.FieldAccountSubType:
		m.ResetAccountSubType()
		return nil
	case generalledgeraccount.FieldAccountClass:
		m.ResetAccountClass()
		return nil
	case generalledgeraccount.FieldBalance:
		m.ResetBalance()
		return nil
	case generalledgeraccount.FieldInterestRate:
		m.ResetInterestRate()
		return nil
	case generalledgeraccount.FieldDateOpened:
		m.ResetDateOpened()
		return nil
	case generalledgeraccount.FieldDateClosed:
		m.ResetDateClosed()
		return nil
	case generalledgeraccount.FieldNotes:
		m.ResetNotes()
		return nil
	case generalledgeraccount.FieldIsTaxRelevant:
		m.ResetIsTaxRelevant()
		return nil
	case generalledgeraccount.FieldIsReconciled:
		m.ResetIsReconciled()
		return nil
	}
	return fmt.Errorf("unknown GeneralLedgerAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GeneralLedgerAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.business_unit != nil {
		edges = append(edges, generalledgeraccount.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, generalledgeraccount.EdgeOrganization)
	}
	if m.tags != nil {
		edges = append(edges, generalledgeraccount.EdgeTags)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GeneralLedgerAccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case generalledgeraccount.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case generalledgeraccount.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case generalledgeraccount.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GeneralLedgerAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedtags != nil {
		edges = append(edges, generalledgeraccount.EdgeTags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GeneralLedgerAccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case generalledgeraccount.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GeneralLedgerAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbusiness_unit {
		edges = append(edges, generalledgeraccount.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, generalledgeraccount.EdgeOrganization)
	}
	if m.clearedtags {
		edges = append(edges, generalledgeraccount.EdgeTags)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GeneralLedgerAccountMutation) EdgeCleared(name string) bool {
	switch name {
	case generalledgeraccount.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case generalledgeraccount.EdgeOrganization:
		return m.clearedorganization
	case generalledgeraccount.EdgeTags:
		return m.clearedtags
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GeneralLedgerAccountMutation) ClearEdge(name string) error {
	switch name {
	case generalledgeraccount.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case generalledgeraccount.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown GeneralLedgerAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GeneralLedgerAccountMutation) ResetEdge(name string) error {
	switch name {
	case generalledgeraccount.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case generalledgeraccount.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case generalledgeraccount.EdgeTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown GeneralLedgerAccount edge %s", name)
}

// GoogleApiMutation represents an operation that mutates the GoogleApi nodes in the graph.
type GoogleApiMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	created_at            *time.Time
	updated_at            *time.Time
	api_key               *string
	mileage_unit          *googleapi.MileageUnit
	add_customer_location *bool
	auto_geocode          *bool
	add_location          *bool
	traffic_model         *googleapi.TrafficModel
	clearedFields         map[string]struct{}
	organization          *uuid.UUID
	clearedorganization   bool
	business_unit         *uuid.UUID
	clearedbusiness_unit  bool
	done                  bool
	oldValue              func(context.Context) (*GoogleApi, error)
	predicates            []predicate.GoogleApi
}

var _ ent.Mutation = (*GoogleApiMutation)(nil)

// googleapiOption allows management of the mutation configuration using functional options.
type googleapiOption func(*GoogleApiMutation)

// newGoogleApiMutation creates new mutation for the GoogleApi entity.
func newGoogleApiMutation(c config, op Op, opts ...googleapiOption) *GoogleApiMutation {
	m := &GoogleApiMutation{
		config:        c,
		op:            op,
		typ:           TypeGoogleApi,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGoogleApiID sets the ID field of the mutation.
func withGoogleApiID(id uuid.UUID) googleapiOption {
	return func(m *GoogleApiMutation) {
		var (
			err   error
			once  sync.Once
			value *GoogleApi
		)
		m.oldValue = func(ctx context.Context) (*GoogleApi, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GoogleApi.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGoogleApi sets the old GoogleApi of the mutation.
func withGoogleApi(node *GoogleApi) googleapiOption {
	return func(m *GoogleApiMutation) {
		m.oldValue = func(context.Context) (*GoogleApi, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GoogleApiMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GoogleApiMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GoogleApi entities.
func (m *GoogleApiMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GoogleApiMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GoogleApiMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GoogleApi.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *GoogleApiMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GoogleApiMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GoogleApi entity.
// If the GoogleApi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleApiMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GoogleApiMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GoogleApiMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GoogleApiMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GoogleApi entity.
// If the GoogleApi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleApiMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GoogleApiMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAPIKey sets the "api_key" field.
func (m *GoogleApiMutation) SetAPIKey(s string) {
	m.api_key = &s
}

// APIKey returns the value of the "api_key" field in the mutation.
func (m *GoogleApiMutation) APIKey() (r string, exists bool) {
	v := m.api_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIKey returns the old "api_key" field's value of the GoogleApi entity.
// If the GoogleApi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleApiMutation) OldAPIKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIKey: %w", err)
	}
	return oldValue.APIKey, nil
}

// ResetAPIKey resets all changes to the "api_key" field.
func (m *GoogleApiMutation) ResetAPIKey() {
	m.api_key = nil
}

// SetMileageUnit sets the "mileage_unit" field.
func (m *GoogleApiMutation) SetMileageUnit(gu googleapi.MileageUnit) {
	m.mileage_unit = &gu
}

// MileageUnit returns the value of the "mileage_unit" field in the mutation.
func (m *GoogleApiMutation) MileageUnit() (r googleapi.MileageUnit, exists bool) {
	v := m.mileage_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldMileageUnit returns the old "mileage_unit" field's value of the GoogleApi entity.
// If the GoogleApi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleApiMutation) OldMileageUnit(ctx context.Context) (v googleapi.MileageUnit, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMileageUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMileageUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMileageUnit: %w", err)
	}
	return oldValue.MileageUnit, nil
}

// ResetMileageUnit resets all changes to the "mileage_unit" field.
func (m *GoogleApiMutation) ResetMileageUnit() {
	m.mileage_unit = nil
}

// SetAddCustomerLocation sets the "add_customer_location" field.
func (m *GoogleApiMutation) SetAddCustomerLocation(b bool) {
	m.add_customer_location = &b
}

// AddCustomerLocation returns the value of the "add_customer_location" field in the mutation.
func (m *GoogleApiMutation) AddCustomerLocation() (r bool, exists bool) {
	v := m.add_customer_location
	if v == nil {
		return
	}
	return *v, true
}

// OldAddCustomerLocation returns the old "add_customer_location" field's value of the GoogleApi entity.
// If the GoogleApi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleApiMutation) OldAddCustomerLocation(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddCustomerLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddCustomerLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddCustomerLocation: %w", err)
	}
	return oldValue.AddCustomerLocation, nil
}

// ResetAddCustomerLocation resets all changes to the "add_customer_location" field.
func (m *GoogleApiMutation) ResetAddCustomerLocation() {
	m.add_customer_location = nil
}

// SetAutoGeocode sets the "auto_geocode" field.
func (m *GoogleApiMutation) SetAutoGeocode(b bool) {
	m.auto_geocode = &b
}

// AutoGeocode returns the value of the "auto_geocode" field in the mutation.
func (m *GoogleApiMutation) AutoGeocode() (r bool, exists bool) {
	v := m.auto_geocode
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoGeocode returns the old "auto_geocode" field's value of the GoogleApi entity.
// If the GoogleApi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleApiMutation) OldAutoGeocode(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoGeocode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoGeocode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoGeocode: %w", err)
	}
	return oldValue.AutoGeocode, nil
}

// ResetAutoGeocode resets all changes to the "auto_geocode" field.
func (m *GoogleApiMutation) ResetAutoGeocode() {
	m.auto_geocode = nil
}

// SetAddLocation sets the "add_location" field.
func (m *GoogleApiMutation) SetAddLocation(b bool) {
	m.add_location = &b
}

// AddLocation returns the value of the "add_location" field in the mutation.
func (m *GoogleApiMutation) AddLocation() (r bool, exists bool) {
	v := m.add_location
	if v == nil {
		return
	}
	return *v, true
}

// OldAddLocation returns the old "add_location" field's value of the GoogleApi entity.
// If the GoogleApi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleApiMutation) OldAddLocation(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddLocation: %w", err)
	}
	return oldValue.AddLocation, nil
}

// ResetAddLocation resets all changes to the "add_location" field.
func (m *GoogleApiMutation) ResetAddLocation() {
	m.add_location = nil
}

// SetTrafficModel sets the "traffic_model" field.
func (m *GoogleApiMutation) SetTrafficModel(gm googleapi.TrafficModel) {
	m.traffic_model = &gm
}

// TrafficModel returns the value of the "traffic_model" field in the mutation.
func (m *GoogleApiMutation) TrafficModel() (r googleapi.TrafficModel, exists bool) {
	v := m.traffic_model
	if v == nil {
		return
	}
	return *v, true
}

// OldTrafficModel returns the old "traffic_model" field's value of the GoogleApi entity.
// If the GoogleApi object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GoogleApiMutation) OldTrafficModel(ctx context.Context) (v googleapi.TrafficModel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrafficModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrafficModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrafficModel: %w", err)
	}
	return oldValue.TrafficModel, nil
}

// ResetTrafficModel resets all changes to the "traffic_model" field.
func (m *GoogleApiMutation) ResetTrafficModel() {
	m.traffic_model = nil
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *GoogleApiMutation) SetOrganizationID(id uuid.UUID) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *GoogleApiMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *GoogleApiMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *GoogleApiMutation) OrganizationID() (id uuid.UUID, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *GoogleApiMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *GoogleApiMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// SetBusinessUnitID sets the "business_unit" edge to the BusinessUnit entity by id.
func (m *GoogleApiMutation) SetBusinessUnitID(id uuid.UUID) {
	m.business_unit = &id
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *GoogleApiMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *GoogleApiMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitID returns the "business_unit" edge ID in the mutation.
func (m *GoogleApiMutation) BusinessUnitID() (id uuid.UUID, exists bool) {
	if m.business_unit != nil {
		return *m.business_unit, true
	}
	return
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *GoogleApiMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *GoogleApiMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// Where appends a list predicates to the GoogleApiMutation builder.
func (m *GoogleApiMutation) Where(ps ...predicate.GoogleApi) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GoogleApiMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GoogleApiMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GoogleApi, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GoogleApiMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GoogleApiMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GoogleApi).
func (m *GoogleApiMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GoogleApiMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, googleapi.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, googleapi.FieldUpdatedAt)
	}
	if m.api_key != nil {
		fields = append(fields, googleapi.FieldAPIKey)
	}
	if m.mileage_unit != nil {
		fields = append(fields, googleapi.FieldMileageUnit)
	}
	if m.add_customer_location != nil {
		fields = append(fields, googleapi.FieldAddCustomerLocation)
	}
	if m.auto_geocode != nil {
		fields = append(fields, googleapi.FieldAutoGeocode)
	}
	if m.add_location != nil {
		fields = append(fields, googleapi.FieldAddLocation)
	}
	if m.traffic_model != nil {
		fields = append(fields, googleapi.FieldTrafficModel)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GoogleApiMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case googleapi.FieldCreatedAt:
		return m.CreatedAt()
	case googleapi.FieldUpdatedAt:
		return m.UpdatedAt()
	case googleapi.FieldAPIKey:
		return m.APIKey()
	case googleapi.FieldMileageUnit:
		return m.MileageUnit()
	case googleapi.FieldAddCustomerLocation:
		return m.AddCustomerLocation()
	case googleapi.FieldAutoGeocode:
		return m.AutoGeocode()
	case googleapi.FieldAddLocation:
		return m.AddLocation()
	case googleapi.FieldTrafficModel:
		return m.TrafficModel()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GoogleApiMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case googleapi.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case googleapi.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case googleapi.FieldAPIKey:
		return m.OldAPIKey(ctx)
	case googleapi.FieldMileageUnit:
		return m.OldMileageUnit(ctx)
	case googleapi.FieldAddCustomerLocation:
		return m.OldAddCustomerLocation(ctx)
	case googleapi.FieldAutoGeocode:
		return m.OldAutoGeocode(ctx)
	case googleapi.FieldAddLocation:
		return m.OldAddLocation(ctx)
	case googleapi.FieldTrafficModel:
		return m.OldTrafficModel(ctx)
	}
	return nil, fmt.Errorf("unknown GoogleApi field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoogleApiMutation) SetField(name string, value ent.Value) error {
	switch name {
	case googleapi.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case googleapi.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case googleapi.FieldAPIKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIKey(v)
		return nil
	case googleapi.FieldMileageUnit:
		v, ok := value.(googleapi.MileageUnit)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMileageUnit(v)
		return nil
	case googleapi.FieldAddCustomerLocation:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddCustomerLocation(v)
		return nil
	case googleapi.FieldAutoGeocode:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoGeocode(v)
		return nil
	case googleapi.FieldAddLocation:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddLocation(v)
		return nil
	case googleapi.FieldTrafficModel:
		v, ok := value.(googleapi.TrafficModel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrafficModel(v)
		return nil
	}
	return fmt.Errorf("unknown GoogleApi field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GoogleApiMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GoogleApiMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GoogleApiMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GoogleApi numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GoogleApiMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GoogleApiMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GoogleApiMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GoogleApi nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GoogleApiMutation) ResetField(name string) error {
	switch name {
	case googleapi.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case googleapi.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case googleapi.FieldAPIKey:
		m.ResetAPIKey()
		return nil
	case googleapi.FieldMileageUnit:
		m.ResetMileageUnit()
		return nil
	case googleapi.FieldAddCustomerLocation:
		m.ResetAddCustomerLocation()
		return nil
	case googleapi.FieldAutoGeocode:
		m.ResetAutoGeocode()
		return nil
	case googleapi.FieldAddLocation:
		m.ResetAddLocation()
		return nil
	case googleapi.FieldTrafficModel:
		m.ResetTrafficModel()
		return nil
	}
	return fmt.Errorf("unknown GoogleApi field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GoogleApiMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.organization != nil {
		edges = append(edges, googleapi.EdgeOrganization)
	}
	if m.business_unit != nil {
		edges = append(edges, googleapi.EdgeBusinessUnit)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GoogleApiMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case googleapi.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case googleapi.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GoogleApiMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GoogleApiMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GoogleApiMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorganization {
		edges = append(edges, googleapi.EdgeOrganization)
	}
	if m.clearedbusiness_unit {
		edges = append(edges, googleapi.EdgeBusinessUnit)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GoogleApiMutation) EdgeCleared(name string) bool {
	switch name {
	case googleapi.EdgeOrganization:
		return m.clearedorganization
	case googleapi.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GoogleApiMutation) ClearEdge(name string) error {
	switch name {
	case googleapi.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case googleapi.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	}
	return fmt.Errorf("unknown GoogleApi unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GoogleApiMutation) ResetEdge(name string) error {
	switch name {
	case googleapi.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case googleapi.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	}
	return fmt.Errorf("unknown GoogleApi edge %s", name)
}

// HazardousMaterialMutation represents an operation that mutates the HazardousMaterial nodes in the graph.
type HazardousMaterialMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	status               *hazardousmaterial.Status
	name                 *string
	hazard_class         *hazardousmaterial.HazardClass
	erg_number           *string
	description          *string
	packing_group        *string
	proper_shipping_name *string
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	done                 bool
	oldValue             func(context.Context) (*HazardousMaterial, error)
	predicates           []predicate.HazardousMaterial
}

var _ ent.Mutation = (*HazardousMaterialMutation)(nil)

// hazardousmaterialOption allows management of the mutation configuration using functional options.
type hazardousmaterialOption func(*HazardousMaterialMutation)

// newHazardousMaterialMutation creates new mutation for the HazardousMaterial entity.
func newHazardousMaterialMutation(c config, op Op, opts ...hazardousmaterialOption) *HazardousMaterialMutation {
	m := &HazardousMaterialMutation{
		config:        c,
		op:            op,
		typ:           TypeHazardousMaterial,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHazardousMaterialID sets the ID field of the mutation.
func withHazardousMaterialID(id uuid.UUID) hazardousmaterialOption {
	return func(m *HazardousMaterialMutation) {
		var (
			err   error
			once  sync.Once
			value *HazardousMaterial
		)
		m.oldValue = func(ctx context.Context) (*HazardousMaterial, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HazardousMaterial.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHazardousMaterial sets the old HazardousMaterial of the mutation.
func withHazardousMaterial(node *HazardousMaterial) hazardousmaterialOption {
	return func(m *HazardousMaterialMutation) {
		m.oldValue = func(context.Context) (*HazardousMaterial, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HazardousMaterialMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HazardousMaterialMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of HazardousMaterial entities.
func (m *HazardousMaterialMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HazardousMaterialMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HazardousMaterialMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HazardousMaterial.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *HazardousMaterialMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *HazardousMaterialMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the HazardousMaterial entity.
// If the HazardousMaterial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HazardousMaterialMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *HazardousMaterialMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *HazardousMaterialMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *HazardousMaterialMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the HazardousMaterial entity.
// If the HazardousMaterial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HazardousMaterialMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *HazardousMaterialMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *HazardousMaterialMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HazardousMaterialMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the HazardousMaterial entity.
// If the HazardousMaterial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HazardousMaterialMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HazardousMaterialMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HazardousMaterialMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HazardousMaterialMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the HazardousMaterial entity.
// If the HazardousMaterial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HazardousMaterialMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HazardousMaterialMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *HazardousMaterialMutation) SetStatus(h hazardousmaterial.Status) {
	m.status = &h
}

// Status returns the value of the "status" field in the mutation.
func (m *HazardousMaterialMutation) Status() (r hazardousmaterial.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the HazardousMaterial entity.
// If the HazardousMaterial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HazardousMaterialMutation) OldStatus(ctx context.Context) (v hazardousmaterial.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *HazardousMaterialMutation) ResetStatus() {
	m.status = nil
}

// SetName sets the "name" field.
func (m *HazardousMaterialMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *HazardousMaterialMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the HazardousMaterial entity.
// If the HazardousMaterial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HazardousMaterialMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *HazardousMaterialMutation) ResetName() {
	m.name = nil
}

// SetHazardClass sets the "hazard_class" field.
func (m *HazardousMaterialMutation) SetHazardClass(hc hazardousmaterial.HazardClass) {
	m.hazard_class = &hc
}

// HazardClass returns the value of the "hazard_class" field in the mutation.
func (m *HazardousMaterialMutation) HazardClass() (r hazardousmaterial.HazardClass, exists bool) {
	v := m.hazard_class
	if v == nil {
		return
	}
	return *v, true
}

// OldHazardClass returns the old "hazard_class" field's value of the HazardousMaterial entity.
// If the HazardousMaterial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HazardousMaterialMutation) OldHazardClass(ctx context.Context) (v hazardousmaterial.HazardClass, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHazardClass is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHazardClass requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHazardClass: %w", err)
	}
	return oldValue.HazardClass, nil
}

// ResetHazardClass resets all changes to the "hazard_class" field.
func (m *HazardousMaterialMutation) ResetHazardClass() {
	m.hazard_class = nil
}

// SetErgNumber sets the "erg_number" field.
func (m *HazardousMaterialMutation) SetErgNumber(s string) {
	m.erg_number = &s
}

// ErgNumber returns the value of the "erg_number" field in the mutation.
func (m *HazardousMaterialMutation) ErgNumber() (r string, exists bool) {
	v := m.erg_number
	if v == nil {
		return
	}
	return *v, true
}

// OldErgNumber returns the old "erg_number" field's value of the HazardousMaterial entity.
// If the HazardousMaterial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HazardousMaterialMutation) OldErgNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErgNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErgNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErgNumber: %w", err)
	}
	return oldValue.ErgNumber, nil
}

// ClearErgNumber clears the value of the "erg_number" field.
func (m *HazardousMaterialMutation) ClearErgNumber() {
	m.erg_number = nil
	m.clearedFields[hazardousmaterial.FieldErgNumber] = struct{}{}
}

// ErgNumberCleared returns if the "erg_number" field was cleared in this mutation.
func (m *HazardousMaterialMutation) ErgNumberCleared() bool {
	_, ok := m.clearedFields[hazardousmaterial.FieldErgNumber]
	return ok
}

// ResetErgNumber resets all changes to the "erg_number" field.
func (m *HazardousMaterialMutation) ResetErgNumber() {
	m.erg_number = nil
	delete(m.clearedFields, hazardousmaterial.FieldErgNumber)
}

// SetDescription sets the "description" field.
func (m *HazardousMaterialMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *HazardousMaterialMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the HazardousMaterial entity.
// If the HazardousMaterial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HazardousMaterialMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *HazardousMaterialMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[hazardousmaterial.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *HazardousMaterialMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[hazardousmaterial.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *HazardousMaterialMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, hazardousmaterial.FieldDescription)
}

// SetPackingGroup sets the "packing_group" field.
func (m *HazardousMaterialMutation) SetPackingGroup(s string) {
	m.packing_group = &s
}

// PackingGroup returns the value of the "packing_group" field in the mutation.
func (m *HazardousMaterialMutation) PackingGroup() (r string, exists bool) {
	v := m.packing_group
	if v == nil {
		return
	}
	return *v, true
}

// OldPackingGroup returns the old "packing_group" field's value of the HazardousMaterial entity.
// If the HazardousMaterial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HazardousMaterialMutation) OldPackingGroup(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPackingGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPackingGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPackingGroup: %w", err)
	}
	return oldValue.PackingGroup, nil
}

// ClearPackingGroup clears the value of the "packing_group" field.
func (m *HazardousMaterialMutation) ClearPackingGroup() {
	m.packing_group = nil
	m.clearedFields[hazardousmaterial.FieldPackingGroup] = struct{}{}
}

// PackingGroupCleared returns if the "packing_group" field was cleared in this mutation.
func (m *HazardousMaterialMutation) PackingGroupCleared() bool {
	_, ok := m.clearedFields[hazardousmaterial.FieldPackingGroup]
	return ok
}

// ResetPackingGroup resets all changes to the "packing_group" field.
func (m *HazardousMaterialMutation) ResetPackingGroup() {
	m.packing_group = nil
	delete(m.clearedFields, hazardousmaterial.FieldPackingGroup)
}

// SetProperShippingName sets the "proper_shipping_name" field.
func (m *HazardousMaterialMutation) SetProperShippingName(s string) {
	m.proper_shipping_name = &s
}

// ProperShippingName returns the value of the "proper_shipping_name" field in the mutation.
func (m *HazardousMaterialMutation) ProperShippingName() (r string, exists bool) {
	v := m.proper_shipping_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProperShippingName returns the old "proper_shipping_name" field's value of the HazardousMaterial entity.
// If the HazardousMaterial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HazardousMaterialMutation) OldProperShippingName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProperShippingName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProperShippingName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProperShippingName: %w", err)
	}
	return oldValue.ProperShippingName, nil
}

// ClearProperShippingName clears the value of the "proper_shipping_name" field.
func (m *HazardousMaterialMutation) ClearProperShippingName() {
	m.proper_shipping_name = nil
	m.clearedFields[hazardousmaterial.FieldProperShippingName] = struct{}{}
}

// ProperShippingNameCleared returns if the "proper_shipping_name" field was cleared in this mutation.
func (m *HazardousMaterialMutation) ProperShippingNameCleared() bool {
	_, ok := m.clearedFields[hazardousmaterial.FieldProperShippingName]
	return ok
}

// ResetProperShippingName resets all changes to the "proper_shipping_name" field.
func (m *HazardousMaterialMutation) ResetProperShippingName() {
	m.proper_shipping_name = nil
	delete(m.clearedFields, hazardousmaterial.FieldProperShippingName)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *HazardousMaterialMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[hazardousmaterial.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *HazardousMaterialMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *HazardousMaterialMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *HazardousMaterialMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *HazardousMaterialMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[hazardousmaterial.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *HazardousMaterialMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *HazardousMaterialMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *HazardousMaterialMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the HazardousMaterialMutation builder.
func (m *HazardousMaterialMutation) Where(ps ...predicate.HazardousMaterial) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HazardousMaterialMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HazardousMaterialMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HazardousMaterial, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HazardousMaterialMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HazardousMaterialMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HazardousMaterial).
func (m *HazardousMaterialMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HazardousMaterialMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.business_unit != nil {
		fields = append(fields, hazardousmaterial.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, hazardousmaterial.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, hazardousmaterial.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, hazardousmaterial.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, hazardousmaterial.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, hazardousmaterial.FieldName)
	}
	if m.hazard_class != nil {
		fields = append(fields, hazardousmaterial.FieldHazardClass)
	}
	if m.erg_number != nil {
		fields = append(fields, hazardousmaterial.FieldErgNumber)
	}
	if m.description != nil {
		fields = append(fields, hazardousmaterial.FieldDescription)
	}
	if m.packing_group != nil {
		fields = append(fields, hazardousmaterial.FieldPackingGroup)
	}
	if m.proper_shipping_name != nil {
		fields = append(fields, hazardousmaterial.FieldProperShippingName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HazardousMaterialMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hazardousmaterial.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case hazardousmaterial.FieldOrganizationID:
		return m.OrganizationID()
	case hazardousmaterial.FieldCreatedAt:
		return m.CreatedAt()
	case hazardousmaterial.FieldUpdatedAt:
		return m.UpdatedAt()
	case hazardousmaterial.FieldStatus:
		return m.Status()
	case hazardousmaterial.FieldName:
		return m.Name()
	case hazardousmaterial.FieldHazardClass:
		return m.HazardClass()
	case hazardousmaterial.FieldErgNumber:
		return m.ErgNumber()
	case hazardousmaterial.FieldDescription:
		return m.Description()
	case hazardousmaterial.FieldPackingGroup:
		return m.PackingGroup()
	case hazardousmaterial.FieldProperShippingName:
		return m.ProperShippingName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HazardousMaterialMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hazardousmaterial.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case hazardousmaterial.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case hazardousmaterial.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case hazardousmaterial.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case hazardousmaterial.FieldStatus:
		return m.OldStatus(ctx)
	case hazardousmaterial.FieldName:
		return m.OldName(ctx)
	case hazardousmaterial.FieldHazardClass:
		return m.OldHazardClass(ctx)
	case hazardousmaterial.FieldErgNumber:
		return m.OldErgNumber(ctx)
	case hazardousmaterial.FieldDescription:
		return m.OldDescription(ctx)
	case hazardousmaterial.FieldPackingGroup:
		return m.OldPackingGroup(ctx)
	case hazardousmaterial.FieldProperShippingName:
		return m.OldProperShippingName(ctx)
	}
	return nil, fmt.Errorf("unknown HazardousMaterial field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HazardousMaterialMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hazardousmaterial.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case hazardousmaterial.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case hazardousmaterial.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case hazardousmaterial.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case hazardousmaterial.FieldStatus:
		v, ok := value.(hazardousmaterial.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case hazardousmaterial.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case hazardousmaterial.FieldHazardClass:
		v, ok := value.(hazardousmaterial.HazardClass)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHazardClass(v)
		return nil
	case hazardousmaterial.FieldErgNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErgNumber(v)
		return nil
	case hazardousmaterial.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case hazardousmaterial.FieldPackingGroup:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPackingGroup(v)
		return nil
	case hazardousmaterial.FieldProperShippingName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProperShippingName(v)
		return nil
	}
	return fmt.Errorf("unknown HazardousMaterial field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HazardousMaterialMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HazardousMaterialMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HazardousMaterialMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown HazardousMaterial numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HazardousMaterialMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(hazardousmaterial.FieldErgNumber) {
		fields = append(fields, hazardousmaterial.FieldErgNumber)
	}
	if m.FieldCleared(hazardousmaterial.FieldDescription) {
		fields = append(fields, hazardousmaterial.FieldDescription)
	}
	if m.FieldCleared(hazardousmaterial.FieldPackingGroup) {
		fields = append(fields, hazardousmaterial.FieldPackingGroup)
	}
	if m.FieldCleared(hazardousmaterial.FieldProperShippingName) {
		fields = append(fields, hazardousmaterial.FieldProperShippingName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HazardousMaterialMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HazardousMaterialMutation) ClearField(name string) error {
	switch name {
	case hazardousmaterial.FieldErgNumber:
		m.ClearErgNumber()
		return nil
	case hazardousmaterial.FieldDescription:
		m.ClearDescription()
		return nil
	case hazardousmaterial.FieldPackingGroup:
		m.ClearPackingGroup()
		return nil
	case hazardousmaterial.FieldProperShippingName:
		m.ClearProperShippingName()
		return nil
	}
	return fmt.Errorf("unknown HazardousMaterial nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HazardousMaterialMutation) ResetField(name string) error {
	switch name {
	case hazardousmaterial.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case hazardousmaterial.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case hazardousmaterial.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case hazardousmaterial.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case hazardousmaterial.FieldStatus:
		m.ResetStatus()
		return nil
	case hazardousmaterial.FieldName:
		m.ResetName()
		return nil
	case hazardousmaterial.FieldHazardClass:
		m.ResetHazardClass()
		return nil
	case hazardousmaterial.FieldErgNumber:
		m.ResetErgNumber()
		return nil
	case hazardousmaterial.FieldDescription:
		m.ResetDescription()
		return nil
	case hazardousmaterial.FieldPackingGroup:
		m.ResetPackingGroup()
		return nil
	case hazardousmaterial.FieldProperShippingName:
		m.ResetProperShippingName()
		return nil
	}
	return fmt.Errorf("unknown HazardousMaterial field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HazardousMaterialMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.business_unit != nil {
		edges = append(edges, hazardousmaterial.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, hazardousmaterial.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HazardousMaterialMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hazardousmaterial.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case hazardousmaterial.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HazardousMaterialMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HazardousMaterialMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HazardousMaterialMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbusiness_unit {
		edges = append(edges, hazardousmaterial.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, hazardousmaterial.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HazardousMaterialMutation) EdgeCleared(name string) bool {
	switch name {
	case hazardousmaterial.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case hazardousmaterial.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HazardousMaterialMutation) ClearEdge(name string) error {
	switch name {
	case hazardousmaterial.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case hazardousmaterial.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown HazardousMaterial unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HazardousMaterialMutation) ResetEdge(name string) error {
	switch name {
	case hazardousmaterial.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case hazardousmaterial.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown HazardousMaterial edge %s", name)
}

// HazardousMaterialSegregationMutation represents an operation that mutates the HazardousMaterialSegregation nodes in the graph.
type HazardousMaterialSegregationMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	class_a              *hazardousmaterialsegregation.ClassA
	class_b              *hazardousmaterialsegregation.ClassB
	segregation_type     *hazardousmaterialsegregation.SegregationType
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	done                 bool
	oldValue             func(context.Context) (*HazardousMaterialSegregation, error)
	predicates           []predicate.HazardousMaterialSegregation
}

var _ ent.Mutation = (*HazardousMaterialSegregationMutation)(nil)

// hazardousmaterialsegregationOption allows management of the mutation configuration using functional options.
type hazardousmaterialsegregationOption func(*HazardousMaterialSegregationMutation)

// newHazardousMaterialSegregationMutation creates new mutation for the HazardousMaterialSegregation entity.
func newHazardousMaterialSegregationMutation(c config, op Op, opts ...hazardousmaterialsegregationOption) *HazardousMaterialSegregationMutation {
	m := &HazardousMaterialSegregationMutation{
		config:        c,
		op:            op,
		typ:           TypeHazardousMaterialSegregation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHazardousMaterialSegregationID sets the ID field of the mutation.
func withHazardousMaterialSegregationID(id uuid.UUID) hazardousmaterialsegregationOption {
	return func(m *HazardousMaterialSegregationMutation) {
		var (
			err   error
			once  sync.Once
			value *HazardousMaterialSegregation
		)
		m.oldValue = func(ctx context.Context) (*HazardousMaterialSegregation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HazardousMaterialSegregation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHazardousMaterialSegregation sets the old HazardousMaterialSegregation of the mutation.
func withHazardousMaterialSegregation(node *HazardousMaterialSegregation) hazardousmaterialsegregationOption {
	return func(m *HazardousMaterialSegregationMutation) {
		m.oldValue = func(context.Context) (*HazardousMaterialSegregation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HazardousMaterialSegregationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HazardousMaterialSegregationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of HazardousMaterialSegregation entities.
func (m *HazardousMaterialSegregationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HazardousMaterialSegregationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HazardousMaterialSegregationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HazardousMaterialSegregation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *HazardousMaterialSegregationMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *HazardousMaterialSegregationMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the HazardousMaterialSegregation entity.
// If the HazardousMaterialSegregation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HazardousMaterialSegregationMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *HazardousMaterialSegregationMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *HazardousMaterialSegregationMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *HazardousMaterialSegregationMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the HazardousMaterialSegregation entity.
// If the HazardousMaterialSegregation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HazardousMaterialSegregationMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *HazardousMaterialSegregationMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *HazardousMaterialSegregationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HazardousMaterialSegregationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the HazardousMaterialSegregation entity.
// If the HazardousMaterialSegregation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HazardousMaterialSegregationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HazardousMaterialSegregationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HazardousMaterialSegregationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HazardousMaterialSegregationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the HazardousMaterialSegregation entity.
// If the HazardousMaterialSegregation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HazardousMaterialSegregationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HazardousMaterialSegregationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetClassA sets the "class_a" field.
func (m *HazardousMaterialSegregationMutation) SetClassA(h hazardousmaterialsegregation.ClassA) {
	m.class_a = &h
}

// ClassA returns the value of the "class_a" field in the mutation.
func (m *HazardousMaterialSegregationMutation) ClassA() (r hazardousmaterialsegregation.ClassA, exists bool) {
	v := m.class_a
	if v == nil {
		return
	}
	return *v, true
}

// OldClassA returns the old "class_a" field's value of the HazardousMaterialSegregation entity.
// If the HazardousMaterialSegregation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HazardousMaterialSegregationMutation) OldClassA(ctx context.Context) (v hazardousmaterialsegregation.ClassA, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClassA is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClassA requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassA: %w", err)
	}
	return oldValue.ClassA, nil
}

// ResetClassA resets all changes to the "class_a" field.
func (m *HazardousMaterialSegregationMutation) ResetClassA() {
	m.class_a = nil
}

// SetClassB sets the "class_b" field.
func (m *HazardousMaterialSegregationMutation) SetClassB(h hazardousmaterialsegregation.ClassB) {
	m.class_b = &h
}

// ClassB returns the value of the "class_b" field in the mutation.
func (m *HazardousMaterialSegregationMutation) ClassB() (r hazardousmaterialsegregation.ClassB, exists bool) {
	v := m.class_b
	if v == nil {
		return
	}
	return *v, true
}

// OldClassB returns the old "class_b" field's value of the HazardousMaterialSegregation entity.
// If the HazardousMaterialSegregation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HazardousMaterialSegregationMutation) OldClassB(ctx context.Context) (v hazardousmaterialsegregation.ClassB, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClassB is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClassB requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClassB: %w", err)
	}
	return oldValue.ClassB, nil
}

// ResetClassB resets all changes to the "class_b" field.
func (m *HazardousMaterialSegregationMutation) ResetClassB() {
	m.class_b = nil
}

// SetSegregationType sets the "segregation_type" field.
func (m *HazardousMaterialSegregationMutation) SetSegregationType(ht hazardousmaterialsegregation.SegregationType) {
	m.segregation_type = &ht
}

// SegregationType returns the value of the "segregation_type" field in the mutation.
func (m *HazardousMaterialSegregationMutation) SegregationType() (r hazardousmaterialsegregation.SegregationType, exists bool) {
	v := m.segregation_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSegregationType returns the old "segregation_type" field's value of the HazardousMaterialSegregation entity.
// If the HazardousMaterialSegregation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HazardousMaterialSegregationMutation) OldSegregationType(ctx context.Context) (v hazardousmaterialsegregation.SegregationType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSegregationType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSegregationType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSegregationType: %w", err)
	}
	return oldValue.SegregationType, nil
}

// ResetSegregationType resets all changes to the "segregation_type" field.
func (m *HazardousMaterialSegregationMutation) ResetSegregationType() {
	m.segregation_type = nil
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *HazardousMaterialSegregationMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[hazardousmaterialsegregation.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *HazardousMaterialSegregationMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *HazardousMaterialSegregationMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *HazardousMaterialSegregationMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *HazardousMaterialSegregationMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[hazardousmaterialsegregation.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *HazardousMaterialSegregationMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *HazardousMaterialSegregationMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *HazardousMaterialSegregationMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the HazardousMaterialSegregationMutation builder.
func (m *HazardousMaterialSegregationMutation) Where(ps ...predicate.HazardousMaterialSegregation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HazardousMaterialSegregationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HazardousMaterialSegregationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HazardousMaterialSegregation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HazardousMaterialSegregationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HazardousMaterialSegregationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HazardousMaterialSegregation).
func (m *HazardousMaterialSegregationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HazardousMaterialSegregationMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.business_unit != nil {
		fields = append(fields, hazardousmaterialsegregation.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, hazardousmaterialsegregation.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, hazardousmaterialsegregation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, hazardousmaterialsegregation.FieldUpdatedAt)
	}
	if m.class_a != nil {
		fields = append(fields, hazardousmaterialsegregation.FieldClassA)
	}
	if m.class_b != nil {
		fields = append(fields, hazardousmaterialsegregation.FieldClassB)
	}
	if m.segregation_type != nil {
		fields = append(fields, hazardousmaterialsegregation.FieldSegregationType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HazardousMaterialSegregationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hazardousmaterialsegregation.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case hazardousmaterialsegregation.FieldOrganizationID:
		return m.OrganizationID()
	case hazardousmaterialsegregation.FieldCreatedAt:
		return m.CreatedAt()
	case hazardousmaterialsegregation.FieldUpdatedAt:
		return m.UpdatedAt()
	case hazardousmaterialsegregation.FieldClassA:
		return m.ClassA()
	case hazardousmaterialsegregation.FieldClassB:
		return m.ClassB()
	case hazardousmaterialsegregation.FieldSegregationType:
		return m.SegregationType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HazardousMaterialSegregationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hazardousmaterialsegregation.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case hazardousmaterialsegregation.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case hazardousmaterialsegregation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case hazardousmaterialsegregation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case hazardousmaterialsegregation.FieldClassA:
		return m.OldClassA(ctx)
	case hazardousmaterialsegregation.FieldClassB:
		return m.OldClassB(ctx)
	case hazardousmaterialsegregation.FieldSegregationType:
		return m.OldSegregationType(ctx)
	}
	return nil, fmt.Errorf("unknown HazardousMaterialSegregation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HazardousMaterialSegregationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hazardousmaterialsegregation.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case hazardousmaterialsegregation.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case hazardousmaterialsegregation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case hazardousmaterialsegregation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case hazardousmaterialsegregation.FieldClassA:
		v, ok := value.(hazardousmaterialsegregation.ClassA)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassA(v)
		return nil
	case hazardousmaterialsegregation.FieldClassB:
		v, ok := value.(hazardousmaterialsegregation.ClassB)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClassB(v)
		return nil
	case hazardousmaterialsegregation.FieldSegregationType:
		v, ok := value.(hazardousmaterialsegregation.SegregationType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSegregationType(v)
		return nil
	}
	return fmt.Errorf("unknown HazardousMaterialSegregation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HazardousMaterialSegregationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HazardousMaterialSegregationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HazardousMaterialSegregationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown HazardousMaterialSegregation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HazardousMaterialSegregationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HazardousMaterialSegregationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HazardousMaterialSegregationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown HazardousMaterialSegregation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HazardousMaterialSegregationMutation) ResetField(name string) error {
	switch name {
	case hazardousmaterialsegregation.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case hazardousmaterialsegregation.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case hazardousmaterialsegregation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case hazardousmaterialsegregation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case hazardousmaterialsegregation.FieldClassA:
		m.ResetClassA()
		return nil
	case hazardousmaterialsegregation.FieldClassB:
		m.ResetClassB()
		return nil
	case hazardousmaterialsegregation.FieldSegregationType:
		m.ResetSegregationType()
		return nil
	}
	return fmt.Errorf("unknown HazardousMaterialSegregation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HazardousMaterialSegregationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.business_unit != nil {
		edges = append(edges, hazardousmaterialsegregation.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, hazardousmaterialsegregation.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HazardousMaterialSegregationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hazardousmaterialsegregation.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case hazardousmaterialsegregation.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HazardousMaterialSegregationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HazardousMaterialSegregationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HazardousMaterialSegregationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbusiness_unit {
		edges = append(edges, hazardousmaterialsegregation.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, hazardousmaterialsegregation.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HazardousMaterialSegregationMutation) EdgeCleared(name string) bool {
	switch name {
	case hazardousmaterialsegregation.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case hazardousmaterialsegregation.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HazardousMaterialSegregationMutation) ClearEdge(name string) error {
	switch name {
	case hazardousmaterialsegregation.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case hazardousmaterialsegregation.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown HazardousMaterialSegregation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HazardousMaterialSegregationMutation) ResetEdge(name string) error {
	switch name {
	case hazardousmaterialsegregation.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case hazardousmaterialsegregation.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown HazardousMaterialSegregation edge %s", name)
}

// InvoiceControlMutation represents an operation that mutates the InvoiceControl nodes in the graph.
type InvoiceControlMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	created_at                *time.Time
	updated_at                *time.Time
	invoice_number_prefix     *string
	credit_memo_number_prefix *string
	invoice_terms             *string
	invoice_footer            *string
	invoice_logo_url          *string
	invoice_date_format       *invoicecontrol.InvoiceDateFormat
	invoice_due_after_days    *uint8
	addinvoice_due_after_days *int8
	invoice_logo_width        *uint16
	addinvoice_logo_width     *int16
	show_amount_due           *bool
	attach_pdf                *bool
	show_invoice_due_date     *bool
	clearedFields             map[string]struct{}
	organization              *uuid.UUID
	clearedorganization       bool
	business_unit             *uuid.UUID
	clearedbusiness_unit      bool
	done                      bool
	oldValue                  func(context.Context) (*InvoiceControl, error)
	predicates                []predicate.InvoiceControl
}

var _ ent.Mutation = (*InvoiceControlMutation)(nil)

// invoicecontrolOption allows management of the mutation configuration using functional options.
type invoicecontrolOption func(*InvoiceControlMutation)

// newInvoiceControlMutation creates new mutation for the InvoiceControl entity.
func newInvoiceControlMutation(c config, op Op, opts ...invoicecontrolOption) *InvoiceControlMutation {
	m := &InvoiceControlMutation{
		config:        c,
		op:            op,
		typ:           TypeInvoiceControl,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvoiceControlID sets the ID field of the mutation.
func withInvoiceControlID(id uuid.UUID) invoicecontrolOption {
	return func(m *InvoiceControlMutation) {
		var (
			err   error
			once  sync.Once
			value *InvoiceControl
		)
		m.oldValue = func(ctx context.Context) (*InvoiceControl, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InvoiceControl.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvoiceControl sets the old InvoiceControl of the mutation.
func withInvoiceControl(node *InvoiceControl) invoicecontrolOption {
	return func(m *InvoiceControlMutation) {
		m.oldValue = func(context.Context) (*InvoiceControl, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InvoiceControlMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InvoiceControlMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InvoiceControl entities.
func (m *InvoiceControlMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InvoiceControlMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InvoiceControlMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InvoiceControl.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InvoiceControlMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InvoiceControlMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InvoiceControl entity.
// If the InvoiceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceControlMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InvoiceControlMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InvoiceControlMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InvoiceControlMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the InvoiceControl entity.
// If the InvoiceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceControlMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InvoiceControlMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetInvoiceNumberPrefix sets the "invoice_number_prefix" field.
func (m *InvoiceControlMutation) SetInvoiceNumberPrefix(s string) {
	m.invoice_number_prefix = &s
}

// InvoiceNumberPrefix returns the value of the "invoice_number_prefix" field in the mutation.
func (m *InvoiceControlMutation) InvoiceNumberPrefix() (r string, exists bool) {
	v := m.invoice_number_prefix
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceNumberPrefix returns the old "invoice_number_prefix" field's value of the InvoiceControl entity.
// If the InvoiceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceControlMutation) OldInvoiceNumberPrefix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceNumberPrefix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceNumberPrefix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceNumberPrefix: %w", err)
	}
	return oldValue.InvoiceNumberPrefix, nil
}

// ResetInvoiceNumberPrefix resets all changes to the "invoice_number_prefix" field.
func (m *InvoiceControlMutation) ResetInvoiceNumberPrefix() {
	m.invoice_number_prefix = nil
}

// SetCreditMemoNumberPrefix sets the "credit_memo_number_prefix" field.
func (m *InvoiceControlMutation) SetCreditMemoNumberPrefix(s string) {
	m.credit_memo_number_prefix = &s
}

// CreditMemoNumberPrefix returns the value of the "credit_memo_number_prefix" field in the mutation.
func (m *InvoiceControlMutation) CreditMemoNumberPrefix() (r string, exists bool) {
	v := m.credit_memo_number_prefix
	if v == nil {
		return
	}
	return *v, true
}

// OldCreditMemoNumberPrefix returns the old "credit_memo_number_prefix" field's value of the InvoiceControl entity.
// If the InvoiceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceControlMutation) OldCreditMemoNumberPrefix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreditMemoNumberPrefix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreditMemoNumberPrefix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreditMemoNumberPrefix: %w", err)
	}
	return oldValue.CreditMemoNumberPrefix, nil
}

// ResetCreditMemoNumberPrefix resets all changes to the "credit_memo_number_prefix" field.
func (m *InvoiceControlMutation) ResetCreditMemoNumberPrefix() {
	m.credit_memo_number_prefix = nil
}

// SetInvoiceTerms sets the "invoice_terms" field.
func (m *InvoiceControlMutation) SetInvoiceTerms(s string) {
	m.invoice_terms = &s
}

// InvoiceTerms returns the value of the "invoice_terms" field in the mutation.
func (m *InvoiceControlMutation) InvoiceTerms() (r string, exists bool) {
	v := m.invoice_terms
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceTerms returns the old "invoice_terms" field's value of the InvoiceControl entity.
// If the InvoiceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceControlMutation) OldInvoiceTerms(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceTerms is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceTerms requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceTerms: %w", err)
	}
	return oldValue.InvoiceTerms, nil
}

// ClearInvoiceTerms clears the value of the "invoice_terms" field.
func (m *InvoiceControlMutation) ClearInvoiceTerms() {
	m.invoice_terms = nil
	m.clearedFields[invoicecontrol.FieldInvoiceTerms] = struct{}{}
}

// InvoiceTermsCleared returns if the "invoice_terms" field was cleared in this mutation.
func (m *InvoiceControlMutation) InvoiceTermsCleared() bool {
	_, ok := m.clearedFields[invoicecontrol.FieldInvoiceTerms]
	return ok
}

// ResetInvoiceTerms resets all changes to the "invoice_terms" field.
func (m *InvoiceControlMutation) ResetInvoiceTerms() {
	m.invoice_terms = nil
	delete(m.clearedFields, invoicecontrol.FieldInvoiceTerms)
}

// SetInvoiceFooter sets the "invoice_footer" field.
func (m *InvoiceControlMutation) SetInvoiceFooter(s string) {
	m.invoice_footer = &s
}

// InvoiceFooter returns the value of the "invoice_footer" field in the mutation.
func (m *InvoiceControlMutation) InvoiceFooter() (r string, exists bool) {
	v := m.invoice_footer
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceFooter returns the old "invoice_footer" field's value of the InvoiceControl entity.
// If the InvoiceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceControlMutation) OldInvoiceFooter(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceFooter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceFooter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceFooter: %w", err)
	}
	return oldValue.InvoiceFooter, nil
}

// ClearInvoiceFooter clears the value of the "invoice_footer" field.
func (m *InvoiceControlMutation) ClearInvoiceFooter() {
	m.invoice_footer = nil
	m.clearedFields[invoicecontrol.FieldInvoiceFooter] = struct{}{}
}

// InvoiceFooterCleared returns if the "invoice_footer" field was cleared in this mutation.
func (m *InvoiceControlMutation) InvoiceFooterCleared() bool {
	_, ok := m.clearedFields[invoicecontrol.FieldInvoiceFooter]
	return ok
}

// ResetInvoiceFooter resets all changes to the "invoice_footer" field.
func (m *InvoiceControlMutation) ResetInvoiceFooter() {
	m.invoice_footer = nil
	delete(m.clearedFields, invoicecontrol.FieldInvoiceFooter)
}

// SetInvoiceLogoURL sets the "invoice_logo_url" field.
func (m *InvoiceControlMutation) SetInvoiceLogoURL(s string) {
	m.invoice_logo_url = &s
}

// InvoiceLogoURL returns the value of the "invoice_logo_url" field in the mutation.
func (m *InvoiceControlMutation) InvoiceLogoURL() (r string, exists bool) {
	v := m.invoice_logo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceLogoURL returns the old "invoice_logo_url" field's value of the InvoiceControl entity.
// If the InvoiceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceControlMutation) OldInvoiceLogoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceLogoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceLogoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceLogoURL: %w", err)
	}
	return oldValue.InvoiceLogoURL, nil
}

// ClearInvoiceLogoURL clears the value of the "invoice_logo_url" field.
func (m *InvoiceControlMutation) ClearInvoiceLogoURL() {
	m.invoice_logo_url = nil
	m.clearedFields[invoicecontrol.FieldInvoiceLogoURL] = struct{}{}
}

// InvoiceLogoURLCleared returns if the "invoice_logo_url" field was cleared in this mutation.
func (m *InvoiceControlMutation) InvoiceLogoURLCleared() bool {
	_, ok := m.clearedFields[invoicecontrol.FieldInvoiceLogoURL]
	return ok
}

// ResetInvoiceLogoURL resets all changes to the "invoice_logo_url" field.
func (m *InvoiceControlMutation) ResetInvoiceLogoURL() {
	m.invoice_logo_url = nil
	delete(m.clearedFields, invoicecontrol.FieldInvoiceLogoURL)
}

// SetInvoiceDateFormat sets the "invoice_date_format" field.
func (m *InvoiceControlMutation) SetInvoiceDateFormat(idf invoicecontrol.InvoiceDateFormat) {
	m.invoice_date_format = &idf
}

// InvoiceDateFormat returns the value of the "invoice_date_format" field in the mutation.
func (m *InvoiceControlMutation) InvoiceDateFormat() (r invoicecontrol.InvoiceDateFormat, exists bool) {
	v := m.invoice_date_format
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceDateFormat returns the old "invoice_date_format" field's value of the InvoiceControl entity.
// If the InvoiceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceControlMutation) OldInvoiceDateFormat(ctx context.Context) (v invoicecontrol.InvoiceDateFormat, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceDateFormat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceDateFormat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceDateFormat: %w", err)
	}
	return oldValue.InvoiceDateFormat, nil
}

// ResetInvoiceDateFormat resets all changes to the "invoice_date_format" field.
func (m *InvoiceControlMutation) ResetInvoiceDateFormat() {
	m.invoice_date_format = nil
}

// SetInvoiceDueAfterDays sets the "invoice_due_after_days" field.
func (m *InvoiceControlMutation) SetInvoiceDueAfterDays(u uint8) {
	m.invoice_due_after_days = &u
	m.addinvoice_due_after_days = nil
}

// InvoiceDueAfterDays returns the value of the "invoice_due_after_days" field in the mutation.
func (m *InvoiceControlMutation) InvoiceDueAfterDays() (r uint8, exists bool) {
	v := m.invoice_due_after_days
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceDueAfterDays returns the old "invoice_due_after_days" field's value of the InvoiceControl entity.
// If the InvoiceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceControlMutation) OldInvoiceDueAfterDays(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceDueAfterDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceDueAfterDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceDueAfterDays: %w", err)
	}
	return oldValue.InvoiceDueAfterDays, nil
}

// AddInvoiceDueAfterDays adds u to the "invoice_due_after_days" field.
func (m *InvoiceControlMutation) AddInvoiceDueAfterDays(u int8) {
	if m.addinvoice_due_after_days != nil {
		*m.addinvoice_due_after_days += u
	} else {
		m.addinvoice_due_after_days = &u
	}
}

// AddedInvoiceDueAfterDays returns the value that was added to the "invoice_due_after_days" field in this mutation.
func (m *InvoiceControlMutation) AddedInvoiceDueAfterDays() (r int8, exists bool) {
	v := m.addinvoice_due_after_days
	if v == nil {
		return
	}
	return *v, true
}

// ResetInvoiceDueAfterDays resets all changes to the "invoice_due_after_days" field.
func (m *InvoiceControlMutation) ResetInvoiceDueAfterDays() {
	m.invoice_due_after_days = nil
	m.addinvoice_due_after_days = nil
}

// SetInvoiceLogoWidth sets the "invoice_logo_width" field.
func (m *InvoiceControlMutation) SetInvoiceLogoWidth(u uint16) {
	m.invoice_logo_width = &u
	m.addinvoice_logo_width = nil
}

// InvoiceLogoWidth returns the value of the "invoice_logo_width" field in the mutation.
func (m *InvoiceControlMutation) InvoiceLogoWidth() (r uint16, exists bool) {
	v := m.invoice_logo_width
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceLogoWidth returns the old "invoice_logo_width" field's value of the InvoiceControl entity.
// If the InvoiceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceControlMutation) OldInvoiceLogoWidth(ctx context.Context) (v uint16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceLogoWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceLogoWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceLogoWidth: %w", err)
	}
	return oldValue.InvoiceLogoWidth, nil
}

// AddInvoiceLogoWidth adds u to the "invoice_logo_width" field.
func (m *InvoiceControlMutation) AddInvoiceLogoWidth(u int16) {
	if m.addinvoice_logo_width != nil {
		*m.addinvoice_logo_width += u
	} else {
		m.addinvoice_logo_width = &u
	}
}

// AddedInvoiceLogoWidth returns the value that was added to the "invoice_logo_width" field in this mutation.
func (m *InvoiceControlMutation) AddedInvoiceLogoWidth() (r int16, exists bool) {
	v := m.addinvoice_logo_width
	if v == nil {
		return
	}
	return *v, true
}

// ResetInvoiceLogoWidth resets all changes to the "invoice_logo_width" field.
func (m *InvoiceControlMutation) ResetInvoiceLogoWidth() {
	m.invoice_logo_width = nil
	m.addinvoice_logo_width = nil
}

// SetShowAmountDue sets the "show_amount_due" field.
func (m *InvoiceControlMutation) SetShowAmountDue(b bool) {
	m.show_amount_due = &b
}

// ShowAmountDue returns the value of the "show_amount_due" field in the mutation.
func (m *InvoiceControlMutation) ShowAmountDue() (r bool, exists bool) {
	v := m.show_amount_due
	if v == nil {
		return
	}
	return *v, true
}

// OldShowAmountDue returns the old "show_amount_due" field's value of the InvoiceControl entity.
// If the InvoiceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceControlMutation) OldShowAmountDue(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShowAmountDue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShowAmountDue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShowAmountDue: %w", err)
	}
	return oldValue.ShowAmountDue, nil
}

// ResetShowAmountDue resets all changes to the "show_amount_due" field.
func (m *InvoiceControlMutation) ResetShowAmountDue() {
	m.show_amount_due = nil
}

// SetAttachPdf sets the "attach_pdf" field.
func (m *InvoiceControlMutation) SetAttachPdf(b bool) {
	m.attach_pdf = &b
}

// AttachPdf returns the value of the "attach_pdf" field in the mutation.
func (m *InvoiceControlMutation) AttachPdf() (r bool, exists bool) {
	v := m.attach_pdf
	if v == nil {
		return
	}
	return *v, true
}

// OldAttachPdf returns the old "attach_pdf" field's value of the InvoiceControl entity.
// If the InvoiceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceControlMutation) OldAttachPdf(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttachPdf is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttachPdf requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttachPdf: %w", err)
	}
	return oldValue.AttachPdf, nil
}

// ResetAttachPdf resets all changes to the "attach_pdf" field.
func (m *InvoiceControlMutation) ResetAttachPdf() {
	m.attach_pdf = nil
}

// SetShowInvoiceDueDate sets the "show_invoice_due_date" field.
func (m *InvoiceControlMutation) SetShowInvoiceDueDate(b bool) {
	m.show_invoice_due_date = &b
}

// ShowInvoiceDueDate returns the value of the "show_invoice_due_date" field in the mutation.
func (m *InvoiceControlMutation) ShowInvoiceDueDate() (r bool, exists bool) {
	v := m.show_invoice_due_date
	if v == nil {
		return
	}
	return *v, true
}

// OldShowInvoiceDueDate returns the old "show_invoice_due_date" field's value of the InvoiceControl entity.
// If the InvoiceControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvoiceControlMutation) OldShowInvoiceDueDate(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShowInvoiceDueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShowInvoiceDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShowInvoiceDueDate: %w", err)
	}
	return oldValue.ShowInvoiceDueDate, nil
}

// ResetShowInvoiceDueDate resets all changes to the "show_invoice_due_date" field.
func (m *InvoiceControlMutation) ResetShowInvoiceDueDate() {
	m.show_invoice_due_date = nil
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *InvoiceControlMutation) SetOrganizationID(id uuid.UUID) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *InvoiceControlMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *InvoiceControlMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *InvoiceControlMutation) OrganizationID() (id uuid.UUID, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *InvoiceControlMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *InvoiceControlMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// SetBusinessUnitID sets the "business_unit" edge to the BusinessUnit entity by id.
func (m *InvoiceControlMutation) SetBusinessUnitID(id uuid.UUID) {
	m.business_unit = &id
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *InvoiceControlMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *InvoiceControlMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitID returns the "business_unit" edge ID in the mutation.
func (m *InvoiceControlMutation) BusinessUnitID() (id uuid.UUID, exists bool) {
	if m.business_unit != nil {
		return *m.business_unit, true
	}
	return
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *InvoiceControlMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *InvoiceControlMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// Where appends a list predicates to the InvoiceControlMutation builder.
func (m *InvoiceControlMutation) Where(ps ...predicate.InvoiceControl) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InvoiceControlMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InvoiceControlMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InvoiceControl, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InvoiceControlMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InvoiceControlMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InvoiceControl).
func (m *InvoiceControlMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InvoiceControlMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, invoicecontrol.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, invoicecontrol.FieldUpdatedAt)
	}
	if m.invoice_number_prefix != nil {
		fields = append(fields, invoicecontrol.FieldInvoiceNumberPrefix)
	}
	if m.credit_memo_number_prefix != nil {
		fields = append(fields, invoicecontrol.FieldCreditMemoNumberPrefix)
	}
	if m.invoice_terms != nil {
		fields = append(fields, invoicecontrol.FieldInvoiceTerms)
	}
	if m.invoice_footer != nil {
		fields = append(fields, invoicecontrol.FieldInvoiceFooter)
	}
	if m.invoice_logo_url != nil {
		fields = append(fields, invoicecontrol.FieldInvoiceLogoURL)
	}
	if m.invoice_date_format != nil {
		fields = append(fields, invoicecontrol.FieldInvoiceDateFormat)
	}
	if m.invoice_due_after_days != nil {
		fields = append(fields, invoicecontrol.FieldInvoiceDueAfterDays)
	}
	if m.invoice_logo_width != nil {
		fields = append(fields, invoicecontrol.FieldInvoiceLogoWidth)
	}
	if m.show_amount_due != nil {
		fields = append(fields, invoicecontrol.FieldShowAmountDue)
	}
	if m.attach_pdf != nil {
		fields = append(fields, invoicecontrol.FieldAttachPdf)
	}
	if m.show_invoice_due_date != nil {
		fields = append(fields, invoicecontrol.FieldShowInvoiceDueDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InvoiceControlMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case invoicecontrol.FieldCreatedAt:
		return m.CreatedAt()
	case invoicecontrol.FieldUpdatedAt:
		return m.UpdatedAt()
	case invoicecontrol.FieldInvoiceNumberPrefix:
		return m.InvoiceNumberPrefix()
	case invoicecontrol.FieldCreditMemoNumberPrefix:
		return m.CreditMemoNumberPrefix()
	case invoicecontrol.FieldInvoiceTerms:
		return m.InvoiceTerms()
	case invoicecontrol.FieldInvoiceFooter:
		return m.InvoiceFooter()
	case invoicecontrol.FieldInvoiceLogoURL:
		return m.InvoiceLogoURL()
	case invoicecontrol.FieldInvoiceDateFormat:
		return m.InvoiceDateFormat()
	case invoicecontrol.FieldInvoiceDueAfterDays:
		return m.InvoiceDueAfterDays()
	case invoicecontrol.FieldInvoiceLogoWidth:
		return m.InvoiceLogoWidth()
	case invoicecontrol.FieldShowAmountDue:
		return m.ShowAmountDue()
	case invoicecontrol.FieldAttachPdf:
		return m.AttachPdf()
	case invoicecontrol.FieldShowInvoiceDueDate:
		return m.ShowInvoiceDueDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InvoiceControlMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case invoicecontrol.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case invoicecontrol.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case invoicecontrol.FieldInvoiceNumberPrefix:
		return m.OldInvoiceNumberPrefix(ctx)
	case invoicecontrol.FieldCreditMemoNumberPrefix:
		return m.OldCreditMemoNumberPrefix(ctx)
	case invoicecontrol.FieldInvoiceTerms:
		return m.OldInvoiceTerms(ctx)
	case invoicecontrol.FieldInvoiceFooter:
		return m.OldInvoiceFooter(ctx)
	case invoicecontrol.FieldInvoiceLogoURL:
		return m.OldInvoiceLogoURL(ctx)
	case invoicecontrol.FieldInvoiceDateFormat:
		return m.OldInvoiceDateFormat(ctx)
	case invoicecontrol.FieldInvoiceDueAfterDays:
		return m.OldInvoiceDueAfterDays(ctx)
	case invoicecontrol.FieldInvoiceLogoWidth:
		return m.OldInvoiceLogoWidth(ctx)
	case invoicecontrol.FieldShowAmountDue:
		return m.OldShowAmountDue(ctx)
	case invoicecontrol.FieldAttachPdf:
		return m.OldAttachPdf(ctx)
	case invoicecontrol.FieldShowInvoiceDueDate:
		return m.OldShowInvoiceDueDate(ctx)
	}
	return nil, fmt.Errorf("unknown InvoiceControl field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvoiceControlMutation) SetField(name string, value ent.Value) error {
	switch name {
	case invoicecontrol.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case invoicecontrol.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case invoicecontrol.FieldInvoiceNumberPrefix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceNumberPrefix(v)
		return nil
	case invoicecontrol.FieldCreditMemoNumberPrefix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreditMemoNumberPrefix(v)
		return nil
	case invoicecontrol.FieldInvoiceTerms:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceTerms(v)
		return nil
	case invoicecontrol.FieldInvoiceFooter:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceFooter(v)
		return nil
	case invoicecontrol.FieldInvoiceLogoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceLogoURL(v)
		return nil
	case invoicecontrol.FieldInvoiceDateFormat:
		v, ok := value.(invoicecontrol.InvoiceDateFormat)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceDateFormat(v)
		return nil
	case invoicecontrol.FieldInvoiceDueAfterDays:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceDueAfterDays(v)
		return nil
	case invoicecontrol.FieldInvoiceLogoWidth:
		v, ok := value.(uint16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceLogoWidth(v)
		return nil
	case invoicecontrol.FieldShowAmountDue:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShowAmountDue(v)
		return nil
	case invoicecontrol.FieldAttachPdf:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttachPdf(v)
		return nil
	case invoicecontrol.FieldShowInvoiceDueDate:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShowInvoiceDueDate(v)
		return nil
	}
	return fmt.Errorf("unknown InvoiceControl field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InvoiceControlMutation) AddedFields() []string {
	var fields []string
	if m.addinvoice_due_after_days != nil {
		fields = append(fields, invoicecontrol.FieldInvoiceDueAfterDays)
	}
	if m.addinvoice_logo_width != nil {
		fields = append(fields, invoicecontrol.FieldInvoiceLogoWidth)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InvoiceControlMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case invoicecontrol.FieldInvoiceDueAfterDays:
		return m.AddedInvoiceDueAfterDays()
	case invoicecontrol.FieldInvoiceLogoWidth:
		return m.AddedInvoiceLogoWidth()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvoiceControlMutation) AddField(name string, value ent.Value) error {
	switch name {
	case invoicecontrol.FieldInvoiceDueAfterDays:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInvoiceDueAfterDays(v)
		return nil
	case invoicecontrol.FieldInvoiceLogoWidth:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInvoiceLogoWidth(v)
		return nil
	}
	return fmt.Errorf("unknown InvoiceControl numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InvoiceControlMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(invoicecontrol.FieldInvoiceTerms) {
		fields = append(fields, invoicecontrol.FieldInvoiceTerms)
	}
	if m.FieldCleared(invoicecontrol.FieldInvoiceFooter) {
		fields = append(fields, invoicecontrol.FieldInvoiceFooter)
	}
	if m.FieldCleared(invoicecontrol.FieldInvoiceLogoURL) {
		fields = append(fields, invoicecontrol.FieldInvoiceLogoURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InvoiceControlMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InvoiceControlMutation) ClearField(name string) error {
	switch name {
	case invoicecontrol.FieldInvoiceTerms:
		m.ClearInvoiceTerms()
		return nil
	case invoicecontrol.FieldInvoiceFooter:
		m.ClearInvoiceFooter()
		return nil
	case invoicecontrol.FieldInvoiceLogoURL:
		m.ClearInvoiceLogoURL()
		return nil
	}
	return fmt.Errorf("unknown InvoiceControl nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InvoiceControlMutation) ResetField(name string) error {
	switch name {
	case invoicecontrol.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case invoicecontrol.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case invoicecontrol.FieldInvoiceNumberPrefix:
		m.ResetInvoiceNumberPrefix()
		return nil
	case invoicecontrol.FieldCreditMemoNumberPrefix:
		m.ResetCreditMemoNumberPrefix()
		return nil
	case invoicecontrol.FieldInvoiceTerms:
		m.ResetInvoiceTerms()
		return nil
	case invoicecontrol.FieldInvoiceFooter:
		m.ResetInvoiceFooter()
		return nil
	case invoicecontrol.FieldInvoiceLogoURL:
		m.ResetInvoiceLogoURL()
		return nil
	case invoicecontrol.FieldInvoiceDateFormat:
		m.ResetInvoiceDateFormat()
		return nil
	case invoicecontrol.FieldInvoiceDueAfterDays:
		m.ResetInvoiceDueAfterDays()
		return nil
	case invoicecontrol.FieldInvoiceLogoWidth:
		m.ResetInvoiceLogoWidth()
		return nil
	case invoicecontrol.FieldShowAmountDue:
		m.ResetShowAmountDue()
		return nil
	case invoicecontrol.FieldAttachPdf:
		m.ResetAttachPdf()
		return nil
	case invoicecontrol.FieldShowInvoiceDueDate:
		m.ResetShowInvoiceDueDate()
		return nil
	}
	return fmt.Errorf("unknown InvoiceControl field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InvoiceControlMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.organization != nil {
		edges = append(edges, invoicecontrol.EdgeOrganization)
	}
	if m.business_unit != nil {
		edges = append(edges, invoicecontrol.EdgeBusinessUnit)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InvoiceControlMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case invoicecontrol.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case invoicecontrol.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InvoiceControlMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InvoiceControlMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InvoiceControlMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorganization {
		edges = append(edges, invoicecontrol.EdgeOrganization)
	}
	if m.clearedbusiness_unit {
		edges = append(edges, invoicecontrol.EdgeBusinessUnit)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InvoiceControlMutation) EdgeCleared(name string) bool {
	switch name {
	case invoicecontrol.EdgeOrganization:
		return m.clearedorganization
	case invoicecontrol.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InvoiceControlMutation) ClearEdge(name string) error {
	switch name {
	case invoicecontrol.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case invoicecontrol.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	}
	return fmt.Errorf("unknown InvoiceControl unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InvoiceControlMutation) ResetEdge(name string) error {
	switch name {
	case invoicecontrol.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case invoicecontrol.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	}
	return fmt.Errorf("unknown InvoiceControl edge %s", name)
}

// LocationCategoryMutation represents an operation that mutates the LocationCategory nodes in the graph.
type LocationCategoryMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	name                 *string
	description          *string
	color                *string
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	done                 bool
	oldValue             func(context.Context) (*LocationCategory, error)
	predicates           []predicate.LocationCategory
}

var _ ent.Mutation = (*LocationCategoryMutation)(nil)

// locationcategoryOption allows management of the mutation configuration using functional options.
type locationcategoryOption func(*LocationCategoryMutation)

// newLocationCategoryMutation creates new mutation for the LocationCategory entity.
func newLocationCategoryMutation(c config, op Op, opts ...locationcategoryOption) *LocationCategoryMutation {
	m := &LocationCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeLocationCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLocationCategoryID sets the ID field of the mutation.
func withLocationCategoryID(id uuid.UUID) locationcategoryOption {
	return func(m *LocationCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *LocationCategory
		)
		m.oldValue = func(ctx context.Context) (*LocationCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LocationCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLocationCategory sets the old LocationCategory of the mutation.
func withLocationCategory(node *LocationCategory) locationcategoryOption {
	return func(m *LocationCategoryMutation) {
		m.oldValue = func(context.Context) (*LocationCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LocationCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LocationCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LocationCategory entities.
func (m *LocationCategoryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LocationCategoryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LocationCategoryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LocationCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *LocationCategoryMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *LocationCategoryMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the LocationCategory entity.
// If the LocationCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationCategoryMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *LocationCategoryMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *LocationCategoryMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *LocationCategoryMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the LocationCategory entity.
// If the LocationCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationCategoryMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *LocationCategoryMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *LocationCategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LocationCategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LocationCategory entity.
// If the LocationCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationCategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LocationCategoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LocationCategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LocationCategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the LocationCategory entity.
// If the LocationCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationCategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LocationCategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *LocationCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LocationCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the LocationCategory entity.
// If the LocationCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LocationCategoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *LocationCategoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *LocationCategoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the LocationCategory entity.
// If the LocationCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationCategoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *LocationCategoryMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[locationcategory.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *LocationCategoryMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[locationcategory.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *LocationCategoryMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, locationcategory.FieldDescription)
}

// SetColor sets the "color" field.
func (m *LocationCategoryMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *LocationCategoryMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the LocationCategory entity.
// If the LocationCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationCategoryMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *LocationCategoryMutation) ClearColor() {
	m.color = nil
	m.clearedFields[locationcategory.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *LocationCategoryMutation) ColorCleared() bool {
	_, ok := m.clearedFields[locationcategory.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *LocationCategoryMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, locationcategory.FieldColor)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *LocationCategoryMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[locationcategory.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *LocationCategoryMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *LocationCategoryMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *LocationCategoryMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *LocationCategoryMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[locationcategory.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *LocationCategoryMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *LocationCategoryMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *LocationCategoryMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the LocationCategoryMutation builder.
func (m *LocationCategoryMutation) Where(ps ...predicate.LocationCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LocationCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LocationCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LocationCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LocationCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LocationCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LocationCategory).
func (m *LocationCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LocationCategoryMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.business_unit != nil {
		fields = append(fields, locationcategory.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, locationcategory.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, locationcategory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, locationcategory.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, locationcategory.FieldName)
	}
	if m.description != nil {
		fields = append(fields, locationcategory.FieldDescription)
	}
	if m.color != nil {
		fields = append(fields, locationcategory.FieldColor)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LocationCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case locationcategory.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case locationcategory.FieldOrganizationID:
		return m.OrganizationID()
	case locationcategory.FieldCreatedAt:
		return m.CreatedAt()
	case locationcategory.FieldUpdatedAt:
		return m.UpdatedAt()
	case locationcategory.FieldName:
		return m.Name()
	case locationcategory.FieldDescription:
		return m.Description()
	case locationcategory.FieldColor:
		return m.Color()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LocationCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case locationcategory.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case locationcategory.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case locationcategory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case locationcategory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case locationcategory.FieldName:
		return m.OldName(ctx)
	case locationcategory.FieldDescription:
		return m.OldDescription(ctx)
	case locationcategory.FieldColor:
		return m.OldColor(ctx)
	}
	return nil, fmt.Errorf("unknown LocationCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case locationcategory.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case locationcategory.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case locationcategory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case locationcategory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case locationcategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case locationcategory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case locationcategory.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	}
	return fmt.Errorf("unknown LocationCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LocationCategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LocationCategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown LocationCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LocationCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(locationcategory.FieldDescription) {
		fields = append(fields, locationcategory.FieldDescription)
	}
	if m.FieldCleared(locationcategory.FieldColor) {
		fields = append(fields, locationcategory.FieldColor)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LocationCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LocationCategoryMutation) ClearField(name string) error {
	switch name {
	case locationcategory.FieldDescription:
		m.ClearDescription()
		return nil
	case locationcategory.FieldColor:
		m.ClearColor()
		return nil
	}
	return fmt.Errorf("unknown LocationCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LocationCategoryMutation) ResetField(name string) error {
	switch name {
	case locationcategory.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case locationcategory.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case locationcategory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case locationcategory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case locationcategory.FieldName:
		m.ResetName()
		return nil
	case locationcategory.FieldDescription:
		m.ResetDescription()
		return nil
	case locationcategory.FieldColor:
		m.ResetColor()
		return nil
	}
	return fmt.Errorf("unknown LocationCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LocationCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.business_unit != nil {
		edges = append(edges, locationcategory.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, locationcategory.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LocationCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case locationcategory.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case locationcategory.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LocationCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LocationCategoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LocationCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbusiness_unit {
		edges = append(edges, locationcategory.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, locationcategory.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LocationCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case locationcategory.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case locationcategory.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LocationCategoryMutation) ClearEdge(name string) error {
	switch name {
	case locationcategory.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case locationcategory.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown LocationCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LocationCategoryMutation) ResetEdge(name string) error {
	switch name {
	case locationcategory.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case locationcategory.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown LocationCategory edge %s", name)
}

// OrganizationMutation represents an operation that mutates the Organization nodes in the graph.
type OrganizationMutation struct {
	config
	op                              Op
	typ                             string
	id                              *uuid.UUID
	created_at                      *time.Time
	updated_at                      *time.Time
	name                            *string
	scac_code                       *string
	dot_number                      *string
	logo_url                        *string
	org_type                        *organization.OrgType
	timezone                        *organization.Timezone
	clearedFields                   map[string]struct{}
	business_unit                   *uuid.UUID
	clearedbusiness_unit            bool
	accounting_control              *uuid.UUID
	clearedaccounting_control       bool
	billing_control                 *uuid.UUID
	clearedbilling_control          bool
	dispatch_control                *uuid.UUID
	cleareddispatch_control         bool
	feasibility_tool_control        *uuid.UUID
	clearedfeasibility_tool_control bool
	invoice_control                 *uuid.UUID
	clearedinvoice_control          bool
	route_control                   *uuid.UUID
	clearedroute_control            bool
	shipment_control                *uuid.UUID
	clearedshipment_control         bool
	email_control                   *uuid.UUID
	clearedemail_control            bool
	google_api                      *uuid.UUID
	clearedgoogle_api               bool
	done                            bool
	oldValue                        func(context.Context) (*Organization, error)
	predicates                      []predicate.Organization
}

var _ ent.Mutation = (*OrganizationMutation)(nil)

// organizationOption allows management of the mutation configuration using functional options.
type organizationOption func(*OrganizationMutation)

// newOrganizationMutation creates new mutation for the Organization entity.
func newOrganizationMutation(c config, op Op, opts ...organizationOption) *OrganizationMutation {
	m := &OrganizationMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganization,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationID sets the ID field of the mutation.
func withOrganizationID(id uuid.UUID) organizationOption {
	return func(m *OrganizationMutation) {
		var (
			err   error
			once  sync.Once
			value *Organization
		)
		m.oldValue = func(ctx context.Context) (*Organization, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Organization.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganization sets the old Organization of the mutation.
func withOrganization(node *Organization) organizationOption {
	return func(m *OrganizationMutation) {
		m.oldValue = func(context.Context) (*Organization, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Organization entities.
func (m *OrganizationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Organization.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrganizationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrganizationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrganizationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *OrganizationMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *OrganizationMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *OrganizationMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetName sets the "name" field.
func (m *OrganizationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrganizationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrganizationMutation) ResetName() {
	m.name = nil
}

// SetScacCode sets the "scac_code" field.
func (m *OrganizationMutation) SetScacCode(s string) {
	m.scac_code = &s
}

// ScacCode returns the value of the "scac_code" field in the mutation.
func (m *OrganizationMutation) ScacCode() (r string, exists bool) {
	v := m.scac_code
	if v == nil {
		return
	}
	return *v, true
}

// OldScacCode returns the old "scac_code" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldScacCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScacCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScacCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScacCode: %w", err)
	}
	return oldValue.ScacCode, nil
}

// ResetScacCode resets all changes to the "scac_code" field.
func (m *OrganizationMutation) ResetScacCode() {
	m.scac_code = nil
}

// SetDotNumber sets the "dot_number" field.
func (m *OrganizationMutation) SetDotNumber(s string) {
	m.dot_number = &s
}

// DotNumber returns the value of the "dot_number" field in the mutation.
func (m *OrganizationMutation) DotNumber() (r string, exists bool) {
	v := m.dot_number
	if v == nil {
		return
	}
	return *v, true
}

// OldDotNumber returns the old "dot_number" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldDotNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDotNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDotNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDotNumber: %w", err)
	}
	return oldValue.DotNumber, nil
}

// ResetDotNumber resets all changes to the "dot_number" field.
func (m *OrganizationMutation) ResetDotNumber() {
	m.dot_number = nil
}

// SetLogoURL sets the "logo_url" field.
func (m *OrganizationMutation) SetLogoURL(s string) {
	m.logo_url = &s
}

// LogoURL returns the value of the "logo_url" field in the mutation.
func (m *OrganizationMutation) LogoURL() (r string, exists bool) {
	v := m.logo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldLogoURL returns the old "logo_url" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldLogoURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogoURL: %w", err)
	}
	return oldValue.LogoURL, nil
}

// ClearLogoURL clears the value of the "logo_url" field.
func (m *OrganizationMutation) ClearLogoURL() {
	m.logo_url = nil
	m.clearedFields[organization.FieldLogoURL] = struct{}{}
}

// LogoURLCleared returns if the "logo_url" field was cleared in this mutation.
func (m *OrganizationMutation) LogoURLCleared() bool {
	_, ok := m.clearedFields[organization.FieldLogoURL]
	return ok
}

// ResetLogoURL resets all changes to the "logo_url" field.
func (m *OrganizationMutation) ResetLogoURL() {
	m.logo_url = nil
	delete(m.clearedFields, organization.FieldLogoURL)
}

// SetOrgType sets the "org_type" field.
func (m *OrganizationMutation) SetOrgType(ot organization.OrgType) {
	m.org_type = &ot
}

// OrgType returns the value of the "org_type" field in the mutation.
func (m *OrganizationMutation) OrgType() (r organization.OrgType, exists bool) {
	v := m.org_type
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgType returns the old "org_type" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldOrgType(ctx context.Context) (v organization.OrgType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrgType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrgType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgType: %w", err)
	}
	return oldValue.OrgType, nil
}

// ResetOrgType resets all changes to the "org_type" field.
func (m *OrganizationMutation) ResetOrgType() {
	m.org_type = nil
}

// SetTimezone sets the "timezone" field.
func (m *OrganizationMutation) SetTimezone(o organization.Timezone) {
	m.timezone = &o
}

// Timezone returns the value of the "timezone" field in the mutation.
func (m *OrganizationMutation) Timezone() (r organization.Timezone, exists bool) {
	v := m.timezone
	if v == nil {
		return
	}
	return *v, true
}

// OldTimezone returns the old "timezone" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldTimezone(ctx context.Context) (v organization.Timezone, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimezone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimezone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimezone: %w", err)
	}
	return oldValue.Timezone, nil
}

// ResetTimezone resets all changes to the "timezone" field.
func (m *OrganizationMutation) ResetTimezone() {
	m.timezone = nil
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *OrganizationMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[organization.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *OrganizationMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *OrganizationMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// SetAccountingControlID sets the "accounting_control" edge to the AccountingControl entity by id.
func (m *OrganizationMutation) SetAccountingControlID(id uuid.UUID) {
	m.accounting_control = &id
}

// ClearAccountingControl clears the "accounting_control" edge to the AccountingControl entity.
func (m *OrganizationMutation) ClearAccountingControl() {
	m.clearedaccounting_control = true
}

// AccountingControlCleared reports if the "accounting_control" edge to the AccountingControl entity was cleared.
func (m *OrganizationMutation) AccountingControlCleared() bool {
	return m.clearedaccounting_control
}

// AccountingControlID returns the "accounting_control" edge ID in the mutation.
func (m *OrganizationMutation) AccountingControlID() (id uuid.UUID, exists bool) {
	if m.accounting_control != nil {
		return *m.accounting_control, true
	}
	return
}

// AccountingControlIDs returns the "accounting_control" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountingControlID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) AccountingControlIDs() (ids []uuid.UUID) {
	if id := m.accounting_control; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccountingControl resets all changes to the "accounting_control" edge.
func (m *OrganizationMutation) ResetAccountingControl() {
	m.accounting_control = nil
	m.clearedaccounting_control = false
}

// SetBillingControlID sets the "billing_control" edge to the BillingControl entity by id.
func (m *OrganizationMutation) SetBillingControlID(id uuid.UUID) {
	m.billing_control = &id
}

// ClearBillingControl clears the "billing_control" edge to the BillingControl entity.
func (m *OrganizationMutation) ClearBillingControl() {
	m.clearedbilling_control = true
}

// BillingControlCleared reports if the "billing_control" edge to the BillingControl entity was cleared.
func (m *OrganizationMutation) BillingControlCleared() bool {
	return m.clearedbilling_control
}

// BillingControlID returns the "billing_control" edge ID in the mutation.
func (m *OrganizationMutation) BillingControlID() (id uuid.UUID, exists bool) {
	if m.billing_control != nil {
		return *m.billing_control, true
	}
	return
}

// BillingControlIDs returns the "billing_control" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BillingControlID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) BillingControlIDs() (ids []uuid.UUID) {
	if id := m.billing_control; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBillingControl resets all changes to the "billing_control" edge.
func (m *OrganizationMutation) ResetBillingControl() {
	m.billing_control = nil
	m.clearedbilling_control = false
}

// SetDispatchControlID sets the "dispatch_control" edge to the DispatchControl entity by id.
func (m *OrganizationMutation) SetDispatchControlID(id uuid.UUID) {
	m.dispatch_control = &id
}

// ClearDispatchControl clears the "dispatch_control" edge to the DispatchControl entity.
func (m *OrganizationMutation) ClearDispatchControl() {
	m.cleareddispatch_control = true
}

// DispatchControlCleared reports if the "dispatch_control" edge to the DispatchControl entity was cleared.
func (m *OrganizationMutation) DispatchControlCleared() bool {
	return m.cleareddispatch_control
}

// DispatchControlID returns the "dispatch_control" edge ID in the mutation.
func (m *OrganizationMutation) DispatchControlID() (id uuid.UUID, exists bool) {
	if m.dispatch_control != nil {
		return *m.dispatch_control, true
	}
	return
}

// DispatchControlIDs returns the "dispatch_control" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DispatchControlID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) DispatchControlIDs() (ids []uuid.UUID) {
	if id := m.dispatch_control; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDispatchControl resets all changes to the "dispatch_control" edge.
func (m *OrganizationMutation) ResetDispatchControl() {
	m.dispatch_control = nil
	m.cleareddispatch_control = false
}

// SetFeasibilityToolControlID sets the "feasibility_tool_control" edge to the FeasibilityToolControl entity by id.
func (m *OrganizationMutation) SetFeasibilityToolControlID(id uuid.UUID) {
	m.feasibility_tool_control = &id
}

// ClearFeasibilityToolControl clears the "feasibility_tool_control" edge to the FeasibilityToolControl entity.
func (m *OrganizationMutation) ClearFeasibilityToolControl() {
	m.clearedfeasibility_tool_control = true
}

// FeasibilityToolControlCleared reports if the "feasibility_tool_control" edge to the FeasibilityToolControl entity was cleared.
func (m *OrganizationMutation) FeasibilityToolControlCleared() bool {
	return m.clearedfeasibility_tool_control
}

// FeasibilityToolControlID returns the "feasibility_tool_control" edge ID in the mutation.
func (m *OrganizationMutation) FeasibilityToolControlID() (id uuid.UUID, exists bool) {
	if m.feasibility_tool_control != nil {
		return *m.feasibility_tool_control, true
	}
	return
}

// FeasibilityToolControlIDs returns the "feasibility_tool_control" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FeasibilityToolControlID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) FeasibilityToolControlIDs() (ids []uuid.UUID) {
	if id := m.feasibility_tool_control; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFeasibilityToolControl resets all changes to the "feasibility_tool_control" edge.
func (m *OrganizationMutation) ResetFeasibilityToolControl() {
	m.feasibility_tool_control = nil
	m.clearedfeasibility_tool_control = false
}

// SetInvoiceControlID sets the "invoice_control" edge to the InvoiceControl entity by id.
func (m *OrganizationMutation) SetInvoiceControlID(id uuid.UUID) {
	m.invoice_control = &id
}

// ClearInvoiceControl clears the "invoice_control" edge to the InvoiceControl entity.
func (m *OrganizationMutation) ClearInvoiceControl() {
	m.clearedinvoice_control = true
}

// InvoiceControlCleared reports if the "invoice_control" edge to the InvoiceControl entity was cleared.
func (m *OrganizationMutation) InvoiceControlCleared() bool {
	return m.clearedinvoice_control
}

// InvoiceControlID returns the "invoice_control" edge ID in the mutation.
func (m *OrganizationMutation) InvoiceControlID() (id uuid.UUID, exists bool) {
	if m.invoice_control != nil {
		return *m.invoice_control, true
	}
	return
}

// InvoiceControlIDs returns the "invoice_control" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InvoiceControlID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) InvoiceControlIDs() (ids []uuid.UUID) {
	if id := m.invoice_control; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInvoiceControl resets all changes to the "invoice_control" edge.
func (m *OrganizationMutation) ResetInvoiceControl() {
	m.invoice_control = nil
	m.clearedinvoice_control = false
}

// SetRouteControlID sets the "route_control" edge to the RouteControl entity by id.
func (m *OrganizationMutation) SetRouteControlID(id uuid.UUID) {
	m.route_control = &id
}

// ClearRouteControl clears the "route_control" edge to the RouteControl entity.
func (m *OrganizationMutation) ClearRouteControl() {
	m.clearedroute_control = true
}

// RouteControlCleared reports if the "route_control" edge to the RouteControl entity was cleared.
func (m *OrganizationMutation) RouteControlCleared() bool {
	return m.clearedroute_control
}

// RouteControlID returns the "route_control" edge ID in the mutation.
func (m *OrganizationMutation) RouteControlID() (id uuid.UUID, exists bool) {
	if m.route_control != nil {
		return *m.route_control, true
	}
	return
}

// RouteControlIDs returns the "route_control" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RouteControlID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) RouteControlIDs() (ids []uuid.UUID) {
	if id := m.route_control; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRouteControl resets all changes to the "route_control" edge.
func (m *OrganizationMutation) ResetRouteControl() {
	m.route_control = nil
	m.clearedroute_control = false
}

// SetShipmentControlID sets the "shipment_control" edge to the ShipmentControl entity by id.
func (m *OrganizationMutation) SetShipmentControlID(id uuid.UUID) {
	m.shipment_control = &id
}

// ClearShipmentControl clears the "shipment_control" edge to the ShipmentControl entity.
func (m *OrganizationMutation) ClearShipmentControl() {
	m.clearedshipment_control = true
}

// ShipmentControlCleared reports if the "shipment_control" edge to the ShipmentControl entity was cleared.
func (m *OrganizationMutation) ShipmentControlCleared() bool {
	return m.clearedshipment_control
}

// ShipmentControlID returns the "shipment_control" edge ID in the mutation.
func (m *OrganizationMutation) ShipmentControlID() (id uuid.UUID, exists bool) {
	if m.shipment_control != nil {
		return *m.shipment_control, true
	}
	return
}

// ShipmentControlIDs returns the "shipment_control" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentControlID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) ShipmentControlIDs() (ids []uuid.UUID) {
	if id := m.shipment_control; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipmentControl resets all changes to the "shipment_control" edge.
func (m *OrganizationMutation) ResetShipmentControl() {
	m.shipment_control = nil
	m.clearedshipment_control = false
}

// SetEmailControlID sets the "email_control" edge to the EmailControl entity by id.
func (m *OrganizationMutation) SetEmailControlID(id uuid.UUID) {
	m.email_control = &id
}

// ClearEmailControl clears the "email_control" edge to the EmailControl entity.
func (m *OrganizationMutation) ClearEmailControl() {
	m.clearedemail_control = true
}

// EmailControlCleared reports if the "email_control" edge to the EmailControl entity was cleared.
func (m *OrganizationMutation) EmailControlCleared() bool {
	return m.clearedemail_control
}

// EmailControlID returns the "email_control" edge ID in the mutation.
func (m *OrganizationMutation) EmailControlID() (id uuid.UUID, exists bool) {
	if m.email_control != nil {
		return *m.email_control, true
	}
	return
}

// EmailControlIDs returns the "email_control" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmailControlID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) EmailControlIDs() (ids []uuid.UUID) {
	if id := m.email_control; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmailControl resets all changes to the "email_control" edge.
func (m *OrganizationMutation) ResetEmailControl() {
	m.email_control = nil
	m.clearedemail_control = false
}

// SetGoogleAPIID sets the "google_api" edge to the GoogleApi entity by id.
func (m *OrganizationMutation) SetGoogleAPIID(id uuid.UUID) {
	m.google_api = &id
}

// ClearGoogleAPI clears the "google_api" edge to the GoogleApi entity.
func (m *OrganizationMutation) ClearGoogleAPI() {
	m.clearedgoogle_api = true
}

// GoogleAPICleared reports if the "google_api" edge to the GoogleApi entity was cleared.
func (m *OrganizationMutation) GoogleAPICleared() bool {
	return m.clearedgoogle_api
}

// GoogleAPIID returns the "google_api" edge ID in the mutation.
func (m *OrganizationMutation) GoogleAPIID() (id uuid.UUID, exists bool) {
	if m.google_api != nil {
		return *m.google_api, true
	}
	return
}

// GoogleAPIIDs returns the "google_api" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GoogleAPIID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) GoogleAPIIDs() (ids []uuid.UUID) {
	if id := m.google_api; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGoogleAPI resets all changes to the "google_api" edge.
func (m *OrganizationMutation) ResetGoogleAPI() {
	m.google_api = nil
	m.clearedgoogle_api = false
}

// Where appends a list predicates to the OrganizationMutation builder.
func (m *OrganizationMutation) Where(ps ...predicate.Organization) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Organization, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Organization).
func (m *OrganizationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, organization.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, organization.FieldUpdatedAt)
	}
	if m.business_unit != nil {
		fields = append(fields, organization.FieldBusinessUnitID)
	}
	if m.name != nil {
		fields = append(fields, organization.FieldName)
	}
	if m.scac_code != nil {
		fields = append(fields, organization.FieldScacCode)
	}
	if m.dot_number != nil {
		fields = append(fields, organization.FieldDotNumber)
	}
	if m.logo_url != nil {
		fields = append(fields, organization.FieldLogoURL)
	}
	if m.org_type != nil {
		fields = append(fields, organization.FieldOrgType)
	}
	if m.timezone != nil {
		fields = append(fields, organization.FieldTimezone)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organization.FieldCreatedAt:
		return m.CreatedAt()
	case organization.FieldUpdatedAt:
		return m.UpdatedAt()
	case organization.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case organization.FieldName:
		return m.Name()
	case organization.FieldScacCode:
		return m.ScacCode()
	case organization.FieldDotNumber:
		return m.DotNumber()
	case organization.FieldLogoURL:
		return m.LogoURL()
	case organization.FieldOrgType:
		return m.OrgType()
	case organization.FieldTimezone:
		return m.Timezone()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organization.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case organization.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case organization.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case organization.FieldName:
		return m.OldName(ctx)
	case organization.FieldScacCode:
		return m.OldScacCode(ctx)
	case organization.FieldDotNumber:
		return m.OldDotNumber(ctx)
	case organization.FieldLogoURL:
		return m.OldLogoURL(ctx)
	case organization.FieldOrgType:
		return m.OldOrgType(ctx)
	case organization.FieldTimezone:
		return m.OldTimezone(ctx)
	}
	return nil, fmt.Errorf("unknown Organization field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organization.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organization.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case organization.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case organization.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case organization.FieldScacCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScacCode(v)
		return nil
	case organization.FieldDotNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDotNumber(v)
		return nil
	case organization.FieldLogoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogoURL(v)
		return nil
	case organization.FieldOrgType:
		v, ok := value.(organization.OrgType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgType(v)
		return nil
	case organization.FieldTimezone:
		v, ok := value.(organization.Timezone)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimezone(v)
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Organization numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organization.FieldLogoURL) {
		fields = append(fields, organization.FieldLogoURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationMutation) ClearField(name string) error {
	switch name {
	case organization.FieldLogoURL:
		m.ClearLogoURL()
		return nil
	}
	return fmt.Errorf("unknown Organization nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationMutation) ResetField(name string) error {
	switch name {
	case organization.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organization.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case organization.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case organization.FieldName:
		m.ResetName()
		return nil
	case organization.FieldScacCode:
		m.ResetScacCode()
		return nil
	case organization.FieldDotNumber:
		m.ResetDotNumber()
		return nil
	case organization.FieldLogoURL:
		m.ResetLogoURL()
		return nil
	case organization.FieldOrgType:
		m.ResetOrgType()
		return nil
	case organization.FieldTimezone:
		m.ResetTimezone()
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m.business_unit != nil {
		edges = append(edges, organization.EdgeBusinessUnit)
	}
	if m.accounting_control != nil {
		edges = append(edges, organization.EdgeAccountingControl)
	}
	if m.billing_control != nil {
		edges = append(edges, organization.EdgeBillingControl)
	}
	if m.dispatch_control != nil {
		edges = append(edges, organization.EdgeDispatchControl)
	}
	if m.feasibility_tool_control != nil {
		edges = append(edges, organization.EdgeFeasibilityToolControl)
	}
	if m.invoice_control != nil {
		edges = append(edges, organization.EdgeInvoiceControl)
	}
	if m.route_control != nil {
		edges = append(edges, organization.EdgeRouteControl)
	}
	if m.shipment_control != nil {
		edges = append(edges, organization.EdgeShipmentControl)
	}
	if m.email_control != nil {
		edges = append(edges, organization.EdgeEmailControl)
	}
	if m.google_api != nil {
		edges = append(edges, organization.EdgeGoogleAPI)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case organization.EdgeAccountingControl:
		if id := m.accounting_control; id != nil {
			return []ent.Value{*id}
		}
	case organization.EdgeBillingControl:
		if id := m.billing_control; id != nil {
			return []ent.Value{*id}
		}
	case organization.EdgeDispatchControl:
		if id := m.dispatch_control; id != nil {
			return []ent.Value{*id}
		}
	case organization.EdgeFeasibilityToolControl:
		if id := m.feasibility_tool_control; id != nil {
			return []ent.Value{*id}
		}
	case organization.EdgeInvoiceControl:
		if id := m.invoice_control; id != nil {
			return []ent.Value{*id}
		}
	case organization.EdgeRouteControl:
		if id := m.route_control; id != nil {
			return []ent.Value{*id}
		}
	case organization.EdgeShipmentControl:
		if id := m.shipment_control; id != nil {
			return []ent.Value{*id}
		}
	case organization.EdgeEmailControl:
		if id := m.email_control; id != nil {
			return []ent.Value{*id}
		}
	case organization.EdgeGoogleAPI:
		if id := m.google_api; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.clearedbusiness_unit {
		edges = append(edges, organization.EdgeBusinessUnit)
	}
	if m.clearedaccounting_control {
		edges = append(edges, organization.EdgeAccountingControl)
	}
	if m.clearedbilling_control {
		edges = append(edges, organization.EdgeBillingControl)
	}
	if m.cleareddispatch_control {
		edges = append(edges, organization.EdgeDispatchControl)
	}
	if m.clearedfeasibility_tool_control {
		edges = append(edges, organization.EdgeFeasibilityToolControl)
	}
	if m.clearedinvoice_control {
		edges = append(edges, organization.EdgeInvoiceControl)
	}
	if m.clearedroute_control {
		edges = append(edges, organization.EdgeRouteControl)
	}
	if m.clearedshipment_control {
		edges = append(edges, organization.EdgeShipmentControl)
	}
	if m.clearedemail_control {
		edges = append(edges, organization.EdgeEmailControl)
	}
	if m.clearedgoogle_api {
		edges = append(edges, organization.EdgeGoogleAPI)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationMutation) EdgeCleared(name string) bool {
	switch name {
	case organization.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case organization.EdgeAccountingControl:
		return m.clearedaccounting_control
	case organization.EdgeBillingControl:
		return m.clearedbilling_control
	case organization.EdgeDispatchControl:
		return m.cleareddispatch_control
	case organization.EdgeFeasibilityToolControl:
		return m.clearedfeasibility_tool_control
	case organization.EdgeInvoiceControl:
		return m.clearedinvoice_control
	case organization.EdgeRouteControl:
		return m.clearedroute_control
	case organization.EdgeShipmentControl:
		return m.clearedshipment_control
	case organization.EdgeEmailControl:
		return m.clearedemail_control
	case organization.EdgeGoogleAPI:
		return m.clearedgoogle_api
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationMutation) ClearEdge(name string) error {
	switch name {
	case organization.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case organization.EdgeAccountingControl:
		m.ClearAccountingControl()
		return nil
	case organization.EdgeBillingControl:
		m.ClearBillingControl()
		return nil
	case organization.EdgeDispatchControl:
		m.ClearDispatchControl()
		return nil
	case organization.EdgeFeasibilityToolControl:
		m.ClearFeasibilityToolControl()
		return nil
	case organization.EdgeInvoiceControl:
		m.ClearInvoiceControl()
		return nil
	case organization.EdgeRouteControl:
		m.ClearRouteControl()
		return nil
	case organization.EdgeShipmentControl:
		m.ClearShipmentControl()
		return nil
	case organization.EdgeEmailControl:
		m.ClearEmailControl()
		return nil
	case organization.EdgeGoogleAPI:
		m.ClearGoogleAPI()
		return nil
	}
	return fmt.Errorf("unknown Organization unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationMutation) ResetEdge(name string) error {
	switch name {
	case organization.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case organization.EdgeAccountingControl:
		m.ResetAccountingControl()
		return nil
	case organization.EdgeBillingControl:
		m.ResetBillingControl()
		return nil
	case organization.EdgeDispatchControl:
		m.ResetDispatchControl()
		return nil
	case organization.EdgeFeasibilityToolControl:
		m.ResetFeasibilityToolControl()
		return nil
	case organization.EdgeInvoiceControl:
		m.ResetInvoiceControl()
		return nil
	case organization.EdgeRouteControl:
		m.ResetRouteControl()
		return nil
	case organization.EdgeShipmentControl:
		m.ResetShipmentControl()
		return nil
	case organization.EdgeEmailControl:
		m.ResetEmailControl()
		return nil
	case organization.EdgeGoogleAPI:
		m.ResetGoogleAPI()
		return nil
	}
	return fmt.Errorf("unknown Organization edge %s", name)
}

// QualifierCodeMutation represents an operation that mutates the QualifierCode nodes in the graph.
type QualifierCodeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	status               *qualifiercode.Status
	code                 *string
	description          *string
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	done                 bool
	oldValue             func(context.Context) (*QualifierCode, error)
	predicates           []predicate.QualifierCode
}

var _ ent.Mutation = (*QualifierCodeMutation)(nil)

// qualifiercodeOption allows management of the mutation configuration using functional options.
type qualifiercodeOption func(*QualifierCodeMutation)

// newQualifierCodeMutation creates new mutation for the QualifierCode entity.
func newQualifierCodeMutation(c config, op Op, opts ...qualifiercodeOption) *QualifierCodeMutation {
	m := &QualifierCodeMutation{
		config:        c,
		op:            op,
		typ:           TypeQualifierCode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withQualifierCodeID sets the ID field of the mutation.
func withQualifierCodeID(id uuid.UUID) qualifiercodeOption {
	return func(m *QualifierCodeMutation) {
		var (
			err   error
			once  sync.Once
			value *QualifierCode
		)
		m.oldValue = func(ctx context.Context) (*QualifierCode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().QualifierCode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withQualifierCode sets the old QualifierCode of the mutation.
func withQualifierCode(node *QualifierCode) qualifiercodeOption {
	return func(m *QualifierCodeMutation) {
		m.oldValue = func(context.Context) (*QualifierCode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m QualifierCodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m QualifierCodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of QualifierCode entities.
func (m *QualifierCodeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *QualifierCodeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *QualifierCodeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().QualifierCode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *QualifierCodeMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *QualifierCodeMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the QualifierCode entity.
// If the QualifierCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QualifierCodeMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *QualifierCodeMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *QualifierCodeMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *QualifierCodeMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the QualifierCode entity.
// If the QualifierCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QualifierCodeMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *QualifierCodeMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *QualifierCodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *QualifierCodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the QualifierCode entity.
// If the QualifierCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QualifierCodeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *QualifierCodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *QualifierCodeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *QualifierCodeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the QualifierCode entity.
// If the QualifierCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QualifierCodeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *QualifierCodeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *QualifierCodeMutation) SetStatus(q qualifiercode.Status) {
	m.status = &q
}

// Status returns the value of the "status" field in the mutation.
func (m *QualifierCodeMutation) Status() (r qualifiercode.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the QualifierCode entity.
// If the QualifierCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QualifierCodeMutation) OldStatus(ctx context.Context) (v qualifiercode.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *QualifierCodeMutation) ResetStatus() {
	m.status = nil
}

// SetCode sets the "code" field.
func (m *QualifierCodeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *QualifierCodeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the QualifierCode entity.
// If the QualifierCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QualifierCodeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *QualifierCodeMutation) ResetCode() {
	m.code = nil
}

// SetDescription sets the "description" field.
func (m *QualifierCodeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *QualifierCodeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the QualifierCode entity.
// If the QualifierCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QualifierCodeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *QualifierCodeMutation) ResetDescription() {
	m.description = nil
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *QualifierCodeMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[qualifiercode.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *QualifierCodeMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *QualifierCodeMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *QualifierCodeMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *QualifierCodeMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[qualifiercode.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *QualifierCodeMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *QualifierCodeMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *QualifierCodeMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the QualifierCodeMutation builder.
func (m *QualifierCodeMutation) Where(ps ...predicate.QualifierCode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the QualifierCodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *QualifierCodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.QualifierCode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *QualifierCodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *QualifierCodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (QualifierCode).
func (m *QualifierCodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *QualifierCodeMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.business_unit != nil {
		fields = append(fields, qualifiercode.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, qualifiercode.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, qualifiercode.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, qualifiercode.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, qualifiercode.FieldStatus)
	}
	if m.code != nil {
		fields = append(fields, qualifiercode.FieldCode)
	}
	if m.description != nil {
		fields = append(fields, qualifiercode.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *QualifierCodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case qualifiercode.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case qualifiercode.FieldOrganizationID:
		return m.OrganizationID()
	case qualifiercode.FieldCreatedAt:
		return m.CreatedAt()
	case qualifiercode.FieldUpdatedAt:
		return m.UpdatedAt()
	case qualifiercode.FieldStatus:
		return m.Status()
	case qualifiercode.FieldCode:
		return m.Code()
	case qualifiercode.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *QualifierCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case qualifiercode.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case qualifiercode.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case qualifiercode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case qualifiercode.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case qualifiercode.FieldStatus:
		return m.OldStatus(ctx)
	case qualifiercode.FieldCode:
		return m.OldCode(ctx)
	case qualifiercode.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown QualifierCode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *QualifierCodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case qualifiercode.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case qualifiercode.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case qualifiercode.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case qualifiercode.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case qualifiercode.FieldStatus:
		v, ok := value.(qualifiercode.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case qualifiercode.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case qualifiercode.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown QualifierCode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *QualifierCodeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *QualifierCodeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *QualifierCodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown QualifierCode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *QualifierCodeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *QualifierCodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *QualifierCodeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown QualifierCode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *QualifierCodeMutation) ResetField(name string) error {
	switch name {
	case qualifiercode.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case qualifiercode.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case qualifiercode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case qualifiercode.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case qualifiercode.FieldStatus:
		m.ResetStatus()
		return nil
	case qualifiercode.FieldCode:
		m.ResetCode()
		return nil
	case qualifiercode.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown QualifierCode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *QualifierCodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.business_unit != nil {
		edges = append(edges, qualifiercode.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, qualifiercode.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *QualifierCodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case qualifiercode.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case qualifiercode.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *QualifierCodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *QualifierCodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *QualifierCodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbusiness_unit {
		edges = append(edges, qualifiercode.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, qualifiercode.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *QualifierCodeMutation) EdgeCleared(name string) bool {
	switch name {
	case qualifiercode.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case qualifiercode.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *QualifierCodeMutation) ClearEdge(name string) error {
	switch name {
	case qualifiercode.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case qualifiercode.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown QualifierCode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *QualifierCodeMutation) ResetEdge(name string) error {
	switch name {
	case qualifiercode.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case qualifiercode.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown QualifierCode edge %s", name)
}

// ReasonCodeMutation represents an operation that mutates the ReasonCode nodes in the graph.
type ReasonCodeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	status               *reasoncode.Status
	code                 *string
	code_type            *reasoncode.CodeType
	description          *string
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	done                 bool
	oldValue             func(context.Context) (*ReasonCode, error)
	predicates           []predicate.ReasonCode
}

var _ ent.Mutation = (*ReasonCodeMutation)(nil)

// reasoncodeOption allows management of the mutation configuration using functional options.
type reasoncodeOption func(*ReasonCodeMutation)

// newReasonCodeMutation creates new mutation for the ReasonCode entity.
func newReasonCodeMutation(c config, op Op, opts ...reasoncodeOption) *ReasonCodeMutation {
	m := &ReasonCodeMutation{
		config:        c,
		op:            op,
		typ:           TypeReasonCode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReasonCodeID sets the ID field of the mutation.
func withReasonCodeID(id uuid.UUID) reasoncodeOption {
	return func(m *ReasonCodeMutation) {
		var (
			err   error
			once  sync.Once
			value *ReasonCode
		)
		m.oldValue = func(ctx context.Context) (*ReasonCode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ReasonCode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReasonCode sets the old ReasonCode of the mutation.
func withReasonCode(node *ReasonCode) reasoncodeOption {
	return func(m *ReasonCodeMutation) {
		m.oldValue = func(context.Context) (*ReasonCode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReasonCodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReasonCodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ReasonCode entities.
func (m *ReasonCodeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReasonCodeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReasonCodeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ReasonCode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *ReasonCodeMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *ReasonCodeMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the ReasonCode entity.
// If the ReasonCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReasonCodeMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *ReasonCodeMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *ReasonCodeMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *ReasonCodeMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the ReasonCode entity.
// If the ReasonCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReasonCodeMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *ReasonCodeMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ReasonCodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ReasonCodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ReasonCode entity.
// If the ReasonCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReasonCodeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ReasonCodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ReasonCodeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ReasonCodeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ReasonCode entity.
// If the ReasonCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReasonCodeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ReasonCodeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *ReasonCodeMutation) SetStatus(r reasoncode.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *ReasonCodeMutation) Status() (r reasoncode.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ReasonCode entity.
// If the ReasonCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReasonCodeMutation) OldStatus(ctx context.Context) (v reasoncode.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ReasonCodeMutation) ResetStatus() {
	m.status = nil
}

// SetCode sets the "code" field.
func (m *ReasonCodeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *ReasonCodeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the ReasonCode entity.
// If the ReasonCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReasonCodeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *ReasonCodeMutation) ResetCode() {
	m.code = nil
}

// SetCodeType sets the "code_type" field.
func (m *ReasonCodeMutation) SetCodeType(rt reasoncode.CodeType) {
	m.code_type = &rt
}

// CodeType returns the value of the "code_type" field in the mutation.
func (m *ReasonCodeMutation) CodeType() (r reasoncode.CodeType, exists bool) {
	v := m.code_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCodeType returns the old "code_type" field's value of the ReasonCode entity.
// If the ReasonCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReasonCodeMutation) OldCodeType(ctx context.Context) (v reasoncode.CodeType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCodeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCodeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCodeType: %w", err)
	}
	return oldValue.CodeType, nil
}

// ResetCodeType resets all changes to the "code_type" field.
func (m *ReasonCodeMutation) ResetCodeType() {
	m.code_type = nil
}

// SetDescription sets the "description" field.
func (m *ReasonCodeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ReasonCodeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ReasonCode entity.
// If the ReasonCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReasonCodeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ReasonCodeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[reasoncode.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ReasonCodeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[reasoncode.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ReasonCodeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, reasoncode.FieldDescription)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *ReasonCodeMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[reasoncode.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *ReasonCodeMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *ReasonCodeMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *ReasonCodeMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *ReasonCodeMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[reasoncode.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *ReasonCodeMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *ReasonCodeMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *ReasonCodeMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the ReasonCodeMutation builder.
func (m *ReasonCodeMutation) Where(ps ...predicate.ReasonCode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReasonCodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReasonCodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ReasonCode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReasonCodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReasonCodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ReasonCode).
func (m *ReasonCodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReasonCodeMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.business_unit != nil {
		fields = append(fields, reasoncode.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, reasoncode.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, reasoncode.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, reasoncode.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, reasoncode.FieldStatus)
	}
	if m.code != nil {
		fields = append(fields, reasoncode.FieldCode)
	}
	if m.code_type != nil {
		fields = append(fields, reasoncode.FieldCodeType)
	}
	if m.description != nil {
		fields = append(fields, reasoncode.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReasonCodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case reasoncode.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case reasoncode.FieldOrganizationID:
		return m.OrganizationID()
	case reasoncode.FieldCreatedAt:
		return m.CreatedAt()
	case reasoncode.FieldUpdatedAt:
		return m.UpdatedAt()
	case reasoncode.FieldStatus:
		return m.Status()
	case reasoncode.FieldCode:
		return m.Code()
	case reasoncode.FieldCodeType:
		return m.CodeType()
	case reasoncode.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReasonCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case reasoncode.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case reasoncode.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case reasoncode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case reasoncode.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case reasoncode.FieldStatus:
		return m.OldStatus(ctx)
	case reasoncode.FieldCode:
		return m.OldCode(ctx)
	case reasoncode.FieldCodeType:
		return m.OldCodeType(ctx)
	case reasoncode.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown ReasonCode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReasonCodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case reasoncode.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case reasoncode.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case reasoncode.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case reasoncode.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case reasoncode.FieldStatus:
		v, ok := value.(reasoncode.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case reasoncode.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case reasoncode.FieldCodeType:
		v, ok := value.(reasoncode.CodeType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCodeType(v)
		return nil
	case reasoncode.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown ReasonCode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReasonCodeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReasonCodeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReasonCodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ReasonCode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReasonCodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(reasoncode.FieldDescription) {
		fields = append(fields, reasoncode.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReasonCodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReasonCodeMutation) ClearField(name string) error {
	switch name {
	case reasoncode.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ReasonCode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReasonCodeMutation) ResetField(name string) error {
	switch name {
	case reasoncode.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case reasoncode.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case reasoncode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case reasoncode.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case reasoncode.FieldStatus:
		m.ResetStatus()
		return nil
	case reasoncode.FieldCode:
		m.ResetCode()
		return nil
	case reasoncode.FieldCodeType:
		m.ResetCodeType()
		return nil
	case reasoncode.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown ReasonCode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReasonCodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.business_unit != nil {
		edges = append(edges, reasoncode.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, reasoncode.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReasonCodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case reasoncode.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case reasoncode.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReasonCodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReasonCodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReasonCodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbusiness_unit {
		edges = append(edges, reasoncode.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, reasoncode.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReasonCodeMutation) EdgeCleared(name string) bool {
	switch name {
	case reasoncode.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case reasoncode.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReasonCodeMutation) ClearEdge(name string) error {
	switch name {
	case reasoncode.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case reasoncode.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown ReasonCode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReasonCodeMutation) ResetEdge(name string) error {
	switch name {
	case reasoncode.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case reasoncode.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown ReasonCode edge %s", name)
}

// RevenueCodeMutation represents an operation that mutates the RevenueCode nodes in the graph.
type RevenueCodeMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	created_at             *time.Time
	updated_at             *time.Time
	status                 *revenuecode.Status
	code                   *string
	description            *string
	clearedFields          map[string]struct{}
	business_unit          *uuid.UUID
	clearedbusiness_unit   bool
	organization           *uuid.UUID
	clearedorganization    bool
	expense_account        *uuid.UUID
	clearedexpense_account bool
	revenue_account        *uuid.UUID
	clearedrevenue_account bool
	done                   bool
	oldValue               func(context.Context) (*RevenueCode, error)
	predicates             []predicate.RevenueCode
}

var _ ent.Mutation = (*RevenueCodeMutation)(nil)

// revenuecodeOption allows management of the mutation configuration using functional options.
type revenuecodeOption func(*RevenueCodeMutation)

// newRevenueCodeMutation creates new mutation for the RevenueCode entity.
func newRevenueCodeMutation(c config, op Op, opts ...revenuecodeOption) *RevenueCodeMutation {
	m := &RevenueCodeMutation{
		config:        c,
		op:            op,
		typ:           TypeRevenueCode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRevenueCodeID sets the ID field of the mutation.
func withRevenueCodeID(id uuid.UUID) revenuecodeOption {
	return func(m *RevenueCodeMutation) {
		var (
			err   error
			once  sync.Once
			value *RevenueCode
		)
		m.oldValue = func(ctx context.Context) (*RevenueCode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RevenueCode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRevenueCode sets the old RevenueCode of the mutation.
func withRevenueCode(node *RevenueCode) revenuecodeOption {
	return func(m *RevenueCodeMutation) {
		m.oldValue = func(context.Context) (*RevenueCode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RevenueCodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RevenueCodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RevenueCode entities.
func (m *RevenueCodeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RevenueCodeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RevenueCodeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RevenueCode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *RevenueCodeMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *RevenueCodeMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the RevenueCode entity.
// If the RevenueCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevenueCodeMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *RevenueCodeMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *RevenueCodeMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *RevenueCodeMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the RevenueCode entity.
// If the RevenueCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevenueCodeMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *RevenueCodeMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RevenueCodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RevenueCodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RevenueCode entity.
// If the RevenueCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevenueCodeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RevenueCodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RevenueCodeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RevenueCodeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RevenueCode entity.
// If the RevenueCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevenueCodeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RevenueCodeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *RevenueCodeMutation) SetStatus(r revenuecode.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *RevenueCodeMutation) Status() (r revenuecode.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the RevenueCode entity.
// If the RevenueCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevenueCodeMutation) OldStatus(ctx context.Context) (v revenuecode.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *RevenueCodeMutation) ResetStatus() {
	m.status = nil
}

// SetCode sets the "code" field.
func (m *RevenueCodeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *RevenueCodeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the RevenueCode entity.
// If the RevenueCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevenueCodeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *RevenueCodeMutation) ResetCode() {
	m.code = nil
}

// SetDescription sets the "description" field.
func (m *RevenueCodeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RevenueCodeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the RevenueCode entity.
// If the RevenueCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevenueCodeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *RevenueCodeMutation) ResetDescription() {
	m.description = nil
}

// SetExpenseAccountID sets the "expense_account_id" field.
func (m *RevenueCodeMutation) SetExpenseAccountID(u uuid.UUID) {
	m.expense_account = &u
}

// ExpenseAccountID returns the value of the "expense_account_id" field in the mutation.
func (m *RevenueCodeMutation) ExpenseAccountID() (r uuid.UUID, exists bool) {
	v := m.expense_account
	if v == nil {
		return
	}
	return *v, true
}

// OldExpenseAccountID returns the old "expense_account_id" field's value of the RevenueCode entity.
// If the RevenueCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevenueCodeMutation) OldExpenseAccountID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpenseAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpenseAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpenseAccountID: %w", err)
	}
	return oldValue.ExpenseAccountID, nil
}

// ClearExpenseAccountID clears the value of the "expense_account_id" field.
func (m *RevenueCodeMutation) ClearExpenseAccountID() {
	m.expense_account = nil
	m.clearedFields[revenuecode.FieldExpenseAccountID] = struct{}{}
}

// ExpenseAccountIDCleared returns if the "expense_account_id" field was cleared in this mutation.
func (m *RevenueCodeMutation) ExpenseAccountIDCleared() bool {
	_, ok := m.clearedFields[revenuecode.FieldExpenseAccountID]
	return ok
}

// ResetExpenseAccountID resets all changes to the "expense_account_id" field.
func (m *RevenueCodeMutation) ResetExpenseAccountID() {
	m.expense_account = nil
	delete(m.clearedFields, revenuecode.FieldExpenseAccountID)
}

// SetRevenueAccountID sets the "revenue_account_id" field.
func (m *RevenueCodeMutation) SetRevenueAccountID(u uuid.UUID) {
	m.revenue_account = &u
}

// RevenueAccountID returns the value of the "revenue_account_id" field in the mutation.
func (m *RevenueCodeMutation) RevenueAccountID() (r uuid.UUID, exists bool) {
	v := m.revenue_account
	if v == nil {
		return
	}
	return *v, true
}

// OldRevenueAccountID returns the old "revenue_account_id" field's value of the RevenueCode entity.
// If the RevenueCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevenueCodeMutation) OldRevenueAccountID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevenueAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevenueAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevenueAccountID: %w", err)
	}
	return oldValue.RevenueAccountID, nil
}

// ClearRevenueAccountID clears the value of the "revenue_account_id" field.
func (m *RevenueCodeMutation) ClearRevenueAccountID() {
	m.revenue_account = nil
	m.clearedFields[revenuecode.FieldRevenueAccountID] = struct{}{}
}

// RevenueAccountIDCleared returns if the "revenue_account_id" field was cleared in this mutation.
func (m *RevenueCodeMutation) RevenueAccountIDCleared() bool {
	_, ok := m.clearedFields[revenuecode.FieldRevenueAccountID]
	return ok
}

// ResetRevenueAccountID resets all changes to the "revenue_account_id" field.
func (m *RevenueCodeMutation) ResetRevenueAccountID() {
	m.revenue_account = nil
	delete(m.clearedFields, revenuecode.FieldRevenueAccountID)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *RevenueCodeMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[revenuecode.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *RevenueCodeMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *RevenueCodeMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *RevenueCodeMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *RevenueCodeMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[revenuecode.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *RevenueCodeMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *RevenueCodeMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *RevenueCodeMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearExpenseAccount clears the "expense_account" edge to the GeneralLedgerAccount entity.
func (m *RevenueCodeMutation) ClearExpenseAccount() {
	m.clearedexpense_account = true
	m.clearedFields[revenuecode.FieldExpenseAccountID] = struct{}{}
}

// ExpenseAccountCleared reports if the "expense_account" edge to the GeneralLedgerAccount entity was cleared.
func (m *RevenueCodeMutation) ExpenseAccountCleared() bool {
	return m.ExpenseAccountIDCleared() || m.clearedexpense_account
}

// ExpenseAccountIDs returns the "expense_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExpenseAccountID instead. It exists only for internal usage by the builders.
func (m *RevenueCodeMutation) ExpenseAccountIDs() (ids []uuid.UUID) {
	if id := m.expense_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExpenseAccount resets all changes to the "expense_account" edge.
func (m *RevenueCodeMutation) ResetExpenseAccount() {
	m.expense_account = nil
	m.clearedexpense_account = false
}

// ClearRevenueAccount clears the "revenue_account" edge to the GeneralLedgerAccount entity.
func (m *RevenueCodeMutation) ClearRevenueAccount() {
	m.clearedrevenue_account = true
	m.clearedFields[revenuecode.FieldRevenueAccountID] = struct{}{}
}

// RevenueAccountCleared reports if the "revenue_account" edge to the GeneralLedgerAccount entity was cleared.
func (m *RevenueCodeMutation) RevenueAccountCleared() bool {
	return m.RevenueAccountIDCleared() || m.clearedrevenue_account
}

// RevenueAccountIDs returns the "revenue_account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RevenueAccountID instead. It exists only for internal usage by the builders.
func (m *RevenueCodeMutation) RevenueAccountIDs() (ids []uuid.UUID) {
	if id := m.revenue_account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRevenueAccount resets all changes to the "revenue_account" edge.
func (m *RevenueCodeMutation) ResetRevenueAccount() {
	m.revenue_account = nil
	m.clearedrevenue_account = false
}

// Where appends a list predicates to the RevenueCodeMutation builder.
func (m *RevenueCodeMutation) Where(ps ...predicate.RevenueCode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RevenueCodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RevenueCodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RevenueCode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RevenueCodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RevenueCodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RevenueCode).
func (m *RevenueCodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RevenueCodeMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.business_unit != nil {
		fields = append(fields, revenuecode.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, revenuecode.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, revenuecode.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, revenuecode.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, revenuecode.FieldStatus)
	}
	if m.code != nil {
		fields = append(fields, revenuecode.FieldCode)
	}
	if m.description != nil {
		fields = append(fields, revenuecode.FieldDescription)
	}
	if m.expense_account != nil {
		fields = append(fields, revenuecode.FieldExpenseAccountID)
	}
	if m.revenue_account != nil {
		fields = append(fields, revenuecode.FieldRevenueAccountID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RevenueCodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case revenuecode.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case revenuecode.FieldOrganizationID:
		return m.OrganizationID()
	case revenuecode.FieldCreatedAt:
		return m.CreatedAt()
	case revenuecode.FieldUpdatedAt:
		return m.UpdatedAt()
	case revenuecode.FieldStatus:
		return m.Status()
	case revenuecode.FieldCode:
		return m.Code()
	case revenuecode.FieldDescription:
		return m.Description()
	case revenuecode.FieldExpenseAccountID:
		return m.ExpenseAccountID()
	case revenuecode.FieldRevenueAccountID:
		return m.RevenueAccountID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RevenueCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case revenuecode.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case revenuecode.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case revenuecode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case revenuecode.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case revenuecode.FieldStatus:
		return m.OldStatus(ctx)
	case revenuecode.FieldCode:
		return m.OldCode(ctx)
	case revenuecode.FieldDescription:
		return m.OldDescription(ctx)
	case revenuecode.FieldExpenseAccountID:
		return m.OldExpenseAccountID(ctx)
	case revenuecode.FieldRevenueAccountID:
		return m.OldRevenueAccountID(ctx)
	}
	return nil, fmt.Errorf("unknown RevenueCode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RevenueCodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case revenuecode.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case revenuecode.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case revenuecode.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case revenuecode.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case revenuecode.FieldStatus:
		v, ok := value.(revenuecode.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case revenuecode.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case revenuecode.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case revenuecode.FieldExpenseAccountID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpenseAccountID(v)
		return nil
	case revenuecode.FieldRevenueAccountID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevenueAccountID(v)
		return nil
	}
	return fmt.Errorf("unknown RevenueCode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RevenueCodeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RevenueCodeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RevenueCodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RevenueCode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RevenueCodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(revenuecode.FieldExpenseAccountID) {
		fields = append(fields, revenuecode.FieldExpenseAccountID)
	}
	if m.FieldCleared(revenuecode.FieldRevenueAccountID) {
		fields = append(fields, revenuecode.FieldRevenueAccountID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RevenueCodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RevenueCodeMutation) ClearField(name string) error {
	switch name {
	case revenuecode.FieldExpenseAccountID:
		m.ClearExpenseAccountID()
		return nil
	case revenuecode.FieldRevenueAccountID:
		m.ClearRevenueAccountID()
		return nil
	}
	return fmt.Errorf("unknown RevenueCode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RevenueCodeMutation) ResetField(name string) error {
	switch name {
	case revenuecode.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case revenuecode.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case revenuecode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case revenuecode.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case revenuecode.FieldStatus:
		m.ResetStatus()
		return nil
	case revenuecode.FieldCode:
		m.ResetCode()
		return nil
	case revenuecode.FieldDescription:
		m.ResetDescription()
		return nil
	case revenuecode.FieldExpenseAccountID:
		m.ResetExpenseAccountID()
		return nil
	case revenuecode.FieldRevenueAccountID:
		m.ResetRevenueAccountID()
		return nil
	}
	return fmt.Errorf("unknown RevenueCode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RevenueCodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.business_unit != nil {
		edges = append(edges, revenuecode.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, revenuecode.EdgeOrganization)
	}
	if m.expense_account != nil {
		edges = append(edges, revenuecode.EdgeExpenseAccount)
	}
	if m.revenue_account != nil {
		edges = append(edges, revenuecode.EdgeRevenueAccount)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RevenueCodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case revenuecode.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case revenuecode.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case revenuecode.EdgeExpenseAccount:
		if id := m.expense_account; id != nil {
			return []ent.Value{*id}
		}
	case revenuecode.EdgeRevenueAccount:
		if id := m.revenue_account; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RevenueCodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RevenueCodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RevenueCodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedbusiness_unit {
		edges = append(edges, revenuecode.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, revenuecode.EdgeOrganization)
	}
	if m.clearedexpense_account {
		edges = append(edges, revenuecode.EdgeExpenseAccount)
	}
	if m.clearedrevenue_account {
		edges = append(edges, revenuecode.EdgeRevenueAccount)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RevenueCodeMutation) EdgeCleared(name string) bool {
	switch name {
	case revenuecode.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case revenuecode.EdgeOrganization:
		return m.clearedorganization
	case revenuecode.EdgeExpenseAccount:
		return m.clearedexpense_account
	case revenuecode.EdgeRevenueAccount:
		return m.clearedrevenue_account
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RevenueCodeMutation) ClearEdge(name string) error {
	switch name {
	case revenuecode.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case revenuecode.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case revenuecode.EdgeExpenseAccount:
		m.ClearExpenseAccount()
		return nil
	case revenuecode.EdgeRevenueAccount:
		m.ClearRevenueAccount()
		return nil
	}
	return fmt.Errorf("unknown RevenueCode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RevenueCodeMutation) ResetEdge(name string) error {
	switch name {
	case revenuecode.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case revenuecode.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case revenuecode.EdgeExpenseAccount:
		m.ResetExpenseAccount()
		return nil
	case revenuecode.EdgeRevenueAccount:
		m.ResetRevenueAccount()
		return nil
	}
	return fmt.Errorf("unknown RevenueCode edge %s", name)
}

// RouteControlMutation represents an operation that mutates the RouteControl nodes in the graph.
type RouteControlMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	distance_method      *routecontrol.DistanceMethod
	mileage_unit         *routecontrol.MileageUnit
	generate_routes      *bool
	clearedFields        map[string]struct{}
	organization         *uuid.UUID
	clearedorganization  bool
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	done                 bool
	oldValue             func(context.Context) (*RouteControl, error)
	predicates           []predicate.RouteControl
}

var _ ent.Mutation = (*RouteControlMutation)(nil)

// routecontrolOption allows management of the mutation configuration using functional options.
type routecontrolOption func(*RouteControlMutation)

// newRouteControlMutation creates new mutation for the RouteControl entity.
func newRouteControlMutation(c config, op Op, opts ...routecontrolOption) *RouteControlMutation {
	m := &RouteControlMutation{
		config:        c,
		op:            op,
		typ:           TypeRouteControl,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRouteControlID sets the ID field of the mutation.
func withRouteControlID(id uuid.UUID) routecontrolOption {
	return func(m *RouteControlMutation) {
		var (
			err   error
			once  sync.Once
			value *RouteControl
		)
		m.oldValue = func(ctx context.Context) (*RouteControl, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RouteControl.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRouteControl sets the old RouteControl of the mutation.
func withRouteControl(node *RouteControl) routecontrolOption {
	return func(m *RouteControlMutation) {
		m.oldValue = func(context.Context) (*RouteControl, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RouteControlMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RouteControlMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RouteControl entities.
func (m *RouteControlMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RouteControlMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RouteControlMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RouteControl.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RouteControlMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RouteControlMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RouteControl entity.
// If the RouteControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteControlMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RouteControlMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RouteControlMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RouteControlMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RouteControl entity.
// If the RouteControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteControlMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RouteControlMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDistanceMethod sets the "distance_method" field.
func (m *RouteControlMutation) SetDistanceMethod(rm routecontrol.DistanceMethod) {
	m.distance_method = &rm
}

// DistanceMethod returns the value of the "distance_method" field in the mutation.
func (m *RouteControlMutation) DistanceMethod() (r routecontrol.DistanceMethod, exists bool) {
	v := m.distance_method
	if v == nil {
		return
	}
	return *v, true
}

// OldDistanceMethod returns the old "distance_method" field's value of the RouteControl entity.
// If the RouteControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteControlMutation) OldDistanceMethod(ctx context.Context) (v routecontrol.DistanceMethod, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDistanceMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDistanceMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistanceMethod: %w", err)
	}
	return oldValue.DistanceMethod, nil
}

// ResetDistanceMethod resets all changes to the "distance_method" field.
func (m *RouteControlMutation) ResetDistanceMethod() {
	m.distance_method = nil
}

// SetMileageUnit sets the "mileage_unit" field.
func (m *RouteControlMutation) SetMileageUnit(ru routecontrol.MileageUnit) {
	m.mileage_unit = &ru
}

// MileageUnit returns the value of the "mileage_unit" field in the mutation.
func (m *RouteControlMutation) MileageUnit() (r routecontrol.MileageUnit, exists bool) {
	v := m.mileage_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldMileageUnit returns the old "mileage_unit" field's value of the RouteControl entity.
// If the RouteControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteControlMutation) OldMileageUnit(ctx context.Context) (v routecontrol.MileageUnit, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMileageUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMileageUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMileageUnit: %w", err)
	}
	return oldValue.MileageUnit, nil
}

// ResetMileageUnit resets all changes to the "mileage_unit" field.
func (m *RouteControlMutation) ResetMileageUnit() {
	m.mileage_unit = nil
}

// SetGenerateRoutes sets the "generate_routes" field.
func (m *RouteControlMutation) SetGenerateRoutes(b bool) {
	m.generate_routes = &b
}

// GenerateRoutes returns the value of the "generate_routes" field in the mutation.
func (m *RouteControlMutation) GenerateRoutes() (r bool, exists bool) {
	v := m.generate_routes
	if v == nil {
		return
	}
	return *v, true
}

// OldGenerateRoutes returns the old "generate_routes" field's value of the RouteControl entity.
// If the RouteControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteControlMutation) OldGenerateRoutes(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGenerateRoutes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGenerateRoutes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenerateRoutes: %w", err)
	}
	return oldValue.GenerateRoutes, nil
}

// ResetGenerateRoutes resets all changes to the "generate_routes" field.
func (m *RouteControlMutation) ResetGenerateRoutes() {
	m.generate_routes = nil
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *RouteControlMutation) SetOrganizationID(id uuid.UUID) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *RouteControlMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *RouteControlMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *RouteControlMutation) OrganizationID() (id uuid.UUID, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *RouteControlMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *RouteControlMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// SetBusinessUnitID sets the "business_unit" edge to the BusinessUnit entity by id.
func (m *RouteControlMutation) SetBusinessUnitID(id uuid.UUID) {
	m.business_unit = &id
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *RouteControlMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *RouteControlMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitID returns the "business_unit" edge ID in the mutation.
func (m *RouteControlMutation) BusinessUnitID() (id uuid.UUID, exists bool) {
	if m.business_unit != nil {
		return *m.business_unit, true
	}
	return
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *RouteControlMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *RouteControlMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// Where appends a list predicates to the RouteControlMutation builder.
func (m *RouteControlMutation) Where(ps ...predicate.RouteControl) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RouteControlMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RouteControlMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RouteControl, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RouteControlMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RouteControlMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RouteControl).
func (m *RouteControlMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RouteControlMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, routecontrol.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, routecontrol.FieldUpdatedAt)
	}
	if m.distance_method != nil {
		fields = append(fields, routecontrol.FieldDistanceMethod)
	}
	if m.mileage_unit != nil {
		fields = append(fields, routecontrol.FieldMileageUnit)
	}
	if m.generate_routes != nil {
		fields = append(fields, routecontrol.FieldGenerateRoutes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RouteControlMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case routecontrol.FieldCreatedAt:
		return m.CreatedAt()
	case routecontrol.FieldUpdatedAt:
		return m.UpdatedAt()
	case routecontrol.FieldDistanceMethod:
		return m.DistanceMethod()
	case routecontrol.FieldMileageUnit:
		return m.MileageUnit()
	case routecontrol.FieldGenerateRoutes:
		return m.GenerateRoutes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RouteControlMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case routecontrol.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case routecontrol.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case routecontrol.FieldDistanceMethod:
		return m.OldDistanceMethod(ctx)
	case routecontrol.FieldMileageUnit:
		return m.OldMileageUnit(ctx)
	case routecontrol.FieldGenerateRoutes:
		return m.OldGenerateRoutes(ctx)
	}
	return nil, fmt.Errorf("unknown RouteControl field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RouteControlMutation) SetField(name string, value ent.Value) error {
	switch name {
	case routecontrol.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case routecontrol.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case routecontrol.FieldDistanceMethod:
		v, ok := value.(routecontrol.DistanceMethod)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistanceMethod(v)
		return nil
	case routecontrol.FieldMileageUnit:
		v, ok := value.(routecontrol.MileageUnit)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMileageUnit(v)
		return nil
	case routecontrol.FieldGenerateRoutes:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenerateRoutes(v)
		return nil
	}
	return fmt.Errorf("unknown RouteControl field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RouteControlMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RouteControlMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RouteControlMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RouteControl numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RouteControlMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RouteControlMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RouteControlMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RouteControl nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RouteControlMutation) ResetField(name string) error {
	switch name {
	case routecontrol.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case routecontrol.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case routecontrol.FieldDistanceMethod:
		m.ResetDistanceMethod()
		return nil
	case routecontrol.FieldMileageUnit:
		m.ResetMileageUnit()
		return nil
	case routecontrol.FieldGenerateRoutes:
		m.ResetGenerateRoutes()
		return nil
	}
	return fmt.Errorf("unknown RouteControl field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RouteControlMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.organization != nil {
		edges = append(edges, routecontrol.EdgeOrganization)
	}
	if m.business_unit != nil {
		edges = append(edges, routecontrol.EdgeBusinessUnit)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RouteControlMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case routecontrol.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case routecontrol.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RouteControlMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RouteControlMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RouteControlMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorganization {
		edges = append(edges, routecontrol.EdgeOrganization)
	}
	if m.clearedbusiness_unit {
		edges = append(edges, routecontrol.EdgeBusinessUnit)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RouteControlMutation) EdgeCleared(name string) bool {
	switch name {
	case routecontrol.EdgeOrganization:
		return m.clearedorganization
	case routecontrol.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RouteControlMutation) ClearEdge(name string) error {
	switch name {
	case routecontrol.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case routecontrol.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	}
	return fmt.Errorf("unknown RouteControl unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RouteControlMutation) ResetEdge(name string) error {
	switch name {
	case routecontrol.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case routecontrol.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	}
	return fmt.Errorf("unknown RouteControl edge %s", name)
}

// ServiceTypeMutation represents an operation that mutates the ServiceType nodes in the graph.
type ServiceTypeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	status               *servicetype.Status
	code                 *string
	description          *string
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	done                 bool
	oldValue             func(context.Context) (*ServiceType, error)
	predicates           []predicate.ServiceType
}

var _ ent.Mutation = (*ServiceTypeMutation)(nil)

// servicetypeOption allows management of the mutation configuration using functional options.
type servicetypeOption func(*ServiceTypeMutation)

// newServiceTypeMutation creates new mutation for the ServiceType entity.
func newServiceTypeMutation(c config, op Op, opts ...servicetypeOption) *ServiceTypeMutation {
	m := &ServiceTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeServiceType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServiceTypeID sets the ID field of the mutation.
func withServiceTypeID(id uuid.UUID) servicetypeOption {
	return func(m *ServiceTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ServiceType
		)
		m.oldValue = func(ctx context.Context) (*ServiceType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ServiceType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServiceType sets the old ServiceType of the mutation.
func withServiceType(node *ServiceType) servicetypeOption {
	return func(m *ServiceTypeMutation) {
		m.oldValue = func(context.Context) (*ServiceType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServiceTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServiceTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ServiceType entities.
func (m *ServiceTypeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServiceTypeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServiceTypeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ServiceType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *ServiceTypeMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *ServiceTypeMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the ServiceType entity.
// If the ServiceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceTypeMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *ServiceTypeMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *ServiceTypeMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *ServiceTypeMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the ServiceType entity.
// If the ServiceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceTypeMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *ServiceTypeMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ServiceTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServiceTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ServiceType entity.
// If the ServiceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServiceTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServiceTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServiceTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ServiceType entity.
// If the ServiceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServiceTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *ServiceTypeMutation) SetStatus(s servicetype.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ServiceTypeMutation) Status() (r servicetype.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ServiceType entity.
// If the ServiceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceTypeMutation) OldStatus(ctx context.Context) (v servicetype.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ServiceTypeMutation) ResetStatus() {
	m.status = nil
}

// SetCode sets the "code" field.
func (m *ServiceTypeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *ServiceTypeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the ServiceType entity.
// If the ServiceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceTypeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *ServiceTypeMutation) ResetCode() {
	m.code = nil
}

// SetDescription sets the "description" field.
func (m *ServiceTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ServiceTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ServiceType entity.
// If the ServiceType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServiceTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ServiceTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[servicetype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ServiceTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[servicetype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ServiceTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, servicetype.FieldDescription)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *ServiceTypeMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[servicetype.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *ServiceTypeMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *ServiceTypeMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *ServiceTypeMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *ServiceTypeMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[servicetype.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *ServiceTypeMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *ServiceTypeMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *ServiceTypeMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the ServiceTypeMutation builder.
func (m *ServiceTypeMutation) Where(ps ...predicate.ServiceType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServiceTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServiceTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ServiceType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServiceTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServiceTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ServiceType).
func (m *ServiceTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServiceTypeMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.business_unit != nil {
		fields = append(fields, servicetype.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, servicetype.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, servicetype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, servicetype.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, servicetype.FieldStatus)
	}
	if m.code != nil {
		fields = append(fields, servicetype.FieldCode)
	}
	if m.description != nil {
		fields = append(fields, servicetype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServiceTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case servicetype.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case servicetype.FieldOrganizationID:
		return m.OrganizationID()
	case servicetype.FieldCreatedAt:
		return m.CreatedAt()
	case servicetype.FieldUpdatedAt:
		return m.UpdatedAt()
	case servicetype.FieldStatus:
		return m.Status()
	case servicetype.FieldCode:
		return m.Code()
	case servicetype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServiceTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case servicetype.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case servicetype.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case servicetype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case servicetype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case servicetype.FieldStatus:
		return m.OldStatus(ctx)
	case servicetype.FieldCode:
		return m.OldCode(ctx)
	case servicetype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown ServiceType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case servicetype.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case servicetype.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case servicetype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case servicetype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case servicetype.FieldStatus:
		v, ok := value.(servicetype.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case servicetype.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case servicetype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown ServiceType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServiceTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServiceTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServiceTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ServiceType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServiceTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(servicetype.FieldDescription) {
		fields = append(fields, servicetype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServiceTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServiceTypeMutation) ClearField(name string) error {
	switch name {
	case servicetype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ServiceType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServiceTypeMutation) ResetField(name string) error {
	switch name {
	case servicetype.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case servicetype.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case servicetype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case servicetype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case servicetype.FieldStatus:
		m.ResetStatus()
		return nil
	case servicetype.FieldCode:
		m.ResetCode()
		return nil
	case servicetype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown ServiceType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServiceTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.business_unit != nil {
		edges = append(edges, servicetype.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, servicetype.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServiceTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case servicetype.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case servicetype.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServiceTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServiceTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServiceTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbusiness_unit {
		edges = append(edges, servicetype.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, servicetype.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServiceTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case servicetype.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case servicetype.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServiceTypeMutation) ClearEdge(name string) error {
	switch name {
	case servicetype.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case servicetype.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown ServiceType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServiceTypeMutation) ResetEdge(name string) error {
	switch name {
	case servicetype.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case servicetype.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown ServiceType edge %s", name)
}

// SessionMutation represents an operation that mutates the Session nodes in the graph.
type SessionMutation struct {
	config
	op            Op
	typ           string
	id            *string
	data          *string
	created_at    *time.Time
	updated_at    *time.Time
	expires_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Session, error)
	predicates    []predicate.Session
}

var _ ent.Mutation = (*SessionMutation)(nil)

// sessionOption allows management of the mutation configuration using functional options.
type sessionOption func(*SessionMutation)

// newSessionMutation creates new mutation for the Session entity.
func newSessionMutation(c config, op Op, opts ...sessionOption) *SessionMutation {
	m := &SessionMutation{
		config:        c,
		op:            op,
		typ:           TypeSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionID sets the ID field of the mutation.
func withSessionID(id string) sessionOption {
	return func(m *SessionMutation) {
		var (
			err   error
			once  sync.Once
			value *Session
		)
		m.oldValue = func(ctx context.Context) (*Session, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Session.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSession sets the old Session of the mutation.
func withSession(node *Session) sessionOption {
	return func(m *SessionMutation) {
		m.oldValue = func(context.Context) (*Session, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Session entities.
func (m *SessionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SessionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SessionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Session.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetData sets the "data" field.
func (m *SessionMutation) SetData(s string) {
	m.data = &s
}

// Data returns the value of the "data" field in the mutation.
func (m *SessionMutation) Data() (r string, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData resets all changes to the "data" field.
func (m *SessionMutation) ResetData() {
	m.data = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SessionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SessionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SessionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *SessionMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *SessionMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *SessionMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// Where appends a list predicates to the SessionMutation builder.
func (m *SessionMutation) Where(ps ...predicate.Session) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Session, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Session).
func (m *SessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SessionMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.data != nil {
		fields = append(fields, session.FieldData)
	}
	if m.created_at != nil {
		fields = append(fields, session.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, session.FieldUpdatedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, session.FieldExpiresAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case session.FieldData:
		return m.Data()
	case session.FieldCreatedAt:
		return m.CreatedAt()
	case session.FieldUpdatedAt:
		return m.UpdatedAt()
	case session.FieldExpiresAt:
		return m.ExpiresAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case session.FieldData:
		return m.OldData(ctx)
	case session.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case session.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case session.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	}
	return nil, fmt.Errorf("unknown Session field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case session.FieldData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	case session.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case session.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case session.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Session numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SessionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Session nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SessionMutation) ResetField(name string) error {
	switch name {
	case session.FieldData:
		m.ResetData()
		return nil
	case session.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case session.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case session.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SessionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SessionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SessionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Session unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SessionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Session edge %s", name)
}

// ShipmentControlMutation represents an operation that mutates the ShipmentControl nodes in the graph.
type ShipmentControlMutation struct {
	config
	op                         Op
	typ                        string
	id                         *uuid.UUID
	created_at                 *time.Time
	updated_at                 *time.Time
	auto_rate_shipment         *bool
	calculate_distance         *bool
	enforce_rev_code           *bool
	enforce_voided_comm        *bool
	generate_routes            *bool
	enforce_commodity          *bool
	auto_sequence_stops        *bool
	auto_shipment_total        *bool
	enforce_origin_destination *bool
	check_for_duplicate_bol    *bool
	send_placard_info          *bool
	enforce_hazmat_seg_rules   *bool
	clearedFields              map[string]struct{}
	organization               *uuid.UUID
	clearedorganization        bool
	business_unit              *uuid.UUID
	clearedbusiness_unit       bool
	done                       bool
	oldValue                   func(context.Context) (*ShipmentControl, error)
	predicates                 []predicate.ShipmentControl
}

var _ ent.Mutation = (*ShipmentControlMutation)(nil)

// shipmentcontrolOption allows management of the mutation configuration using functional options.
type shipmentcontrolOption func(*ShipmentControlMutation)

// newShipmentControlMutation creates new mutation for the ShipmentControl entity.
func newShipmentControlMutation(c config, op Op, opts ...shipmentcontrolOption) *ShipmentControlMutation {
	m := &ShipmentControlMutation{
		config:        c,
		op:            op,
		typ:           TypeShipmentControl,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShipmentControlID sets the ID field of the mutation.
func withShipmentControlID(id uuid.UUID) shipmentcontrolOption {
	return func(m *ShipmentControlMutation) {
		var (
			err   error
			once  sync.Once
			value *ShipmentControl
		)
		m.oldValue = func(ctx context.Context) (*ShipmentControl, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShipmentControl.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShipmentControl sets the old ShipmentControl of the mutation.
func withShipmentControl(node *ShipmentControl) shipmentcontrolOption {
	return func(m *ShipmentControlMutation) {
		m.oldValue = func(context.Context) (*ShipmentControl, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShipmentControlMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShipmentControlMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ShipmentControl entities.
func (m *ShipmentControlMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShipmentControlMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ShipmentControlMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ShipmentControl.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ShipmentControlMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ShipmentControlMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ShipmentControl entity.
// If the ShipmentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentControlMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ShipmentControlMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ShipmentControlMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ShipmentControlMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ShipmentControl entity.
// If the ShipmentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentControlMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ShipmentControlMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAutoRateShipment sets the "auto_rate_shipment" field.
func (m *ShipmentControlMutation) SetAutoRateShipment(b bool) {
	m.auto_rate_shipment = &b
}

// AutoRateShipment returns the value of the "auto_rate_shipment" field in the mutation.
func (m *ShipmentControlMutation) AutoRateShipment() (r bool, exists bool) {
	v := m.auto_rate_shipment
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoRateShipment returns the old "auto_rate_shipment" field's value of the ShipmentControl entity.
// If the ShipmentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentControlMutation) OldAutoRateShipment(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoRateShipment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoRateShipment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoRateShipment: %w", err)
	}
	return oldValue.AutoRateShipment, nil
}

// ResetAutoRateShipment resets all changes to the "auto_rate_shipment" field.
func (m *ShipmentControlMutation) ResetAutoRateShipment() {
	m.auto_rate_shipment = nil
}

// SetCalculateDistance sets the "calculate_distance" field.
func (m *ShipmentControlMutation) SetCalculateDistance(b bool) {
	m.calculate_distance = &b
}

// CalculateDistance returns the value of the "calculate_distance" field in the mutation.
func (m *ShipmentControlMutation) CalculateDistance() (r bool, exists bool) {
	v := m.calculate_distance
	if v == nil {
		return
	}
	return *v, true
}

// OldCalculateDistance returns the old "calculate_distance" field's value of the ShipmentControl entity.
// If the ShipmentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentControlMutation) OldCalculateDistance(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCalculateDistance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCalculateDistance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCalculateDistance: %w", err)
	}
	return oldValue.CalculateDistance, nil
}

// ResetCalculateDistance resets all changes to the "calculate_distance" field.
func (m *ShipmentControlMutation) ResetCalculateDistance() {
	m.calculate_distance = nil
}

// SetEnforceRevCode sets the "enforce_rev_code" field.
func (m *ShipmentControlMutation) SetEnforceRevCode(b bool) {
	m.enforce_rev_code = &b
}

// EnforceRevCode returns the value of the "enforce_rev_code" field in the mutation.
func (m *ShipmentControlMutation) EnforceRevCode() (r bool, exists bool) {
	v := m.enforce_rev_code
	if v == nil {
		return
	}
	return *v, true
}

// OldEnforceRevCode returns the old "enforce_rev_code" field's value of the ShipmentControl entity.
// If the ShipmentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentControlMutation) OldEnforceRevCode(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnforceRevCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnforceRevCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnforceRevCode: %w", err)
	}
	return oldValue.EnforceRevCode, nil
}

// ResetEnforceRevCode resets all changes to the "enforce_rev_code" field.
func (m *ShipmentControlMutation) ResetEnforceRevCode() {
	m.enforce_rev_code = nil
}

// SetEnforceVoidedComm sets the "enforce_voided_comm" field.
func (m *ShipmentControlMutation) SetEnforceVoidedComm(b bool) {
	m.enforce_voided_comm = &b
}

// EnforceVoidedComm returns the value of the "enforce_voided_comm" field in the mutation.
func (m *ShipmentControlMutation) EnforceVoidedComm() (r bool, exists bool) {
	v := m.enforce_voided_comm
	if v == nil {
		return
	}
	return *v, true
}

// OldEnforceVoidedComm returns the old "enforce_voided_comm" field's value of the ShipmentControl entity.
// If the ShipmentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentControlMutation) OldEnforceVoidedComm(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnforceVoidedComm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnforceVoidedComm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnforceVoidedComm: %w", err)
	}
	return oldValue.EnforceVoidedComm, nil
}

// ResetEnforceVoidedComm resets all changes to the "enforce_voided_comm" field.
func (m *ShipmentControlMutation) ResetEnforceVoidedComm() {
	m.enforce_voided_comm = nil
}

// SetGenerateRoutes sets the "generate_routes" field.
func (m *ShipmentControlMutation) SetGenerateRoutes(b bool) {
	m.generate_routes = &b
}

// GenerateRoutes returns the value of the "generate_routes" field in the mutation.
func (m *ShipmentControlMutation) GenerateRoutes() (r bool, exists bool) {
	v := m.generate_routes
	if v == nil {
		return
	}
	return *v, true
}

// OldGenerateRoutes returns the old "generate_routes" field's value of the ShipmentControl entity.
// If the ShipmentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentControlMutation) OldGenerateRoutes(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGenerateRoutes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGenerateRoutes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGenerateRoutes: %w", err)
	}
	return oldValue.GenerateRoutes, nil
}

// ResetGenerateRoutes resets all changes to the "generate_routes" field.
func (m *ShipmentControlMutation) ResetGenerateRoutes() {
	m.generate_routes = nil
}

// SetEnforceCommodity sets the "enforce_commodity" field.
func (m *ShipmentControlMutation) SetEnforceCommodity(b bool) {
	m.enforce_commodity = &b
}

// EnforceCommodity returns the value of the "enforce_commodity" field in the mutation.
func (m *ShipmentControlMutation) EnforceCommodity() (r bool, exists bool) {
	v := m.enforce_commodity
	if v == nil {
		return
	}
	return *v, true
}

// OldEnforceCommodity returns the old "enforce_commodity" field's value of the ShipmentControl entity.
// If the ShipmentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentControlMutation) OldEnforceCommodity(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnforceCommodity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnforceCommodity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnforceCommodity: %w", err)
	}
	return oldValue.EnforceCommodity, nil
}

// ResetEnforceCommodity resets all changes to the "enforce_commodity" field.
func (m *ShipmentControlMutation) ResetEnforceCommodity() {
	m.enforce_commodity = nil
}

// SetAutoSequenceStops sets the "auto_sequence_stops" field.
func (m *ShipmentControlMutation) SetAutoSequenceStops(b bool) {
	m.auto_sequence_stops = &b
}

// AutoSequenceStops returns the value of the "auto_sequence_stops" field in the mutation.
func (m *ShipmentControlMutation) AutoSequenceStops() (r bool, exists bool) {
	v := m.auto_sequence_stops
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoSequenceStops returns the old "auto_sequence_stops" field's value of the ShipmentControl entity.
// If the ShipmentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentControlMutation) OldAutoSequenceStops(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoSequenceStops is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoSequenceStops requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoSequenceStops: %w", err)
	}
	return oldValue.AutoSequenceStops, nil
}

// ResetAutoSequenceStops resets all changes to the "auto_sequence_stops" field.
func (m *ShipmentControlMutation) ResetAutoSequenceStops() {
	m.auto_sequence_stops = nil
}

// SetAutoShipmentTotal sets the "auto_shipment_total" field.
func (m *ShipmentControlMutation) SetAutoShipmentTotal(b bool) {
	m.auto_shipment_total = &b
}

// AutoShipmentTotal returns the value of the "auto_shipment_total" field in the mutation.
func (m *ShipmentControlMutation) AutoShipmentTotal() (r bool, exists bool) {
	v := m.auto_shipment_total
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoShipmentTotal returns the old "auto_shipment_total" field's value of the ShipmentControl entity.
// If the ShipmentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentControlMutation) OldAutoShipmentTotal(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoShipmentTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoShipmentTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoShipmentTotal: %w", err)
	}
	return oldValue.AutoShipmentTotal, nil
}

// ResetAutoShipmentTotal resets all changes to the "auto_shipment_total" field.
func (m *ShipmentControlMutation) ResetAutoShipmentTotal() {
	m.auto_shipment_total = nil
}

// SetEnforceOriginDestination sets the "enforce_origin_destination" field.
func (m *ShipmentControlMutation) SetEnforceOriginDestination(b bool) {
	m.enforce_origin_destination = &b
}

// EnforceOriginDestination returns the value of the "enforce_origin_destination" field in the mutation.
func (m *ShipmentControlMutation) EnforceOriginDestination() (r bool, exists bool) {
	v := m.enforce_origin_destination
	if v == nil {
		return
	}
	return *v, true
}

// OldEnforceOriginDestination returns the old "enforce_origin_destination" field's value of the ShipmentControl entity.
// If the ShipmentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentControlMutation) OldEnforceOriginDestination(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnforceOriginDestination is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnforceOriginDestination requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnforceOriginDestination: %w", err)
	}
	return oldValue.EnforceOriginDestination, nil
}

// ResetEnforceOriginDestination resets all changes to the "enforce_origin_destination" field.
func (m *ShipmentControlMutation) ResetEnforceOriginDestination() {
	m.enforce_origin_destination = nil
}

// SetCheckForDuplicateBol sets the "check_for_duplicate_bol" field.
func (m *ShipmentControlMutation) SetCheckForDuplicateBol(b bool) {
	m.check_for_duplicate_bol = &b
}

// CheckForDuplicateBol returns the value of the "check_for_duplicate_bol" field in the mutation.
func (m *ShipmentControlMutation) CheckForDuplicateBol() (r bool, exists bool) {
	v := m.check_for_duplicate_bol
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckForDuplicateBol returns the old "check_for_duplicate_bol" field's value of the ShipmentControl entity.
// If the ShipmentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentControlMutation) OldCheckForDuplicateBol(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCheckForDuplicateBol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCheckForDuplicateBol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckForDuplicateBol: %w", err)
	}
	return oldValue.CheckForDuplicateBol, nil
}

// ResetCheckForDuplicateBol resets all changes to the "check_for_duplicate_bol" field.
func (m *ShipmentControlMutation) ResetCheckForDuplicateBol() {
	m.check_for_duplicate_bol = nil
}

// SetSendPlacardInfo sets the "send_placard_info" field.
func (m *ShipmentControlMutation) SetSendPlacardInfo(b bool) {
	m.send_placard_info = &b
}

// SendPlacardInfo returns the value of the "send_placard_info" field in the mutation.
func (m *ShipmentControlMutation) SendPlacardInfo() (r bool, exists bool) {
	v := m.send_placard_info
	if v == nil {
		return
	}
	return *v, true
}

// OldSendPlacardInfo returns the old "send_placard_info" field's value of the ShipmentControl entity.
// If the ShipmentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentControlMutation) OldSendPlacardInfo(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSendPlacardInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSendPlacardInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSendPlacardInfo: %w", err)
	}
	return oldValue.SendPlacardInfo, nil
}

// ResetSendPlacardInfo resets all changes to the "send_placard_info" field.
func (m *ShipmentControlMutation) ResetSendPlacardInfo() {
	m.send_placard_info = nil
}

// SetEnforceHazmatSegRules sets the "enforce_hazmat_seg_rules" field.
func (m *ShipmentControlMutation) SetEnforceHazmatSegRules(b bool) {
	m.enforce_hazmat_seg_rules = &b
}

// EnforceHazmatSegRules returns the value of the "enforce_hazmat_seg_rules" field in the mutation.
func (m *ShipmentControlMutation) EnforceHazmatSegRules() (r bool, exists bool) {
	v := m.enforce_hazmat_seg_rules
	if v == nil {
		return
	}
	return *v, true
}

// OldEnforceHazmatSegRules returns the old "enforce_hazmat_seg_rules" field's value of the ShipmentControl entity.
// If the ShipmentControl object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentControlMutation) OldEnforceHazmatSegRules(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnforceHazmatSegRules is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnforceHazmatSegRules requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnforceHazmatSegRules: %w", err)
	}
	return oldValue.EnforceHazmatSegRules, nil
}

// ResetEnforceHazmatSegRules resets all changes to the "enforce_hazmat_seg_rules" field.
func (m *ShipmentControlMutation) ResetEnforceHazmatSegRules() {
	m.enforce_hazmat_seg_rules = nil
}

// SetOrganizationID sets the "organization" edge to the Organization entity by id.
func (m *ShipmentControlMutation) SetOrganizationID(id uuid.UUID) {
	m.organization = &id
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *ShipmentControlMutation) ClearOrganization() {
	m.clearedorganization = true
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *ShipmentControlMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationID returns the "organization" edge ID in the mutation.
func (m *ShipmentControlMutation) OrganizationID() (id uuid.UUID, exists bool) {
	if m.organization != nil {
		return *m.organization, true
	}
	return
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *ShipmentControlMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *ShipmentControlMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// SetBusinessUnitID sets the "business_unit" edge to the BusinessUnit entity by id.
func (m *ShipmentControlMutation) SetBusinessUnitID(id uuid.UUID) {
	m.business_unit = &id
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *ShipmentControlMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *ShipmentControlMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitID returns the "business_unit" edge ID in the mutation.
func (m *ShipmentControlMutation) BusinessUnitID() (id uuid.UUID, exists bool) {
	if m.business_unit != nil {
		return *m.business_unit, true
	}
	return
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *ShipmentControlMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *ShipmentControlMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// Where appends a list predicates to the ShipmentControlMutation builder.
func (m *ShipmentControlMutation) Where(ps ...predicate.ShipmentControl) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ShipmentControlMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ShipmentControlMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ShipmentControl, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ShipmentControlMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ShipmentControlMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ShipmentControl).
func (m *ShipmentControlMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShipmentControlMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, shipmentcontrol.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, shipmentcontrol.FieldUpdatedAt)
	}
	if m.auto_rate_shipment != nil {
		fields = append(fields, shipmentcontrol.FieldAutoRateShipment)
	}
	if m.calculate_distance != nil {
		fields = append(fields, shipmentcontrol.FieldCalculateDistance)
	}
	if m.enforce_rev_code != nil {
		fields = append(fields, shipmentcontrol.FieldEnforceRevCode)
	}
	if m.enforce_voided_comm != nil {
		fields = append(fields, shipmentcontrol.FieldEnforceVoidedComm)
	}
	if m.generate_routes != nil {
		fields = append(fields, shipmentcontrol.FieldGenerateRoutes)
	}
	if m.enforce_commodity != nil {
		fields = append(fields, shipmentcontrol.FieldEnforceCommodity)
	}
	if m.auto_sequence_stops != nil {
		fields = append(fields, shipmentcontrol.FieldAutoSequenceStops)
	}
	if m.auto_shipment_total != nil {
		fields = append(fields, shipmentcontrol.FieldAutoShipmentTotal)
	}
	if m.enforce_origin_destination != nil {
		fields = append(fields, shipmentcontrol.FieldEnforceOriginDestination)
	}
	if m.check_for_duplicate_bol != nil {
		fields = append(fields, shipmentcontrol.FieldCheckForDuplicateBol)
	}
	if m.send_placard_info != nil {
		fields = append(fields, shipmentcontrol.FieldSendPlacardInfo)
	}
	if m.enforce_hazmat_seg_rules != nil {
		fields = append(fields, shipmentcontrol.FieldEnforceHazmatSegRules)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShipmentControlMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shipmentcontrol.FieldCreatedAt:
		return m.CreatedAt()
	case shipmentcontrol.FieldUpdatedAt:
		return m.UpdatedAt()
	case shipmentcontrol.FieldAutoRateShipment:
		return m.AutoRateShipment()
	case shipmentcontrol.FieldCalculateDistance:
		return m.CalculateDistance()
	case shipmentcontrol.FieldEnforceRevCode:
		return m.EnforceRevCode()
	case shipmentcontrol.FieldEnforceVoidedComm:
		return m.EnforceVoidedComm()
	case shipmentcontrol.FieldGenerateRoutes:
		return m.GenerateRoutes()
	case shipmentcontrol.FieldEnforceCommodity:
		return m.EnforceCommodity()
	case shipmentcontrol.FieldAutoSequenceStops:
		return m.AutoSequenceStops()
	case shipmentcontrol.FieldAutoShipmentTotal:
		return m.AutoShipmentTotal()
	case shipmentcontrol.FieldEnforceOriginDestination:
		return m.EnforceOriginDestination()
	case shipmentcontrol.FieldCheckForDuplicateBol:
		return m.CheckForDuplicateBol()
	case shipmentcontrol.FieldSendPlacardInfo:
		return m.SendPlacardInfo()
	case shipmentcontrol.FieldEnforceHazmatSegRules:
		return m.EnforceHazmatSegRules()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShipmentControlMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shipmentcontrol.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case shipmentcontrol.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case shipmentcontrol.FieldAutoRateShipment:
		return m.OldAutoRateShipment(ctx)
	case shipmentcontrol.FieldCalculateDistance:
		return m.OldCalculateDistance(ctx)
	case shipmentcontrol.FieldEnforceRevCode:
		return m.OldEnforceRevCode(ctx)
	case shipmentcontrol.FieldEnforceVoidedComm:
		return m.OldEnforceVoidedComm(ctx)
	case shipmentcontrol.FieldGenerateRoutes:
		return m.OldGenerateRoutes(ctx)
	case shipmentcontrol.FieldEnforceCommodity:
		return m.OldEnforceCommodity(ctx)
	case shipmentcontrol.FieldAutoSequenceStops:
		return m.OldAutoSequenceStops(ctx)
	case shipmentcontrol.FieldAutoShipmentTotal:
		return m.OldAutoShipmentTotal(ctx)
	case shipmentcontrol.FieldEnforceOriginDestination:
		return m.OldEnforceOriginDestination(ctx)
	case shipmentcontrol.FieldCheckForDuplicateBol:
		return m.OldCheckForDuplicateBol(ctx)
	case shipmentcontrol.FieldSendPlacardInfo:
		return m.OldSendPlacardInfo(ctx)
	case shipmentcontrol.FieldEnforceHazmatSegRules:
		return m.OldEnforceHazmatSegRules(ctx)
	}
	return nil, fmt.Errorf("unknown ShipmentControl field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentControlMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shipmentcontrol.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case shipmentcontrol.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case shipmentcontrol.FieldAutoRateShipment:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoRateShipment(v)
		return nil
	case shipmentcontrol.FieldCalculateDistance:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCalculateDistance(v)
		return nil
	case shipmentcontrol.FieldEnforceRevCode:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnforceRevCode(v)
		return nil
	case shipmentcontrol.FieldEnforceVoidedComm:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnforceVoidedComm(v)
		return nil
	case shipmentcontrol.FieldGenerateRoutes:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGenerateRoutes(v)
		return nil
	case shipmentcontrol.FieldEnforceCommodity:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnforceCommodity(v)
		return nil
	case shipmentcontrol.FieldAutoSequenceStops:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoSequenceStops(v)
		return nil
	case shipmentcontrol.FieldAutoShipmentTotal:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoShipmentTotal(v)
		return nil
	case shipmentcontrol.FieldEnforceOriginDestination:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnforceOriginDestination(v)
		return nil
	case shipmentcontrol.FieldCheckForDuplicateBol:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckForDuplicateBol(v)
		return nil
	case shipmentcontrol.FieldSendPlacardInfo:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSendPlacardInfo(v)
		return nil
	case shipmentcontrol.FieldEnforceHazmatSegRules:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnforceHazmatSegRules(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentControl field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShipmentControlMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShipmentControlMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentControlMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ShipmentControl numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShipmentControlMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShipmentControlMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShipmentControlMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ShipmentControl nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShipmentControlMutation) ResetField(name string) error {
	switch name {
	case shipmentcontrol.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case shipmentcontrol.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case shipmentcontrol.FieldAutoRateShipment:
		m.ResetAutoRateShipment()
		return nil
	case shipmentcontrol.FieldCalculateDistance:
		m.ResetCalculateDistance()
		return nil
	case shipmentcontrol.FieldEnforceRevCode:
		m.ResetEnforceRevCode()
		return nil
	case shipmentcontrol.FieldEnforceVoidedComm:
		m.ResetEnforceVoidedComm()
		return nil
	case shipmentcontrol.FieldGenerateRoutes:
		m.ResetGenerateRoutes()
		return nil
	case shipmentcontrol.FieldEnforceCommodity:
		m.ResetEnforceCommodity()
		return nil
	case shipmentcontrol.FieldAutoSequenceStops:
		m.ResetAutoSequenceStops()
		return nil
	case shipmentcontrol.FieldAutoShipmentTotal:
		m.ResetAutoShipmentTotal()
		return nil
	case shipmentcontrol.FieldEnforceOriginDestination:
		m.ResetEnforceOriginDestination()
		return nil
	case shipmentcontrol.FieldCheckForDuplicateBol:
		m.ResetCheckForDuplicateBol()
		return nil
	case shipmentcontrol.FieldSendPlacardInfo:
		m.ResetSendPlacardInfo()
		return nil
	case shipmentcontrol.FieldEnforceHazmatSegRules:
		m.ResetEnforceHazmatSegRules()
		return nil
	}
	return fmt.Errorf("unknown ShipmentControl field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShipmentControlMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.organization != nil {
		edges = append(edges, shipmentcontrol.EdgeOrganization)
	}
	if m.business_unit != nil {
		edges = append(edges, shipmentcontrol.EdgeBusinessUnit)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShipmentControlMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case shipmentcontrol.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case shipmentcontrol.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShipmentControlMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShipmentControlMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShipmentControlMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorganization {
		edges = append(edges, shipmentcontrol.EdgeOrganization)
	}
	if m.clearedbusiness_unit {
		edges = append(edges, shipmentcontrol.EdgeBusinessUnit)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShipmentControlMutation) EdgeCleared(name string) bool {
	switch name {
	case shipmentcontrol.EdgeOrganization:
		return m.clearedorganization
	case shipmentcontrol.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShipmentControlMutation) ClearEdge(name string) error {
	switch name {
	case shipmentcontrol.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case shipmentcontrol.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	}
	return fmt.Errorf("unknown ShipmentControl unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShipmentControlMutation) ResetEdge(name string) error {
	switch name {
	case shipmentcontrol.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case shipmentcontrol.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	}
	return fmt.Errorf("unknown ShipmentControl edge %s", name)
}

// ShipmentTypeMutation represents an operation that mutates the ShipmentType nodes in the graph.
type ShipmentTypeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	status               *shipmenttype.Status
	code                 *string
	description          *string
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	done                 bool
	oldValue             func(context.Context) (*ShipmentType, error)
	predicates           []predicate.ShipmentType
}

var _ ent.Mutation = (*ShipmentTypeMutation)(nil)

// shipmenttypeOption allows management of the mutation configuration using functional options.
type shipmenttypeOption func(*ShipmentTypeMutation)

// newShipmentTypeMutation creates new mutation for the ShipmentType entity.
func newShipmentTypeMutation(c config, op Op, opts ...shipmenttypeOption) *ShipmentTypeMutation {
	m := &ShipmentTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeShipmentType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShipmentTypeID sets the ID field of the mutation.
func withShipmentTypeID(id uuid.UUID) shipmenttypeOption {
	return func(m *ShipmentTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *ShipmentType
		)
		m.oldValue = func(ctx context.Context) (*ShipmentType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShipmentType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShipmentType sets the old ShipmentType of the mutation.
func withShipmentType(node *ShipmentType) shipmenttypeOption {
	return func(m *ShipmentTypeMutation) {
		m.oldValue = func(context.Context) (*ShipmentType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShipmentTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShipmentTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ShipmentType entities.
func (m *ShipmentTypeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShipmentTypeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ShipmentTypeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ShipmentType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *ShipmentTypeMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *ShipmentTypeMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the ShipmentType entity.
// If the ShipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentTypeMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *ShipmentTypeMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *ShipmentTypeMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *ShipmentTypeMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the ShipmentType entity.
// If the ShipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentTypeMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *ShipmentTypeMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ShipmentTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ShipmentTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ShipmentType entity.
// If the ShipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ShipmentTypeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ShipmentTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ShipmentTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ShipmentType entity.
// If the ShipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ShipmentTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *ShipmentTypeMutation) SetStatus(s shipmenttype.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ShipmentTypeMutation) Status() (r shipmenttype.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ShipmentType entity.
// If the ShipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentTypeMutation) OldStatus(ctx context.Context) (v shipmenttype.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ShipmentTypeMutation) ResetStatus() {
	m.status = nil
}

// SetCode sets the "code" field.
func (m *ShipmentTypeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *ShipmentTypeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the ShipmentType entity.
// If the ShipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentTypeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *ShipmentTypeMutation) ResetCode() {
	m.code = nil
}

// SetDescription sets the "description" field.
func (m *ShipmentTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ShipmentTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ShipmentType entity.
// If the ShipmentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ShipmentTypeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[shipmenttype.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ShipmentTypeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[shipmenttype.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ShipmentTypeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, shipmenttype.FieldDescription)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *ShipmentTypeMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[shipmenttype.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *ShipmentTypeMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *ShipmentTypeMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *ShipmentTypeMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *ShipmentTypeMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[shipmenttype.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *ShipmentTypeMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *ShipmentTypeMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *ShipmentTypeMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the ShipmentTypeMutation builder.
func (m *ShipmentTypeMutation) Where(ps ...predicate.ShipmentType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ShipmentTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ShipmentTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ShipmentType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ShipmentTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ShipmentTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ShipmentType).
func (m *ShipmentTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShipmentTypeMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.business_unit != nil {
		fields = append(fields, shipmenttype.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, shipmenttype.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, shipmenttype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, shipmenttype.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, shipmenttype.FieldStatus)
	}
	if m.code != nil {
		fields = append(fields, shipmenttype.FieldCode)
	}
	if m.description != nil {
		fields = append(fields, shipmenttype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShipmentTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shipmenttype.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case shipmenttype.FieldOrganizationID:
		return m.OrganizationID()
	case shipmenttype.FieldCreatedAt:
		return m.CreatedAt()
	case shipmenttype.FieldUpdatedAt:
		return m.UpdatedAt()
	case shipmenttype.FieldStatus:
		return m.Status()
	case shipmenttype.FieldCode:
		return m.Code()
	case shipmenttype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShipmentTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shipmenttype.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case shipmenttype.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case shipmenttype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case shipmenttype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case shipmenttype.FieldStatus:
		return m.OldStatus(ctx)
	case shipmenttype.FieldCode:
		return m.OldCode(ctx)
	case shipmenttype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown ShipmentType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shipmenttype.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case shipmenttype.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case shipmenttype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case shipmenttype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case shipmenttype.FieldStatus:
		v, ok := value.(shipmenttype.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case shipmenttype.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case shipmenttype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShipmentTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShipmentTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ShipmentType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShipmentTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(shipmenttype.FieldDescription) {
		fields = append(fields, shipmenttype.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShipmentTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShipmentTypeMutation) ClearField(name string) error {
	switch name {
	case shipmenttype.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ShipmentType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShipmentTypeMutation) ResetField(name string) error {
	switch name {
	case shipmenttype.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case shipmenttype.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case shipmenttype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case shipmenttype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case shipmenttype.FieldStatus:
		m.ResetStatus()
		return nil
	case shipmenttype.FieldCode:
		m.ResetCode()
		return nil
	case shipmenttype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown ShipmentType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShipmentTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.business_unit != nil {
		edges = append(edges, shipmenttype.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, shipmenttype.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShipmentTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case shipmenttype.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case shipmenttype.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShipmentTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShipmentTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShipmentTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbusiness_unit {
		edges = append(edges, shipmenttype.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, shipmenttype.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShipmentTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case shipmenttype.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case shipmenttype.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShipmentTypeMutation) ClearEdge(name string) error {
	switch name {
	case shipmenttype.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case shipmenttype.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown ShipmentType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShipmentTypeMutation) ResetEdge(name string) error {
	switch name {
	case shipmenttype.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case shipmenttype.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown ShipmentType edge %s", name)
}

// TableChangeAlertMutation represents an operation that mutates the TableChangeAlert nodes in the graph.
type TableChangeAlertMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	status               *tablechangealert.Status
	name                 *string
	database_action      *tablechangealert.DatabaseAction
	source               *tablechangealert.Source
	table_name           *string
	topic_name           *string
	description          *string
	custom_subject       *string
	function_name        *string
	trigger_name         *string
	listener_name        *string
	email_recipients     *string
	effective_date       **pgtype.Date
	expiration_date      **pgtype.Date
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	done                 bool
	oldValue             func(context.Context) (*TableChangeAlert, error)
	predicates           []predicate.TableChangeAlert
}

var _ ent.Mutation = (*TableChangeAlertMutation)(nil)

// tablechangealertOption allows management of the mutation configuration using functional options.
type tablechangealertOption func(*TableChangeAlertMutation)

// newTableChangeAlertMutation creates new mutation for the TableChangeAlert entity.
func newTableChangeAlertMutation(c config, op Op, opts ...tablechangealertOption) *TableChangeAlertMutation {
	m := &TableChangeAlertMutation{
		config:        c,
		op:            op,
		typ:           TypeTableChangeAlert,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTableChangeAlertID sets the ID field of the mutation.
func withTableChangeAlertID(id uuid.UUID) tablechangealertOption {
	return func(m *TableChangeAlertMutation) {
		var (
			err   error
			once  sync.Once
			value *TableChangeAlert
		)
		m.oldValue = func(ctx context.Context) (*TableChangeAlert, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TableChangeAlert.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTableChangeAlert sets the old TableChangeAlert of the mutation.
func withTableChangeAlert(node *TableChangeAlert) tablechangealertOption {
	return func(m *TableChangeAlertMutation) {
		m.oldValue = func(context.Context) (*TableChangeAlert, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TableChangeAlertMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TableChangeAlertMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TableChangeAlert entities.
func (m *TableChangeAlertMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TableChangeAlertMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TableChangeAlertMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TableChangeAlert.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *TableChangeAlertMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *TableChangeAlertMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *TableChangeAlertMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *TableChangeAlertMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *TableChangeAlertMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *TableChangeAlertMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TableChangeAlertMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TableChangeAlertMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TableChangeAlertMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TableChangeAlertMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TableChangeAlertMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TableChangeAlertMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *TableChangeAlertMutation) SetStatus(t tablechangealert.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *TableChangeAlertMutation) Status() (r tablechangealert.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldStatus(ctx context.Context) (v tablechangealert.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TableChangeAlertMutation) ResetStatus() {
	m.status = nil
}

// SetName sets the "name" field.
func (m *TableChangeAlertMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TableChangeAlertMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TableChangeAlertMutation) ResetName() {
	m.name = nil
}

// SetDatabaseAction sets the "database_action" field.
func (m *TableChangeAlertMutation) SetDatabaseAction(ta tablechangealert.DatabaseAction) {
	m.database_action = &ta
}

// DatabaseAction returns the value of the "database_action" field in the mutation.
func (m *TableChangeAlertMutation) DatabaseAction() (r tablechangealert.DatabaseAction, exists bool) {
	v := m.database_action
	if v == nil {
		return
	}
	return *v, true
}

// OldDatabaseAction returns the old "database_action" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldDatabaseAction(ctx context.Context) (v tablechangealert.DatabaseAction, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDatabaseAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDatabaseAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDatabaseAction: %w", err)
	}
	return oldValue.DatabaseAction, nil
}

// ResetDatabaseAction resets all changes to the "database_action" field.
func (m *TableChangeAlertMutation) ResetDatabaseAction() {
	m.database_action = nil
}

// SetSource sets the "source" field.
func (m *TableChangeAlertMutation) SetSource(t tablechangealert.Source) {
	m.source = &t
}

// Source returns the value of the "source" field in the mutation.
func (m *TableChangeAlertMutation) Source() (r tablechangealert.Source, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldSource(ctx context.Context) (v tablechangealert.Source, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *TableChangeAlertMutation) ResetSource() {
	m.source = nil
}

// SetTableName sets the "table_name" field.
func (m *TableChangeAlertMutation) SetTableName(s string) {
	m.table_name = &s
}

// TableName returns the value of the "table_name" field in the mutation.
func (m *TableChangeAlertMutation) TableName() (r string, exists bool) {
	v := m.table_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTableName returns the old "table_name" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldTableName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTableName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTableName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTableName: %w", err)
	}
	return oldValue.TableName, nil
}

// ClearTableName clears the value of the "table_name" field.
func (m *TableChangeAlertMutation) ClearTableName() {
	m.table_name = nil
	m.clearedFields[tablechangealert.FieldTableName] = struct{}{}
}

// TableNameCleared returns if the "table_name" field was cleared in this mutation.
func (m *TableChangeAlertMutation) TableNameCleared() bool {
	_, ok := m.clearedFields[tablechangealert.FieldTableName]
	return ok
}

// ResetTableName resets all changes to the "table_name" field.
func (m *TableChangeAlertMutation) ResetTableName() {
	m.table_name = nil
	delete(m.clearedFields, tablechangealert.FieldTableName)
}

// SetTopicName sets the "topic_name" field.
func (m *TableChangeAlertMutation) SetTopicName(s string) {
	m.topic_name = &s
}

// TopicName returns the value of the "topic_name" field in the mutation.
func (m *TableChangeAlertMutation) TopicName() (r string, exists bool) {
	v := m.topic_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTopicName returns the old "topic_name" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldTopicName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopicName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopicName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopicName: %w", err)
	}
	return oldValue.TopicName, nil
}

// ClearTopicName clears the value of the "topic_name" field.
func (m *TableChangeAlertMutation) ClearTopicName() {
	m.topic_name = nil
	m.clearedFields[tablechangealert.FieldTopicName] = struct{}{}
}

// TopicNameCleared returns if the "topic_name" field was cleared in this mutation.
func (m *TableChangeAlertMutation) TopicNameCleared() bool {
	_, ok := m.clearedFields[tablechangealert.FieldTopicName]
	return ok
}

// ResetTopicName resets all changes to the "topic_name" field.
func (m *TableChangeAlertMutation) ResetTopicName() {
	m.topic_name = nil
	delete(m.clearedFields, tablechangealert.FieldTopicName)
}

// SetDescription sets the "description" field.
func (m *TableChangeAlertMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TableChangeAlertMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TableChangeAlertMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[tablechangealert.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TableChangeAlertMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[tablechangealert.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TableChangeAlertMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, tablechangealert.FieldDescription)
}

// SetCustomSubject sets the "custom_subject" field.
func (m *TableChangeAlertMutation) SetCustomSubject(s string) {
	m.custom_subject = &s
}

// CustomSubject returns the value of the "custom_subject" field in the mutation.
func (m *TableChangeAlertMutation) CustomSubject() (r string, exists bool) {
	v := m.custom_subject
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomSubject returns the old "custom_subject" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldCustomSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomSubject: %w", err)
	}
	return oldValue.CustomSubject, nil
}

// ClearCustomSubject clears the value of the "custom_subject" field.
func (m *TableChangeAlertMutation) ClearCustomSubject() {
	m.custom_subject = nil
	m.clearedFields[tablechangealert.FieldCustomSubject] = struct{}{}
}

// CustomSubjectCleared returns if the "custom_subject" field was cleared in this mutation.
func (m *TableChangeAlertMutation) CustomSubjectCleared() bool {
	_, ok := m.clearedFields[tablechangealert.FieldCustomSubject]
	return ok
}

// ResetCustomSubject resets all changes to the "custom_subject" field.
func (m *TableChangeAlertMutation) ResetCustomSubject() {
	m.custom_subject = nil
	delete(m.clearedFields, tablechangealert.FieldCustomSubject)
}

// SetFunctionName sets the "function_name" field.
func (m *TableChangeAlertMutation) SetFunctionName(s string) {
	m.function_name = &s
}

// FunctionName returns the value of the "function_name" field in the mutation.
func (m *TableChangeAlertMutation) FunctionName() (r string, exists bool) {
	v := m.function_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFunctionName returns the old "function_name" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldFunctionName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFunctionName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFunctionName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFunctionName: %w", err)
	}
	return oldValue.FunctionName, nil
}

// ClearFunctionName clears the value of the "function_name" field.
func (m *TableChangeAlertMutation) ClearFunctionName() {
	m.function_name = nil
	m.clearedFields[tablechangealert.FieldFunctionName] = struct{}{}
}

// FunctionNameCleared returns if the "function_name" field was cleared in this mutation.
func (m *TableChangeAlertMutation) FunctionNameCleared() bool {
	_, ok := m.clearedFields[tablechangealert.FieldFunctionName]
	return ok
}

// ResetFunctionName resets all changes to the "function_name" field.
func (m *TableChangeAlertMutation) ResetFunctionName() {
	m.function_name = nil
	delete(m.clearedFields, tablechangealert.FieldFunctionName)
}

// SetTriggerName sets the "trigger_name" field.
func (m *TableChangeAlertMutation) SetTriggerName(s string) {
	m.trigger_name = &s
}

// TriggerName returns the value of the "trigger_name" field in the mutation.
func (m *TableChangeAlertMutation) TriggerName() (r string, exists bool) {
	v := m.trigger_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTriggerName returns the old "trigger_name" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldTriggerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTriggerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTriggerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTriggerName: %w", err)
	}
	return oldValue.TriggerName, nil
}

// ClearTriggerName clears the value of the "trigger_name" field.
func (m *TableChangeAlertMutation) ClearTriggerName() {
	m.trigger_name = nil
	m.clearedFields[tablechangealert.FieldTriggerName] = struct{}{}
}

// TriggerNameCleared returns if the "trigger_name" field was cleared in this mutation.
func (m *TableChangeAlertMutation) TriggerNameCleared() bool {
	_, ok := m.clearedFields[tablechangealert.FieldTriggerName]
	return ok
}

// ResetTriggerName resets all changes to the "trigger_name" field.
func (m *TableChangeAlertMutation) ResetTriggerName() {
	m.trigger_name = nil
	delete(m.clearedFields, tablechangealert.FieldTriggerName)
}

// SetListenerName sets the "listener_name" field.
func (m *TableChangeAlertMutation) SetListenerName(s string) {
	m.listener_name = &s
}

// ListenerName returns the value of the "listener_name" field in the mutation.
func (m *TableChangeAlertMutation) ListenerName() (r string, exists bool) {
	v := m.listener_name
	if v == nil {
		return
	}
	return *v, true
}

// OldListenerName returns the old "listener_name" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldListenerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldListenerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldListenerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldListenerName: %w", err)
	}
	return oldValue.ListenerName, nil
}

// ClearListenerName clears the value of the "listener_name" field.
func (m *TableChangeAlertMutation) ClearListenerName() {
	m.listener_name = nil
	m.clearedFields[tablechangealert.FieldListenerName] = struct{}{}
}

// ListenerNameCleared returns if the "listener_name" field was cleared in this mutation.
func (m *TableChangeAlertMutation) ListenerNameCleared() bool {
	_, ok := m.clearedFields[tablechangealert.FieldListenerName]
	return ok
}

// ResetListenerName resets all changes to the "listener_name" field.
func (m *TableChangeAlertMutation) ResetListenerName() {
	m.listener_name = nil
	delete(m.clearedFields, tablechangealert.FieldListenerName)
}

// SetEmailRecipients sets the "email_recipients" field.
func (m *TableChangeAlertMutation) SetEmailRecipients(s string) {
	m.email_recipients = &s
}

// EmailRecipients returns the value of the "email_recipients" field in the mutation.
func (m *TableChangeAlertMutation) EmailRecipients() (r string, exists bool) {
	v := m.email_recipients
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailRecipients returns the old "email_recipients" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldEmailRecipients(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailRecipients is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailRecipients requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailRecipients: %w", err)
	}
	return oldValue.EmailRecipients, nil
}

// ClearEmailRecipients clears the value of the "email_recipients" field.
func (m *TableChangeAlertMutation) ClearEmailRecipients() {
	m.email_recipients = nil
	m.clearedFields[tablechangealert.FieldEmailRecipients] = struct{}{}
}

// EmailRecipientsCleared returns if the "email_recipients" field was cleared in this mutation.
func (m *TableChangeAlertMutation) EmailRecipientsCleared() bool {
	_, ok := m.clearedFields[tablechangealert.FieldEmailRecipients]
	return ok
}

// ResetEmailRecipients resets all changes to the "email_recipients" field.
func (m *TableChangeAlertMutation) ResetEmailRecipients() {
	m.email_recipients = nil
	delete(m.clearedFields, tablechangealert.FieldEmailRecipients)
}

// SetEffectiveDate sets the "effective_date" field.
func (m *TableChangeAlertMutation) SetEffectiveDate(pg *pgtype.Date) {
	m.effective_date = &pg
}

// EffectiveDate returns the value of the "effective_date" field in the mutation.
func (m *TableChangeAlertMutation) EffectiveDate() (r *pgtype.Date, exists bool) {
	v := m.effective_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEffectiveDate returns the old "effective_date" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldEffectiveDate(ctx context.Context) (v *pgtype.Date, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffectiveDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffectiveDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffectiveDate: %w", err)
	}
	return oldValue.EffectiveDate, nil
}

// ClearEffectiveDate clears the value of the "effective_date" field.
func (m *TableChangeAlertMutation) ClearEffectiveDate() {
	m.effective_date = nil
	m.clearedFields[tablechangealert.FieldEffectiveDate] = struct{}{}
}

// EffectiveDateCleared returns if the "effective_date" field was cleared in this mutation.
func (m *TableChangeAlertMutation) EffectiveDateCleared() bool {
	_, ok := m.clearedFields[tablechangealert.FieldEffectiveDate]
	return ok
}

// ResetEffectiveDate resets all changes to the "effective_date" field.
func (m *TableChangeAlertMutation) ResetEffectiveDate() {
	m.effective_date = nil
	delete(m.clearedFields, tablechangealert.FieldEffectiveDate)
}

// SetExpirationDate sets the "expiration_date" field.
func (m *TableChangeAlertMutation) SetExpirationDate(pg *pgtype.Date) {
	m.expiration_date = &pg
}

// ExpirationDate returns the value of the "expiration_date" field in the mutation.
func (m *TableChangeAlertMutation) ExpirationDate() (r *pgtype.Date, exists bool) {
	v := m.expiration_date
	if v == nil {
		return
	}
	return *v, true
}

// OldExpirationDate returns the old "expiration_date" field's value of the TableChangeAlert entity.
// If the TableChangeAlert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TableChangeAlertMutation) OldExpirationDate(ctx context.Context) (v *pgtype.Date, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpirationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpirationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpirationDate: %w", err)
	}
	return oldValue.ExpirationDate, nil
}

// ClearExpirationDate clears the value of the "expiration_date" field.
func (m *TableChangeAlertMutation) ClearExpirationDate() {
	m.expiration_date = nil
	m.clearedFields[tablechangealert.FieldExpirationDate] = struct{}{}
}

// ExpirationDateCleared returns if the "expiration_date" field was cleared in this mutation.
func (m *TableChangeAlertMutation) ExpirationDateCleared() bool {
	_, ok := m.clearedFields[tablechangealert.FieldExpirationDate]
	return ok
}

// ResetExpirationDate resets all changes to the "expiration_date" field.
func (m *TableChangeAlertMutation) ResetExpirationDate() {
	m.expiration_date = nil
	delete(m.clearedFields, tablechangealert.FieldExpirationDate)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *TableChangeAlertMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[tablechangealert.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *TableChangeAlertMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *TableChangeAlertMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *TableChangeAlertMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *TableChangeAlertMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[tablechangealert.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *TableChangeAlertMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *TableChangeAlertMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *TableChangeAlertMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// Where appends a list predicates to the TableChangeAlertMutation builder.
func (m *TableChangeAlertMutation) Where(ps ...predicate.TableChangeAlert) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TableChangeAlertMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TableChangeAlertMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TableChangeAlert, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TableChangeAlertMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TableChangeAlertMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TableChangeAlert).
func (m *TableChangeAlertMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TableChangeAlertMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.business_unit != nil {
		fields = append(fields, tablechangealert.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, tablechangealert.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, tablechangealert.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tablechangealert.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, tablechangealert.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, tablechangealert.FieldName)
	}
	if m.database_action != nil {
		fields = append(fields, tablechangealert.FieldDatabaseAction)
	}
	if m.source != nil {
		fields = append(fields, tablechangealert.FieldSource)
	}
	if m.table_name != nil {
		fields = append(fields, tablechangealert.FieldTableName)
	}
	if m.topic_name != nil {
		fields = append(fields, tablechangealert.FieldTopicName)
	}
	if m.description != nil {
		fields = append(fields, tablechangealert.FieldDescription)
	}
	if m.custom_subject != nil {
		fields = append(fields, tablechangealert.FieldCustomSubject)
	}
	if m.function_name != nil {
		fields = append(fields, tablechangealert.FieldFunctionName)
	}
	if m.trigger_name != nil {
		fields = append(fields, tablechangealert.FieldTriggerName)
	}
	if m.listener_name != nil {
		fields = append(fields, tablechangealert.FieldListenerName)
	}
	if m.email_recipients != nil {
		fields = append(fields, tablechangealert.FieldEmailRecipients)
	}
	if m.effective_date != nil {
		fields = append(fields, tablechangealert.FieldEffectiveDate)
	}
	if m.expiration_date != nil {
		fields = append(fields, tablechangealert.FieldExpirationDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TableChangeAlertMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tablechangealert.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case tablechangealert.FieldOrganizationID:
		return m.OrganizationID()
	case tablechangealert.FieldCreatedAt:
		return m.CreatedAt()
	case tablechangealert.FieldUpdatedAt:
		return m.UpdatedAt()
	case tablechangealert.FieldStatus:
		return m.Status()
	case tablechangealert.FieldName:
		return m.Name()
	case tablechangealert.FieldDatabaseAction:
		return m.DatabaseAction()
	case tablechangealert.FieldSource:
		return m.Source()
	case tablechangealert.FieldTableName:
		return m.TableName()
	case tablechangealert.FieldTopicName:
		return m.TopicName()
	case tablechangealert.FieldDescription:
		return m.Description()
	case tablechangealert.FieldCustomSubject:
		return m.CustomSubject()
	case tablechangealert.FieldFunctionName:
		return m.FunctionName()
	case tablechangealert.FieldTriggerName:
		return m.TriggerName()
	case tablechangealert.FieldListenerName:
		return m.ListenerName()
	case tablechangealert.FieldEmailRecipients:
		return m.EmailRecipients()
	case tablechangealert.FieldEffectiveDate:
		return m.EffectiveDate()
	case tablechangealert.FieldExpirationDate:
		return m.ExpirationDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TableChangeAlertMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tablechangealert.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case tablechangealert.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case tablechangealert.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tablechangealert.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tablechangealert.FieldStatus:
		return m.OldStatus(ctx)
	case tablechangealert.FieldName:
		return m.OldName(ctx)
	case tablechangealert.FieldDatabaseAction:
		return m.OldDatabaseAction(ctx)
	case tablechangealert.FieldSource:
		return m.OldSource(ctx)
	case tablechangealert.FieldTableName:
		return m.OldTableName(ctx)
	case tablechangealert.FieldTopicName:
		return m.OldTopicName(ctx)
	case tablechangealert.FieldDescription:
		return m.OldDescription(ctx)
	case tablechangealert.FieldCustomSubject:
		return m.OldCustomSubject(ctx)
	case tablechangealert.FieldFunctionName:
		return m.OldFunctionName(ctx)
	case tablechangealert.FieldTriggerName:
		return m.OldTriggerName(ctx)
	case tablechangealert.FieldListenerName:
		return m.OldListenerName(ctx)
	case tablechangealert.FieldEmailRecipients:
		return m.OldEmailRecipients(ctx)
	case tablechangealert.FieldEffectiveDate:
		return m.OldEffectiveDate(ctx)
	case tablechangealert.FieldExpirationDate:
		return m.OldExpirationDate(ctx)
	}
	return nil, fmt.Errorf("unknown TableChangeAlert field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TableChangeAlertMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tablechangealert.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case tablechangealert.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case tablechangealert.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tablechangealert.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tablechangealert.FieldStatus:
		v, ok := value.(tablechangealert.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case tablechangealert.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tablechangealert.FieldDatabaseAction:
		v, ok := value.(tablechangealert.DatabaseAction)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDatabaseAction(v)
		return nil
	case tablechangealert.FieldSource:
		v, ok := value.(tablechangealert.Source)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case tablechangealert.FieldTableName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTableName(v)
		return nil
	case tablechangealert.FieldTopicName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopicName(v)
		return nil
	case tablechangealert.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case tablechangealert.FieldCustomSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomSubject(v)
		return nil
	case tablechangealert.FieldFunctionName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFunctionName(v)
		return nil
	case tablechangealert.FieldTriggerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTriggerName(v)
		return nil
	case tablechangealert.FieldListenerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetListenerName(v)
		return nil
	case tablechangealert.FieldEmailRecipients:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailRecipients(v)
		return nil
	case tablechangealert.FieldEffectiveDate:
		v, ok := value.(*pgtype.Date)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffectiveDate(v)
		return nil
	case tablechangealert.FieldExpirationDate:
		v, ok := value.(*pgtype.Date)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpirationDate(v)
		return nil
	}
	return fmt.Errorf("unknown TableChangeAlert field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TableChangeAlertMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TableChangeAlertMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TableChangeAlertMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TableChangeAlert numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TableChangeAlertMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tablechangealert.FieldTableName) {
		fields = append(fields, tablechangealert.FieldTableName)
	}
	if m.FieldCleared(tablechangealert.FieldTopicName) {
		fields = append(fields, tablechangealert.FieldTopicName)
	}
	if m.FieldCleared(tablechangealert.FieldDescription) {
		fields = append(fields, tablechangealert.FieldDescription)
	}
	if m.FieldCleared(tablechangealert.FieldCustomSubject) {
		fields = append(fields, tablechangealert.FieldCustomSubject)
	}
	if m.FieldCleared(tablechangealert.FieldFunctionName) {
		fields = append(fields, tablechangealert.FieldFunctionName)
	}
	if m.FieldCleared(tablechangealert.FieldTriggerName) {
		fields = append(fields, tablechangealert.FieldTriggerName)
	}
	if m.FieldCleared(tablechangealert.FieldListenerName) {
		fields = append(fields, tablechangealert.FieldListenerName)
	}
	if m.FieldCleared(tablechangealert.FieldEmailRecipients) {
		fields = append(fields, tablechangealert.FieldEmailRecipients)
	}
	if m.FieldCleared(tablechangealert.FieldEffectiveDate) {
		fields = append(fields, tablechangealert.FieldEffectiveDate)
	}
	if m.FieldCleared(tablechangealert.FieldExpirationDate) {
		fields = append(fields, tablechangealert.FieldExpirationDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TableChangeAlertMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TableChangeAlertMutation) ClearField(name string) error {
	switch name {
	case tablechangealert.FieldTableName:
		m.ClearTableName()
		return nil
	case tablechangealert.FieldTopicName:
		m.ClearTopicName()
		return nil
	case tablechangealert.FieldDescription:
		m.ClearDescription()
		return nil
	case tablechangealert.FieldCustomSubject:
		m.ClearCustomSubject()
		return nil
	case tablechangealert.FieldFunctionName:
		m.ClearFunctionName()
		return nil
	case tablechangealert.FieldTriggerName:
		m.ClearTriggerName()
		return nil
	case tablechangealert.FieldListenerName:
		m.ClearListenerName()
		return nil
	case tablechangealert.FieldEmailRecipients:
		m.ClearEmailRecipients()
		return nil
	case tablechangealert.FieldEffectiveDate:
		m.ClearEffectiveDate()
		return nil
	case tablechangealert.FieldExpirationDate:
		m.ClearExpirationDate()
		return nil
	}
	return fmt.Errorf("unknown TableChangeAlert nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TableChangeAlertMutation) ResetField(name string) error {
	switch name {
	case tablechangealert.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case tablechangealert.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case tablechangealert.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tablechangealert.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tablechangealert.FieldStatus:
		m.ResetStatus()
		return nil
	case tablechangealert.FieldName:
		m.ResetName()
		return nil
	case tablechangealert.FieldDatabaseAction:
		m.ResetDatabaseAction()
		return nil
	case tablechangealert.FieldSource:
		m.ResetSource()
		return nil
	case tablechangealert.FieldTableName:
		m.ResetTableName()
		return nil
	case tablechangealert.FieldTopicName:
		m.ResetTopicName()
		return nil
	case tablechangealert.FieldDescription:
		m.ResetDescription()
		return nil
	case tablechangealert.FieldCustomSubject:
		m.ResetCustomSubject()
		return nil
	case tablechangealert.FieldFunctionName:
		m.ResetFunctionName()
		return nil
	case tablechangealert.FieldTriggerName:
		m.ResetTriggerName()
		return nil
	case tablechangealert.FieldListenerName:
		m.ResetListenerName()
		return nil
	case tablechangealert.FieldEmailRecipients:
		m.ResetEmailRecipients()
		return nil
	case tablechangealert.FieldEffectiveDate:
		m.ResetEffectiveDate()
		return nil
	case tablechangealert.FieldExpirationDate:
		m.ResetExpirationDate()
		return nil
	}
	return fmt.Errorf("unknown TableChangeAlert field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TableChangeAlertMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.business_unit != nil {
		edges = append(edges, tablechangealert.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, tablechangealert.EdgeOrganization)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TableChangeAlertMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tablechangealert.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case tablechangealert.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TableChangeAlertMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TableChangeAlertMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TableChangeAlertMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbusiness_unit {
		edges = append(edges, tablechangealert.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, tablechangealert.EdgeOrganization)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TableChangeAlertMutation) EdgeCleared(name string) bool {
	switch name {
	case tablechangealert.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case tablechangealert.EdgeOrganization:
		return m.clearedorganization
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TableChangeAlertMutation) ClearEdge(name string) error {
	switch name {
	case tablechangealert.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case tablechangealert.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown TableChangeAlert unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TableChangeAlertMutation) ResetEdge(name string) error {
	switch name {
	case tablechangealert.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case tablechangealert.EdgeOrganization:
		m.ResetOrganization()
		return nil
	}
	return fmt.Errorf("unknown TableChangeAlert edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op                            Op
	typ                           string
	id                            *uuid.UUID
	created_at                    *time.Time
	updated_at                    *time.Time
	name                          *string
	description                   *string
	color                         *string
	clearedFields                 map[string]struct{}
	business_unit                 *uuid.UUID
	clearedbusiness_unit          bool
	organization                  *uuid.UUID
	clearedorganization           bool
	general_ledger_account        map[uuid.UUID]struct{}
	removedgeneral_ledger_account map[uuid.UUID]struct{}
	clearedgeneral_ledger_account bool
	done                          bool
	oldValue                      func(context.Context) (*Tag, error)
	predicates                    []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id uuid.UUID) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tag entities.
func (m *TagMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *TagMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *TagMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *TagMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *TagMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *TagMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *TagMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TagMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *TagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TagMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *TagMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TagMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TagMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[tag.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TagMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[tag.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TagMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, tag.FieldDescription)
}

// SetColor sets the "color" field.
func (m *TagMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *TagMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *TagMutation) ClearColor() {
	m.color = nil
	m.clearedFields[tag.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *TagMutation) ColorCleared() bool {
	_, ok := m.clearedFields[tag.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *TagMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, tag.FieldColor)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *TagMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[tag.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *TagMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *TagMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *TagMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *TagMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[tag.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *TagMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *TagMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *TagMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// AddGeneralLedgerAccountIDs adds the "general_ledger_account" edge to the GeneralLedgerAccount entity by ids.
func (m *TagMutation) AddGeneralLedgerAccountIDs(ids ...uuid.UUID) {
	if m.general_ledger_account == nil {
		m.general_ledger_account = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.general_ledger_account[ids[i]] = struct{}{}
	}
}

// ClearGeneralLedgerAccount clears the "general_ledger_account" edge to the GeneralLedgerAccount entity.
func (m *TagMutation) ClearGeneralLedgerAccount() {
	m.clearedgeneral_ledger_account = true
}

// GeneralLedgerAccountCleared reports if the "general_ledger_account" edge to the GeneralLedgerAccount entity was cleared.
func (m *TagMutation) GeneralLedgerAccountCleared() bool {
	return m.clearedgeneral_ledger_account
}

// RemoveGeneralLedgerAccountIDs removes the "general_ledger_account" edge to the GeneralLedgerAccount entity by IDs.
func (m *TagMutation) RemoveGeneralLedgerAccountIDs(ids ...uuid.UUID) {
	if m.removedgeneral_ledger_account == nil {
		m.removedgeneral_ledger_account = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.general_ledger_account, ids[i])
		m.removedgeneral_ledger_account[ids[i]] = struct{}{}
	}
}

// RemovedGeneralLedgerAccount returns the removed IDs of the "general_ledger_account" edge to the GeneralLedgerAccount entity.
func (m *TagMutation) RemovedGeneralLedgerAccountIDs() (ids []uuid.UUID) {
	for id := range m.removedgeneral_ledger_account {
		ids = append(ids, id)
	}
	return
}

// GeneralLedgerAccountIDs returns the "general_ledger_account" edge IDs in the mutation.
func (m *TagMutation) GeneralLedgerAccountIDs() (ids []uuid.UUID) {
	for id := range m.general_ledger_account {
		ids = append(ids, id)
	}
	return
}

// ResetGeneralLedgerAccount resets all changes to the "general_ledger_account" edge.
func (m *TagMutation) ResetGeneralLedgerAccount() {
	m.general_ledger_account = nil
	m.clearedgeneral_ledger_account = false
	m.removedgeneral_ledger_account = nil
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.business_unit != nil {
		fields = append(fields, tag.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, tag.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, tag.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tag.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, tag.FieldName)
	}
	if m.description != nil {
		fields = append(fields, tag.FieldDescription)
	}
	if m.color != nil {
		fields = append(fields, tag.FieldColor)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case tag.FieldOrganizationID:
		return m.OrganizationID()
	case tag.FieldCreatedAt:
		return m.CreatedAt()
	case tag.FieldUpdatedAt:
		return m.UpdatedAt()
	case tag.FieldName:
		return m.Name()
	case tag.FieldDescription:
		return m.Description()
	case tag.FieldColor:
		return m.Color()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case tag.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case tag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tag.FieldName:
		return m.OldName(ctx)
	case tag.FieldDescription:
		return m.OldDescription(ctx)
	case tag.FieldColor:
		return m.OldColor(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case tag.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case tag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tag.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case tag.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tag.FieldDescription) {
		fields = append(fields, tag.FieldDescription)
	}
	if m.FieldCleared(tag.FieldColor) {
		fields = append(fields, tag.FieldColor)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	switch name {
	case tag.FieldDescription:
		m.ClearDescription()
		return nil
	case tag.FieldColor:
		m.ClearColor()
		return nil
	}
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case tag.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case tag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tag.FieldName:
		m.ResetName()
		return nil
	case tag.FieldDescription:
		m.ResetDescription()
		return nil
	case tag.FieldColor:
		m.ResetColor()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.business_unit != nil {
		edges = append(edges, tag.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, tag.EdgeOrganization)
	}
	if m.general_ledger_account != nil {
		edges = append(edges, tag.EdgeGeneralLedgerAccount)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case tag.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case tag.EdgeGeneralLedgerAccount:
		ids := make([]ent.Value, 0, len(m.general_ledger_account))
		for id := range m.general_ledger_account {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedgeneral_ledger_account != nil {
		edges = append(edges, tag.EdgeGeneralLedgerAccount)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeGeneralLedgerAccount:
		ids := make([]ent.Value, 0, len(m.removedgeneral_ledger_account))
		for id := range m.removedgeneral_ledger_account {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbusiness_unit {
		edges = append(edges, tag.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, tag.EdgeOrganization)
	}
	if m.clearedgeneral_ledger_account {
		edges = append(edges, tag.EdgeGeneralLedgerAccount)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	switch name {
	case tag.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case tag.EdgeOrganization:
		return m.clearedorganization
	case tag.EdgeGeneralLedgerAccount:
		return m.clearedgeneral_ledger_account
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	switch name {
	case tag.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case tag.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	switch name {
	case tag.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case tag.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case tag.EdgeGeneralLedgerAccount:
		m.ResetGeneralLedgerAccount()
		return nil
	}
	return fmt.Errorf("unknown Tag edge %s", name)
}

// TractorMutation represents an operation that mutates the Tractor nodes in the graph.
type TractorMutation struct {
	config
	op                            Op
	typ                           string
	id                            *uuid.UUID
	created_at                    *time.Time
	updated_at                    *time.Time
	code                          *string
	status                        *tractor.Status
	license_plate_number          *string
	vin                           *string
	model                         *string
	year                          *int16
	addyear                       *int16
	leased                        *bool
	leased_date                   **pgtype.Date
	clearedFields                 map[string]struct{}
	business_unit                 *uuid.UUID
	clearedbusiness_unit          bool
	organization                  *uuid.UUID
	clearedorganization           bool
	equipment_type                *uuid.UUID
	clearedequipment_type         bool
	equipment_manufacturer        *uuid.UUID
	clearedequipment_manufacturer bool
	state                         *uuid.UUID
	clearedstate                  bool
	primary_worker                *uuid.UUID
	clearedprimary_worker         bool
	secondary_worker              *uuid.UUID
	clearedsecondary_worker       bool
	fleet_code                    *uuid.UUID
	clearedfleet_code             bool
	done                          bool
	oldValue                      func(context.Context) (*Tractor, error)
	predicates                    []predicate.Tractor
}

var _ ent.Mutation = (*TractorMutation)(nil)

// tractorOption allows management of the mutation configuration using functional options.
type tractorOption func(*TractorMutation)

// newTractorMutation creates new mutation for the Tractor entity.
func newTractorMutation(c config, op Op, opts ...tractorOption) *TractorMutation {
	m := &TractorMutation{
		config:        c,
		op:            op,
		typ:           TypeTractor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTractorID sets the ID field of the mutation.
func withTractorID(id uuid.UUID) tractorOption {
	return func(m *TractorMutation) {
		var (
			err   error
			once  sync.Once
			value *Tractor
		)
		m.oldValue = func(ctx context.Context) (*Tractor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tractor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTractor sets the old Tractor of the mutation.
func withTractor(node *Tractor) tractorOption {
	return func(m *TractorMutation) {
		m.oldValue = func(context.Context) (*Tractor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TractorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TractorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tractor entities.
func (m *TractorMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TractorMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TractorMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tractor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *TractorMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *TractorMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the Tractor entity.
// If the Tractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TractorMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *TractorMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *TractorMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *TractorMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Tractor entity.
// If the Tractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TractorMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *TractorMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TractorMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TractorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tractor entity.
// If the Tractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TractorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TractorMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TractorMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TractorMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Tractor entity.
// If the Tractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TractorMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TractorMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCode sets the "code" field.
func (m *TractorMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *TractorMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Tractor entity.
// If the Tractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TractorMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *TractorMutation) ResetCode() {
	m.code = nil
}

// SetStatus sets the "status" field.
func (m *TractorMutation) SetStatus(t tractor.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *TractorMutation) Status() (r tractor.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Tractor entity.
// If the Tractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TractorMutation) OldStatus(ctx context.Context) (v tractor.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TractorMutation) ResetStatus() {
	m.status = nil
}

// SetEquipmentTypeID sets the "equipment_type_id" field.
func (m *TractorMutation) SetEquipmentTypeID(u uuid.UUID) {
	m.equipment_type = &u
}

// EquipmentTypeID returns the value of the "equipment_type_id" field in the mutation.
func (m *TractorMutation) EquipmentTypeID() (r uuid.UUID, exists bool) {
	v := m.equipment_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEquipmentTypeID returns the old "equipment_type_id" field's value of the Tractor entity.
// If the Tractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TractorMutation) OldEquipmentTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEquipmentTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEquipmentTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEquipmentTypeID: %w", err)
	}
	return oldValue.EquipmentTypeID, nil
}

// ClearEquipmentTypeID clears the value of the "equipment_type_id" field.
func (m *TractorMutation) ClearEquipmentTypeID() {
	m.equipment_type = nil
	m.clearedFields[tractor.FieldEquipmentTypeID] = struct{}{}
}

// EquipmentTypeIDCleared returns if the "equipment_type_id" field was cleared in this mutation.
func (m *TractorMutation) EquipmentTypeIDCleared() bool {
	_, ok := m.clearedFields[tractor.FieldEquipmentTypeID]
	return ok
}

// ResetEquipmentTypeID resets all changes to the "equipment_type_id" field.
func (m *TractorMutation) ResetEquipmentTypeID() {
	m.equipment_type = nil
	delete(m.clearedFields, tractor.FieldEquipmentTypeID)
}

// SetLicensePlateNumber sets the "license_plate_number" field.
func (m *TractorMutation) SetLicensePlateNumber(s string) {
	m.license_plate_number = &s
}

// LicensePlateNumber returns the value of the "license_plate_number" field in the mutation.
func (m *TractorMutation) LicensePlateNumber() (r string, exists bool) {
	v := m.license_plate_number
	if v == nil {
		return
	}
	return *v, true
}

// OldLicensePlateNumber returns the old "license_plate_number" field's value of the Tractor entity.
// If the Tractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TractorMutation) OldLicensePlateNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLicensePlateNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLicensePlateNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicensePlateNumber: %w", err)
	}
	return oldValue.LicensePlateNumber, nil
}

// ClearLicensePlateNumber clears the value of the "license_plate_number" field.
func (m *TractorMutation) ClearLicensePlateNumber() {
	m.license_plate_number = nil
	m.clearedFields[tractor.FieldLicensePlateNumber] = struct{}{}
}

// LicensePlateNumberCleared returns if the "license_plate_number" field was cleared in this mutation.
func (m *TractorMutation) LicensePlateNumberCleared() bool {
	_, ok := m.clearedFields[tractor.FieldLicensePlateNumber]
	return ok
}

// ResetLicensePlateNumber resets all changes to the "license_plate_number" field.
func (m *TractorMutation) ResetLicensePlateNumber() {
	m.license_plate_number = nil
	delete(m.clearedFields, tractor.FieldLicensePlateNumber)
}

// SetVin sets the "vin" field.
func (m *TractorMutation) SetVin(s string) {
	m.vin = &s
}

// Vin returns the value of the "vin" field in the mutation.
func (m *TractorMutation) Vin() (r string, exists bool) {
	v := m.vin
	if v == nil {
		return
	}
	return *v, true
}

// OldVin returns the old "vin" field's value of the Tractor entity.
// If the Tractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TractorMutation) OldVin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVin: %w", err)
	}
	return oldValue.Vin, nil
}

// ClearVin clears the value of the "vin" field.
func (m *TractorMutation) ClearVin() {
	m.vin = nil
	m.clearedFields[tractor.FieldVin] = struct{}{}
}

// VinCleared returns if the "vin" field was cleared in this mutation.
func (m *TractorMutation) VinCleared() bool {
	_, ok := m.clearedFields[tractor.FieldVin]
	return ok
}

// ResetVin resets all changes to the "vin" field.
func (m *TractorMutation) ResetVin() {
	m.vin = nil
	delete(m.clearedFields, tractor.FieldVin)
}

// SetEquipmentManufacturerID sets the "equipment_manufacturer_id" field.
func (m *TractorMutation) SetEquipmentManufacturerID(u uuid.UUID) {
	m.equipment_manufacturer = &u
}

// EquipmentManufacturerID returns the value of the "equipment_manufacturer_id" field in the mutation.
func (m *TractorMutation) EquipmentManufacturerID() (r uuid.UUID, exists bool) {
	v := m.equipment_manufacturer
	if v == nil {
		return
	}
	return *v, true
}

// OldEquipmentManufacturerID returns the old "equipment_manufacturer_id" field's value of the Tractor entity.
// If the Tractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TractorMutation) OldEquipmentManufacturerID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEquipmentManufacturerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEquipmentManufacturerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEquipmentManufacturerID: %w", err)
	}
	return oldValue.EquipmentManufacturerID, nil
}

// ClearEquipmentManufacturerID clears the value of the "equipment_manufacturer_id" field.
func (m *TractorMutation) ClearEquipmentManufacturerID() {
	m.equipment_manufacturer = nil
	m.clearedFields[tractor.FieldEquipmentManufacturerID] = struct{}{}
}

// EquipmentManufacturerIDCleared returns if the "equipment_manufacturer_id" field was cleared in this mutation.
func (m *TractorMutation) EquipmentManufacturerIDCleared() bool {
	_, ok := m.clearedFields[tractor.FieldEquipmentManufacturerID]
	return ok
}

// ResetEquipmentManufacturerID resets all changes to the "equipment_manufacturer_id" field.
func (m *TractorMutation) ResetEquipmentManufacturerID() {
	m.equipment_manufacturer = nil
	delete(m.clearedFields, tractor.FieldEquipmentManufacturerID)
}

// SetModel sets the "model" field.
func (m *TractorMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *TractorMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the Tractor entity.
// If the Tractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TractorMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ClearModel clears the value of the "model" field.
func (m *TractorMutation) ClearModel() {
	m.model = nil
	m.clearedFields[tractor.FieldModel] = struct{}{}
}

// ModelCleared returns if the "model" field was cleared in this mutation.
func (m *TractorMutation) ModelCleared() bool {
	_, ok := m.clearedFields[tractor.FieldModel]
	return ok
}

// ResetModel resets all changes to the "model" field.
func (m *TractorMutation) ResetModel() {
	m.model = nil
	delete(m.clearedFields, tractor.FieldModel)
}

// SetYear sets the "year" field.
func (m *TractorMutation) SetYear(i int16) {
	m.year = &i
	m.addyear = nil
}

// Year returns the value of the "year" field in the mutation.
func (m *TractorMutation) Year() (r int16, exists bool) {
	v := m.year
	if v == nil {
		return
	}
	return *v, true
}

// OldYear returns the old "year" field's value of the Tractor entity.
// If the Tractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TractorMutation) OldYear(ctx context.Context) (v *int16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYear: %w", err)
	}
	return oldValue.Year, nil
}

// AddYear adds i to the "year" field.
func (m *TractorMutation) AddYear(i int16) {
	if m.addyear != nil {
		*m.addyear += i
	} else {
		m.addyear = &i
	}
}

// AddedYear returns the value that was added to the "year" field in this mutation.
func (m *TractorMutation) AddedYear() (r int16, exists bool) {
	v := m.addyear
	if v == nil {
		return
	}
	return *v, true
}

// ClearYear clears the value of the "year" field.
func (m *TractorMutation) ClearYear() {
	m.year = nil
	m.addyear = nil
	m.clearedFields[tractor.FieldYear] = struct{}{}
}

// YearCleared returns if the "year" field was cleared in this mutation.
func (m *TractorMutation) YearCleared() bool {
	_, ok := m.clearedFields[tractor.FieldYear]
	return ok
}

// ResetYear resets all changes to the "year" field.
func (m *TractorMutation) ResetYear() {
	m.year = nil
	m.addyear = nil
	delete(m.clearedFields, tractor.FieldYear)
}

// SetStateID sets the "state_id" field.
func (m *TractorMutation) SetStateID(u uuid.UUID) {
	m.state = &u
}

// StateID returns the value of the "state_id" field in the mutation.
func (m *TractorMutation) StateID() (r uuid.UUID, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldStateID returns the old "state_id" field's value of the Tractor entity.
// If the Tractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TractorMutation) OldStateID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStateID: %w", err)
	}
	return oldValue.StateID, nil
}

// ClearStateID clears the value of the "state_id" field.
func (m *TractorMutation) ClearStateID() {
	m.state = nil
	m.clearedFields[tractor.FieldStateID] = struct{}{}
}

// StateIDCleared returns if the "state_id" field was cleared in this mutation.
func (m *TractorMutation) StateIDCleared() bool {
	_, ok := m.clearedFields[tractor.FieldStateID]
	return ok
}

// ResetStateID resets all changes to the "state_id" field.
func (m *TractorMutation) ResetStateID() {
	m.state = nil
	delete(m.clearedFields, tractor.FieldStateID)
}

// SetLeased sets the "leased" field.
func (m *TractorMutation) SetLeased(b bool) {
	m.leased = &b
}

// Leased returns the value of the "leased" field in the mutation.
func (m *TractorMutation) Leased() (r bool, exists bool) {
	v := m.leased
	if v == nil {
		return
	}
	return *v, true
}

// OldLeased returns the old "leased" field's value of the Tractor entity.
// If the Tractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TractorMutation) OldLeased(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeased is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeased requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeased: %w", err)
	}
	return oldValue.Leased, nil
}

// ResetLeased resets all changes to the "leased" field.
func (m *TractorMutation) ResetLeased() {
	m.leased = nil
}

// SetLeasedDate sets the "leased_date" field.
func (m *TractorMutation) SetLeasedDate(pg *pgtype.Date) {
	m.leased_date = &pg
}

// LeasedDate returns the value of the "leased_date" field in the mutation.
func (m *TractorMutation) LeasedDate() (r *pgtype.Date, exists bool) {
	v := m.leased_date
	if v == nil {
		return
	}
	return *v, true
}

// OldLeasedDate returns the old "leased_date" field's value of the Tractor entity.
// If the Tractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TractorMutation) OldLeasedDate(ctx context.Context) (v *pgtype.Date, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeasedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeasedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeasedDate: %w", err)
	}
	return oldValue.LeasedDate, nil
}

// ClearLeasedDate clears the value of the "leased_date" field.
func (m *TractorMutation) ClearLeasedDate() {
	m.leased_date = nil
	m.clearedFields[tractor.FieldLeasedDate] = struct{}{}
}

// LeasedDateCleared returns if the "leased_date" field was cleared in this mutation.
func (m *TractorMutation) LeasedDateCleared() bool {
	_, ok := m.clearedFields[tractor.FieldLeasedDate]
	return ok
}

// ResetLeasedDate resets all changes to the "leased_date" field.
func (m *TractorMutation) ResetLeasedDate() {
	m.leased_date = nil
	delete(m.clearedFields, tractor.FieldLeasedDate)
}

// SetPrimaryWorkerID sets the "primary_worker_id" field.
func (m *TractorMutation) SetPrimaryWorkerID(u uuid.UUID) {
	m.primary_worker = &u
}

// PrimaryWorkerID returns the value of the "primary_worker_id" field in the mutation.
func (m *TractorMutation) PrimaryWorkerID() (r uuid.UUID, exists bool) {
	v := m.primary_worker
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryWorkerID returns the old "primary_worker_id" field's value of the Tractor entity.
// If the Tractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TractorMutation) OldPrimaryWorkerID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryWorkerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryWorkerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryWorkerID: %w", err)
	}
	return oldValue.PrimaryWorkerID, nil
}

// ResetPrimaryWorkerID resets all changes to the "primary_worker_id" field.
func (m *TractorMutation) ResetPrimaryWorkerID() {
	m.primary_worker = nil
}

// SetSecondaryWorkerID sets the "secondary_worker_id" field.
func (m *TractorMutation) SetSecondaryWorkerID(u uuid.UUID) {
	m.secondary_worker = &u
}

// SecondaryWorkerID returns the value of the "secondary_worker_id" field in the mutation.
func (m *TractorMutation) SecondaryWorkerID() (r uuid.UUID, exists bool) {
	v := m.secondary_worker
	if v == nil {
		return
	}
	return *v, true
}

// OldSecondaryWorkerID returns the old "secondary_worker_id" field's value of the Tractor entity.
// If the Tractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TractorMutation) OldSecondaryWorkerID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecondaryWorkerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecondaryWorkerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecondaryWorkerID: %w", err)
	}
	return oldValue.SecondaryWorkerID, nil
}

// ClearSecondaryWorkerID clears the value of the "secondary_worker_id" field.
func (m *TractorMutation) ClearSecondaryWorkerID() {
	m.secondary_worker = nil
	m.clearedFields[tractor.FieldSecondaryWorkerID] = struct{}{}
}

// SecondaryWorkerIDCleared returns if the "secondary_worker_id" field was cleared in this mutation.
func (m *TractorMutation) SecondaryWorkerIDCleared() bool {
	_, ok := m.clearedFields[tractor.FieldSecondaryWorkerID]
	return ok
}

// ResetSecondaryWorkerID resets all changes to the "secondary_worker_id" field.
func (m *TractorMutation) ResetSecondaryWorkerID() {
	m.secondary_worker = nil
	delete(m.clearedFields, tractor.FieldSecondaryWorkerID)
}

// SetFleetCodeID sets the "fleet_code_id" field.
func (m *TractorMutation) SetFleetCodeID(u uuid.UUID) {
	m.fleet_code = &u
}

// FleetCodeID returns the value of the "fleet_code_id" field in the mutation.
func (m *TractorMutation) FleetCodeID() (r uuid.UUID, exists bool) {
	v := m.fleet_code
	if v == nil {
		return
	}
	return *v, true
}

// OldFleetCodeID returns the old "fleet_code_id" field's value of the Tractor entity.
// If the Tractor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TractorMutation) OldFleetCodeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFleetCodeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFleetCodeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFleetCodeID: %w", err)
	}
	return oldValue.FleetCodeID, nil
}

// ResetFleetCodeID resets all changes to the "fleet_code_id" field.
func (m *TractorMutation) ResetFleetCodeID() {
	m.fleet_code = nil
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *TractorMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[tractor.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *TractorMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *TractorMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *TractorMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *TractorMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[tractor.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *TractorMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *TractorMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *TractorMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearEquipmentType clears the "equipment_type" edge to the EquipmentType entity.
func (m *TractorMutation) ClearEquipmentType() {
	m.clearedequipment_type = true
	m.clearedFields[tractor.FieldEquipmentTypeID] = struct{}{}
}

// EquipmentTypeCleared reports if the "equipment_type" edge to the EquipmentType entity was cleared.
func (m *TractorMutation) EquipmentTypeCleared() bool {
	return m.EquipmentTypeIDCleared() || m.clearedequipment_type
}

// EquipmentTypeIDs returns the "equipment_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EquipmentTypeID instead. It exists only for internal usage by the builders.
func (m *TractorMutation) EquipmentTypeIDs() (ids []uuid.UUID) {
	if id := m.equipment_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEquipmentType resets all changes to the "equipment_type" edge.
func (m *TractorMutation) ResetEquipmentType() {
	m.equipment_type = nil
	m.clearedequipment_type = false
}

// ClearEquipmentManufacturer clears the "equipment_manufacturer" edge to the EquipmentManufactuer entity.
func (m *TractorMutation) ClearEquipmentManufacturer() {
	m.clearedequipment_manufacturer = true
	m.clearedFields[tractor.FieldEquipmentManufacturerID] = struct{}{}
}

// EquipmentManufacturerCleared reports if the "equipment_manufacturer" edge to the EquipmentManufactuer entity was cleared.
func (m *TractorMutation) EquipmentManufacturerCleared() bool {
	return m.EquipmentManufacturerIDCleared() || m.clearedequipment_manufacturer
}

// EquipmentManufacturerIDs returns the "equipment_manufacturer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EquipmentManufacturerID instead. It exists only for internal usage by the builders.
func (m *TractorMutation) EquipmentManufacturerIDs() (ids []uuid.UUID) {
	if id := m.equipment_manufacturer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEquipmentManufacturer resets all changes to the "equipment_manufacturer" edge.
func (m *TractorMutation) ResetEquipmentManufacturer() {
	m.equipment_manufacturer = nil
	m.clearedequipment_manufacturer = false
}

// ClearState clears the "state" edge to the UsState entity.
func (m *TractorMutation) ClearState() {
	m.clearedstate = true
	m.clearedFields[tractor.FieldStateID] = struct{}{}
}

// StateCleared reports if the "state" edge to the UsState entity was cleared.
func (m *TractorMutation) StateCleared() bool {
	return m.StateIDCleared() || m.clearedstate
}

// StateIDs returns the "state" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StateID instead. It exists only for internal usage by the builders.
func (m *TractorMutation) StateIDs() (ids []uuid.UUID) {
	if id := m.state; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetState resets all changes to the "state" edge.
func (m *TractorMutation) ResetState() {
	m.state = nil
	m.clearedstate = false
}

// ClearPrimaryWorker clears the "primary_worker" edge to the Worker entity.
func (m *TractorMutation) ClearPrimaryWorker() {
	m.clearedprimary_worker = true
	m.clearedFields[tractor.FieldPrimaryWorkerID] = struct{}{}
}

// PrimaryWorkerCleared reports if the "primary_worker" edge to the Worker entity was cleared.
func (m *TractorMutation) PrimaryWorkerCleared() bool {
	return m.clearedprimary_worker
}

// PrimaryWorkerIDs returns the "primary_worker" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PrimaryWorkerID instead. It exists only for internal usage by the builders.
func (m *TractorMutation) PrimaryWorkerIDs() (ids []uuid.UUID) {
	if id := m.primary_worker; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrimaryWorker resets all changes to the "primary_worker" edge.
func (m *TractorMutation) ResetPrimaryWorker() {
	m.primary_worker = nil
	m.clearedprimary_worker = false
}

// ClearSecondaryWorker clears the "secondary_worker" edge to the Worker entity.
func (m *TractorMutation) ClearSecondaryWorker() {
	m.clearedsecondary_worker = true
	m.clearedFields[tractor.FieldSecondaryWorkerID] = struct{}{}
}

// SecondaryWorkerCleared reports if the "secondary_worker" edge to the Worker entity was cleared.
func (m *TractorMutation) SecondaryWorkerCleared() bool {
	return m.SecondaryWorkerIDCleared() || m.clearedsecondary_worker
}

// SecondaryWorkerIDs returns the "secondary_worker" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SecondaryWorkerID instead. It exists only for internal usage by the builders.
func (m *TractorMutation) SecondaryWorkerIDs() (ids []uuid.UUID) {
	if id := m.secondary_worker; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSecondaryWorker resets all changes to the "secondary_worker" edge.
func (m *TractorMutation) ResetSecondaryWorker() {
	m.secondary_worker = nil
	m.clearedsecondary_worker = false
}

// ClearFleetCode clears the "fleet_code" edge to the FleetCode entity.
func (m *TractorMutation) ClearFleetCode() {
	m.clearedfleet_code = true
	m.clearedFields[tractor.FieldFleetCodeID] = struct{}{}
}

// FleetCodeCleared reports if the "fleet_code" edge to the FleetCode entity was cleared.
func (m *TractorMutation) FleetCodeCleared() bool {
	return m.clearedfleet_code
}

// FleetCodeIDs returns the "fleet_code" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FleetCodeID instead. It exists only for internal usage by the builders.
func (m *TractorMutation) FleetCodeIDs() (ids []uuid.UUID) {
	if id := m.fleet_code; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFleetCode resets all changes to the "fleet_code" edge.
func (m *TractorMutation) ResetFleetCode() {
	m.fleet_code = nil
	m.clearedfleet_code = false
}

// Where appends a list predicates to the TractorMutation builder.
func (m *TractorMutation) Where(ps ...predicate.Tractor) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TractorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TractorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tractor, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TractorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TractorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tractor).
func (m *TractorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TractorMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.business_unit != nil {
		fields = append(fields, tractor.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, tractor.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, tractor.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, tractor.FieldUpdatedAt)
	}
	if m.code != nil {
		fields = append(fields, tractor.FieldCode)
	}
	if m.status != nil {
		fields = append(fields, tractor.FieldStatus)
	}
	if m.equipment_type != nil {
		fields = append(fields, tractor.FieldEquipmentTypeID)
	}
	if m.license_plate_number != nil {
		fields = append(fields, tractor.FieldLicensePlateNumber)
	}
	if m.vin != nil {
		fields = append(fields, tractor.FieldVin)
	}
	if m.equipment_manufacturer != nil {
		fields = append(fields, tractor.FieldEquipmentManufacturerID)
	}
	if m.model != nil {
		fields = append(fields, tractor.FieldModel)
	}
	if m.year != nil {
		fields = append(fields, tractor.FieldYear)
	}
	if m.state != nil {
		fields = append(fields, tractor.FieldStateID)
	}
	if m.leased != nil {
		fields = append(fields, tractor.FieldLeased)
	}
	if m.leased_date != nil {
		fields = append(fields, tractor.FieldLeasedDate)
	}
	if m.primary_worker != nil {
		fields = append(fields, tractor.FieldPrimaryWorkerID)
	}
	if m.secondary_worker != nil {
		fields = append(fields, tractor.FieldSecondaryWorkerID)
	}
	if m.fleet_code != nil {
		fields = append(fields, tractor.FieldFleetCodeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TractorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tractor.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case tractor.FieldOrganizationID:
		return m.OrganizationID()
	case tractor.FieldCreatedAt:
		return m.CreatedAt()
	case tractor.FieldUpdatedAt:
		return m.UpdatedAt()
	case tractor.FieldCode:
		return m.Code()
	case tractor.FieldStatus:
		return m.Status()
	case tractor.FieldEquipmentTypeID:
		return m.EquipmentTypeID()
	case tractor.FieldLicensePlateNumber:
		return m.LicensePlateNumber()
	case tractor.FieldVin:
		return m.Vin()
	case tractor.FieldEquipmentManufacturerID:
		return m.EquipmentManufacturerID()
	case tractor.FieldModel:
		return m.Model()
	case tractor.FieldYear:
		return m.Year()
	case tractor.FieldStateID:
		return m.StateID()
	case tractor.FieldLeased:
		return m.Leased()
	case tractor.FieldLeasedDate:
		return m.LeasedDate()
	case tractor.FieldPrimaryWorkerID:
		return m.PrimaryWorkerID()
	case tractor.FieldSecondaryWorkerID:
		return m.SecondaryWorkerID()
	case tractor.FieldFleetCodeID:
		return m.FleetCodeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TractorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tractor.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case tractor.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case tractor.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tractor.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tractor.FieldCode:
		return m.OldCode(ctx)
	case tractor.FieldStatus:
		return m.OldStatus(ctx)
	case tractor.FieldEquipmentTypeID:
		return m.OldEquipmentTypeID(ctx)
	case tractor.FieldLicensePlateNumber:
		return m.OldLicensePlateNumber(ctx)
	case tractor.FieldVin:
		return m.OldVin(ctx)
	case tractor.FieldEquipmentManufacturerID:
		return m.OldEquipmentManufacturerID(ctx)
	case tractor.FieldModel:
		return m.OldModel(ctx)
	case tractor.FieldYear:
		return m.OldYear(ctx)
	case tractor.FieldStateID:
		return m.OldStateID(ctx)
	case tractor.FieldLeased:
		return m.OldLeased(ctx)
	case tractor.FieldLeasedDate:
		return m.OldLeasedDate(ctx)
	case tractor.FieldPrimaryWorkerID:
		return m.OldPrimaryWorkerID(ctx)
	case tractor.FieldSecondaryWorkerID:
		return m.OldSecondaryWorkerID(ctx)
	case tractor.FieldFleetCodeID:
		return m.OldFleetCodeID(ctx)
	}
	return nil, fmt.Errorf("unknown Tractor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TractorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tractor.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case tractor.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case tractor.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tractor.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tractor.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case tractor.FieldStatus:
		v, ok := value.(tractor.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case tractor.FieldEquipmentTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEquipmentTypeID(v)
		return nil
	case tractor.FieldLicensePlateNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicensePlateNumber(v)
		return nil
	case tractor.FieldVin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVin(v)
		return nil
	case tractor.FieldEquipmentManufacturerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEquipmentManufacturerID(v)
		return nil
	case tractor.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case tractor.FieldYear:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYear(v)
		return nil
	case tractor.FieldStateID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStateID(v)
		return nil
	case tractor.FieldLeased:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeased(v)
		return nil
	case tractor.FieldLeasedDate:
		v, ok := value.(*pgtype.Date)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeasedDate(v)
		return nil
	case tractor.FieldPrimaryWorkerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryWorkerID(v)
		return nil
	case tractor.FieldSecondaryWorkerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecondaryWorkerID(v)
		return nil
	case tractor.FieldFleetCodeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFleetCodeID(v)
		return nil
	}
	return fmt.Errorf("unknown Tractor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TractorMutation) AddedFields() []string {
	var fields []string
	if m.addyear != nil {
		fields = append(fields, tractor.FieldYear)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TractorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tractor.FieldYear:
		return m.AddedYear()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TractorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tractor.FieldYear:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYear(v)
		return nil
	}
	return fmt.Errorf("unknown Tractor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TractorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tractor.FieldEquipmentTypeID) {
		fields = append(fields, tractor.FieldEquipmentTypeID)
	}
	if m.FieldCleared(tractor.FieldLicensePlateNumber) {
		fields = append(fields, tractor.FieldLicensePlateNumber)
	}
	if m.FieldCleared(tractor.FieldVin) {
		fields = append(fields, tractor.FieldVin)
	}
	if m.FieldCleared(tractor.FieldEquipmentManufacturerID) {
		fields = append(fields, tractor.FieldEquipmentManufacturerID)
	}
	if m.FieldCleared(tractor.FieldModel) {
		fields = append(fields, tractor.FieldModel)
	}
	if m.FieldCleared(tractor.FieldYear) {
		fields = append(fields, tractor.FieldYear)
	}
	if m.FieldCleared(tractor.FieldStateID) {
		fields = append(fields, tractor.FieldStateID)
	}
	if m.FieldCleared(tractor.FieldLeasedDate) {
		fields = append(fields, tractor.FieldLeasedDate)
	}
	if m.FieldCleared(tractor.FieldSecondaryWorkerID) {
		fields = append(fields, tractor.FieldSecondaryWorkerID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TractorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TractorMutation) ClearField(name string) error {
	switch name {
	case tractor.FieldEquipmentTypeID:
		m.ClearEquipmentTypeID()
		return nil
	case tractor.FieldLicensePlateNumber:
		m.ClearLicensePlateNumber()
		return nil
	case tractor.FieldVin:
		m.ClearVin()
		return nil
	case tractor.FieldEquipmentManufacturerID:
		m.ClearEquipmentManufacturerID()
		return nil
	case tractor.FieldModel:
		m.ClearModel()
		return nil
	case tractor.FieldYear:
		m.ClearYear()
		return nil
	case tractor.FieldStateID:
		m.ClearStateID()
		return nil
	case tractor.FieldLeasedDate:
		m.ClearLeasedDate()
		return nil
	case tractor.FieldSecondaryWorkerID:
		m.ClearSecondaryWorkerID()
		return nil
	}
	return fmt.Errorf("unknown Tractor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TractorMutation) ResetField(name string) error {
	switch name {
	case tractor.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case tractor.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case tractor.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tractor.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tractor.FieldCode:
		m.ResetCode()
		return nil
	case tractor.FieldStatus:
		m.ResetStatus()
		return nil
	case tractor.FieldEquipmentTypeID:
		m.ResetEquipmentTypeID()
		return nil
	case tractor.FieldLicensePlateNumber:
		m.ResetLicensePlateNumber()
		return nil
	case tractor.FieldVin:
		m.ResetVin()
		return nil
	case tractor.FieldEquipmentManufacturerID:
		m.ResetEquipmentManufacturerID()
		return nil
	case tractor.FieldModel:
		m.ResetModel()
		return nil
	case tractor.FieldYear:
		m.ResetYear()
		return nil
	case tractor.FieldStateID:
		m.ResetStateID()
		return nil
	case tractor.FieldLeased:
		m.ResetLeased()
		return nil
	case tractor.FieldLeasedDate:
		m.ResetLeasedDate()
		return nil
	case tractor.FieldPrimaryWorkerID:
		m.ResetPrimaryWorkerID()
		return nil
	case tractor.FieldSecondaryWorkerID:
		m.ResetSecondaryWorkerID()
		return nil
	case tractor.FieldFleetCodeID:
		m.ResetFleetCodeID()
		return nil
	}
	return fmt.Errorf("unknown Tractor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TractorMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.business_unit != nil {
		edges = append(edges, tractor.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, tractor.EdgeOrganization)
	}
	if m.equipment_type != nil {
		edges = append(edges, tractor.EdgeEquipmentType)
	}
	if m.equipment_manufacturer != nil {
		edges = append(edges, tractor.EdgeEquipmentManufacturer)
	}
	if m.state != nil {
		edges = append(edges, tractor.EdgeState)
	}
	if m.primary_worker != nil {
		edges = append(edges, tractor.EdgePrimaryWorker)
	}
	if m.secondary_worker != nil {
		edges = append(edges, tractor.EdgeSecondaryWorker)
	}
	if m.fleet_code != nil {
		edges = append(edges, tractor.EdgeFleetCode)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TractorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tractor.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case tractor.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case tractor.EdgeEquipmentType:
		if id := m.equipment_type; id != nil {
			return []ent.Value{*id}
		}
	case tractor.EdgeEquipmentManufacturer:
		if id := m.equipment_manufacturer; id != nil {
			return []ent.Value{*id}
		}
	case tractor.EdgeState:
		if id := m.state; id != nil {
			return []ent.Value{*id}
		}
	case tractor.EdgePrimaryWorker:
		if id := m.primary_worker; id != nil {
			return []ent.Value{*id}
		}
	case tractor.EdgeSecondaryWorker:
		if id := m.secondary_worker; id != nil {
			return []ent.Value{*id}
		}
	case tractor.EdgeFleetCode:
		if id := m.fleet_code; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TractorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TractorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TractorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedbusiness_unit {
		edges = append(edges, tractor.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, tractor.EdgeOrganization)
	}
	if m.clearedequipment_type {
		edges = append(edges, tractor.EdgeEquipmentType)
	}
	if m.clearedequipment_manufacturer {
		edges = append(edges, tractor.EdgeEquipmentManufacturer)
	}
	if m.clearedstate {
		edges = append(edges, tractor.EdgeState)
	}
	if m.clearedprimary_worker {
		edges = append(edges, tractor.EdgePrimaryWorker)
	}
	if m.clearedsecondary_worker {
		edges = append(edges, tractor.EdgeSecondaryWorker)
	}
	if m.clearedfleet_code {
		edges = append(edges, tractor.EdgeFleetCode)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TractorMutation) EdgeCleared(name string) bool {
	switch name {
	case tractor.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case tractor.EdgeOrganization:
		return m.clearedorganization
	case tractor.EdgeEquipmentType:
		return m.clearedequipment_type
	case tractor.EdgeEquipmentManufacturer:
		return m.clearedequipment_manufacturer
	case tractor.EdgeState:
		return m.clearedstate
	case tractor.EdgePrimaryWorker:
		return m.clearedprimary_worker
	case tractor.EdgeSecondaryWorker:
		return m.clearedsecondary_worker
	case tractor.EdgeFleetCode:
		return m.clearedfleet_code
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TractorMutation) ClearEdge(name string) error {
	switch name {
	case tractor.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case tractor.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case tractor.EdgeEquipmentType:
		m.ClearEquipmentType()
		return nil
	case tractor.EdgeEquipmentManufacturer:
		m.ClearEquipmentManufacturer()
		return nil
	case tractor.EdgeState:
		m.ClearState()
		return nil
	case tractor.EdgePrimaryWorker:
		m.ClearPrimaryWorker()
		return nil
	case tractor.EdgeSecondaryWorker:
		m.ClearSecondaryWorker()
		return nil
	case tractor.EdgeFleetCode:
		m.ClearFleetCode()
		return nil
	}
	return fmt.Errorf("unknown Tractor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TractorMutation) ResetEdge(name string) error {
	switch name {
	case tractor.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case tractor.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case tractor.EdgeEquipmentType:
		m.ResetEquipmentType()
		return nil
	case tractor.EdgeEquipmentManufacturer:
		m.ResetEquipmentManufacturer()
		return nil
	case tractor.EdgeState:
		m.ResetState()
		return nil
	case tractor.EdgePrimaryWorker:
		m.ResetPrimaryWorker()
		return nil
	case tractor.EdgeSecondaryWorker:
		m.ResetSecondaryWorker()
		return nil
	case tractor.EdgeFleetCode:
		m.ResetFleetCode()
		return nil
	}
	return fmt.Errorf("unknown Tractor edge %s", name)
}

// UsStateMutation represents an operation that mutates the UsState nodes in the graph.
type UsStateMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	abbreviation  *string
	country_name  *string
	country_iso3  *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UsState, error)
	predicates    []predicate.UsState
}

var _ ent.Mutation = (*UsStateMutation)(nil)

// usstateOption allows management of the mutation configuration using functional options.
type usstateOption func(*UsStateMutation)

// newUsStateMutation creates new mutation for the UsState entity.
func newUsStateMutation(c config, op Op, opts ...usstateOption) *UsStateMutation {
	m := &UsStateMutation{
		config:        c,
		op:            op,
		typ:           TypeUsState,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUsStateID sets the ID field of the mutation.
func withUsStateID(id uuid.UUID) usstateOption {
	return func(m *UsStateMutation) {
		var (
			err   error
			once  sync.Once
			value *UsState
		)
		m.oldValue = func(ctx context.Context) (*UsState, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UsState.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUsState sets the old UsState of the mutation.
func withUsState(node *UsState) usstateOption {
	return func(m *UsStateMutation) {
		m.oldValue = func(context.Context) (*UsState, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UsStateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UsStateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UsState entities.
func (m *UsStateMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UsStateMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UsStateMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UsState.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UsStateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UsStateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UsState entity.
// If the UsState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsStateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UsStateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UsStateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UsStateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UsState entity.
// If the UsState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsStateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UsStateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *UsStateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UsStateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the UsState entity.
// If the UsState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsStateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UsStateMutation) ResetName() {
	m.name = nil
}

// SetAbbreviation sets the "abbreviation" field.
func (m *UsStateMutation) SetAbbreviation(s string) {
	m.abbreviation = &s
}

// Abbreviation returns the value of the "abbreviation" field in the mutation.
func (m *UsStateMutation) Abbreviation() (r string, exists bool) {
	v := m.abbreviation
	if v == nil {
		return
	}
	return *v, true
}

// OldAbbreviation returns the old "abbreviation" field's value of the UsState entity.
// If the UsState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsStateMutation) OldAbbreviation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAbbreviation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAbbreviation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAbbreviation: %w", err)
	}
	return oldValue.Abbreviation, nil
}

// ResetAbbreviation resets all changes to the "abbreviation" field.
func (m *UsStateMutation) ResetAbbreviation() {
	m.abbreviation = nil
}

// SetCountryName sets the "country_name" field.
func (m *UsStateMutation) SetCountryName(s string) {
	m.country_name = &s
}

// CountryName returns the value of the "country_name" field in the mutation.
func (m *UsStateMutation) CountryName() (r string, exists bool) {
	v := m.country_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryName returns the old "country_name" field's value of the UsState entity.
// If the UsState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsStateMutation) OldCountryName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountryName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountryName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryName: %w", err)
	}
	return oldValue.CountryName, nil
}

// ResetCountryName resets all changes to the "country_name" field.
func (m *UsStateMutation) ResetCountryName() {
	m.country_name = nil
}

// SetCountryIso3 sets the "country_iso3" field.
func (m *UsStateMutation) SetCountryIso3(s string) {
	m.country_iso3 = &s
}

// CountryIso3 returns the value of the "country_iso3" field in the mutation.
func (m *UsStateMutation) CountryIso3() (r string, exists bool) {
	v := m.country_iso3
	if v == nil {
		return
	}
	return *v, true
}

// OldCountryIso3 returns the old "country_iso3" field's value of the UsState entity.
// If the UsState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsStateMutation) OldCountryIso3(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountryIso3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountryIso3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountryIso3: %w", err)
	}
	return oldValue.CountryIso3, nil
}

// ResetCountryIso3 resets all changes to the "country_iso3" field.
func (m *UsStateMutation) ResetCountryIso3() {
	m.country_iso3 = nil
}

// Where appends a list predicates to the UsStateMutation builder.
func (m *UsStateMutation) Where(ps ...predicate.UsState) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UsStateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UsStateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UsState, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UsStateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UsStateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UsState).
func (m *UsStateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UsStateMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, usstate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usstate.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, usstate.FieldName)
	}
	if m.abbreviation != nil {
		fields = append(fields, usstate.FieldAbbreviation)
	}
	if m.country_name != nil {
		fields = append(fields, usstate.FieldCountryName)
	}
	if m.country_iso3 != nil {
		fields = append(fields, usstate.FieldCountryIso3)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UsStateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usstate.FieldCreatedAt:
		return m.CreatedAt()
	case usstate.FieldUpdatedAt:
		return m.UpdatedAt()
	case usstate.FieldName:
		return m.Name()
	case usstate.FieldAbbreviation:
		return m.Abbreviation()
	case usstate.FieldCountryName:
		return m.CountryName()
	case usstate.FieldCountryIso3:
		return m.CountryIso3()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UsStateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usstate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usstate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case usstate.FieldName:
		return m.OldName(ctx)
	case usstate.FieldAbbreviation:
		return m.OldAbbreviation(ctx)
	case usstate.FieldCountryName:
		return m.OldCountryName(ctx)
	case usstate.FieldCountryIso3:
		return m.OldCountryIso3(ctx)
	}
	return nil, fmt.Errorf("unknown UsState field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsStateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usstate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usstate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case usstate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case usstate.FieldAbbreviation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAbbreviation(v)
		return nil
	case usstate.FieldCountryName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryName(v)
		return nil
	case usstate.FieldCountryIso3:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountryIso3(v)
		return nil
	}
	return fmt.Errorf("unknown UsState field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UsStateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UsStateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsStateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UsState numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UsStateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UsStateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UsStateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UsState nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UsStateMutation) ResetField(name string) error {
	switch name {
	case usstate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usstate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case usstate.FieldName:
		m.ResetName()
		return nil
	case usstate.FieldAbbreviation:
		m.ResetAbbreviation()
		return nil
	case usstate.FieldCountryName:
		m.ResetCountryName()
		return nil
	case usstate.FieldCountryIso3:
		m.ResetCountryIso3()
		return nil
	}
	return fmt.Errorf("unknown UsState field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UsStateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UsStateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UsStateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UsStateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UsStateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UsStateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UsStateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UsState unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UsStateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UsState edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	created_at            *time.Time
	updated_at            *time.Time
	status                *user.Status
	name                  *string
	username              *string
	password              *string
	email                 *string
	timezone              *user.Timezone
	profile_pic_url       *string
	thumbnail_url         *string
	phone_number          *string
	is_admin              *bool
	is_super_admin        *bool
	last_login            *time.Time
	clearedFields         map[string]struct{}
	business_unit         *uuid.UUID
	clearedbusiness_unit  bool
	organization          *uuid.UUID
	clearedorganization   bool
	user_favorites        map[uuid.UUID]struct{}
	removeduser_favorites map[uuid.UUID]struct{}
	cleareduser_favorites bool
	done                  bool
	oldValue              func(context.Context) (*User, error)
	predicates            []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *UserMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *UserMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *UserMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *UserMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *UserMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *UserMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(u user.Status) {
	m.status = &u
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r user.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v user.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetTimezone sets the "timezone" field.
func (m *UserMutation) SetTimezone(u user.Timezone) {
	m.timezone = &u
}

// Timezone returns the value of the "timezone" field in the mutation.
func (m *UserMutation) Timezone() (r user.Timezone, exists bool) {
	v := m.timezone
	if v == nil {
		return
	}
	return *v, true
}

// OldTimezone returns the old "timezone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTimezone(ctx context.Context) (v user.Timezone, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimezone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimezone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimezone: %w", err)
	}
	return oldValue.Timezone, nil
}

// ResetTimezone resets all changes to the "timezone" field.
func (m *UserMutation) ResetTimezone() {
	m.timezone = nil
}

// SetProfilePicURL sets the "profile_pic_url" field.
func (m *UserMutation) SetProfilePicURL(s string) {
	m.profile_pic_url = &s
}

// ProfilePicURL returns the value of the "profile_pic_url" field in the mutation.
func (m *UserMutation) ProfilePicURL() (r string, exists bool) {
	v := m.profile_pic_url
	if v == nil {
		return
	}
	return *v, true
}

// OldProfilePicURL returns the old "profile_pic_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldProfilePicURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfilePicURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfilePicURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfilePicURL: %w", err)
	}
	return oldValue.ProfilePicURL, nil
}

// ClearProfilePicURL clears the value of the "profile_pic_url" field.
func (m *UserMutation) ClearProfilePicURL() {
	m.profile_pic_url = nil
	m.clearedFields[user.FieldProfilePicURL] = struct{}{}
}

// ProfilePicURLCleared returns if the "profile_pic_url" field was cleared in this mutation.
func (m *UserMutation) ProfilePicURLCleared() bool {
	_, ok := m.clearedFields[user.FieldProfilePicURL]
	return ok
}

// ResetProfilePicURL resets all changes to the "profile_pic_url" field.
func (m *UserMutation) ResetProfilePicURL() {
	m.profile_pic_url = nil
	delete(m.clearedFields, user.FieldProfilePicURL)
}

// SetThumbnailURL sets the "thumbnail_url" field.
func (m *UserMutation) SetThumbnailURL(s string) {
	m.thumbnail_url = &s
}

// ThumbnailURL returns the value of the "thumbnail_url" field in the mutation.
func (m *UserMutation) ThumbnailURL() (r string, exists bool) {
	v := m.thumbnail_url
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnailURL returns the old "thumbnail_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldThumbnailURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnailURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnailURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnailURL: %w", err)
	}
	return oldValue.ThumbnailURL, nil
}

// ClearThumbnailURL clears the value of the "thumbnail_url" field.
func (m *UserMutation) ClearThumbnailURL() {
	m.thumbnail_url = nil
	m.clearedFields[user.FieldThumbnailURL] = struct{}{}
}

// ThumbnailURLCleared returns if the "thumbnail_url" field was cleared in this mutation.
func (m *UserMutation) ThumbnailURLCleared() bool {
	_, ok := m.clearedFields[user.FieldThumbnailURL]
	return ok
}

// ResetThumbnailURL resets all changes to the "thumbnail_url" field.
func (m *UserMutation) ResetThumbnailURL() {
	m.thumbnail_url = nil
	delete(m.clearedFields, user.FieldThumbnailURL)
}

// SetPhoneNumber sets the "phone_number" field.
func (m *UserMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *UserMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ClearPhoneNumber clears the value of the "phone_number" field.
func (m *UserMutation) ClearPhoneNumber() {
	m.phone_number = nil
	m.clearedFields[user.FieldPhoneNumber] = struct{}{}
}

// PhoneNumberCleared returns if the "phone_number" field was cleared in this mutation.
func (m *UserMutation) PhoneNumberCleared() bool {
	_, ok := m.clearedFields[user.FieldPhoneNumber]
	return ok
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *UserMutation) ResetPhoneNumber() {
	m.phone_number = nil
	delete(m.clearedFields, user.FieldPhoneNumber)
}

// SetIsAdmin sets the "is_admin" field.
func (m *UserMutation) SetIsAdmin(b bool) {
	m.is_admin = &b
}

// IsAdmin returns the value of the "is_admin" field in the mutation.
func (m *UserMutation) IsAdmin() (r bool, exists bool) {
	v := m.is_admin
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAdmin returns the old "is_admin" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsAdmin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAdmin: %w", err)
	}
	return oldValue.IsAdmin, nil
}

// ResetIsAdmin resets all changes to the "is_admin" field.
func (m *UserMutation) ResetIsAdmin() {
	m.is_admin = nil
}

// SetIsSuperAdmin sets the "is_super_admin" field.
func (m *UserMutation) SetIsSuperAdmin(b bool) {
	m.is_super_admin = &b
}

// IsSuperAdmin returns the value of the "is_super_admin" field in the mutation.
func (m *UserMutation) IsSuperAdmin() (r bool, exists bool) {
	v := m.is_super_admin
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSuperAdmin returns the old "is_super_admin" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsSuperAdmin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSuperAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSuperAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSuperAdmin: %w", err)
	}
	return oldValue.IsSuperAdmin, nil
}

// ResetIsSuperAdmin resets all changes to the "is_super_admin" field.
func (m *UserMutation) ResetIsSuperAdmin() {
	m.is_super_admin = nil
}

// SetLastLogin sets the "last_login" field.
func (m *UserMutation) SetLastLogin(t time.Time) {
	m.last_login = &t
}

// LastLogin returns the value of the "last_login" field in the mutation.
func (m *UserMutation) LastLogin() (r time.Time, exists bool) {
	v := m.last_login
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLogin returns the old "last_login" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLogin(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLogin: %w", err)
	}
	return oldValue.LastLogin, nil
}

// ClearLastLogin clears the value of the "last_login" field.
func (m *UserMutation) ClearLastLogin() {
	m.last_login = nil
	m.clearedFields[user.FieldLastLogin] = struct{}{}
}

// LastLoginCleared returns if the "last_login" field was cleared in this mutation.
func (m *UserMutation) LastLoginCleared() bool {
	_, ok := m.clearedFields[user.FieldLastLogin]
	return ok
}

// ResetLastLogin resets all changes to the "last_login" field.
func (m *UserMutation) ResetLastLogin() {
	m.last_login = nil
	delete(m.clearedFields, user.FieldLastLogin)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *UserMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[user.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *UserMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *UserMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *UserMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *UserMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[user.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *UserMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *UserMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *UserMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// AddUserFavoriteIDs adds the "user_favorites" edge to the UserFavorite entity by ids.
func (m *UserMutation) AddUserFavoriteIDs(ids ...uuid.UUID) {
	if m.user_favorites == nil {
		m.user_favorites = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_favorites[ids[i]] = struct{}{}
	}
}

// ClearUserFavorites clears the "user_favorites" edge to the UserFavorite entity.
func (m *UserMutation) ClearUserFavorites() {
	m.cleareduser_favorites = true
}

// UserFavoritesCleared reports if the "user_favorites" edge to the UserFavorite entity was cleared.
func (m *UserMutation) UserFavoritesCleared() bool {
	return m.cleareduser_favorites
}

// RemoveUserFavoriteIDs removes the "user_favorites" edge to the UserFavorite entity by IDs.
func (m *UserMutation) RemoveUserFavoriteIDs(ids ...uuid.UUID) {
	if m.removeduser_favorites == nil {
		m.removeduser_favorites = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_favorites, ids[i])
		m.removeduser_favorites[ids[i]] = struct{}{}
	}
}

// RemovedUserFavorites returns the removed IDs of the "user_favorites" edge to the UserFavorite entity.
func (m *UserMutation) RemovedUserFavoritesIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_favorites {
		ids = append(ids, id)
	}
	return
}

// UserFavoritesIDs returns the "user_favorites" edge IDs in the mutation.
func (m *UserMutation) UserFavoritesIDs() (ids []uuid.UUID) {
	for id := range m.user_favorites {
		ids = append(ids, id)
	}
	return
}

// ResetUserFavorites resets all changes to the "user_favorites" edge.
func (m *UserMutation) ResetUserFavorites() {
	m.user_favorites = nil
	m.cleareduser_favorites = false
	m.removeduser_favorites = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.business_unit != nil {
		fields = append(fields, user.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, user.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.timezone != nil {
		fields = append(fields, user.FieldTimezone)
	}
	if m.profile_pic_url != nil {
		fields = append(fields, user.FieldProfilePicURL)
	}
	if m.thumbnail_url != nil {
		fields = append(fields, user.FieldThumbnailURL)
	}
	if m.phone_number != nil {
		fields = append(fields, user.FieldPhoneNumber)
	}
	if m.is_admin != nil {
		fields = append(fields, user.FieldIsAdmin)
	}
	if m.is_super_admin != nil {
		fields = append(fields, user.FieldIsSuperAdmin)
	}
	if m.last_login != nil {
		fields = append(fields, user.FieldLastLogin)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case user.FieldOrganizationID:
		return m.OrganizationID()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldStatus:
		return m.Status()
	case user.FieldName:
		return m.Name()
	case user.FieldUsername:
		return m.Username()
	case user.FieldPassword:
		return m.Password()
	case user.FieldEmail:
		return m.Email()
	case user.FieldTimezone:
		return m.Timezone()
	case user.FieldProfilePicURL:
		return m.ProfilePicURL()
	case user.FieldThumbnailURL:
		return m.ThumbnailURL()
	case user.FieldPhoneNumber:
		return m.PhoneNumber()
	case user.FieldIsAdmin:
		return m.IsAdmin()
	case user.FieldIsSuperAdmin:
		return m.IsSuperAdmin()
	case user.FieldLastLogin:
		return m.LastLogin()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case user.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldTimezone:
		return m.OldTimezone(ctx)
	case user.FieldProfilePicURL:
		return m.OldProfilePicURL(ctx)
	case user.FieldThumbnailURL:
		return m.OldThumbnailURL(ctx)
	case user.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case user.FieldIsAdmin:
		return m.OldIsAdmin(ctx)
	case user.FieldIsSuperAdmin:
		return m.OldIsSuperAdmin(ctx)
	case user.FieldLastLogin:
		return m.OldLastLogin(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case user.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(user.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldTimezone:
		v, ok := value.(user.Timezone)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimezone(v)
		return nil
	case user.FieldProfilePicURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfilePicURL(v)
		return nil
	case user.FieldThumbnailURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnailURL(v)
		return nil
	case user.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case user.FieldIsAdmin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAdmin(v)
		return nil
	case user.FieldIsSuperAdmin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSuperAdmin(v)
		return nil
	case user.FieldLastLogin:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLogin(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldProfilePicURL) {
		fields = append(fields, user.FieldProfilePicURL)
	}
	if m.FieldCleared(user.FieldThumbnailURL) {
		fields = append(fields, user.FieldThumbnailURL)
	}
	if m.FieldCleared(user.FieldPhoneNumber) {
		fields = append(fields, user.FieldPhoneNumber)
	}
	if m.FieldCleared(user.FieldLastLogin) {
		fields = append(fields, user.FieldLastLogin)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldProfilePicURL:
		m.ClearProfilePicURL()
		return nil
	case user.FieldThumbnailURL:
		m.ClearThumbnailURL()
		return nil
	case user.FieldPhoneNumber:
		m.ClearPhoneNumber()
		return nil
	case user.FieldLastLogin:
		m.ClearLastLogin()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case user.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldTimezone:
		m.ResetTimezone()
		return nil
	case user.FieldProfilePicURL:
		m.ResetProfilePicURL()
		return nil
	case user.FieldThumbnailURL:
		m.ResetThumbnailURL()
		return nil
	case user.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case user.FieldIsAdmin:
		m.ResetIsAdmin()
		return nil
	case user.FieldIsSuperAdmin:
		m.ResetIsSuperAdmin()
		return nil
	case user.FieldLastLogin:
		m.ResetLastLogin()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.business_unit != nil {
		edges = append(edges, user.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, user.EdgeOrganization)
	}
	if m.user_favorites != nil {
		edges = append(edges, user.EdgeUserFavorites)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeUserFavorites:
		ids := make([]ent.Value, 0, len(m.user_favorites))
		for id := range m.user_favorites {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removeduser_favorites != nil {
		edges = append(edges, user.EdgeUserFavorites)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserFavorites:
		ids := make([]ent.Value, 0, len(m.removeduser_favorites))
		for id := range m.removeduser_favorites {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbusiness_unit {
		edges = append(edges, user.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, user.EdgeOrganization)
	}
	if m.cleareduser_favorites {
		edges = append(edges, user.EdgeUserFavorites)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case user.EdgeOrganization:
		return m.clearedorganization
	case user.EdgeUserFavorites:
		return m.cleareduser_favorites
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case user.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case user.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case user.EdgeUserFavorites:
		m.ResetUserFavorites()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserFavoriteMutation represents an operation that mutates the UserFavorite nodes in the graph.
type UserFavoriteMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	page_link            *string
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	user                 *uuid.UUID
	cleareduser          bool
	done                 bool
	oldValue             func(context.Context) (*UserFavorite, error)
	predicates           []predicate.UserFavorite
}

var _ ent.Mutation = (*UserFavoriteMutation)(nil)

// userfavoriteOption allows management of the mutation configuration using functional options.
type userfavoriteOption func(*UserFavoriteMutation)

// newUserFavoriteMutation creates new mutation for the UserFavorite entity.
func newUserFavoriteMutation(c config, op Op, opts ...userfavoriteOption) *UserFavoriteMutation {
	m := &UserFavoriteMutation{
		config:        c,
		op:            op,
		typ:           TypeUserFavorite,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserFavoriteID sets the ID field of the mutation.
func withUserFavoriteID(id uuid.UUID) userfavoriteOption {
	return func(m *UserFavoriteMutation) {
		var (
			err   error
			once  sync.Once
			value *UserFavorite
		)
		m.oldValue = func(ctx context.Context) (*UserFavorite, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserFavorite.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserFavorite sets the old UserFavorite of the mutation.
func withUserFavorite(node *UserFavorite) userfavoriteOption {
	return func(m *UserFavoriteMutation) {
		m.oldValue = func(context.Context) (*UserFavorite, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserFavoriteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserFavoriteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserFavorite entities.
func (m *UserFavoriteMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserFavoriteMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserFavoriteMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserFavorite.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *UserFavoriteMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *UserFavoriteMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the UserFavorite entity.
// If the UserFavorite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFavoriteMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *UserFavoriteMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *UserFavoriteMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *UserFavoriteMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the UserFavorite entity.
// If the UserFavorite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFavoriteMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *UserFavoriteMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserFavoriteMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserFavoriteMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserFavorite entity.
// If the UserFavorite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFavoriteMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserFavoriteMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserFavoriteMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserFavoriteMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserFavorite entity.
// If the UserFavorite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFavoriteMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserFavoriteMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetPageLink sets the "page_link" field.
func (m *UserFavoriteMutation) SetPageLink(s string) {
	m.page_link = &s
}

// PageLink returns the value of the "page_link" field in the mutation.
func (m *UserFavoriteMutation) PageLink() (r string, exists bool) {
	v := m.page_link
	if v == nil {
		return
	}
	return *v, true
}

// OldPageLink returns the old "page_link" field's value of the UserFavorite entity.
// If the UserFavorite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFavoriteMutation) OldPageLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPageLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPageLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPageLink: %w", err)
	}
	return oldValue.PageLink, nil
}

// ResetPageLink resets all changes to the "page_link" field.
func (m *UserFavoriteMutation) ResetPageLink() {
	m.page_link = nil
}

// SetUserID sets the "user_id" field.
func (m *UserFavoriteMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserFavoriteMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserFavorite entity.
// If the UserFavorite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFavoriteMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserFavoriteMutation) ResetUserID() {
	m.user = nil
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *UserFavoriteMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[userfavorite.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *UserFavoriteMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *UserFavoriteMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *UserFavoriteMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *UserFavoriteMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[userfavorite.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *UserFavoriteMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *UserFavoriteMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *UserFavoriteMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserFavoriteMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userfavorite.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserFavoriteMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserFavoriteMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserFavoriteMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserFavoriteMutation builder.
func (m *UserFavoriteMutation) Where(ps ...predicate.UserFavorite) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserFavoriteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserFavoriteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserFavorite, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserFavoriteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserFavoriteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserFavorite).
func (m *UserFavoriteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserFavoriteMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.business_unit != nil {
		fields = append(fields, userfavorite.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, userfavorite.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, userfavorite.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userfavorite.FieldUpdatedAt)
	}
	if m.page_link != nil {
		fields = append(fields, userfavorite.FieldPageLink)
	}
	if m.user != nil {
		fields = append(fields, userfavorite.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserFavoriteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userfavorite.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case userfavorite.FieldOrganizationID:
		return m.OrganizationID()
	case userfavorite.FieldCreatedAt:
		return m.CreatedAt()
	case userfavorite.FieldUpdatedAt:
		return m.UpdatedAt()
	case userfavorite.FieldPageLink:
		return m.PageLink()
	case userfavorite.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserFavoriteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userfavorite.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case userfavorite.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case userfavorite.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userfavorite.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userfavorite.FieldPageLink:
		return m.OldPageLink(ctx)
	case userfavorite.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown UserFavorite field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserFavoriteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userfavorite.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case userfavorite.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case userfavorite.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userfavorite.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userfavorite.FieldPageLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPageLink(v)
		return nil
	case userfavorite.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown UserFavorite field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserFavoriteMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserFavoriteMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserFavoriteMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserFavorite numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserFavoriteMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserFavoriteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserFavoriteMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserFavorite nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserFavoriteMutation) ResetField(name string) error {
	switch name {
	case userfavorite.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case userfavorite.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case userfavorite.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userfavorite.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userfavorite.FieldPageLink:
		m.ResetPageLink()
		return nil
	case userfavorite.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown UserFavorite field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserFavoriteMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.business_unit != nil {
		edges = append(edges, userfavorite.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, userfavorite.EdgeOrganization)
	}
	if m.user != nil {
		edges = append(edges, userfavorite.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserFavoriteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userfavorite.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case userfavorite.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case userfavorite.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserFavoriteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserFavoriteMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserFavoriteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbusiness_unit {
		edges = append(edges, userfavorite.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, userfavorite.EdgeOrganization)
	}
	if m.cleareduser {
		edges = append(edges, userfavorite.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserFavoriteMutation) EdgeCleared(name string) bool {
	switch name {
	case userfavorite.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case userfavorite.EdgeOrganization:
		return m.clearedorganization
	case userfavorite.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserFavoriteMutation) ClearEdge(name string) error {
	switch name {
	case userfavorite.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case userfavorite.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case userfavorite.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserFavorite unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserFavoriteMutation) ResetEdge(name string) error {
	switch name {
	case userfavorite.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case userfavorite.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case userfavorite.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserFavorite edge %s", name)
}

// WorkerMutation represents an operation that mutates the Worker nodes in the graph.
type WorkerMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	created_at               *time.Time
	updated_at               *time.Time
	status                   *worker.Status
	code                     *string
	profile_picture_url      *string
	worker_type              *worker.WorkerType
	first_name               *string
	last_name                *string
	city                     *string
	postal_code              *string
	clearedFields            map[string]struct{}
	business_unit            *uuid.UUID
	clearedbusiness_unit     bool
	organization             *uuid.UUID
	clearedorganization      bool
	state                    *uuid.UUID
	clearedstate             bool
	fleet_code               *uuid.UUID
	clearedfleet_code        bool
	manager                  *uuid.UUID
	clearedmanager           bool
	primary_tractor          *uuid.UUID
	clearedprimary_tractor   bool
	secondary_tractor        *uuid.UUID
	clearedsecondary_tractor bool
	worker_profile           *uuid.UUID
	clearedworker_profile    bool
	worker_comments          map[uuid.UUID]struct{}
	removedworker_comments   map[uuid.UUID]struct{}
	clearedworker_comments   bool
	worker_contacts          map[uuid.UUID]struct{}
	removedworker_contacts   map[uuid.UUID]struct{}
	clearedworker_contacts   bool
	done                     bool
	oldValue                 func(context.Context) (*Worker, error)
	predicates               []predicate.Worker
}

var _ ent.Mutation = (*WorkerMutation)(nil)

// workerOption allows management of the mutation configuration using functional options.
type workerOption func(*WorkerMutation)

// newWorkerMutation creates new mutation for the Worker entity.
func newWorkerMutation(c config, op Op, opts ...workerOption) *WorkerMutation {
	m := &WorkerMutation{
		config:        c,
		op:            op,
		typ:           TypeWorker,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkerID sets the ID field of the mutation.
func withWorkerID(id uuid.UUID) workerOption {
	return func(m *WorkerMutation) {
		var (
			err   error
			once  sync.Once
			value *Worker
		)
		m.oldValue = func(ctx context.Context) (*Worker, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Worker.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorker sets the old Worker of the mutation.
func withWorker(node *Worker) workerOption {
	return func(m *WorkerMutation) {
		m.oldValue = func(context.Context) (*Worker, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Worker entities.
func (m *WorkerMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkerMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkerMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Worker.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *WorkerMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *WorkerMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the Worker entity.
// If the Worker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *WorkerMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *WorkerMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *WorkerMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Worker entity.
// If the Worker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *WorkerMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Worker entity.
// If the Worker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Worker entity.
// If the Worker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *WorkerMutation) SetStatus(w worker.Status) {
	m.status = &w
}

// Status returns the value of the "status" field in the mutation.
func (m *WorkerMutation) Status() (r worker.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Worker entity.
// If the Worker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerMutation) OldStatus(ctx context.Context) (v worker.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *WorkerMutation) ResetStatus() {
	m.status = nil
}

// SetCode sets the "code" field.
func (m *WorkerMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *WorkerMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Worker entity.
// If the Worker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *WorkerMutation) ResetCode() {
	m.code = nil
}

// SetProfilePictureURL sets the "profile_picture_url" field.
func (m *WorkerMutation) SetProfilePictureURL(s string) {
	m.profile_picture_url = &s
}

// ProfilePictureURL returns the value of the "profile_picture_url" field in the mutation.
func (m *WorkerMutation) ProfilePictureURL() (r string, exists bool) {
	v := m.profile_picture_url
	if v == nil {
		return
	}
	return *v, true
}

// OldProfilePictureURL returns the old "profile_picture_url" field's value of the Worker entity.
// If the Worker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerMutation) OldProfilePictureURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProfilePictureURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProfilePictureURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfilePictureURL: %w", err)
	}
	return oldValue.ProfilePictureURL, nil
}

// ClearProfilePictureURL clears the value of the "profile_picture_url" field.
func (m *WorkerMutation) ClearProfilePictureURL() {
	m.profile_picture_url = nil
	m.clearedFields[worker.FieldProfilePictureURL] = struct{}{}
}

// ProfilePictureURLCleared returns if the "profile_picture_url" field was cleared in this mutation.
func (m *WorkerMutation) ProfilePictureURLCleared() bool {
	_, ok := m.clearedFields[worker.FieldProfilePictureURL]
	return ok
}

// ResetProfilePictureURL resets all changes to the "profile_picture_url" field.
func (m *WorkerMutation) ResetProfilePictureURL() {
	m.profile_picture_url = nil
	delete(m.clearedFields, worker.FieldProfilePictureURL)
}

// SetWorkerType sets the "worker_type" field.
func (m *WorkerMutation) SetWorkerType(wt worker.WorkerType) {
	m.worker_type = &wt
}

// WorkerType returns the value of the "worker_type" field in the mutation.
func (m *WorkerMutation) WorkerType() (r worker.WorkerType, exists bool) {
	v := m.worker_type
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkerType returns the old "worker_type" field's value of the Worker entity.
// If the Worker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerMutation) OldWorkerType(ctx context.Context) (v worker.WorkerType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkerType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkerType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkerType: %w", err)
	}
	return oldValue.WorkerType, nil
}

// ResetWorkerType resets all changes to the "worker_type" field.
func (m *WorkerMutation) ResetWorkerType() {
	m.worker_type = nil
}

// SetFirstName sets the "first_name" field.
func (m *WorkerMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *WorkerMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the Worker entity.
// If the Worker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *WorkerMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *WorkerMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *WorkerMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the Worker entity.
// If the Worker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *WorkerMutation) ResetLastName() {
	m.last_name = nil
}

// SetCity sets the "city" field.
func (m *WorkerMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *WorkerMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Worker entity.
// If the Worker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ClearCity clears the value of the "city" field.
func (m *WorkerMutation) ClearCity() {
	m.city = nil
	m.clearedFields[worker.FieldCity] = struct{}{}
}

// CityCleared returns if the "city" field was cleared in this mutation.
func (m *WorkerMutation) CityCleared() bool {
	_, ok := m.clearedFields[worker.FieldCity]
	return ok
}

// ResetCity resets all changes to the "city" field.
func (m *WorkerMutation) ResetCity() {
	m.city = nil
	delete(m.clearedFields, worker.FieldCity)
}

// SetPostalCode sets the "postal_code" field.
func (m *WorkerMutation) SetPostalCode(s string) {
	m.postal_code = &s
}

// PostalCode returns the value of the "postal_code" field in the mutation.
func (m *WorkerMutation) PostalCode() (r string, exists bool) {
	v := m.postal_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPostalCode returns the old "postal_code" field's value of the Worker entity.
// If the Worker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerMutation) OldPostalCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostalCode: %w", err)
	}
	return oldValue.PostalCode, nil
}

// ClearPostalCode clears the value of the "postal_code" field.
func (m *WorkerMutation) ClearPostalCode() {
	m.postal_code = nil
	m.clearedFields[worker.FieldPostalCode] = struct{}{}
}

// PostalCodeCleared returns if the "postal_code" field was cleared in this mutation.
func (m *WorkerMutation) PostalCodeCleared() bool {
	_, ok := m.clearedFields[worker.FieldPostalCode]
	return ok
}

// ResetPostalCode resets all changes to the "postal_code" field.
func (m *WorkerMutation) ResetPostalCode() {
	m.postal_code = nil
	delete(m.clearedFields, worker.FieldPostalCode)
}

// SetStateID sets the "state_id" field.
func (m *WorkerMutation) SetStateID(u uuid.UUID) {
	m.state = &u
}

// StateID returns the value of the "state_id" field in the mutation.
func (m *WorkerMutation) StateID() (r uuid.UUID, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldStateID returns the old "state_id" field's value of the Worker entity.
// If the Worker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerMutation) OldStateID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStateID: %w", err)
	}
	return oldValue.StateID, nil
}

// ClearStateID clears the value of the "state_id" field.
func (m *WorkerMutation) ClearStateID() {
	m.state = nil
	m.clearedFields[worker.FieldStateID] = struct{}{}
}

// StateIDCleared returns if the "state_id" field was cleared in this mutation.
func (m *WorkerMutation) StateIDCleared() bool {
	_, ok := m.clearedFields[worker.FieldStateID]
	return ok
}

// ResetStateID resets all changes to the "state_id" field.
func (m *WorkerMutation) ResetStateID() {
	m.state = nil
	delete(m.clearedFields, worker.FieldStateID)
}

// SetFleetCodeID sets the "fleet_code_id" field.
func (m *WorkerMutation) SetFleetCodeID(u uuid.UUID) {
	m.fleet_code = &u
}

// FleetCodeID returns the value of the "fleet_code_id" field in the mutation.
func (m *WorkerMutation) FleetCodeID() (r uuid.UUID, exists bool) {
	v := m.fleet_code
	if v == nil {
		return
	}
	return *v, true
}

// OldFleetCodeID returns the old "fleet_code_id" field's value of the Worker entity.
// If the Worker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerMutation) OldFleetCodeID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFleetCodeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFleetCodeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFleetCodeID: %w", err)
	}
	return oldValue.FleetCodeID, nil
}

// ClearFleetCodeID clears the value of the "fleet_code_id" field.
func (m *WorkerMutation) ClearFleetCodeID() {
	m.fleet_code = nil
	m.clearedFields[worker.FieldFleetCodeID] = struct{}{}
}

// FleetCodeIDCleared returns if the "fleet_code_id" field was cleared in this mutation.
func (m *WorkerMutation) FleetCodeIDCleared() bool {
	_, ok := m.clearedFields[worker.FieldFleetCodeID]
	return ok
}

// ResetFleetCodeID resets all changes to the "fleet_code_id" field.
func (m *WorkerMutation) ResetFleetCodeID() {
	m.fleet_code = nil
	delete(m.clearedFields, worker.FieldFleetCodeID)
}

// SetManagerID sets the "manager_id" field.
func (m *WorkerMutation) SetManagerID(u uuid.UUID) {
	m.manager = &u
}

// ManagerID returns the value of the "manager_id" field in the mutation.
func (m *WorkerMutation) ManagerID() (r uuid.UUID, exists bool) {
	v := m.manager
	if v == nil {
		return
	}
	return *v, true
}

// OldManagerID returns the old "manager_id" field's value of the Worker entity.
// If the Worker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerMutation) OldManagerID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManagerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManagerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManagerID: %w", err)
	}
	return oldValue.ManagerID, nil
}

// ClearManagerID clears the value of the "manager_id" field.
func (m *WorkerMutation) ClearManagerID() {
	m.manager = nil
	m.clearedFields[worker.FieldManagerID] = struct{}{}
}

// ManagerIDCleared returns if the "manager_id" field was cleared in this mutation.
func (m *WorkerMutation) ManagerIDCleared() bool {
	_, ok := m.clearedFields[worker.FieldManagerID]
	return ok
}

// ResetManagerID resets all changes to the "manager_id" field.
func (m *WorkerMutation) ResetManagerID() {
	m.manager = nil
	delete(m.clearedFields, worker.FieldManagerID)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *WorkerMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[worker.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *WorkerMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *WorkerMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *WorkerMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *WorkerMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[worker.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *WorkerMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *WorkerMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *WorkerMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearState clears the "state" edge to the UsState entity.
func (m *WorkerMutation) ClearState() {
	m.clearedstate = true
	m.clearedFields[worker.FieldStateID] = struct{}{}
}

// StateCleared reports if the "state" edge to the UsState entity was cleared.
func (m *WorkerMutation) StateCleared() bool {
	return m.StateIDCleared() || m.clearedstate
}

// StateIDs returns the "state" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StateID instead. It exists only for internal usage by the builders.
func (m *WorkerMutation) StateIDs() (ids []uuid.UUID) {
	if id := m.state; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetState resets all changes to the "state" edge.
func (m *WorkerMutation) ResetState() {
	m.state = nil
	m.clearedstate = false
}

// ClearFleetCode clears the "fleet_code" edge to the FleetCode entity.
func (m *WorkerMutation) ClearFleetCode() {
	m.clearedfleet_code = true
	m.clearedFields[worker.FieldFleetCodeID] = struct{}{}
}

// FleetCodeCleared reports if the "fleet_code" edge to the FleetCode entity was cleared.
func (m *WorkerMutation) FleetCodeCleared() bool {
	return m.FleetCodeIDCleared() || m.clearedfleet_code
}

// FleetCodeIDs returns the "fleet_code" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FleetCodeID instead. It exists only for internal usage by the builders.
func (m *WorkerMutation) FleetCodeIDs() (ids []uuid.UUID) {
	if id := m.fleet_code; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFleetCode resets all changes to the "fleet_code" edge.
func (m *WorkerMutation) ResetFleetCode() {
	m.fleet_code = nil
	m.clearedfleet_code = false
}

// ClearManager clears the "manager" edge to the User entity.
func (m *WorkerMutation) ClearManager() {
	m.clearedmanager = true
	m.clearedFields[worker.FieldManagerID] = struct{}{}
}

// ManagerCleared reports if the "manager" edge to the User entity was cleared.
func (m *WorkerMutation) ManagerCleared() bool {
	return m.ManagerIDCleared() || m.clearedmanager
}

// ManagerIDs returns the "manager" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ManagerID instead. It exists only for internal usage by the builders.
func (m *WorkerMutation) ManagerIDs() (ids []uuid.UUID) {
	if id := m.manager; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetManager resets all changes to the "manager" edge.
func (m *WorkerMutation) ResetManager() {
	m.manager = nil
	m.clearedmanager = false
}

// SetPrimaryTractorID sets the "primary_tractor" edge to the Tractor entity by id.
func (m *WorkerMutation) SetPrimaryTractorID(id uuid.UUID) {
	m.primary_tractor = &id
}

// ClearPrimaryTractor clears the "primary_tractor" edge to the Tractor entity.
func (m *WorkerMutation) ClearPrimaryTractor() {
	m.clearedprimary_tractor = true
}

// PrimaryTractorCleared reports if the "primary_tractor" edge to the Tractor entity was cleared.
func (m *WorkerMutation) PrimaryTractorCleared() bool {
	return m.clearedprimary_tractor
}

// PrimaryTractorID returns the "primary_tractor" edge ID in the mutation.
func (m *WorkerMutation) PrimaryTractorID() (id uuid.UUID, exists bool) {
	if m.primary_tractor != nil {
		return *m.primary_tractor, true
	}
	return
}

// PrimaryTractorIDs returns the "primary_tractor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PrimaryTractorID instead. It exists only for internal usage by the builders.
func (m *WorkerMutation) PrimaryTractorIDs() (ids []uuid.UUID) {
	if id := m.primary_tractor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrimaryTractor resets all changes to the "primary_tractor" edge.
func (m *WorkerMutation) ResetPrimaryTractor() {
	m.primary_tractor = nil
	m.clearedprimary_tractor = false
}

// SetSecondaryTractorID sets the "secondary_tractor" edge to the Tractor entity by id.
func (m *WorkerMutation) SetSecondaryTractorID(id uuid.UUID) {
	m.secondary_tractor = &id
}

// ClearSecondaryTractor clears the "secondary_tractor" edge to the Tractor entity.
func (m *WorkerMutation) ClearSecondaryTractor() {
	m.clearedsecondary_tractor = true
}

// SecondaryTractorCleared reports if the "secondary_tractor" edge to the Tractor entity was cleared.
func (m *WorkerMutation) SecondaryTractorCleared() bool {
	return m.clearedsecondary_tractor
}

// SecondaryTractorID returns the "secondary_tractor" edge ID in the mutation.
func (m *WorkerMutation) SecondaryTractorID() (id uuid.UUID, exists bool) {
	if m.secondary_tractor != nil {
		return *m.secondary_tractor, true
	}
	return
}

// SecondaryTractorIDs returns the "secondary_tractor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SecondaryTractorID instead. It exists only for internal usage by the builders.
func (m *WorkerMutation) SecondaryTractorIDs() (ids []uuid.UUID) {
	if id := m.secondary_tractor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSecondaryTractor resets all changes to the "secondary_tractor" edge.
func (m *WorkerMutation) ResetSecondaryTractor() {
	m.secondary_tractor = nil
	m.clearedsecondary_tractor = false
}

// SetWorkerProfileID sets the "worker_profile" edge to the WorkerProfile entity by id.
func (m *WorkerMutation) SetWorkerProfileID(id uuid.UUID) {
	m.worker_profile = &id
}

// ClearWorkerProfile clears the "worker_profile" edge to the WorkerProfile entity.
func (m *WorkerMutation) ClearWorkerProfile() {
	m.clearedworker_profile = true
}

// WorkerProfileCleared reports if the "worker_profile" edge to the WorkerProfile entity was cleared.
func (m *WorkerMutation) WorkerProfileCleared() bool {
	return m.clearedworker_profile
}

// WorkerProfileID returns the "worker_profile" edge ID in the mutation.
func (m *WorkerMutation) WorkerProfileID() (id uuid.UUID, exists bool) {
	if m.worker_profile != nil {
		return *m.worker_profile, true
	}
	return
}

// WorkerProfileIDs returns the "worker_profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkerProfileID instead. It exists only for internal usage by the builders.
func (m *WorkerMutation) WorkerProfileIDs() (ids []uuid.UUID) {
	if id := m.worker_profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkerProfile resets all changes to the "worker_profile" edge.
func (m *WorkerMutation) ResetWorkerProfile() {
	m.worker_profile = nil
	m.clearedworker_profile = false
}

// AddWorkerCommentIDs adds the "worker_comments" edge to the WorkerComment entity by ids.
func (m *WorkerMutation) AddWorkerCommentIDs(ids ...uuid.UUID) {
	if m.worker_comments == nil {
		m.worker_comments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.worker_comments[ids[i]] = struct{}{}
	}
}

// ClearWorkerComments clears the "worker_comments" edge to the WorkerComment entity.
func (m *WorkerMutation) ClearWorkerComments() {
	m.clearedworker_comments = true
}

// WorkerCommentsCleared reports if the "worker_comments" edge to the WorkerComment entity was cleared.
func (m *WorkerMutation) WorkerCommentsCleared() bool {
	return m.clearedworker_comments
}

// RemoveWorkerCommentIDs removes the "worker_comments" edge to the WorkerComment entity by IDs.
func (m *WorkerMutation) RemoveWorkerCommentIDs(ids ...uuid.UUID) {
	if m.removedworker_comments == nil {
		m.removedworker_comments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.worker_comments, ids[i])
		m.removedworker_comments[ids[i]] = struct{}{}
	}
}

// RemovedWorkerComments returns the removed IDs of the "worker_comments" edge to the WorkerComment entity.
func (m *WorkerMutation) RemovedWorkerCommentsIDs() (ids []uuid.UUID) {
	for id := range m.removedworker_comments {
		ids = append(ids, id)
	}
	return
}

// WorkerCommentsIDs returns the "worker_comments" edge IDs in the mutation.
func (m *WorkerMutation) WorkerCommentsIDs() (ids []uuid.UUID) {
	for id := range m.worker_comments {
		ids = append(ids, id)
	}
	return
}

// ResetWorkerComments resets all changes to the "worker_comments" edge.
func (m *WorkerMutation) ResetWorkerComments() {
	m.worker_comments = nil
	m.clearedworker_comments = false
	m.removedworker_comments = nil
}

// AddWorkerContactIDs adds the "worker_contacts" edge to the WorkerContact entity by ids.
func (m *WorkerMutation) AddWorkerContactIDs(ids ...uuid.UUID) {
	if m.worker_contacts == nil {
		m.worker_contacts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.worker_contacts[ids[i]] = struct{}{}
	}
}

// ClearWorkerContacts clears the "worker_contacts" edge to the WorkerContact entity.
func (m *WorkerMutation) ClearWorkerContacts() {
	m.clearedworker_contacts = true
}

// WorkerContactsCleared reports if the "worker_contacts" edge to the WorkerContact entity was cleared.
func (m *WorkerMutation) WorkerContactsCleared() bool {
	return m.clearedworker_contacts
}

// RemoveWorkerContactIDs removes the "worker_contacts" edge to the WorkerContact entity by IDs.
func (m *WorkerMutation) RemoveWorkerContactIDs(ids ...uuid.UUID) {
	if m.removedworker_contacts == nil {
		m.removedworker_contacts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.worker_contacts, ids[i])
		m.removedworker_contacts[ids[i]] = struct{}{}
	}
}

// RemovedWorkerContacts returns the removed IDs of the "worker_contacts" edge to the WorkerContact entity.
func (m *WorkerMutation) RemovedWorkerContactsIDs() (ids []uuid.UUID) {
	for id := range m.removedworker_contacts {
		ids = append(ids, id)
	}
	return
}

// WorkerContactsIDs returns the "worker_contacts" edge IDs in the mutation.
func (m *WorkerMutation) WorkerContactsIDs() (ids []uuid.UUID) {
	for id := range m.worker_contacts {
		ids = append(ids, id)
	}
	return
}

// ResetWorkerContacts resets all changes to the "worker_contacts" edge.
func (m *WorkerMutation) ResetWorkerContacts() {
	m.worker_contacts = nil
	m.clearedworker_contacts = false
	m.removedworker_contacts = nil
}

// Where appends a list predicates to the WorkerMutation builder.
func (m *WorkerMutation) Where(ps ...predicate.Worker) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Worker, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Worker).
func (m *WorkerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkerMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.business_unit != nil {
		fields = append(fields, worker.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, worker.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, worker.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, worker.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, worker.FieldStatus)
	}
	if m.code != nil {
		fields = append(fields, worker.FieldCode)
	}
	if m.profile_picture_url != nil {
		fields = append(fields, worker.FieldProfilePictureURL)
	}
	if m.worker_type != nil {
		fields = append(fields, worker.FieldWorkerType)
	}
	if m.first_name != nil {
		fields = append(fields, worker.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, worker.FieldLastName)
	}
	if m.city != nil {
		fields = append(fields, worker.FieldCity)
	}
	if m.postal_code != nil {
		fields = append(fields, worker.FieldPostalCode)
	}
	if m.state != nil {
		fields = append(fields, worker.FieldStateID)
	}
	if m.fleet_code != nil {
		fields = append(fields, worker.FieldFleetCodeID)
	}
	if m.manager != nil {
		fields = append(fields, worker.FieldManagerID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case worker.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case worker.FieldOrganizationID:
		return m.OrganizationID()
	case worker.FieldCreatedAt:
		return m.CreatedAt()
	case worker.FieldUpdatedAt:
		return m.UpdatedAt()
	case worker.FieldStatus:
		return m.Status()
	case worker.FieldCode:
		return m.Code()
	case worker.FieldProfilePictureURL:
		return m.ProfilePictureURL()
	case worker.FieldWorkerType:
		return m.WorkerType()
	case worker.FieldFirstName:
		return m.FirstName()
	case worker.FieldLastName:
		return m.LastName()
	case worker.FieldCity:
		return m.City()
	case worker.FieldPostalCode:
		return m.PostalCode()
	case worker.FieldStateID:
		return m.StateID()
	case worker.FieldFleetCodeID:
		return m.FleetCodeID()
	case worker.FieldManagerID:
		return m.ManagerID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case worker.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case worker.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case worker.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case worker.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case worker.FieldStatus:
		return m.OldStatus(ctx)
	case worker.FieldCode:
		return m.OldCode(ctx)
	case worker.FieldProfilePictureURL:
		return m.OldProfilePictureURL(ctx)
	case worker.FieldWorkerType:
		return m.OldWorkerType(ctx)
	case worker.FieldFirstName:
		return m.OldFirstName(ctx)
	case worker.FieldLastName:
		return m.OldLastName(ctx)
	case worker.FieldCity:
		return m.OldCity(ctx)
	case worker.FieldPostalCode:
		return m.OldPostalCode(ctx)
	case worker.FieldStateID:
		return m.OldStateID(ctx)
	case worker.FieldFleetCodeID:
		return m.OldFleetCodeID(ctx)
	case worker.FieldManagerID:
		return m.OldManagerID(ctx)
	}
	return nil, fmt.Errorf("unknown Worker field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case worker.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case worker.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case worker.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case worker.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case worker.FieldStatus:
		v, ok := value.(worker.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case worker.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case worker.FieldProfilePictureURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfilePictureURL(v)
		return nil
	case worker.FieldWorkerType:
		v, ok := value.(worker.WorkerType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkerType(v)
		return nil
	case worker.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case worker.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case worker.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case worker.FieldPostalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostalCode(v)
		return nil
	case worker.FieldStateID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStateID(v)
		return nil
	case worker.FieldFleetCodeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFleetCodeID(v)
		return nil
	case worker.FieldManagerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManagerID(v)
		return nil
	}
	return fmt.Errorf("unknown Worker field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Worker numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(worker.FieldProfilePictureURL) {
		fields = append(fields, worker.FieldProfilePictureURL)
	}
	if m.FieldCleared(worker.FieldCity) {
		fields = append(fields, worker.FieldCity)
	}
	if m.FieldCleared(worker.FieldPostalCode) {
		fields = append(fields, worker.FieldPostalCode)
	}
	if m.FieldCleared(worker.FieldStateID) {
		fields = append(fields, worker.FieldStateID)
	}
	if m.FieldCleared(worker.FieldFleetCodeID) {
		fields = append(fields, worker.FieldFleetCodeID)
	}
	if m.FieldCleared(worker.FieldManagerID) {
		fields = append(fields, worker.FieldManagerID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkerMutation) ClearField(name string) error {
	switch name {
	case worker.FieldProfilePictureURL:
		m.ClearProfilePictureURL()
		return nil
	case worker.FieldCity:
		m.ClearCity()
		return nil
	case worker.FieldPostalCode:
		m.ClearPostalCode()
		return nil
	case worker.FieldStateID:
		m.ClearStateID()
		return nil
	case worker.FieldFleetCodeID:
		m.ClearFleetCodeID()
		return nil
	case worker.FieldManagerID:
		m.ClearManagerID()
		return nil
	}
	return fmt.Errorf("unknown Worker nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkerMutation) ResetField(name string) error {
	switch name {
	case worker.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case worker.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case worker.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case worker.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case worker.FieldStatus:
		m.ResetStatus()
		return nil
	case worker.FieldCode:
		m.ResetCode()
		return nil
	case worker.FieldProfilePictureURL:
		m.ResetProfilePictureURL()
		return nil
	case worker.FieldWorkerType:
		m.ResetWorkerType()
		return nil
	case worker.FieldFirstName:
		m.ResetFirstName()
		return nil
	case worker.FieldLastName:
		m.ResetLastName()
		return nil
	case worker.FieldCity:
		m.ResetCity()
		return nil
	case worker.FieldPostalCode:
		m.ResetPostalCode()
		return nil
	case worker.FieldStateID:
		m.ResetStateID()
		return nil
	case worker.FieldFleetCodeID:
		m.ResetFleetCodeID()
		return nil
	case worker.FieldManagerID:
		m.ResetManagerID()
		return nil
	}
	return fmt.Errorf("unknown Worker field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkerMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m.business_unit != nil {
		edges = append(edges, worker.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, worker.EdgeOrganization)
	}
	if m.state != nil {
		edges = append(edges, worker.EdgeState)
	}
	if m.fleet_code != nil {
		edges = append(edges, worker.EdgeFleetCode)
	}
	if m.manager != nil {
		edges = append(edges, worker.EdgeManager)
	}
	if m.primary_tractor != nil {
		edges = append(edges, worker.EdgePrimaryTractor)
	}
	if m.secondary_tractor != nil {
		edges = append(edges, worker.EdgeSecondaryTractor)
	}
	if m.worker_profile != nil {
		edges = append(edges, worker.EdgeWorkerProfile)
	}
	if m.worker_comments != nil {
		edges = append(edges, worker.EdgeWorkerComments)
	}
	if m.worker_contacts != nil {
		edges = append(edges, worker.EdgeWorkerContacts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case worker.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case worker.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case worker.EdgeState:
		if id := m.state; id != nil {
			return []ent.Value{*id}
		}
	case worker.EdgeFleetCode:
		if id := m.fleet_code; id != nil {
			return []ent.Value{*id}
		}
	case worker.EdgeManager:
		if id := m.manager; id != nil {
			return []ent.Value{*id}
		}
	case worker.EdgePrimaryTractor:
		if id := m.primary_tractor; id != nil {
			return []ent.Value{*id}
		}
	case worker.EdgeSecondaryTractor:
		if id := m.secondary_tractor; id != nil {
			return []ent.Value{*id}
		}
	case worker.EdgeWorkerProfile:
		if id := m.worker_profile; id != nil {
			return []ent.Value{*id}
		}
	case worker.EdgeWorkerComments:
		ids := make([]ent.Value, 0, len(m.worker_comments))
		for id := range m.worker_comments {
			ids = append(ids, id)
		}
		return ids
	case worker.EdgeWorkerContacts:
		ids := make([]ent.Value, 0, len(m.worker_contacts))
		for id := range m.worker_contacts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	if m.removedworker_comments != nil {
		edges = append(edges, worker.EdgeWorkerComments)
	}
	if m.removedworker_contacts != nil {
		edges = append(edges, worker.EdgeWorkerContacts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case worker.EdgeWorkerComments:
		ids := make([]ent.Value, 0, len(m.removedworker_comments))
		for id := range m.removedworker_comments {
			ids = append(ids, id)
		}
		return ids
	case worker.EdgeWorkerContacts:
		ids := make([]ent.Value, 0, len(m.removedworker_contacts))
		for id := range m.removedworker_contacts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.clearedbusiness_unit {
		edges = append(edges, worker.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, worker.EdgeOrganization)
	}
	if m.clearedstate {
		edges = append(edges, worker.EdgeState)
	}
	if m.clearedfleet_code {
		edges = append(edges, worker.EdgeFleetCode)
	}
	if m.clearedmanager {
		edges = append(edges, worker.EdgeManager)
	}
	if m.clearedprimary_tractor {
		edges = append(edges, worker.EdgePrimaryTractor)
	}
	if m.clearedsecondary_tractor {
		edges = append(edges, worker.EdgeSecondaryTractor)
	}
	if m.clearedworker_profile {
		edges = append(edges, worker.EdgeWorkerProfile)
	}
	if m.clearedworker_comments {
		edges = append(edges, worker.EdgeWorkerComments)
	}
	if m.clearedworker_contacts {
		edges = append(edges, worker.EdgeWorkerContacts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkerMutation) EdgeCleared(name string) bool {
	switch name {
	case worker.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case worker.EdgeOrganization:
		return m.clearedorganization
	case worker.EdgeState:
		return m.clearedstate
	case worker.EdgeFleetCode:
		return m.clearedfleet_code
	case worker.EdgeManager:
		return m.clearedmanager
	case worker.EdgePrimaryTractor:
		return m.clearedprimary_tractor
	case worker.EdgeSecondaryTractor:
		return m.clearedsecondary_tractor
	case worker.EdgeWorkerProfile:
		return m.clearedworker_profile
	case worker.EdgeWorkerComments:
		return m.clearedworker_comments
	case worker.EdgeWorkerContacts:
		return m.clearedworker_contacts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkerMutation) ClearEdge(name string) error {
	switch name {
	case worker.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case worker.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case worker.EdgeState:
		m.ClearState()
		return nil
	case worker.EdgeFleetCode:
		m.ClearFleetCode()
		return nil
	case worker.EdgeManager:
		m.ClearManager()
		return nil
	case worker.EdgePrimaryTractor:
		m.ClearPrimaryTractor()
		return nil
	case worker.EdgeSecondaryTractor:
		m.ClearSecondaryTractor()
		return nil
	case worker.EdgeWorkerProfile:
		m.ClearWorkerProfile()
		return nil
	}
	return fmt.Errorf("unknown Worker unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkerMutation) ResetEdge(name string) error {
	switch name {
	case worker.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case worker.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case worker.EdgeState:
		m.ResetState()
		return nil
	case worker.EdgeFleetCode:
		m.ResetFleetCode()
		return nil
	case worker.EdgeManager:
		m.ResetManager()
		return nil
	case worker.EdgePrimaryTractor:
		m.ResetPrimaryTractor()
		return nil
	case worker.EdgeSecondaryTractor:
		m.ResetSecondaryTractor()
		return nil
	case worker.EdgeWorkerProfile:
		m.ResetWorkerProfile()
		return nil
	case worker.EdgeWorkerComments:
		m.ResetWorkerComments()
		return nil
	case worker.EdgeWorkerContacts:
		m.ResetWorkerContacts()
		return nil
	}
	return fmt.Errorf("unknown Worker edge %s", name)
}

// WorkerCommentMutation represents an operation that mutates the WorkerComment nodes in the graph.
type WorkerCommentMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	comment              *string
	entered_by           *uuid.UUID
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	worker               *uuid.UUID
	clearedworker        bool
	comment_type         *uuid.UUID
	clearedcomment_type  bool
	done                 bool
	oldValue             func(context.Context) (*WorkerComment, error)
	predicates           []predicate.WorkerComment
}

var _ ent.Mutation = (*WorkerCommentMutation)(nil)

// workercommentOption allows management of the mutation configuration using functional options.
type workercommentOption func(*WorkerCommentMutation)

// newWorkerCommentMutation creates new mutation for the WorkerComment entity.
func newWorkerCommentMutation(c config, op Op, opts ...workercommentOption) *WorkerCommentMutation {
	m := &WorkerCommentMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkerComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkerCommentID sets the ID field of the mutation.
func withWorkerCommentID(id uuid.UUID) workercommentOption {
	return func(m *WorkerCommentMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkerComment
		)
		m.oldValue = func(ctx context.Context) (*WorkerComment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkerComment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkerComment sets the old WorkerComment of the mutation.
func withWorkerComment(node *WorkerComment) workercommentOption {
	return func(m *WorkerCommentMutation) {
		m.oldValue = func(context.Context) (*WorkerComment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkerCommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkerCommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkerComment entities.
func (m *WorkerCommentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkerCommentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkerCommentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkerComment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *WorkerCommentMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *WorkerCommentMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the WorkerComment entity.
// If the WorkerComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerCommentMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *WorkerCommentMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *WorkerCommentMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *WorkerCommentMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the WorkerComment entity.
// If the WorkerComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerCommentMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *WorkerCommentMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkerCommentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkerCommentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WorkerComment entity.
// If the WorkerComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerCommentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkerCommentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkerCommentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkerCommentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WorkerComment entity.
// If the WorkerComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerCommentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkerCommentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetWorkerID sets the "worker_id" field.
func (m *WorkerCommentMutation) SetWorkerID(u uuid.UUID) {
	m.worker = &u
}

// WorkerID returns the value of the "worker_id" field in the mutation.
func (m *WorkerCommentMutation) WorkerID() (r uuid.UUID, exists bool) {
	v := m.worker
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkerID returns the old "worker_id" field's value of the WorkerComment entity.
// If the WorkerComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerCommentMutation) OldWorkerID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkerID: %w", err)
	}
	return oldValue.WorkerID, nil
}

// ResetWorkerID resets all changes to the "worker_id" field.
func (m *WorkerCommentMutation) ResetWorkerID() {
	m.worker = nil
}

// SetCommentTypeID sets the "comment_type_id" field.
func (m *WorkerCommentMutation) SetCommentTypeID(u uuid.UUID) {
	m.comment_type = &u
}

// CommentTypeID returns the value of the "comment_type_id" field in the mutation.
func (m *WorkerCommentMutation) CommentTypeID() (r uuid.UUID, exists bool) {
	v := m.comment_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCommentTypeID returns the old "comment_type_id" field's value of the WorkerComment entity.
// If the WorkerComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerCommentMutation) OldCommentTypeID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommentTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommentTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommentTypeID: %w", err)
	}
	return oldValue.CommentTypeID, nil
}

// ResetCommentTypeID resets all changes to the "comment_type_id" field.
func (m *WorkerCommentMutation) ResetCommentTypeID() {
	m.comment_type = nil
}

// SetComment sets the "comment" field.
func (m *WorkerCommentMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *WorkerCommentMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the WorkerComment entity.
// If the WorkerComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerCommentMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ResetComment resets all changes to the "comment" field.
func (m *WorkerCommentMutation) ResetComment() {
	m.comment = nil
}

// SetEnteredBy sets the "entered_by" field.
func (m *WorkerCommentMutation) SetEnteredBy(u uuid.UUID) {
	m.entered_by = &u
}

// EnteredBy returns the value of the "entered_by" field in the mutation.
func (m *WorkerCommentMutation) EnteredBy() (r uuid.UUID, exists bool) {
	v := m.entered_by
	if v == nil {
		return
	}
	return *v, true
}

// OldEnteredBy returns the old "entered_by" field's value of the WorkerComment entity.
// If the WorkerComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerCommentMutation) OldEnteredBy(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnteredBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnteredBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnteredBy: %w", err)
	}
	return oldValue.EnteredBy, nil
}

// ResetEnteredBy resets all changes to the "entered_by" field.
func (m *WorkerCommentMutation) ResetEnteredBy() {
	m.entered_by = nil
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *WorkerCommentMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[workercomment.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *WorkerCommentMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *WorkerCommentMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *WorkerCommentMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *WorkerCommentMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[workercomment.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *WorkerCommentMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *WorkerCommentMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *WorkerCommentMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearWorker clears the "worker" edge to the Worker entity.
func (m *WorkerCommentMutation) ClearWorker() {
	m.clearedworker = true
	m.clearedFields[workercomment.FieldWorkerID] = struct{}{}
}

// WorkerCleared reports if the "worker" edge to the Worker entity was cleared.
func (m *WorkerCommentMutation) WorkerCleared() bool {
	return m.clearedworker
}

// WorkerIDs returns the "worker" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkerID instead. It exists only for internal usage by the builders.
func (m *WorkerCommentMutation) WorkerIDs() (ids []uuid.UUID) {
	if id := m.worker; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorker resets all changes to the "worker" edge.
func (m *WorkerCommentMutation) ResetWorker() {
	m.worker = nil
	m.clearedworker = false
}

// ClearCommentType clears the "comment_type" edge to the CommentType entity.
func (m *WorkerCommentMutation) ClearCommentType() {
	m.clearedcomment_type = true
	m.clearedFields[workercomment.FieldCommentTypeID] = struct{}{}
}

// CommentTypeCleared reports if the "comment_type" edge to the CommentType entity was cleared.
func (m *WorkerCommentMutation) CommentTypeCleared() bool {
	return m.clearedcomment_type
}

// CommentTypeIDs returns the "comment_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CommentTypeID instead. It exists only for internal usage by the builders.
func (m *WorkerCommentMutation) CommentTypeIDs() (ids []uuid.UUID) {
	if id := m.comment_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCommentType resets all changes to the "comment_type" edge.
func (m *WorkerCommentMutation) ResetCommentType() {
	m.comment_type = nil
	m.clearedcomment_type = false
}

// Where appends a list predicates to the WorkerCommentMutation builder.
func (m *WorkerCommentMutation) Where(ps ...predicate.WorkerComment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkerCommentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkerCommentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkerComment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkerCommentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkerCommentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkerComment).
func (m *WorkerCommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkerCommentMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.business_unit != nil {
		fields = append(fields, workercomment.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, workercomment.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, workercomment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, workercomment.FieldUpdatedAt)
	}
	if m.worker != nil {
		fields = append(fields, workercomment.FieldWorkerID)
	}
	if m.comment_type != nil {
		fields = append(fields, workercomment.FieldCommentTypeID)
	}
	if m.comment != nil {
		fields = append(fields, workercomment.FieldComment)
	}
	if m.entered_by != nil {
		fields = append(fields, workercomment.FieldEnteredBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkerCommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workercomment.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case workercomment.FieldOrganizationID:
		return m.OrganizationID()
	case workercomment.FieldCreatedAt:
		return m.CreatedAt()
	case workercomment.FieldUpdatedAt:
		return m.UpdatedAt()
	case workercomment.FieldWorkerID:
		return m.WorkerID()
	case workercomment.FieldCommentTypeID:
		return m.CommentTypeID()
	case workercomment.FieldComment:
		return m.Comment()
	case workercomment.FieldEnteredBy:
		return m.EnteredBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkerCommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workercomment.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case workercomment.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case workercomment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workercomment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case workercomment.FieldWorkerID:
		return m.OldWorkerID(ctx)
	case workercomment.FieldCommentTypeID:
		return m.OldCommentTypeID(ctx)
	case workercomment.FieldComment:
		return m.OldComment(ctx)
	case workercomment.FieldEnteredBy:
		return m.OldEnteredBy(ctx)
	}
	return nil, fmt.Errorf("unknown WorkerComment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkerCommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workercomment.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case workercomment.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case workercomment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workercomment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case workercomment.FieldWorkerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkerID(v)
		return nil
	case workercomment.FieldCommentTypeID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentTypeID(v)
		return nil
	case workercomment.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case workercomment.FieldEnteredBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnteredBy(v)
		return nil
	}
	return fmt.Errorf("unknown WorkerComment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkerCommentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkerCommentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkerCommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WorkerComment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkerCommentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkerCommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkerCommentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WorkerComment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkerCommentMutation) ResetField(name string) error {
	switch name {
	case workercomment.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case workercomment.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case workercomment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workercomment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case workercomment.FieldWorkerID:
		m.ResetWorkerID()
		return nil
	case workercomment.FieldCommentTypeID:
		m.ResetCommentTypeID()
		return nil
	case workercomment.FieldComment:
		m.ResetComment()
		return nil
	case workercomment.FieldEnteredBy:
		m.ResetEnteredBy()
		return nil
	}
	return fmt.Errorf("unknown WorkerComment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkerCommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.business_unit != nil {
		edges = append(edges, workercomment.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, workercomment.EdgeOrganization)
	}
	if m.worker != nil {
		edges = append(edges, workercomment.EdgeWorker)
	}
	if m.comment_type != nil {
		edges = append(edges, workercomment.EdgeCommentType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkerCommentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workercomment.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case workercomment.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case workercomment.EdgeWorker:
		if id := m.worker; id != nil {
			return []ent.Value{*id}
		}
	case workercomment.EdgeCommentType:
		if id := m.comment_type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkerCommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkerCommentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkerCommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedbusiness_unit {
		edges = append(edges, workercomment.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, workercomment.EdgeOrganization)
	}
	if m.clearedworker {
		edges = append(edges, workercomment.EdgeWorker)
	}
	if m.clearedcomment_type {
		edges = append(edges, workercomment.EdgeCommentType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkerCommentMutation) EdgeCleared(name string) bool {
	switch name {
	case workercomment.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case workercomment.EdgeOrganization:
		return m.clearedorganization
	case workercomment.EdgeWorker:
		return m.clearedworker
	case workercomment.EdgeCommentType:
		return m.clearedcomment_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkerCommentMutation) ClearEdge(name string) error {
	switch name {
	case workercomment.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case workercomment.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case workercomment.EdgeWorker:
		m.ClearWorker()
		return nil
	case workercomment.EdgeCommentType:
		m.ClearCommentType()
		return nil
	}
	return fmt.Errorf("unknown WorkerComment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkerCommentMutation) ResetEdge(name string) error {
	switch name {
	case workercomment.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case workercomment.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case workercomment.EdgeWorker:
		m.ResetWorker()
		return nil
	case workercomment.EdgeCommentType:
		m.ResetCommentType()
		return nil
	}
	return fmt.Errorf("unknown WorkerComment edge %s", name)
}

// WorkerContactMutation represents an operation that mutates the WorkerContact nodes in the graph.
type WorkerContactMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	name                 *string
	email                *string
	phone                *string
	relationship         *string
	is_primary           *bool
	clearedFields        map[string]struct{}
	business_unit        *uuid.UUID
	clearedbusiness_unit bool
	organization         *uuid.UUID
	clearedorganization  bool
	worker               *uuid.UUID
	clearedworker        bool
	done                 bool
	oldValue             func(context.Context) (*WorkerContact, error)
	predicates           []predicate.WorkerContact
}

var _ ent.Mutation = (*WorkerContactMutation)(nil)

// workercontactOption allows management of the mutation configuration using functional options.
type workercontactOption func(*WorkerContactMutation)

// newWorkerContactMutation creates new mutation for the WorkerContact entity.
func newWorkerContactMutation(c config, op Op, opts ...workercontactOption) *WorkerContactMutation {
	m := &WorkerContactMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkerContact,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkerContactID sets the ID field of the mutation.
func withWorkerContactID(id uuid.UUID) workercontactOption {
	return func(m *WorkerContactMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkerContact
		)
		m.oldValue = func(ctx context.Context) (*WorkerContact, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkerContact.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkerContact sets the old WorkerContact of the mutation.
func withWorkerContact(node *WorkerContact) workercontactOption {
	return func(m *WorkerContactMutation) {
		m.oldValue = func(context.Context) (*WorkerContact, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkerContactMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkerContactMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkerContact entities.
func (m *WorkerContactMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkerContactMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkerContactMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkerContact.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *WorkerContactMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *WorkerContactMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the WorkerContact entity.
// If the WorkerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerContactMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *WorkerContactMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *WorkerContactMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *WorkerContactMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the WorkerContact entity.
// If the WorkerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerContactMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *WorkerContactMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkerContactMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkerContactMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WorkerContact entity.
// If the WorkerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerContactMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkerContactMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkerContactMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkerContactMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WorkerContact entity.
// If the WorkerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerContactMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkerContactMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetWorkerID sets the "worker_id" field.
func (m *WorkerContactMutation) SetWorkerID(u uuid.UUID) {
	m.worker = &u
}

// WorkerID returns the value of the "worker_id" field in the mutation.
func (m *WorkerContactMutation) WorkerID() (r uuid.UUID, exists bool) {
	v := m.worker
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkerID returns the old "worker_id" field's value of the WorkerContact entity.
// If the WorkerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerContactMutation) OldWorkerID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkerID: %w", err)
	}
	return oldValue.WorkerID, nil
}

// ResetWorkerID resets all changes to the "worker_id" field.
func (m *WorkerContactMutation) ResetWorkerID() {
	m.worker = nil
}

// SetName sets the "name" field.
func (m *WorkerContactMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WorkerContactMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the WorkerContact entity.
// If the WorkerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerContactMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WorkerContactMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *WorkerContactMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *WorkerContactMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the WorkerContact entity.
// If the WorkerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerContactMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *WorkerContactMutation) ResetEmail() {
	m.email = nil
}

// SetPhone sets the "phone" field.
func (m *WorkerContactMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *WorkerContactMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the WorkerContact entity.
// If the WorkerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerContactMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *WorkerContactMutation) ResetPhone() {
	m.phone = nil
}

// SetRelationship sets the "relationship" field.
func (m *WorkerContactMutation) SetRelationship(s string) {
	m.relationship = &s
}

// Relationship returns the value of the "relationship" field in the mutation.
func (m *WorkerContactMutation) Relationship() (r string, exists bool) {
	v := m.relationship
	if v == nil {
		return
	}
	return *v, true
}

// OldRelationship returns the old "relationship" field's value of the WorkerContact entity.
// If the WorkerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerContactMutation) OldRelationship(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelationship is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelationship requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelationship: %w", err)
	}
	return oldValue.Relationship, nil
}

// ClearRelationship clears the value of the "relationship" field.
func (m *WorkerContactMutation) ClearRelationship() {
	m.relationship = nil
	m.clearedFields[workercontact.FieldRelationship] = struct{}{}
}

// RelationshipCleared returns if the "relationship" field was cleared in this mutation.
func (m *WorkerContactMutation) RelationshipCleared() bool {
	_, ok := m.clearedFields[workercontact.FieldRelationship]
	return ok
}

// ResetRelationship resets all changes to the "relationship" field.
func (m *WorkerContactMutation) ResetRelationship() {
	m.relationship = nil
	delete(m.clearedFields, workercontact.FieldRelationship)
}

// SetIsPrimary sets the "is_primary" field.
func (m *WorkerContactMutation) SetIsPrimary(b bool) {
	m.is_primary = &b
}

// IsPrimary returns the value of the "is_primary" field in the mutation.
func (m *WorkerContactMutation) IsPrimary() (r bool, exists bool) {
	v := m.is_primary
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPrimary returns the old "is_primary" field's value of the WorkerContact entity.
// If the WorkerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerContactMutation) OldIsPrimary(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPrimary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPrimary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPrimary: %w", err)
	}
	return oldValue.IsPrimary, nil
}

// ResetIsPrimary resets all changes to the "is_primary" field.
func (m *WorkerContactMutation) ResetIsPrimary() {
	m.is_primary = nil
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *WorkerContactMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[workercontact.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *WorkerContactMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *WorkerContactMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *WorkerContactMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *WorkerContactMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[workercontact.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *WorkerContactMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *WorkerContactMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *WorkerContactMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearWorker clears the "worker" edge to the Worker entity.
func (m *WorkerContactMutation) ClearWorker() {
	m.clearedworker = true
	m.clearedFields[workercontact.FieldWorkerID] = struct{}{}
}

// WorkerCleared reports if the "worker" edge to the Worker entity was cleared.
func (m *WorkerContactMutation) WorkerCleared() bool {
	return m.clearedworker
}

// WorkerIDs returns the "worker" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkerID instead. It exists only for internal usage by the builders.
func (m *WorkerContactMutation) WorkerIDs() (ids []uuid.UUID) {
	if id := m.worker; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorker resets all changes to the "worker" edge.
func (m *WorkerContactMutation) ResetWorker() {
	m.worker = nil
	m.clearedworker = false
}

// Where appends a list predicates to the WorkerContactMutation builder.
func (m *WorkerContactMutation) Where(ps ...predicate.WorkerContact) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkerContactMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkerContactMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkerContact, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkerContactMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkerContactMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkerContact).
func (m *WorkerContactMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkerContactMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.business_unit != nil {
		fields = append(fields, workercontact.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, workercontact.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, workercontact.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, workercontact.FieldUpdatedAt)
	}
	if m.worker != nil {
		fields = append(fields, workercontact.FieldWorkerID)
	}
	if m.name != nil {
		fields = append(fields, workercontact.FieldName)
	}
	if m.email != nil {
		fields = append(fields, workercontact.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, workercontact.FieldPhone)
	}
	if m.relationship != nil {
		fields = append(fields, workercontact.FieldRelationship)
	}
	if m.is_primary != nil {
		fields = append(fields, workercontact.FieldIsPrimary)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkerContactMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workercontact.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case workercontact.FieldOrganizationID:
		return m.OrganizationID()
	case workercontact.FieldCreatedAt:
		return m.CreatedAt()
	case workercontact.FieldUpdatedAt:
		return m.UpdatedAt()
	case workercontact.FieldWorkerID:
		return m.WorkerID()
	case workercontact.FieldName:
		return m.Name()
	case workercontact.FieldEmail:
		return m.Email()
	case workercontact.FieldPhone:
		return m.Phone()
	case workercontact.FieldRelationship:
		return m.Relationship()
	case workercontact.FieldIsPrimary:
		return m.IsPrimary()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkerContactMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workercontact.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case workercontact.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case workercontact.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workercontact.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case workercontact.FieldWorkerID:
		return m.OldWorkerID(ctx)
	case workercontact.FieldName:
		return m.OldName(ctx)
	case workercontact.FieldEmail:
		return m.OldEmail(ctx)
	case workercontact.FieldPhone:
		return m.OldPhone(ctx)
	case workercontact.FieldRelationship:
		return m.OldRelationship(ctx)
	case workercontact.FieldIsPrimary:
		return m.OldIsPrimary(ctx)
	}
	return nil, fmt.Errorf("unknown WorkerContact field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkerContactMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workercontact.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case workercontact.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case workercontact.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workercontact.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case workercontact.FieldWorkerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkerID(v)
		return nil
	case workercontact.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case workercontact.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case workercontact.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case workercontact.FieldRelationship:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelationship(v)
		return nil
	case workercontact.FieldIsPrimary:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPrimary(v)
		return nil
	}
	return fmt.Errorf("unknown WorkerContact field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkerContactMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkerContactMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkerContactMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WorkerContact numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkerContactMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workercontact.FieldRelationship) {
		fields = append(fields, workercontact.FieldRelationship)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkerContactMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkerContactMutation) ClearField(name string) error {
	switch name {
	case workercontact.FieldRelationship:
		m.ClearRelationship()
		return nil
	}
	return fmt.Errorf("unknown WorkerContact nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkerContactMutation) ResetField(name string) error {
	switch name {
	case workercontact.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case workercontact.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case workercontact.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workercontact.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case workercontact.FieldWorkerID:
		m.ResetWorkerID()
		return nil
	case workercontact.FieldName:
		m.ResetName()
		return nil
	case workercontact.FieldEmail:
		m.ResetEmail()
		return nil
	case workercontact.FieldPhone:
		m.ResetPhone()
		return nil
	case workercontact.FieldRelationship:
		m.ResetRelationship()
		return nil
	case workercontact.FieldIsPrimary:
		m.ResetIsPrimary()
		return nil
	}
	return fmt.Errorf("unknown WorkerContact field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkerContactMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.business_unit != nil {
		edges = append(edges, workercontact.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, workercontact.EdgeOrganization)
	}
	if m.worker != nil {
		edges = append(edges, workercontact.EdgeWorker)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkerContactMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workercontact.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case workercontact.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case workercontact.EdgeWorker:
		if id := m.worker; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkerContactMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkerContactMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkerContactMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbusiness_unit {
		edges = append(edges, workercontact.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, workercontact.EdgeOrganization)
	}
	if m.clearedworker {
		edges = append(edges, workercontact.EdgeWorker)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkerContactMutation) EdgeCleared(name string) bool {
	switch name {
	case workercontact.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case workercontact.EdgeOrganization:
		return m.clearedorganization
	case workercontact.EdgeWorker:
		return m.clearedworker
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkerContactMutation) ClearEdge(name string) error {
	switch name {
	case workercontact.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case workercontact.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case workercontact.EdgeWorker:
		m.ClearWorker()
		return nil
	}
	return fmt.Errorf("unknown WorkerContact unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkerContactMutation) ResetEdge(name string) error {
	switch name {
	case workercontact.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case workercontact.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case workercontact.EdgeWorker:
		m.ResetWorker()
		return nil
	}
	return fmt.Errorf("unknown WorkerContact edge %s", name)
}

// WorkerProfileMutation represents an operation that mutates the WorkerProfile nodes in the graph.
type WorkerProfileMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	created_at              *time.Time
	updated_at              *time.Time
	race                    *string
	sex                     *string
	date_of_birth           **pgtype.Date
	license_number          *string
	license_expiration_date **pgtype.Date
	endorsements            *workerprofile.Endorsements
	hazmat_expiration_date  **pgtype.Date
	hire_date               **pgtype.Date
	termination_date        **pgtype.Date
	physical_due_date       **pgtype.Date
	medical_cert_date       **pgtype.Date
	mvr_due_date            **pgtype.Date
	clearedFields           map[string]struct{}
	business_unit           *uuid.UUID
	clearedbusiness_unit    bool
	organization            *uuid.UUID
	clearedorganization     bool
	worker                  *uuid.UUID
	clearedworker           bool
	state                   *uuid.UUID
	clearedstate            bool
	done                    bool
	oldValue                func(context.Context) (*WorkerProfile, error)
	predicates              []predicate.WorkerProfile
}

var _ ent.Mutation = (*WorkerProfileMutation)(nil)

// workerprofileOption allows management of the mutation configuration using functional options.
type workerprofileOption func(*WorkerProfileMutation)

// newWorkerProfileMutation creates new mutation for the WorkerProfile entity.
func newWorkerProfileMutation(c config, op Op, opts ...workerprofileOption) *WorkerProfileMutation {
	m := &WorkerProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkerProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkerProfileID sets the ID field of the mutation.
func withWorkerProfileID(id uuid.UUID) workerprofileOption {
	return func(m *WorkerProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkerProfile
		)
		m.oldValue = func(ctx context.Context) (*WorkerProfile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkerProfile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkerProfile sets the old WorkerProfile of the mutation.
func withWorkerProfile(node *WorkerProfile) workerprofileOption {
	return func(m *WorkerProfileMutation) {
		m.oldValue = func(context.Context) (*WorkerProfile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkerProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkerProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkerProfile entities.
func (m *WorkerProfileMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkerProfileMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkerProfileMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkerProfile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBusinessUnitID sets the "business_unit_id" field.
func (m *WorkerProfileMutation) SetBusinessUnitID(u uuid.UUID) {
	m.business_unit = &u
}

// BusinessUnitID returns the value of the "business_unit_id" field in the mutation.
func (m *WorkerProfileMutation) BusinessUnitID() (r uuid.UUID, exists bool) {
	v := m.business_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessUnitID returns the old "business_unit_id" field's value of the WorkerProfile entity.
// If the WorkerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerProfileMutation) OldBusinessUnitID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessUnitID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessUnitID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessUnitID: %w", err)
	}
	return oldValue.BusinessUnitID, nil
}

// ResetBusinessUnitID resets all changes to the "business_unit_id" field.
func (m *WorkerProfileMutation) ResetBusinessUnitID() {
	m.business_unit = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *WorkerProfileMutation) SetOrganizationID(u uuid.UUID) {
	m.organization = &u
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *WorkerProfileMutation) OrganizationID() (r uuid.UUID, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the WorkerProfile entity.
// If the WorkerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerProfileMutation) OldOrganizationID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *WorkerProfileMutation) ResetOrganizationID() {
	m.organization = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkerProfileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkerProfileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WorkerProfile entity.
// If the WorkerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerProfileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkerProfileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkerProfileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkerProfileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WorkerProfile entity.
// If the WorkerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerProfileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkerProfileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetWorkerID sets the "worker_id" field.
func (m *WorkerProfileMutation) SetWorkerID(u uuid.UUID) {
	m.worker = &u
}

// WorkerID returns the value of the "worker_id" field in the mutation.
func (m *WorkerProfileMutation) WorkerID() (r uuid.UUID, exists bool) {
	v := m.worker
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkerID returns the old "worker_id" field's value of the WorkerProfile entity.
// If the WorkerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerProfileMutation) OldWorkerID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkerID: %w", err)
	}
	return oldValue.WorkerID, nil
}

// ResetWorkerID resets all changes to the "worker_id" field.
func (m *WorkerProfileMutation) ResetWorkerID() {
	m.worker = nil
}

// SetRace sets the "race" field.
func (m *WorkerProfileMutation) SetRace(s string) {
	m.race = &s
}

// Race returns the value of the "race" field in the mutation.
func (m *WorkerProfileMutation) Race() (r string, exists bool) {
	v := m.race
	if v == nil {
		return
	}
	return *v, true
}

// OldRace returns the old "race" field's value of the WorkerProfile entity.
// If the WorkerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerProfileMutation) OldRace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRace: %w", err)
	}
	return oldValue.Race, nil
}

// ClearRace clears the value of the "race" field.
func (m *WorkerProfileMutation) ClearRace() {
	m.race = nil
	m.clearedFields[workerprofile.FieldRace] = struct{}{}
}

// RaceCleared returns if the "race" field was cleared in this mutation.
func (m *WorkerProfileMutation) RaceCleared() bool {
	_, ok := m.clearedFields[workerprofile.FieldRace]
	return ok
}

// ResetRace resets all changes to the "race" field.
func (m *WorkerProfileMutation) ResetRace() {
	m.race = nil
	delete(m.clearedFields, workerprofile.FieldRace)
}

// SetSex sets the "sex" field.
func (m *WorkerProfileMutation) SetSex(s string) {
	m.sex = &s
}

// Sex returns the value of the "sex" field in the mutation.
func (m *WorkerProfileMutation) Sex() (r string, exists bool) {
	v := m.sex
	if v == nil {
		return
	}
	return *v, true
}

// OldSex returns the old "sex" field's value of the WorkerProfile entity.
// If the WorkerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerProfileMutation) OldSex(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSex: %w", err)
	}
	return oldValue.Sex, nil
}

// ClearSex clears the value of the "sex" field.
func (m *WorkerProfileMutation) ClearSex() {
	m.sex = nil
	m.clearedFields[workerprofile.FieldSex] = struct{}{}
}

// SexCleared returns if the "sex" field was cleared in this mutation.
func (m *WorkerProfileMutation) SexCleared() bool {
	_, ok := m.clearedFields[workerprofile.FieldSex]
	return ok
}

// ResetSex resets all changes to the "sex" field.
func (m *WorkerProfileMutation) ResetSex() {
	m.sex = nil
	delete(m.clearedFields, workerprofile.FieldSex)
}

// SetDateOfBirth sets the "date_of_birth" field.
func (m *WorkerProfileMutation) SetDateOfBirth(pg *pgtype.Date) {
	m.date_of_birth = &pg
}

// DateOfBirth returns the value of the "date_of_birth" field in the mutation.
func (m *WorkerProfileMutation) DateOfBirth() (r *pgtype.Date, exists bool) {
	v := m.date_of_birth
	if v == nil {
		return
	}
	return *v, true
}

// OldDateOfBirth returns the old "date_of_birth" field's value of the WorkerProfile entity.
// If the WorkerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerProfileMutation) OldDateOfBirth(ctx context.Context) (v *pgtype.Date, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDateOfBirth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDateOfBirth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateOfBirth: %w", err)
	}
	return oldValue.DateOfBirth, nil
}

// ClearDateOfBirth clears the value of the "date_of_birth" field.
func (m *WorkerProfileMutation) ClearDateOfBirth() {
	m.date_of_birth = nil
	m.clearedFields[workerprofile.FieldDateOfBirth] = struct{}{}
}

// DateOfBirthCleared returns if the "date_of_birth" field was cleared in this mutation.
func (m *WorkerProfileMutation) DateOfBirthCleared() bool {
	_, ok := m.clearedFields[workerprofile.FieldDateOfBirth]
	return ok
}

// ResetDateOfBirth resets all changes to the "date_of_birth" field.
func (m *WorkerProfileMutation) ResetDateOfBirth() {
	m.date_of_birth = nil
	delete(m.clearedFields, workerprofile.FieldDateOfBirth)
}

// SetLicenseNumber sets the "license_number" field.
func (m *WorkerProfileMutation) SetLicenseNumber(s string) {
	m.license_number = &s
}

// LicenseNumber returns the value of the "license_number" field in the mutation.
func (m *WorkerProfileMutation) LicenseNumber() (r string, exists bool) {
	v := m.license_number
	if v == nil {
		return
	}
	return *v, true
}

// OldLicenseNumber returns the old "license_number" field's value of the WorkerProfile entity.
// If the WorkerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerProfileMutation) OldLicenseNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLicenseNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLicenseNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicenseNumber: %w", err)
	}
	return oldValue.LicenseNumber, nil
}

// ResetLicenseNumber resets all changes to the "license_number" field.
func (m *WorkerProfileMutation) ResetLicenseNumber() {
	m.license_number = nil
}

// SetLicenseStateID sets the "license_state_id" field.
func (m *WorkerProfileMutation) SetLicenseStateID(u uuid.UUID) {
	m.state = &u
}

// LicenseStateID returns the value of the "license_state_id" field in the mutation.
func (m *WorkerProfileMutation) LicenseStateID() (r uuid.UUID, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldLicenseStateID returns the old "license_state_id" field's value of the WorkerProfile entity.
// If the WorkerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerProfileMutation) OldLicenseStateID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLicenseStateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLicenseStateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicenseStateID: %w", err)
	}
	return oldValue.LicenseStateID, nil
}

// ResetLicenseStateID resets all changes to the "license_state_id" field.
func (m *WorkerProfileMutation) ResetLicenseStateID() {
	m.state = nil
}

// SetLicenseExpirationDate sets the "license_expiration_date" field.
func (m *WorkerProfileMutation) SetLicenseExpirationDate(pg *pgtype.Date) {
	m.license_expiration_date = &pg
}

// LicenseExpirationDate returns the value of the "license_expiration_date" field in the mutation.
func (m *WorkerProfileMutation) LicenseExpirationDate() (r *pgtype.Date, exists bool) {
	v := m.license_expiration_date
	if v == nil {
		return
	}
	return *v, true
}

// OldLicenseExpirationDate returns the old "license_expiration_date" field's value of the WorkerProfile entity.
// If the WorkerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerProfileMutation) OldLicenseExpirationDate(ctx context.Context) (v *pgtype.Date, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLicenseExpirationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLicenseExpirationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicenseExpirationDate: %w", err)
	}
	return oldValue.LicenseExpirationDate, nil
}

// ClearLicenseExpirationDate clears the value of the "license_expiration_date" field.
func (m *WorkerProfileMutation) ClearLicenseExpirationDate() {
	m.license_expiration_date = nil
	m.clearedFields[workerprofile.FieldLicenseExpirationDate] = struct{}{}
}

// LicenseExpirationDateCleared returns if the "license_expiration_date" field was cleared in this mutation.
func (m *WorkerProfileMutation) LicenseExpirationDateCleared() bool {
	_, ok := m.clearedFields[workerprofile.FieldLicenseExpirationDate]
	return ok
}

// ResetLicenseExpirationDate resets all changes to the "license_expiration_date" field.
func (m *WorkerProfileMutation) ResetLicenseExpirationDate() {
	m.license_expiration_date = nil
	delete(m.clearedFields, workerprofile.FieldLicenseExpirationDate)
}

// SetEndorsements sets the "endorsements" field.
func (m *WorkerProfileMutation) SetEndorsements(w workerprofile.Endorsements) {
	m.endorsements = &w
}

// Endorsements returns the value of the "endorsements" field in the mutation.
func (m *WorkerProfileMutation) Endorsements() (r workerprofile.Endorsements, exists bool) {
	v := m.endorsements
	if v == nil {
		return
	}
	return *v, true
}

// OldEndorsements returns the old "endorsements" field's value of the WorkerProfile entity.
// If the WorkerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerProfileMutation) OldEndorsements(ctx context.Context) (v workerprofile.Endorsements, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndorsements is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndorsements requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndorsements: %w", err)
	}
	return oldValue.Endorsements, nil
}

// ClearEndorsements clears the value of the "endorsements" field.
func (m *WorkerProfileMutation) ClearEndorsements() {
	m.endorsements = nil
	m.clearedFields[workerprofile.FieldEndorsements] = struct{}{}
}

// EndorsementsCleared returns if the "endorsements" field was cleared in this mutation.
func (m *WorkerProfileMutation) EndorsementsCleared() bool {
	_, ok := m.clearedFields[workerprofile.FieldEndorsements]
	return ok
}

// ResetEndorsements resets all changes to the "endorsements" field.
func (m *WorkerProfileMutation) ResetEndorsements() {
	m.endorsements = nil
	delete(m.clearedFields, workerprofile.FieldEndorsements)
}

// SetHazmatExpirationDate sets the "hazmat_expiration_date" field.
func (m *WorkerProfileMutation) SetHazmatExpirationDate(pg *pgtype.Date) {
	m.hazmat_expiration_date = &pg
}

// HazmatExpirationDate returns the value of the "hazmat_expiration_date" field in the mutation.
func (m *WorkerProfileMutation) HazmatExpirationDate() (r *pgtype.Date, exists bool) {
	v := m.hazmat_expiration_date
	if v == nil {
		return
	}
	return *v, true
}

// OldHazmatExpirationDate returns the old "hazmat_expiration_date" field's value of the WorkerProfile entity.
// If the WorkerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerProfileMutation) OldHazmatExpirationDate(ctx context.Context) (v *pgtype.Date, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHazmatExpirationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHazmatExpirationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHazmatExpirationDate: %w", err)
	}
	return oldValue.HazmatExpirationDate, nil
}

// ClearHazmatExpirationDate clears the value of the "hazmat_expiration_date" field.
func (m *WorkerProfileMutation) ClearHazmatExpirationDate() {
	m.hazmat_expiration_date = nil
	m.clearedFields[workerprofile.FieldHazmatExpirationDate] = struct{}{}
}

// HazmatExpirationDateCleared returns if the "hazmat_expiration_date" field was cleared in this mutation.
func (m *WorkerProfileMutation) HazmatExpirationDateCleared() bool {
	_, ok := m.clearedFields[workerprofile.FieldHazmatExpirationDate]
	return ok
}

// ResetHazmatExpirationDate resets all changes to the "hazmat_expiration_date" field.
func (m *WorkerProfileMutation) ResetHazmatExpirationDate() {
	m.hazmat_expiration_date = nil
	delete(m.clearedFields, workerprofile.FieldHazmatExpirationDate)
}

// SetHireDate sets the "hire_date" field.
func (m *WorkerProfileMutation) SetHireDate(pg *pgtype.Date) {
	m.hire_date = &pg
}

// HireDate returns the value of the "hire_date" field in the mutation.
func (m *WorkerProfileMutation) HireDate() (r *pgtype.Date, exists bool) {
	v := m.hire_date
	if v == nil {
		return
	}
	return *v, true
}

// OldHireDate returns the old "hire_date" field's value of the WorkerProfile entity.
// If the WorkerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerProfileMutation) OldHireDate(ctx context.Context) (v *pgtype.Date, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHireDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHireDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHireDate: %w", err)
	}
	return oldValue.HireDate, nil
}

// ClearHireDate clears the value of the "hire_date" field.
func (m *WorkerProfileMutation) ClearHireDate() {
	m.hire_date = nil
	m.clearedFields[workerprofile.FieldHireDate] = struct{}{}
}

// HireDateCleared returns if the "hire_date" field was cleared in this mutation.
func (m *WorkerProfileMutation) HireDateCleared() bool {
	_, ok := m.clearedFields[workerprofile.FieldHireDate]
	return ok
}

// ResetHireDate resets all changes to the "hire_date" field.
func (m *WorkerProfileMutation) ResetHireDate() {
	m.hire_date = nil
	delete(m.clearedFields, workerprofile.FieldHireDate)
}

// SetTerminationDate sets the "termination_date" field.
func (m *WorkerProfileMutation) SetTerminationDate(pg *pgtype.Date) {
	m.termination_date = &pg
}

// TerminationDate returns the value of the "termination_date" field in the mutation.
func (m *WorkerProfileMutation) TerminationDate() (r *pgtype.Date, exists bool) {
	v := m.termination_date
	if v == nil {
		return
	}
	return *v, true
}

// OldTerminationDate returns the old "termination_date" field's value of the WorkerProfile entity.
// If the WorkerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerProfileMutation) OldTerminationDate(ctx context.Context) (v *pgtype.Date, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTerminationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTerminationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTerminationDate: %w", err)
	}
	return oldValue.TerminationDate, nil
}

// ClearTerminationDate clears the value of the "termination_date" field.
func (m *WorkerProfileMutation) ClearTerminationDate() {
	m.termination_date = nil
	m.clearedFields[workerprofile.FieldTerminationDate] = struct{}{}
}

// TerminationDateCleared returns if the "termination_date" field was cleared in this mutation.
func (m *WorkerProfileMutation) TerminationDateCleared() bool {
	_, ok := m.clearedFields[workerprofile.FieldTerminationDate]
	return ok
}

// ResetTerminationDate resets all changes to the "termination_date" field.
func (m *WorkerProfileMutation) ResetTerminationDate() {
	m.termination_date = nil
	delete(m.clearedFields, workerprofile.FieldTerminationDate)
}

// SetPhysicalDueDate sets the "physical_due_date" field.
func (m *WorkerProfileMutation) SetPhysicalDueDate(pg *pgtype.Date) {
	m.physical_due_date = &pg
}

// PhysicalDueDate returns the value of the "physical_due_date" field in the mutation.
func (m *WorkerProfileMutation) PhysicalDueDate() (r *pgtype.Date, exists bool) {
	v := m.physical_due_date
	if v == nil {
		return
	}
	return *v, true
}

// OldPhysicalDueDate returns the old "physical_due_date" field's value of the WorkerProfile entity.
// If the WorkerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerProfileMutation) OldPhysicalDueDate(ctx context.Context) (v *pgtype.Date, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhysicalDueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhysicalDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhysicalDueDate: %w", err)
	}
	return oldValue.PhysicalDueDate, nil
}

// ClearPhysicalDueDate clears the value of the "physical_due_date" field.
func (m *WorkerProfileMutation) ClearPhysicalDueDate() {
	m.physical_due_date = nil
	m.clearedFields[workerprofile.FieldPhysicalDueDate] = struct{}{}
}

// PhysicalDueDateCleared returns if the "physical_due_date" field was cleared in this mutation.
func (m *WorkerProfileMutation) PhysicalDueDateCleared() bool {
	_, ok := m.clearedFields[workerprofile.FieldPhysicalDueDate]
	return ok
}

// ResetPhysicalDueDate resets all changes to the "physical_due_date" field.
func (m *WorkerProfileMutation) ResetPhysicalDueDate() {
	m.physical_due_date = nil
	delete(m.clearedFields, workerprofile.FieldPhysicalDueDate)
}

// SetMedicalCertDate sets the "medical_cert_date" field.
func (m *WorkerProfileMutation) SetMedicalCertDate(pg *pgtype.Date) {
	m.medical_cert_date = &pg
}

// MedicalCertDate returns the value of the "medical_cert_date" field in the mutation.
func (m *WorkerProfileMutation) MedicalCertDate() (r *pgtype.Date, exists bool) {
	v := m.medical_cert_date
	if v == nil {
		return
	}
	return *v, true
}

// OldMedicalCertDate returns the old "medical_cert_date" field's value of the WorkerProfile entity.
// If the WorkerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerProfileMutation) OldMedicalCertDate(ctx context.Context) (v *pgtype.Date, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMedicalCertDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMedicalCertDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMedicalCertDate: %w", err)
	}
	return oldValue.MedicalCertDate, nil
}

// ClearMedicalCertDate clears the value of the "medical_cert_date" field.
func (m *WorkerProfileMutation) ClearMedicalCertDate() {
	m.medical_cert_date = nil
	m.clearedFields[workerprofile.FieldMedicalCertDate] = struct{}{}
}

// MedicalCertDateCleared returns if the "medical_cert_date" field was cleared in this mutation.
func (m *WorkerProfileMutation) MedicalCertDateCleared() bool {
	_, ok := m.clearedFields[workerprofile.FieldMedicalCertDate]
	return ok
}

// ResetMedicalCertDate resets all changes to the "medical_cert_date" field.
func (m *WorkerProfileMutation) ResetMedicalCertDate() {
	m.medical_cert_date = nil
	delete(m.clearedFields, workerprofile.FieldMedicalCertDate)
}

// SetMvrDueDate sets the "mvr_due_date" field.
func (m *WorkerProfileMutation) SetMvrDueDate(pg *pgtype.Date) {
	m.mvr_due_date = &pg
}

// MvrDueDate returns the value of the "mvr_due_date" field in the mutation.
func (m *WorkerProfileMutation) MvrDueDate() (r *pgtype.Date, exists bool) {
	v := m.mvr_due_date
	if v == nil {
		return
	}
	return *v, true
}

// OldMvrDueDate returns the old "mvr_due_date" field's value of the WorkerProfile entity.
// If the WorkerProfile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkerProfileMutation) OldMvrDueDate(ctx context.Context) (v *pgtype.Date, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMvrDueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMvrDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMvrDueDate: %w", err)
	}
	return oldValue.MvrDueDate, nil
}

// ClearMvrDueDate clears the value of the "mvr_due_date" field.
func (m *WorkerProfileMutation) ClearMvrDueDate() {
	m.mvr_due_date = nil
	m.clearedFields[workerprofile.FieldMvrDueDate] = struct{}{}
}

// MvrDueDateCleared returns if the "mvr_due_date" field was cleared in this mutation.
func (m *WorkerProfileMutation) MvrDueDateCleared() bool {
	_, ok := m.clearedFields[workerprofile.FieldMvrDueDate]
	return ok
}

// ResetMvrDueDate resets all changes to the "mvr_due_date" field.
func (m *WorkerProfileMutation) ResetMvrDueDate() {
	m.mvr_due_date = nil
	delete(m.clearedFields, workerprofile.FieldMvrDueDate)
}

// ClearBusinessUnit clears the "business_unit" edge to the BusinessUnit entity.
func (m *WorkerProfileMutation) ClearBusinessUnit() {
	m.clearedbusiness_unit = true
	m.clearedFields[workerprofile.FieldBusinessUnitID] = struct{}{}
}

// BusinessUnitCleared reports if the "business_unit" edge to the BusinessUnit entity was cleared.
func (m *WorkerProfileMutation) BusinessUnitCleared() bool {
	return m.clearedbusiness_unit
}

// BusinessUnitIDs returns the "business_unit" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessUnitID instead. It exists only for internal usage by the builders.
func (m *WorkerProfileMutation) BusinessUnitIDs() (ids []uuid.UUID) {
	if id := m.business_unit; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusinessUnit resets all changes to the "business_unit" edge.
func (m *WorkerProfileMutation) ResetBusinessUnit() {
	m.business_unit = nil
	m.clearedbusiness_unit = false
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *WorkerProfileMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[workerprofile.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *WorkerProfileMutation) OrganizationCleared() bool {
	return m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *WorkerProfileMutation) OrganizationIDs() (ids []uuid.UUID) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *WorkerProfileMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// ClearWorker clears the "worker" edge to the Worker entity.
func (m *WorkerProfileMutation) ClearWorker() {
	m.clearedworker = true
	m.clearedFields[workerprofile.FieldWorkerID] = struct{}{}
}

// WorkerCleared reports if the "worker" edge to the Worker entity was cleared.
func (m *WorkerProfileMutation) WorkerCleared() bool {
	return m.clearedworker
}

// WorkerIDs returns the "worker" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkerID instead. It exists only for internal usage by the builders.
func (m *WorkerProfileMutation) WorkerIDs() (ids []uuid.UUID) {
	if id := m.worker; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorker resets all changes to the "worker" edge.
func (m *WorkerProfileMutation) ResetWorker() {
	m.worker = nil
	m.clearedworker = false
}

// SetStateID sets the "state" edge to the UsState entity by id.
func (m *WorkerProfileMutation) SetStateID(id uuid.UUID) {
	m.state = &id
}

// ClearState clears the "state" edge to the UsState entity.
func (m *WorkerProfileMutation) ClearState() {
	m.clearedstate = true
	m.clearedFields[workerprofile.FieldLicenseStateID] = struct{}{}
}

// StateCleared reports if the "state" edge to the UsState entity was cleared.
func (m *WorkerProfileMutation) StateCleared() bool {
	return m.clearedstate
}

// StateID returns the "state" edge ID in the mutation.
func (m *WorkerProfileMutation) StateID() (id uuid.UUID, exists bool) {
	if m.state != nil {
		return *m.state, true
	}
	return
}

// StateIDs returns the "state" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StateID instead. It exists only for internal usage by the builders.
func (m *WorkerProfileMutation) StateIDs() (ids []uuid.UUID) {
	if id := m.state; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetState resets all changes to the "state" edge.
func (m *WorkerProfileMutation) ResetState() {
	m.state = nil
	m.clearedstate = false
}

// Where appends a list predicates to the WorkerProfileMutation builder.
func (m *WorkerProfileMutation) Where(ps ...predicate.WorkerProfile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkerProfileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkerProfileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkerProfile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkerProfileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkerProfileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkerProfile).
func (m *WorkerProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkerProfileMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.business_unit != nil {
		fields = append(fields, workerprofile.FieldBusinessUnitID)
	}
	if m.organization != nil {
		fields = append(fields, workerprofile.FieldOrganizationID)
	}
	if m.created_at != nil {
		fields = append(fields, workerprofile.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, workerprofile.FieldUpdatedAt)
	}
	if m.worker != nil {
		fields = append(fields, workerprofile.FieldWorkerID)
	}
	if m.race != nil {
		fields = append(fields, workerprofile.FieldRace)
	}
	if m.sex != nil {
		fields = append(fields, workerprofile.FieldSex)
	}
	if m.date_of_birth != nil {
		fields = append(fields, workerprofile.FieldDateOfBirth)
	}
	if m.license_number != nil {
		fields = append(fields, workerprofile.FieldLicenseNumber)
	}
	if m.state != nil {
		fields = append(fields, workerprofile.FieldLicenseStateID)
	}
	if m.license_expiration_date != nil {
		fields = append(fields, workerprofile.FieldLicenseExpirationDate)
	}
	if m.endorsements != nil {
		fields = append(fields, workerprofile.FieldEndorsements)
	}
	if m.hazmat_expiration_date != nil {
		fields = append(fields, workerprofile.FieldHazmatExpirationDate)
	}
	if m.hire_date != nil {
		fields = append(fields, workerprofile.FieldHireDate)
	}
	if m.termination_date != nil {
		fields = append(fields, workerprofile.FieldTerminationDate)
	}
	if m.physical_due_date != nil {
		fields = append(fields, workerprofile.FieldPhysicalDueDate)
	}
	if m.medical_cert_date != nil {
		fields = append(fields, workerprofile.FieldMedicalCertDate)
	}
	if m.mvr_due_date != nil {
		fields = append(fields, workerprofile.FieldMvrDueDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkerProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workerprofile.FieldBusinessUnitID:
		return m.BusinessUnitID()
	case workerprofile.FieldOrganizationID:
		return m.OrganizationID()
	case workerprofile.FieldCreatedAt:
		return m.CreatedAt()
	case workerprofile.FieldUpdatedAt:
		return m.UpdatedAt()
	case workerprofile.FieldWorkerID:
		return m.WorkerID()
	case workerprofile.FieldRace:
		return m.Race()
	case workerprofile.FieldSex:
		return m.Sex()
	case workerprofile.FieldDateOfBirth:
		return m.DateOfBirth()
	case workerprofile.FieldLicenseNumber:
		return m.LicenseNumber()
	case workerprofile.FieldLicenseStateID:
		return m.LicenseStateID()
	case workerprofile.FieldLicenseExpirationDate:
		return m.LicenseExpirationDate()
	case workerprofile.FieldEndorsements:
		return m.Endorsements()
	case workerprofile.FieldHazmatExpirationDate:
		return m.HazmatExpirationDate()
	case workerprofile.FieldHireDate:
		return m.HireDate()
	case workerprofile.FieldTerminationDate:
		return m.TerminationDate()
	case workerprofile.FieldPhysicalDueDate:
		return m.PhysicalDueDate()
	case workerprofile.FieldMedicalCertDate:
		return m.MedicalCertDate()
	case workerprofile.FieldMvrDueDate:
		return m.MvrDueDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkerProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workerprofile.FieldBusinessUnitID:
		return m.OldBusinessUnitID(ctx)
	case workerprofile.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	case workerprofile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workerprofile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case workerprofile.FieldWorkerID:
		return m.OldWorkerID(ctx)
	case workerprofile.FieldRace:
		return m.OldRace(ctx)
	case workerprofile.FieldSex:
		return m.OldSex(ctx)
	case workerprofile.FieldDateOfBirth:
		return m.OldDateOfBirth(ctx)
	case workerprofile.FieldLicenseNumber:
		return m.OldLicenseNumber(ctx)
	case workerprofile.FieldLicenseStateID:
		return m.OldLicenseStateID(ctx)
	case workerprofile.FieldLicenseExpirationDate:
		return m.OldLicenseExpirationDate(ctx)
	case workerprofile.FieldEndorsements:
		return m.OldEndorsements(ctx)
	case workerprofile.FieldHazmatExpirationDate:
		return m.OldHazmatExpirationDate(ctx)
	case workerprofile.FieldHireDate:
		return m.OldHireDate(ctx)
	case workerprofile.FieldTerminationDate:
		return m.OldTerminationDate(ctx)
	case workerprofile.FieldPhysicalDueDate:
		return m.OldPhysicalDueDate(ctx)
	case workerprofile.FieldMedicalCertDate:
		return m.OldMedicalCertDate(ctx)
	case workerprofile.FieldMvrDueDate:
		return m.OldMvrDueDate(ctx)
	}
	return nil, fmt.Errorf("unknown WorkerProfile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkerProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workerprofile.FieldBusinessUnitID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessUnitID(v)
		return nil
	case workerprofile.FieldOrganizationID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	case workerprofile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workerprofile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case workerprofile.FieldWorkerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkerID(v)
		return nil
	case workerprofile.FieldRace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRace(v)
		return nil
	case workerprofile.FieldSex:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSex(v)
		return nil
	case workerprofile.FieldDateOfBirth:
		v, ok := value.(*pgtype.Date)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateOfBirth(v)
		return nil
	case workerprofile.FieldLicenseNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicenseNumber(v)
		return nil
	case workerprofile.FieldLicenseStateID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicenseStateID(v)
		return nil
	case workerprofile.FieldLicenseExpirationDate:
		v, ok := value.(*pgtype.Date)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicenseExpirationDate(v)
		return nil
	case workerprofile.FieldEndorsements:
		v, ok := value.(workerprofile.Endorsements)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndorsements(v)
		return nil
	case workerprofile.FieldHazmatExpirationDate:
		v, ok := value.(*pgtype.Date)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHazmatExpirationDate(v)
		return nil
	case workerprofile.FieldHireDate:
		v, ok := value.(*pgtype.Date)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHireDate(v)
		return nil
	case workerprofile.FieldTerminationDate:
		v, ok := value.(*pgtype.Date)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTerminationDate(v)
		return nil
	case workerprofile.FieldPhysicalDueDate:
		v, ok := value.(*pgtype.Date)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhysicalDueDate(v)
		return nil
	case workerprofile.FieldMedicalCertDate:
		v, ok := value.(*pgtype.Date)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMedicalCertDate(v)
		return nil
	case workerprofile.FieldMvrDueDate:
		v, ok := value.(*pgtype.Date)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMvrDueDate(v)
		return nil
	}
	return fmt.Errorf("unknown WorkerProfile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkerProfileMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkerProfileMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkerProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WorkerProfile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkerProfileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workerprofile.FieldRace) {
		fields = append(fields, workerprofile.FieldRace)
	}
	if m.FieldCleared(workerprofile.FieldSex) {
		fields = append(fields, workerprofile.FieldSex)
	}
	if m.FieldCleared(workerprofile.FieldDateOfBirth) {
		fields = append(fields, workerprofile.FieldDateOfBirth)
	}
	if m.FieldCleared(workerprofile.FieldLicenseExpirationDate) {
		fields = append(fields, workerprofile.FieldLicenseExpirationDate)
	}
	if m.FieldCleared(workerprofile.FieldEndorsements) {
		fields = append(fields, workerprofile.FieldEndorsements)
	}
	if m.FieldCleared(workerprofile.FieldHazmatExpirationDate) {
		fields = append(fields, workerprofile.FieldHazmatExpirationDate)
	}
	if m.FieldCleared(workerprofile.FieldHireDate) {
		fields = append(fields, workerprofile.FieldHireDate)
	}
	if m.FieldCleared(workerprofile.FieldTerminationDate) {
		fields = append(fields, workerprofile.FieldTerminationDate)
	}
	if m.FieldCleared(workerprofile.FieldPhysicalDueDate) {
		fields = append(fields, workerprofile.FieldPhysicalDueDate)
	}
	if m.FieldCleared(workerprofile.FieldMedicalCertDate) {
		fields = append(fields, workerprofile.FieldMedicalCertDate)
	}
	if m.FieldCleared(workerprofile.FieldMvrDueDate) {
		fields = append(fields, workerprofile.FieldMvrDueDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkerProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkerProfileMutation) ClearField(name string) error {
	switch name {
	case workerprofile.FieldRace:
		m.ClearRace()
		return nil
	case workerprofile.FieldSex:
		m.ClearSex()
		return nil
	case workerprofile.FieldDateOfBirth:
		m.ClearDateOfBirth()
		return nil
	case workerprofile.FieldLicenseExpirationDate:
		m.ClearLicenseExpirationDate()
		return nil
	case workerprofile.FieldEndorsements:
		m.ClearEndorsements()
		return nil
	case workerprofile.FieldHazmatExpirationDate:
		m.ClearHazmatExpirationDate()
		return nil
	case workerprofile.FieldHireDate:
		m.ClearHireDate()
		return nil
	case workerprofile.FieldTerminationDate:
		m.ClearTerminationDate()
		return nil
	case workerprofile.FieldPhysicalDueDate:
		m.ClearPhysicalDueDate()
		return nil
	case workerprofile.FieldMedicalCertDate:
		m.ClearMedicalCertDate()
		return nil
	case workerprofile.FieldMvrDueDate:
		m.ClearMvrDueDate()
		return nil
	}
	return fmt.Errorf("unknown WorkerProfile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkerProfileMutation) ResetField(name string) error {
	switch name {
	case workerprofile.FieldBusinessUnitID:
		m.ResetBusinessUnitID()
		return nil
	case workerprofile.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	case workerprofile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workerprofile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case workerprofile.FieldWorkerID:
		m.ResetWorkerID()
		return nil
	case workerprofile.FieldRace:
		m.ResetRace()
		return nil
	case workerprofile.FieldSex:
		m.ResetSex()
		return nil
	case workerprofile.FieldDateOfBirth:
		m.ResetDateOfBirth()
		return nil
	case workerprofile.FieldLicenseNumber:
		m.ResetLicenseNumber()
		return nil
	case workerprofile.FieldLicenseStateID:
		m.ResetLicenseStateID()
		return nil
	case workerprofile.FieldLicenseExpirationDate:
		m.ResetLicenseExpirationDate()
		return nil
	case workerprofile.FieldEndorsements:
		m.ResetEndorsements()
		return nil
	case workerprofile.FieldHazmatExpirationDate:
		m.ResetHazmatExpirationDate()
		return nil
	case workerprofile.FieldHireDate:
		m.ResetHireDate()
		return nil
	case workerprofile.FieldTerminationDate:
		m.ResetTerminationDate()
		return nil
	case workerprofile.FieldPhysicalDueDate:
		m.ResetPhysicalDueDate()
		return nil
	case workerprofile.FieldMedicalCertDate:
		m.ResetMedicalCertDate()
		return nil
	case workerprofile.FieldMvrDueDate:
		m.ResetMvrDueDate()
		return nil
	}
	return fmt.Errorf("unknown WorkerProfile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkerProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.business_unit != nil {
		edges = append(edges, workerprofile.EdgeBusinessUnit)
	}
	if m.organization != nil {
		edges = append(edges, workerprofile.EdgeOrganization)
	}
	if m.worker != nil {
		edges = append(edges, workerprofile.EdgeWorker)
	}
	if m.state != nil {
		edges = append(edges, workerprofile.EdgeState)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkerProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workerprofile.EdgeBusinessUnit:
		if id := m.business_unit; id != nil {
			return []ent.Value{*id}
		}
	case workerprofile.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case workerprofile.EdgeWorker:
		if id := m.worker; id != nil {
			return []ent.Value{*id}
		}
	case workerprofile.EdgeState:
		if id := m.state; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkerProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkerProfileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkerProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedbusiness_unit {
		edges = append(edges, workerprofile.EdgeBusinessUnit)
	}
	if m.clearedorganization {
		edges = append(edges, workerprofile.EdgeOrganization)
	}
	if m.clearedworker {
		edges = append(edges, workerprofile.EdgeWorker)
	}
	if m.clearedstate {
		edges = append(edges, workerprofile.EdgeState)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkerProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case workerprofile.EdgeBusinessUnit:
		return m.clearedbusiness_unit
	case workerprofile.EdgeOrganization:
		return m.clearedorganization
	case workerprofile.EdgeWorker:
		return m.clearedworker
	case workerprofile.EdgeState:
		return m.clearedstate
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkerProfileMutation) ClearEdge(name string) error {
	switch name {
	case workerprofile.EdgeBusinessUnit:
		m.ClearBusinessUnit()
		return nil
	case workerprofile.EdgeOrganization:
		m.ClearOrganization()
		return nil
	case workerprofile.EdgeWorker:
		m.ClearWorker()
		return nil
	case workerprofile.EdgeState:
		m.ClearState()
		return nil
	}
	return fmt.Errorf("unknown WorkerProfile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkerProfileMutation) ResetEdge(name string) error {
	switch name {
	case workerprofile.EdgeBusinessUnit:
		m.ResetBusinessUnit()
		return nil
	case workerprofile.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case workerprofile.EdgeWorker:
		m.ResetWorker()
		return nil
	case workerprofile.EdgeState:
		m.ResetState()
		return nil
	}
	return fmt.Errorf("unknown WorkerProfile edge %s", name)
}
